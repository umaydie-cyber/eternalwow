import React, { useState, useEffect, useCallback, useReducer, useRef } from 'react';

// ==================== GAME DATA ====================
const RACES = ['äººç±»', 'çŸ®äºº', 'æš—å¤œç²¾çµ', 'ä¾å„’', 'å…½äºº', 'å·¨é­”', 'ç‰›å¤´äºº', 'äº¡çµ'];

// ==================== RACE TRAITS ====================
// è¯´æ˜ï¼šç§æ—è¢«åŠ¨æŠ€èƒ½/æ•ˆæœä¸å ç”¨æŠ€èƒ½æ ï¼ˆSkillEditor ä¼šè¿‡æ»¤ passiveï¼‰ã€‚
// å¦‚éœ€æ‰©å±•å…¶å®ƒç§æ—ï¼Œå¾€è¿™é‡Œç»§ç»­åŠ å³å¯ã€‚
const RACE_TRAITS = {
    'äººç±»': {
        // åˆå§‹é¢å¤–æŠ€èƒ½ï¼ˆä¼šå†™è¿›è§’è‰² skills åˆ—è¡¨ï¼Œç”¨äºå±•ç¤ºï¼‰
        extraSkills: ['racial_human_spirit', 'racial_human_hospitality'],
        // äººç±»ç²¾é­‚ï¼šå…¨èƒ½/ç²¾é€š/æš´å‡»/æ€¥é€Ÿ +2
        statBonus: { versatility: 2, mastery: 2, critRate: 2, haste: 2 },
        // å®¾è‡³å¦‚å½’ï¼šåœ°å›¾æˆ˜æ–—ç»“æŸåå›å¤æœ€å¤§ç”Ÿå‘½å€¼çš„ 10%
        mapCombatEndHealPct: 0.10,
    },
    'çŸ®äºº': {
        // é€‰æ‹©çŸ®äººè§’è‰²ï¼šé¢å¤–è·å¾—ä¸¤ä¸ªç§æ—æŠ€èƒ½
        extraSkills: ['racial_dwarf_spirit', 'racial_dwarf_stoneform'],
        // çŸ®äººç²¾é­„ï¼šæš´å‡»ä¼¤å®³ +15%ï¼ˆä»¥å€ç‡åŠ æˆï¼š0.15 => +15%ï¼‰
        statBonus: { critDamage: 0.15 },
        // çŸ³åƒå½¢æ€ï¼šæˆ˜æ–—ä¸­é¦–æ¬¡å—åˆ°è¯…å’’/ä¸­æ¯’æ•ˆæœæ—¶å…ç–«ï¼ˆæ¯ç§å„ 1 æ¬¡ï¼‰
        firstDebuffImmunity: { curse: true, poison: true },
    },
    'æš—å¤œç²¾çµ': {
        // é€‰æ‹©æš—å¤œç²¾çµè§’è‰²ï¼šé¢å¤–è·å¾—ä¸¤ä¸ªç§æ—æŠ€èƒ½
        extraSkills: ['racial_nightelf_spirit', 'racial_nightelf_shadowmeld'],
        // ç²¾çµç²¾é­„ï¼šæ—©æ™¨6ç‚¹-æ™šä¸Š6ç‚¹æš´å‡»+6ï¼›æ™šä¸Š6ç‚¹-æ¬¡æ—¥æ—©æ™¨6ç‚¹æ€¥é€Ÿ+6
        timeBasedStatBonus: {
            dayStart: 6,
            nightStart: 18,
            dayBonus: { critRate: 6 },
            nightBonus: { haste: 6 },
        },
        // éšéï¼šåœ°å›¾æˆ˜æ–—ç¬¬ä¸€æ ¼æŠ€èƒ½é€ æˆçš„ä¼¤å®³æé«˜20%ï¼ˆä¹˜ç®—ï¼‰
        mapFirstSlotDamageMult: 1.2,
    },
    'ä¾å„’': {
        // é€‰æ‹©ä¾å„’è§’è‰²ï¼šé¢å¤–è·å¾—ä¸¤ä¸ªç§æ—æŠ€èƒ½
        extraSkills: ['racial_gnome_spirit', 'racial_gnome_familiarity'],
        // ä¾å„’ç²¾é­„ï¼šå…¨èƒ½ +6
        statBonus: { versatility: 6 },
        // ç†Ÿç¨”ï¼šé‡‡é›†ç†Ÿç»ƒ +30
        gatherStatBonus: { proficiency: 30 },
    },
    'å…½äºº': {
        // é€‰æ‹©å…½äººè§’è‰²ï¼šé¢å¤–è·å¾—ä¸¤ä¸ªç§æ—æŠ€èƒ½
        extraSkills: ['racial_orc_spirit', 'racial_orc_bloodfury'],
        // å…½äººç²¾é­„ï¼šç²¾é€š +3ï¼Œå…¨èƒ½ +3
        statBonus: { mastery: 3, versatility: 3 },
        // è¡€æ€§ç‹‚æ€’ï¼šå‰4ä¸ªæŠ€èƒ½æ ¼é€ æˆçš„ä¼¤å®³æé«˜10%ï¼ˆä¹˜ç®—ï¼‰
        firstNSlotDamageMult: { n: 4, mult: 1.10 },
    },
};


const CLASSES = {
    protection_warrior: {
        id: 'protection_warrior',
        name: 'é˜²æŠ¤æˆ˜å£«',
        baseStats: { hp: 150, mp: 50, attack: 15, spellPower: 5, armor: 30, magicResist: 10, blockValue: 20},
        baseGatherStats: { proficiency: 5, precision: 3, perception: 2 },
        skills: [
            { level: 1, skillId: 'basic_attack' },
            { level: 1, skillId: 'rest' },
            { level: 1, skillId: 'mastery_precise_block' },
            { level: 3, skillId: 'shield_bash' },
            { level: 5, skillId: 'shield_block' },
            { level: 10, skillId: 'revenge' },
            { level: 20, skillId: 'thunder_strike' },
            { level: 30, skillId: 'shield_wall' },
        ]
    },
    discipline_priest: {
        id: 'discipline_priest',
        name: 'æˆ’å¾‹ç‰§å¸ˆ',
        baseStats: {
            hp: 100,
            mp: 120,
            attack: 5,
            spellPower: 15,
            armor: 10,
            magicResist: 20,
        },
        baseGatherStats: { proficiency: 5, precision: 3, perception: 2 },
        skills: [
            { level: 1, skillId: 'basic_attack' },
            { level: 1, skillId: 'rest' },
            { level: 1, skillId: 'mastery_atonement' },
            { level: 3, skillId: 'smite' },
            { level: 5, skillId: 'shadow_word_pain' },
            { level: 10, skillId: 'mind_blast' },
            { level: 20, skillId: 'power_word_radiance' },
            { level: 30, skillId: 'penance' },
            { level: 50, skillId: 'holy_nova' },
        ]
    },
    frost_mage: {
        id: 'frost_mage',
        name: 'å†°éœœæ³•å¸ˆ',
        baseStats: {
            hp: 90,
            mp: 150,
            attack: 5,
            spellPower: 18,
            armor: 8,
            magicResist: 25,
        },
        baseGatherStats: { proficiency: 5, precision: 3, perception: 2 },
        skills: [
            { level: 1, skillId: 'basic_attack' },
            { level: 1, skillId: 'rest' },
            { level: 1, skillId: 'mastery_deep_winter' },
            { level: 3, skillId: 'frostbolt' },
            { level: 5, skillId: 'ice_lance' },
            { level: 10, skillId: 'blizzard' },
            { level: 20, skillId: 'frozen_orb' },
            { level: 30, skillId: 'icy_veins' },
            { level: 40, skillId: 'comet_storm' },
            { level: 50, skillId: 'ice_barrier' },
            { level: 52, skillId: 'conditional_frost_strike' },
        ]
    }
};

// ==================== èµ„æºå»ºç­‘ï¼ˆä¸å¯å»ºé€ ï¼Œç”¨äºæ´¾é£é‡‡é›†ï¼‰ ====================
const RESOURCE_BUILDINGS = {
    lumber_mill: {
        id: 'lumber_mill',
        name: 'ä¼æœ¨åœº',
        icon: 'ğŸª“',
        description: 'æ´¾é£è§’è‰²ç ä¼æœ¨æ',
        resourceType: 'wood',
        baseProduction: 5,
        maxWorkers: 3,
        // å±æ€§æƒé‡ï¼šç†Ÿç»ƒ60%ã€ç²¾ç»†20%ã€æ„ŸçŸ¥20%
        statWeights: { proficiency: 0.6, precision: 0.2, perception: 0.2 }
    },
    iron_mine: {
        id: 'iron_mine',
        name: 'é“çŸ¿åœº',
        icon: 'â›ï¸',
        description: 'æ´¾é£è§’è‰²å¼€é‡‡é“çŸ¿',
        resourceType: 'ironOre',
        baseProduction: 3,
        maxWorkers: 3,
        statWeights: { proficiency: 0.5, precision: 0.3, perception: 0.2 }
    },
    gathering_hut: {
        id: 'gathering_hut',
        name: 'é‡‡é›†æ‰€',
        icon: 'ğŸŒ¿',
        description: 'æ´¾é£è§’è‰²é‡‡é›†è‰è¯',
        resourceType: 'herb',
        baseProduction: 4,
        maxWorkers: 3,
        statWeights: { proficiency: 0.3, precision: 0.3, perception: 0.4 }
    },
    hunter_lodge: {
        id: 'hunter_lodge',
        name: 'çŒäººå°å±‹',
        icon: 'ğŸ¹',
        description: 'æ´¾é£è§’è‰²ç‹©çŒè·å–æ¯›çš®',
        resourceType: 'leather',
        baseProduction: 3,
        maxWorkers: 3,
        statWeights: { proficiency: 0.4, precision: 0.4, perception: 0.2 }
    },
    mana_well: {
        id: 'mana_well',
        name: 'é­”åŠ›ä¹‹æº',
        icon: 'ğŸ’',
        description: 'æ´¾é£è§’è‰²æ±²å–é­”æ³•ç²¾å',
        resourceType: 'magicEssence',
        baseProduction: 1,
        maxWorkers: 2,
        statWeights: { proficiency: 0.2, precision: 0.3, perception: 0.5 }
    },
    foundry: {
        id: 'foundry',
        name: 'é“¸é€ å‚',
        icon: 'ğŸ”¥',
        description: 'æ´¾é£è§’è‰²å°†é“çŸ¿ç‚¼æˆé“é”­ï¼ˆæ¶ˆè€—é“çŸ¿ï¼‰',
        resourceType: 'ironIngot',
        baseProduction: 2,
        maxWorkers: 2,
        consumption: { ironOre: 3 },
        statWeights: { proficiency: 0.5, precision: 0.4, perception: 0.1 }
    },
    alchemy_lab: {
        id: 'alchemy_lab',
        name: 'ç‚¼é‡‘å®éªŒå®¤',
        icon: 'âš—ï¸',
        description: 'æ´¾é£è§’è‰²ç‚¼åˆ¶ç‚¼é‡‘æ²¹ï¼ˆæ¶ˆè€—è‰è¯ï¼‰',
        resourceType: 'alchemyOil',
        baseProduction: 2,
        maxWorkers: 2,
        consumption: { herb: 2 },
        statWeights: { proficiency: 0.3, precision: 0.5, perception: 0.2 }
    },
};

// ==================== åŠŸèƒ½å»ºç­‘ï¼ˆå¯å»ºé€ å¤šä¸ªï¼‰ ====================
const FUNCTIONAL_BUILDINGS = {
    plaza_fountain: {
        id: 'plaza_fountain',
        name: 'å¹¿åœºå–·æ³‰',
        icon: 'â›²',
        description: 'æ‰€æœ‰è„±æˆ˜è‹±é›„æ¯ç§’é¢å¤–å›å¤2ç‚¹ç”Ÿå‘½',
        cost: { gold: 10000, wood: 10000, ironOre: 8000 },
        maxCount: 500,
        effect: { type: 'regen', value: 2 }
    },
    warehouse: {
        id: 'warehouse',
        name: 'ä»“åº“',
        icon: 'ğŸšï¸',
        description: 'å¢åŠ 1ä¸ªèƒŒåŒ…æ ¼å­',
        cost: { gold: 80000, ironOre: 30000,ironIngot: 15000, magicEssence: 15000,alchemyOil:10000},
        maxCount: 150,
        effect: { type: 'inventorySize', value: 1 }
    },
    training_dummy: {
        id: 'training_dummy',
        name: 'è®­ç»ƒå‡äºº',
        icon: 'ğŸ¯',
        description: 'æ‰€æœ‰è§’è‰²ç»éªŒè·å–æé«˜1%',
        cost: { gold: 500000, leather: 30000, ironOre: 30000,ironIngot: 15000, magicEssence: 15000 },
        maxCount: 30,
        effect: { type: 'expBonus', value: 0.01 }
    },
    mechanical_arm: {
        id: 'mechanical_arm',
        name: 'æœºæ¢°è‡‚',
        icon: 'ğŸ¦¾',
        description: 'å¼ºåŒ–ä¸€ä¸ªèƒŒåŒ…æ ä½ï¼Œä½¿å…¶è‡ªåŠ¨åˆæˆ',
        cost: { gold: 500000, ironIngot: 20000, magicEssence: 20000, alchemyOil: 15000 },
        maxCount: 10,
        effect: { type: 'autoMerge', value: 1 }
    },

    glow_lighthouse: {
        id: 'glow_lighthouse',
        name: 'è¾‰å…‰ç¯å¡”',
        icon: 'ğŸ—¼',
        description: 'æ¯åº§ä½¿è§’è‰²è„±ç¦»æˆ˜æ–—æ‰€éœ€æ—¶é—´é™ä½1ç§’ï¼ˆæœ€å¤šé™ä½2ç§’ï¼‰',
        cost: { gold: 1000000, ironOre: 200000, wood: 500000, alchemyOil: 100000 },
        maxCount: 2,
        effect: { type: 'outOfCombatDelay', value: -1 }
    },



    // âœ… æ–°å¢ï¼šå¯»é¾™ä¼šï¼ˆæ¯çº§+5%è£…å¤‡/ç‰©å“æ‰è½æ¦‚ç‡ï¼Œæ»¡çº§+100%ï¼‰
    dragon_seekers_guild: {
        id: 'dragon_seekers_guild',
        name: 'å¯»é¾™ä¼š',
        icon: 'ğŸ‰',
        description: 'æ¯çº§æé«˜è£…å¤‡/ç‰©å“æ‰è½æ¦‚ç‡5%ï¼ˆæ»¡çº§+100%ï¼š0.1%â†’0.2%ï¼‰',
        cost: { gold: 50000, ironIngot: 30000, magicEssence: 30000 },
        maxCount: 20,
        effect: { type: 'dropBonus', value: 0.05 }
    },
};

// ==================== TALENTS ====================
// å¤©èµ‹è§¦å‘ç±»å‹ï¼ˆç”¨äºæœªæ¥æ‰©å±•ï¼‰
const TALENT_TYPES = {
    AURA: 'aura',          // æˆ˜æ–—ä¸­å¸¸é©»/å…‰ç¯ç±»ï¼ˆå¦‚æŠ¤ç”²+100ã€å§¿æ€ï¼‰
    ON_HIT: 'on_hit',      // å‘½ä¸­/ä½¿ç”¨æ™®é€šæ”»å‡»åè§¦å‘
    ON_BLOCK: 'on_block',  // æˆåŠŸæ ¼æŒ¡åè§¦å‘
};

// è§„åˆ™ï¼šæ¯10çº§ä¸€è¡Œï¼Œæ¯è¡Œ3é€‰1ã€‚æœªåˆ°ç­‰çº§ä¸èƒ½ç‚¹ã€‚ç‚¹äº®ååŒæ’å…¶å®ƒå˜é»‘ã€‚
// ç›®å‰åªå®ç°æˆ˜å£«ï¼ˆé˜²æŠ¤æˆ˜å£«ï¼‰10/20çº§ï¼Œ30-70çº§é¢„ç•™å ä½ã€‚
const TALENTS = {
    protection_warrior: [
        {
            tier: 10,
            options: [
                { id: 'plain', type: TALENT_TYPES.ON_HIT, name: 'è´¨æœ´', description: 'æ™®é€šæ”»å‡»ä½¿ä½ åœ¨æœ¬åœºæˆ˜æ–—ä¸­çš„æ”»å‡»å¼ºåº¦æé«˜5ç‚¹ã€‚' },
                { id: 'block_master', type: TALENT_TYPES.ON_BLOCK, name: 'æ ¼æŒ¡å¤§å¸ˆ', description: 'æˆ˜æ–—ä¸­æ¯æ¬¡æˆåŠŸçš„æ ¼æŒ¡éƒ½ä¼šä½¿ä½ åœ¨æœ¬åœºæˆ˜æ–—ä¸­çš„æ ¼æŒ¡å€¼æé«˜10ç‚¹ã€‚' },
                { id: 'armor_up', type: TALENT_TYPES.AURA, name: 'å ç”²è¿‡', description: 'ä½ åœ¨æˆ˜æ–—ä¸­çš„æŠ¤ç”²å€¼æå‡100ç‚¹ã€‚' },
            ]
        },
        {
            tier: 20,
            options: [
                { id: 'defense_stance', type: TALENT_TYPES.AURA, name: 'é˜²å¾¡å§¿æ€', description: 'ä½ åœ¨æˆ˜æ–—ä¸­å—åˆ°çš„ä¼¤å®³é™ä½20%ã€‚' },
                { id: 'battle_stance', type: TALENT_TYPES.AURA, name: 'æˆ˜æ–—å§¿æ€', description: 'ä½ åœ¨æˆ˜æ–—ä¸­çš„æ”»å‡»å¼ºåº¦æå‡10%ã€‚' },
                { id: 'berserk_stance', type: TALENT_TYPES.AURA, name: 'ç‹‚æš´å§¿æ€', description: 'ä½ åœ¨æˆ˜æ–—ä¸­è·å¾—é¢å¤–çš„8%æš´å‡»å’Œ20%æš´å‡»ä¼¤å®³ã€‚' },
            ]
        },
        {
            tier: 30,
            options: [
                { id: 'brutal_momentum', type: TALENT_TYPES.ON_HIT, name: 'æ®‹æš´åŠ¨åŠ›', description: 'ä½ çš„é‡ä¼¤é€ æˆçš„ä¼¤å®³çš„150%ä¼šæ²»ç–—ä½ ã€‚' },
                { id: 'demoralizing_shout', type: TALENT_TYPES.ON_HIT, name: 'æŒ«å¿—æ€’å¼', description: 'ä½ çš„é›·éœ†ä¸€å‡»ä¼šä¸ºç›®æ ‡æ–½åŠ debuffã€æŒ«å¿—æ€’å¼ã€‘ï¼Œä½¿å…¶é€ æˆçš„æ‰€æœ‰ä¼¤å®³é™ä½20%ã€‚' },
                { id: 'mountain_king', type: TALENT_TYPES.ON_HIT, name: 'å±±ä¸˜ä¹‹ç‹', description: 'é›·éœ†ä¸€å‡»æœ‰50%å‡ ç‡å†æ¬¡é‡Šæ”¾ä¸€æ¬¡ã€‚' },
            ]
        },
        {
            tier: 40,
            options: [
                { id: 'guardian_shield', type: TALENT_TYPES.AURA, name: 'æŠ¤å«ç¥ç›¾', description: 'ä½ çš„ç›¾å¢™å¯ä»¥é…ç½®2æ¬¡ã€‚' },
                { id: 'indomitable_might', type: TALENT_TYPES.AURA, name: 'æ— åšä¸æ‘§ä¹‹åŠ›', description: 'ä½ çš„ç›¾å¢™åŒæ—¶ä½¿ä½ é€ æˆçš„ä¼¤å®³æé«˜50%ã€‚' },
                { id: 'fortified_wall', type: TALENT_TYPES.AURA, name: 'åšæ¯…é•¿åŸ', description: 'ç›¾å¢™çš„å‡ä¼¤æé«˜åˆ°75%ã€‚' },
            ]
        },
        {
            tier: 50,
            options: [
                {
                    id: 'crit_breakthrough',
                    type: TALENT_TYPES.AURA,
                    name: 'çˆ†å‘çªç ´',
                    description: 'è¶…è¿‡100%çš„æš´å‡»ç‡ä¼šç›´æ¥è½¬åŒ–ä¸ºå¯¹æ€»ä¼¤å®³çš„åŠ æˆã€‚'
                },
                {
                    id: 'block_breakthrough',
                    type: TALENT_TYPES.AURA,
                    name: 'æ ¼æŒ¡çªç ´',
                    description: 'è¶…è¿‡95%çš„æ ¼æŒ¡ç‡ä¼šç›´æ¥è½¬åŒ–ä¸ºå¯¹æ€»æ ¼æŒ¡å€¼çš„åŠ æˆã€‚'
                },
                {
                    id: 'holy_sword',
                    type: TALENT_TYPES.ON_HIT,
                    name: 'åœ£å‰‘',
                    description: 'æ™®é€šæ”»å‡»ä¼šé¢å¤–é€ æˆ100%ç»“ç®—æ ¼æŒ¡å€¼çš„ä¼¤å®³ã€‚'
                },
            ]
        },
        ...[60, 70].map(tier => ({
            tier,
            options: [
                { id: `t${tier}_a`, name: 'ï¼ˆé¢„ç•™ï¼‰å¤©èµ‹A', description: 'å¾…å®ç°' },
                { id: `t${tier}_b`, name: 'ï¼ˆé¢„ç•™ï¼‰å¤©èµ‹B', description: 'å¾…å®ç°' },
                { id: `t${tier}_c`, name: 'ï¼ˆé¢„ç•™ï¼‰å¤©èµ‹C', description: 'å¾…å®ç°' },
            ]
        }))
    ],
    discipline_priest: [
        {
            tier: 10,
            options: [
                {
                    id: 'shadow_amp',
                    name: 'æš—å½±å¢å¹…',
                    description: 'æˆ˜æ–—ä¸­æš—å½±ä¼¤å®³æé«˜20%',
                    type: 'aura'
                },
                {
                    id: 'holy_vuln',
                    name: 'ç¥åœ£å¢å¹…',
                    description: 'æƒ©å‡»ä½¿ç›®æ ‡å—åˆ°çš„æ³•æœ¯ä¼¤å®³æé«˜10%ï¼ŒæŒç»­2å›åˆ',
                    type: 'on_hit'
                },
                {
                    id: 'holy_infusion',
                    name: 'ç¥åœ£çŒæ³¨',
                    description: 'æƒ©å‡»ä½¿ä½ æœ¬åœºæˆ˜æ–—æ³•æœ¯å¼ºåº¦+2',
                    type: 'on_cast'
                }
            ]
        },
        {
            tier: 20,
            options: [
                {
                    id: 'radiance_plus',
                    name: 'åœ£å…‰çš„è®¸è¯º',
                    description: 'çœŸè¨€æœ¯ï¼šè€€å¯å¤šé…ç½®1æ¬¡',
                    type: 'aura'
                },
                {
                    id: 'long_atonement',
                    name: 'æŒä¹…ä¹‹å…‰',
                    description: 'æ•‘èµæŒç»­æ—¶é—´+2å›åˆ',
                    type: 'aura'
                },
                {
                    id: 'dark_side',
                    name: 'é˜´æš—é¢ä¹‹åŠ›',
                    description: 'å¿ƒçµéœ‡çˆ†ä¼¤å®³æé«˜80%',
                    type: 'aura'
                }
            ]
        },
        {
            tier: 30,
            options: [
                {
                    id: 'pwt',
                    name: 'çœŸè¨€æœ¯ï¼šè€',
                    description: 'å…¨é˜Ÿç”Ÿå‘½å€¼æé«˜10%',
                    type: 'aura'
                },
                {
                    id: 'holy_enlight',
                    name: 'ç¥åœ£å¯è¿ª',
                    description: 'å…¨é˜Ÿæ³•æœ¯å¼ºåº¦æé«˜5%',
                    type: 'aura'
                },
                {
                    id: 'shadowfiend',
                    name: 'æš—å½±é­”',
                    description: 'æ¯å›åˆé€ æˆ0.3å€æ³•æœ¯å¼ºåº¦çš„æš—å½±ä¼¤å®³',
                    type: 'dot'
                }
            ]
        },
        {
            tier: 40,
            options: [
                {
                    id: 'fortune_misfortune',
                    name: 'ç¥¸ç¦ç›¸ä¾',
                    description: 'æƒ©å‡»å’Œå¿ƒçµéœ‡çˆ†è·å¾—buffã€ç¥¸ç¦ç›¸ä¾ã€‘ï¼Œæ¯å±‚ä½¿è‹¦ä¿®çš„æ²»ç–—é‡æé«˜25%ï¼Œä½¿ç”¨è‹¦ä¿®åæ¸…ç©ºå±‚æ•°',
                    type: 'on_cast'
                },
                {
                    id: 'ultimate_penance',
                    name: 'ç»ˆæè‹¦ä¿®',
                    description: 'è‹¦ä¿®è¿˜ä¼šå¯¹å½“å‰ç›®æ ‡é€ æˆ2å€æ³•æœ¯å¼ºåº¦çš„ä¼¤å®³',
                    type: 'aura'
                },
                {
                    id: 'borrowed_time',
                    name: 'äº‰åˆ†å¤ºç§’',
                    description: 'é‡Šæ”¾è‹¦ä¿®ä½¿ä½ çš„æ€¥é€Ÿæé«˜30%ï¼ŒæŒç»­4å›åˆ',
                    type: 'on_cast'
                }
            ]
        },
        {
            tier: 50,
            options: [
                {
                    id: 'fantasia',
                    name: 'å¹»æƒ³æ›²',
                    description: 'æ¯å›åˆè·å¾—ä¸€å±‚å¹»æƒ³æ›²ï¼›æ¯å±‚ä½¿ä½ çš„ä¸‹ä¸€ä¸ªã€ç¥åœ£æ–°æ˜Ÿã€‘ä¼¤å®³ä¸æ²»ç–—é‡æé«˜20%ï¼Œæ–½æ”¾åæ¸…ç©ºå±‚æ•°',
                    type: 'on_turn'
                },
                {
                    id: 'holy_barrier',
                    name: 'ç¥åœ£éšœå£',
                    description: 'ã€ç¥åœ£æ–°æ˜Ÿã€‘ä¸ºå…¨é˜Ÿæ–½åŠ 2å›åˆæ•‘èµæ•ˆæœï¼Œå¹¶æ–½åŠ 2å€æ³•æœ¯å¼ºåº¦çš„æŠ¤ç›¾',
                    type: 'on_cast'
                },
                {
                    id: 'holy_avatar',
                    name: 'ç¥åœ£åŒ–èº«',
                    description: 'ä½ çš„æ³•æœ¯å¼ºåº¦æé«˜20%',
                    type: 'aura'
                }
            ]
        }
    ],
    frost_mage: [
        {
            tier: 10,
            options: [
                {
                    id: 'lingering_cold',
                    name: 'å»¶ç»µå¯’å†·',
                    description: 'å¯’å†°ç®­ä½¿ä½ çš„æ³•æœ¯å¼ºåº¦æé«˜5ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸ',
                    type: 'on_cast'
                },
                {
                    id: 'piercing_cold',
                    name: 'å¯’å†·åˆºéª¨',
                    description: 'çˆ†å‡»ç‡æé«˜10',
                    type: 'aura'
                },
                {
                    id: 'frost_amp',
                    name: 'å¯’å†°å¢å¹…',
                    description: 'æ³•æœ¯ä¼¤å®³æé«˜10%',
                    type: 'aura'
                }
            ]
        },
        {
            tier: 20,
            options: [
                {
                    id: 'fingers_of_frost',
                    name: 'å¯’å†°æŒ‡',
                    description: 'å¯’å†°ç®­æœ‰50%æ¦‚ç‡ä½¿ä½ è·å¾—1å±‚å¯’å†°æŒ‡æ•ˆæœï¼Œå¯’å†°æŒ‡ä½¿ä¸‹ä¸€ä¸ªå†°æªæœ¯çš„ä¼¤å®³æé«˜100%',
                    type: 'on_cast'
                },
                {
                    id: 'cold_wisdom',
                    name: 'å†°å†·æ™ºæ…§',
                    description: 'å¯’å†°ç®­æœ‰25%æ¦‚ç‡é¢å¤–å¯¹ç›®æ ‡æ–½æ”¾å†°é£æš´',
                    type: 'on_cast'
                },
                {
                    id: 'endless_winter',
                    name: 'æ— å°½å¯’å†¬',
                    description: 'å¯’å†°å®ç æŒç»­æ—¶é—´æé«˜2å›åˆï¼Œä¼¤å®³æé«˜åˆ°0.8å€æ³•æœ¯å¼ºåº¦',
                    type: 'aura'
                }
            ]
        },
        {
            tier: 30,
            options: [
                {
                    id: 'frozen_touch',
                    name: 'å†°å†»ä¹‹è§¦',
                    description: 'ä½ çš„å†°æªæœ¯é€ æˆçš„ä¼¤å®³æå‡25%',
                    type: 'aura'
                },
                {
                    id: 'cold_intuition',
                    name: 'å†°å†·ç›´è§‰',
                    description: 'ä½ çš„å†°å†·æ™ºæ…§è§¦å‘æ¦‚ç‡æé«˜è‡³40%',
                    type: 'aura'
                },
                {
                    id: 'orb_mastery',
                    name: 'å®ç ç²¾é€š',
                    description: 'ä½ çš„å¯’å†°å®ç é€ æˆDOTä¼¤å®³æ—¶æœ‰25%æ¦‚ç‡ç”Ÿæˆä¸€å±‚å¯’å†°æŒ‡',
                    type: 'on_hit'
                }
            ]
        },
        {
            tier: 40,
            options: [
                {
                    id: 'glacial_spike',
                    name: 'å†°å·çªè¿›',
                    description: 'ä½ çš„å½—æ˜Ÿé£æš´æ¯é€ æˆä¸€æ¬¡ä¼¤å®³ï¼Œè·å–ä¸€å±‚å¯’å†°æŒ‡',
                    type: 'on_hit'
                },
                {
                    id: 'double_comet',
                    name: 'åŒå½—æ˜Ÿ',
                    description: 'ä½ çš„å½—æ˜Ÿé£æš´å¯ä»¥é…ç½®2æ¬¡',
                    type: 'aura'
                },
                {
                    id: 'arcane_intellect',
                    name: 'å¥¥æœ¯æ™ºæ…§',
                    description: 'ä½ çš„å°é˜Ÿæ‰€æœ‰æˆå‘˜çš„æ³•æœ¯å¼ºåº¦æé«˜10%',
                    type: 'aura'
                }
            ]
        },
        {
            tier: 50,
            options: [
                {
                    id: 'frost_crit_breakthrough',
                    type: TALENT_TYPES.AURA,
                    name: 'å¯’å†°çªç ´',
                    description: 'è¶…è¿‡100%çš„æš´å‡»ç‡ä¼šç›´æ¥è½¬åŒ–ä¸ºå¯¹æ€»ä¼¤å®³çš„åŠ æˆã€‚å†°é£æš´æŒç»­æœŸé—´ï¼Œä½ çš„æ‰€æœ‰æš´å‡»ç‡éƒ½è½¬åŒ–ä¸ºä¼¤å®³å¢å¹…ï¼ˆä¸å†è§¦å‘æš´å‡»åˆ¤å®šï¼‰ã€‚'
                },
                {
                    id: 'glacial_mastery',
                    type: TALENT_TYPES.AURA,
                    name: 'æå¯’ç²¾é€š',
                    description: 'å†°æªæœ¯çš„æš´å‡»ä¼¤å®³é¢å¤–å¢åŠ 100%ï¼ˆæ€»è®¡+300%ï¼‰ã€‚å¯’å†°æŒ‡æ•ˆæœæå‡è‡³150%ä¼¤å®³åŠ æˆã€‚'
                },
                {
                    id: 'absolute_zero',
                    type: TALENT_TYPES.AURA,
                    name: 'ç»å¯¹é›¶åº¦',
                    description: 'å†°é£æš´çš„æŒç»­æ—¶é—´å»¶é•¿2å›åˆï¼Œæ¯å›åˆä¼¤å®³æé«˜50%ã€‚å†°é£æš´æœŸé—´ä½ çš„æ‰€æœ‰å†°éœœä¼¤å®³é¢å¤–æé«˜25%ã€‚'
                }
            ]
        },
    ]

};

const SKILLS = {
    basic_attack: {
        limit: 20,
        id: 'basic_attack',
        name: 'æ™®é€šæ”»å‡»',
        description: 'é€ æˆåŸºäºæ”»å‡»å¼ºåº¦çš„ä¼¤å®³',
        icon: 'âš”ï¸',
        type: 'damage',
        calculate: (char) => {
            // æ€¥é€Ÿï¼šæ™®é€šæ”»å‡»ä¼¤å®³æé«˜ï¼ˆæ€¥é€Ÿ * 2%ï¼‰
            const hasteMult = 1 + ((char.stats.haste || 0) * 0.02);
            let damage = char.stats.attack * 1.2 * (char.stats.basicAttackMultiplier || 1) * hasteMult;

            // ===== 50çº§å¤©èµ‹ï¼šçˆ†å‘çªç ´ - è¶…è¿‡100%çš„æš´å‡»ç‡è½¬åŒ–ä¸ºä¼¤å®³åŠ æˆ =====
            let effectiveCritRate = char.stats.critRate || 0;
            let critBreakthroughBonus = 1;
            if (char.talents?.[50] === 'crit_breakthrough' && effectiveCritRate > 100) {
                const excessCrit = effectiveCritRate - 100;
                critBreakthroughBonus = 1 + (excessCrit / 100); // è¶…å‡ºéƒ¨åˆ†ç›´æ¥åŠ æˆ
                effectiveCritRate = 100; // æš´å‡»ç‡å°é¡¶100%
            }
            damage *= critBreakthroughBonus;

            // æš´å‡»åˆ¤å®š
            if (Math.random() < effectiveCritRate / 100) {
                damage *= char.stats.critDamage;
                return {
                    damage: Math.floor(damage),
                    isCrit: true,
                    // 50çº§å¤©èµ‹ï¼šåœ£å‰‘ - æ™®æ”»é¢å¤–é€ æˆæ ¼æŒ¡å€¼ä¼¤å®³
                    holySwordDamage: char.talents?.[50] === 'holy_sword'
                        ? Math.floor((char.stats.blockValue || 0) * 1.0)
                        : 0
                };
            }

            damage *= (1 + char.stats.versatility / 100);
            return {
                damage: Math.floor(damage),
                isCrit: false,
                // 50çº§å¤©èµ‹ï¼šåœ£å‰‘ - æ™®æ”»é¢å¤–é€ æˆæ ¼æŒ¡å€¼ä¼¤å®³
                holySwordDamage: char.talents?.[50] === 'holy_sword'
                    ? Math.floor((char.stats.blockValue || 0) * 1.0)
                    : 0
            };
        }
    },
    rest: {
        limit: 20,
        id: 'rest',
        name: 'ä¼‘æ¯',
        description: 'å›å¤åŸºäºè¡€é‡ä¸Šé™çš„ç”Ÿå‘½',
        icon: 'ğŸ’¤',
        type: 'heal',
        calculate: (char) => ({ heal: Math.floor(char.stats.maxHp * 0.05) })
    },

    // ==================== ç§æ—æŠ€èƒ½ ====================
    racial_human_spirit: {
        id: 'racial_human_spirit',
        name: 'äººç±»ç²¾é­‚',
        icon: 'ğŸ§¬',
        type: 'passive',
        description: 'å…¨èƒ½+2ï¼Œç²¾é€š+2ï¼Œæš´å‡»+2ï¼Œæ€¥é€Ÿ+2ã€‚'
    },
    racial_human_hospitality: {
        id: 'racial_human_hospitality',
        name: 'å®¾è‡³å¦‚å½’',
        icon: 'ğŸ ',
        type: 'passive',
        description: 'ç‚‰çŸ³...å•Šä¸å¯¹ï¼Œåœ°å›¾æˆ˜æ–—ç»“æŸåï¼Œå›å¤æœ€å¤§ç”Ÿå‘½å€¼çš„10%ã€‚'
    },

    racial_dwarf_spirit: {
        id: 'racial_dwarf_spirit',
        name: 'çŸ®äººç²¾é­„',
        icon: 'ğŸª¨',
        type: 'passive',
        description: 'æš´å‡»ä¼¤å®³ +15%ã€‚'
    },
    racial_dwarf_stoneform: {
        id: 'racial_dwarf_stoneform',
        name: 'çŸ³åƒå½¢æ€',
        icon: 'ğŸ—¿',
        type: 'passive',
        description: 'æˆ˜æ–—ä¸­é¦–æ¬¡å—åˆ°ã€è¯…å’’ã€‘ä¸ã€ä¸­æ¯’ã€‘æ•ˆæœæ—¶å…ç–«ï¼ˆæ¯ç§å„ 1 æ¬¡ï¼‰ã€‚'
    },

    racial_nightelf_spirit: {
        id: 'racial_nightelf_spirit',
        name: 'ç²¾çµç²¾é­„',
        icon: 'ğŸŒ™',
        type: 'passive',
        description: 'æ—©æ™¨6ç‚¹-æ™šä¸Š6ç‚¹ï¼šæš´å‡»ç‡+6ï¼›æ™šä¸Š6ç‚¹-æ¬¡æ—¥æ—©æ™¨6ç‚¹ï¼šæ€¥é€Ÿ+6ã€‚'
    },
    racial_nightelf_shadowmeld: {
        id: 'racial_nightelf_shadowmeld',
        name: 'éšé',
        icon: 'ğŸ«¥',
        type: 'passive',
        description: 'åœ°å›¾æˆ˜æ–—ä¸­ï¼šç¬¬1æ ¼æŠ€èƒ½é€ æˆçš„ä¼¤å®³æé«˜20%ï¼ˆä¹˜ç®—ï¼‰ã€‚'
    },

    racial_gnome_spirit: {
        id: 'racial_gnome_spirit',
        name: 'ä¾å„’ç²¾é­„',
        icon: 'âš™ï¸',
        type: 'passive',
        description: 'å…¨èƒ½ +6ã€‚'
    },
    racial_gnome_familiarity: {
        id: 'racial_gnome_familiarity',
        name: 'ç†Ÿç¨”',
        icon: 'ğŸ”§',
        type: 'passive',
        description: 'ä¸€ä¸ªå‘å¾®çš„ä¾å„’ï¼Ÿç†Ÿç»ƒå¢åŠ 30ã€‚'
    },


    racial_orc_spirit: {
        id: 'racial_orc_spirit',
        name: 'å…½äººç²¾é­„',
        icon: 'ğŸ©¸',
        type: 'passive',
        description: 'ç²¾é€š +3ï¼Œå…¨èƒ½ +3ã€‚'
    },
    racial_orc_bloodfury: {
        id: 'racial_orc_bloodfury',
        name: 'è¡€æ€§ç‹‚æ€’',
        icon: 'ğŸ”¥',
        type: 'passive',
        description: 'å…½äººæ°¸ä¸ä¸ºå¥´ï¼å‰4ä¸ªæŠ€èƒ½æ ¼é€ æˆçš„ä¼¤å®³æé«˜10%ã€‚'
    },




    mastery_precise_block: {
        id: 'mastery_precise_block',
        name: 'ç²¾é€šï¼šç²¾ç¡®æ ¼æŒ¡',
        icon: 'ğŸ¯',
        iconUrl : 'icons/wow/vanilla/abilities/Ability_Warrior_DefensiveStance.png',
        type: 'passive',
        description: 'è¢«åŠ¨ï¼šæ ¼æŒ¡å€¼æé«˜(10 + ç²¾é€š/2)%ã€‚è¯¥æå‡åŸºäºåŸå§‹æ ¼æŒ¡æ•°å€¼ã€‚'
    },
    shield_bash: {
        limit: 3,
        id: 'shield_bash',
        name: 'ç›¾ç‰ŒçŒ›å‡»',
        description: 'é€ æˆåŸºäºæ”»å‡»å¼ºåº¦å’Œæ ¼æŒ¡å€¼çš„ä¼¤å®³',
        icon: 'ğŸ›¡ï¸',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Fire_FireArmor.png',
        type: 'damage',
        calculate: (char) => {
            let damage = char.stats.attack * 1.5 + char.stats.blockValue * 0.3;
            damage *= (1 + char.stats.mastery / 100);
            if (Math.random() < char.stats.critRate/100) {
                damage *= char.stats.critDamage;
                return { damage: Math.floor(damage), isCrit: true };
            }
            damage *= (1 + char.stats.versatility / 100);
            return { damage: Math.floor(damage), isCrit: false };
        }
    },
    shield_block: {
        limit: 2,
        id: 'shield_block',
        name: 'ç›¾ç‰Œæ ¼æŒ¡',
        description: 'è·å¾—40%æ ¼æŒ¡ç‡åŠ æˆï¼ŒæŒç»­2å¸§',
        icon: 'ğŸ”°',
        iconUrl : 'icons/wow/vanilla/abilities/Ability_Defend.png',
        type: 'buff',
        duration: 2,
        calculate: () => ({ buff: { blockRate: 0.4, duration: 2 } })
    },
    revenge: {
        limit: 2,
        id: 'revenge',
        name: 'å¤ä»‡',
        description: 'é€ æˆåŸºäºæ”»å‡»å¼ºåº¦çš„é«˜é¢ä¼¤å®³',
        icon: 'ğŸ’¥',
        iconUrl : 'icons/wow/vanilla/abilities/Ability_Warrior_Revenge.png',
        type: 'damage',
        calculate: (char) => {
            let damage = char.stats.attack * 2.5;
            if (Math.random() < char.stats.critRate/100) {
                damage *= char.stats.critDamage;
                return { damage: Math.floor(damage), isCrit: true };
            }
            damage *= (1 + char.stats.versatility / 100);
            return { damage: Math.floor(damage), isCrit: false };
        }
    },
    thunder_strike: {
        id: 'thunder_strike',
        name: 'é›·éœ†ä¸€å‡»',
        icon: 'âš¡',
        iconUrl : 'icons/wow/vanilla/abilities/Ability_ThunderClap.png',
        type: 'aoe_damage',
        limit: 2,
        description: 'å¯¹æ‰€æœ‰æ•Œäººé€ æˆ0.8å€æ”»å‡»å¼ºåº¦çš„ä¼¤å®³ï¼Œæš´å‡»æ—¶å¯¹æ¯ä¸ªç›®æ ‡æ–½åŠ é‡ä¼¤ï¼ˆDOT 0.5å€æ”»å‡»å¼ºåº¦ï¼ŒæŒç»­4å›åˆï¼‰',
        calculate: (char) => {
            let baseDamage = char.stats.attack * 0.8;

            // æš´å‡»åˆ¤å®š
            const isCrit = Math.random() < (char.stats.critRate / 100);
            if (isCrit) {
                baseDamage *= char.stats.critDamage;
            }

            // å…¨èƒ½åŠ æˆ
            baseDamage *= (1 + char.stats.versatility / 100);

            const damage = Math.floor(baseDamage);

            // æš´å‡»æ—¶ç”Ÿæˆçš„DOTï¼ˆæ¯ç›®æ ‡ç‹¬ç«‹ï¼‰
            const dot = isCrit ? {
                damagePerTurn: Math.floor(char.stats.attack * 0.5),
                duration: 4,
                name: 'é‡ä¼¤'
            } : null;

            return {
                aoeDamage: damage,
                isCrit,
                dotOnCrit: dot  // æˆ˜æ–—ç³»ç»Ÿä¼šæ£€æŸ¥è¿™ä¸ªå¹¶å¯¹æ¯ä¸ªç›®æ ‡æ–½åŠ 
            };
        }
    },

    shield_wall: {
        id: 'shield_wall',
        name: 'ç›¾å¢™',
        icon: 'ğŸ›¡ï¸',
        iconUrl : 'icons/wow/vanilla/abilities/Ability_Warrior_ShieldWall.png',
        type: 'buff',
        limit: 1, // åŸºç¡€1æ¬¡ï¼ŒæŠ¤å«ç¥ç›¾å¤©èµ‹å¯æå‡åˆ°2æ¬¡
        description: 'å—åˆ°çš„æ‰€æœ‰ä¼¤å®³é™ä½50%ï¼ŒæŒç»­3å›åˆ',
        duration: 3,
        calculate: (char) => {
            // 40çº§å¤©èµ‹ï¼šåšæ¯…é•¿åŸ - å‡ä¼¤æé«˜åˆ°75%
            const damageTakenMult = char.talents?.[40] === 'fortified_wall' ? 0.25 : 0.5;
            // 40çº§å¤©èµ‹ï¼šæ— åšä¸æ‘§ä¹‹åŠ› - é€ æˆä¼¤å®³æé«˜50%
            const damageDealtMult = char.talents?.[40] === 'indomitable_might' ? 1.5 : 1;

            return {
                buff: {
                    damageTakenMult,
                    damageDealtMult,
                    duration: 3
                }
            };
        }
    },
    mastery_atonement: {
        id: 'mastery_atonement',
        name: 'ç²¾é€šï¼šæ•‘èµ',
        icon: 'âœï¸',
        iconUrl : 'icons/wow/vanilla/items/INV_Banner_01.png',
        type: 'passive',
        description: 'è¢«åŠ¨ï¼šæ•‘èµæ²»ç–—æ¯”ä¾‹æå‡(ç²¾é€š/5)%ã€‚è¯¥æ•°å€¼ç›´æ¥åŠ åœ¨åŸºç¡€20%ä¸Šã€‚'
    },
    smite: {
        id: 'smite',
        name: 'æƒ©å‡»',
        icon: 'âœ¨',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Holy_HolySmite.png',
        type: 'damage',
        limit: 3,
        description: 'é€ æˆåŸºäºæ³•æœ¯å¼ºåº¦çš„ç¥åœ£ä¼¤å®³',
        calculate: (char) => {
            let damage = char.stats.spellPower * 1.2;
            return {
                damage: Math.floor(damage),
                school: 'holy'
            };
        }
    },
    shadow_word_pain: {
        id: 'shadow_word_pain',
        name: 'çœŸè¨€æœ¯ï¼šç—›',
        icon: 'ğŸ©¸',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Shadow_ShadowWordPain.png',
        type: 'dot',
        limit: 2,
        description: 'æŒç»­3å›åˆé€ æˆæš—å½±ä¼¤å®³',
        calculate: (char) => ({
            dot: {
                school: 'shadow',
                damagePerTurn: Math.floor(char.stats.spellPower * 0.6),
                duration: 3
            }
        })
    },
    mind_blast: {
        id: 'mind_blast',
        name: 'å¿ƒçµéœ‡çˆ†',
        icon: 'ğŸ§ ',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Shadow_UnholyFrenzy.png',
        type: 'damage',
        limit: 2,
        description: 'é€ æˆé«˜é¢æš—å½±ä¼¤å®³',
        calculate: (char) => {
            let damage = char.stats.spellPower * 2.0;
            return {
                damage: Math.floor(damage),
                school: 'shadow'
            };
        }
    },
    power_word_radiance: {
        id: 'power_word_radiance',
        name: 'çœŸè¨€æœ¯ï¼šè€€',
        icon: 'ğŸŒŸ',
        iconUrl : 'icons/wow/vanilla/spells/yao.png',
        type: 'heal',
        limit: 2,
        description: 'ä¸ºå…¨é˜Ÿæ²»ç–—å¹¶æ–½åŠ ã€æ•‘èµã€‘',
        calculate: (char) => ({
            healAll: Math.floor(char.stats.spellPower * 1.5),
            applyAtonement: {
                duration: 2
            }
        })
    },
    penance: {
        id: 'penance',
        name: 'è‹¦ä¿®',
        icon: 'âœï¸',
        iconUrl : 'icons/wow/vanilla/spells/kuxiu.png',
        type: 'heal',
        limit: 2,
        description: 'å¯¹æœ€å‰æ’çš„é˜Ÿå‹å›å¤3å€æ³•æœ¯å¼ºåº¦çš„ç”Ÿå‘½å€¼',
        calculate: (char, combatContext) => {
            let healAmount = Math.floor(char.stats.spellPower * 3);

            // 40çº§å¤©èµ‹ï¼šç¥¸ç¦ç›¸ä¾ - æ¯å±‚æé«˜25%æ²»ç–—é‡
            const fortuneStacks = combatContext?.fortuneMisfortuneStacks || 0;
            if (char.talents?.[40] === 'fortune_misfortune' && fortuneStacks > 0) {
                healAmount = Math.floor(healAmount * (1 + fortuneStacks * 0.25));
            }

            const result = {
                penanceHeal: healAmount,
                clearFortuneStacks: char.talents?.[40] === 'fortune_misfortune'
            };

            // 40çº§å¤©èµ‹ï¼šç»ˆæè‹¦ä¿® - è¿˜ä¼šé€ æˆ2å€æ³•å¼ºä¼¤å®³
            if (char.talents?.[40] === 'ultimate_penance') {
                result.penanceDamage = Math.floor(char.stats.spellPower * 2);
            }

            // 40çº§å¤©èµ‹ï¼šäº‰åˆ†å¤ºç§’ - é‡Šæ”¾åæ€¥é€Ÿ+30%æŒç»­4å›åˆ
            if (char.talents?.[40] === 'borrowed_time') {
                result.applyHasteBuff = {
                    hasteBonus: 30,
                    duration: 4
                };
            }

            return result;
        }
    },
    holy_nova: {
        id: 'holy_nova',
        name: 'ç¥åœ£æ–°æ˜Ÿ',
        icon: 'ğŸ’¥',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Holy_HolyNova.png',
        type: 'aoe_hybrid',
        limit: 1,
        description: 'å¯¹æ‰€æœ‰æ•Œäººé€ æˆ 2å€æ³•æœ¯å¼ºåº¦ çš„ç¥åœ£ä¼¤å®³ï¼Œå¹¶å¯¹æ‰€æœ‰é˜Ÿå‹æ¢å¤ 2å€æ³•æœ¯å¼ºåº¦ çš„ç”Ÿå‘½å€¼',
        calculate: (char, combatContext) => {
            const base = Math.floor(char.stats.spellPower * 2);

            // 50çº§å¤©èµ‹ï¼šå¹»æƒ³æ›² - æ¯å±‚ä½¿ä¸‹ä¸€ä¸ªç¥åœ£æ–°æ˜Ÿä¼¤å®³/æ²»ç–— +20%ï¼Œæ–½æ”¾åæ¸…ç©º
            const fantasiaStacks = Number(combatContext?.fantasiaStacks) || 0;
            const fantasiaMult = (char.talents?.[50] === 'fantasia' && fantasiaStacks > 0)
                ? (1 + fantasiaStacks * 0.20)
                : 1;

            const amount = Math.floor(base * fantasiaMult);

            const result = {
                aoeDamage: amount,
                healAll: amount,
                school: 'holy',

                fantasiaStacksUsed: (fantasiaMult > 1) ? fantasiaStacks : 0,
                clearFantasiaStacks: (fantasiaMult > 1)
            };

            // 50çº§å¤©èµ‹ï¼šç¥åœ£éšœå£ - ç¥åœ£æ–°æ˜Ÿä¸ºå…¨é˜Ÿæ–½åŠ 2å›åˆæ•‘èµï¼Œå¹¶æ–½åŠ 2å€æ³•æœ¯å¼ºåº¦æŠ¤ç›¾ï¼ˆåœ¨Bossæˆ˜ä¼šæ‰©å±•åˆ°å…¨é˜Ÿï¼‰
            if (char.talents?.[50] === 'holy_barrier') {
                result.applyAtonement = { duration: 2 };
                const sp = Number(char.stats.spellPower) || 0;
                result.shield = {
                    type: 'holy_barrier',
                    name: 'ç¥åœ£éšœå£',
                    amount: Math.floor(sp * 2),
                    maxAmount: Math.floor(sp * 2),
                    duration: 2
                };
            }

            return result;
        }
    },


    // ==================== å†°éœœæ³•å¸ˆæŠ€èƒ½ ====================
    mastery_deep_winter: {
        id: 'mastery_deep_winter',
        name: 'ç²¾é€šï¼šæ·±å†¬ä¹‹å¯’',
        icon: 'â„ï¸',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Frost_FrostWard.png',
        type: 'passive',
        description: 'è¢«åŠ¨ï¼šå†°æªæœ¯çš„åŸºç¡€æŠ€èƒ½å€ç‡æå‡(ç²¾é€š/2)%ã€‚è¯¥æ•°å€¼ç›´æ¥åŠ åœ¨åŸºç¡€120%ä¸Šã€‚'
    },
    frostbolt: {
        id: 'frostbolt',
        name: 'å¯’å†°ç®­',
        icon: 'â„ï¸',
        iconUrl: 'icons/wow/vanilla/spells/Spell_Frost_FrostBolt02.png',
        type: 'damage',
        limit: 8,
        description: 'é€ æˆ1.8å€æ³•æœ¯å¼ºåº¦çš„å†°éœœä¼¤å®³',
        calculate: (char, combatContext) => {
            let damage = char.stats.spellPower * 1.8;

            // å†°å†·è¡€è„‰buffï¼šå†°éœœä¼¤å®³æé«˜50%
            if (combatContext?.icyVeinsBuff) {
                damage *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æ³•æœ¯ä¼¤å®³æé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                damage *= 1.1;
            }

            // 50çº§å¤©èµ‹ï¼šç»å¯¹é›¶åº¦ - å†°é£æš´æœŸé—´æ‰€æœ‰å†°éœœä¼¤å®³é¢å¤–+25%
            if (char.talents?.[50] === 'absolute_zero' && combatContext?.blizzardActive) {
                damage *= 1.25;
            }

            // æš´å‡»åˆ¤å®š
            let critRate = char.stats.critRate || 0;
            // 10çº§å¤©èµ‹ï¼šå¯’å†·åˆºéª¨ - æš´å‡»ç‡æé«˜10
            if (char.talents?.[10] === 'piercing_cold') {
                critRate += 10;
            }

            // ===== 50çº§å¤©èµ‹ï¼šå¯’å†°çªç ´ =====
            let critBreakthroughBonus = 1;
            let forcedCritConversion = false;

            if (char.talents?.[50] === 'frost_crit_breakthrough') {
                if (combatContext?.blizzardActive) {
                    // å†°é£æš´æœŸé—´ï¼šæ‰€æœ‰æš´å‡»ç‡è½¬åŒ–ä¸ºä¼¤å®³åŠ æˆ
                    critBreakthroughBonus = 1 + (critRate / 100);
                    forcedCritConversion = true;
                    critRate = 0;
                } else if (critRate > 100) {
                    // éå†°é£æš´æœŸé—´ï¼šè¶…è¿‡100%çš„æš´å‡»è½¬åŒ–ä¸ºä¼¤å®³
                    const excessCrit = critRate - 100;
                    critBreakthroughBonus = 1 + (excessCrit / 100);
                    critRate = 100;
                }
            }

            damage *= critBreakthroughBonus;

            const isCrit = !forcedCritConversion && Math.random() < critRate / 100;
            if (isCrit) {
                damage *= char.stats.critDamage;
            }

            return {
                damage: Math.floor(damage),
                isCrit,
                school: 'frost',
                triggerFrostboltTalents: true,
                critConverted: forcedCritConversion
            };
        }
    },
    ice_lance: {
        id: 'ice_lance',
        name: 'å†°æªæœ¯',
        icon: 'ğŸ”±',
        iconUrl: 'icons/wow/vanilla/spells/Spell_Frost_FrostBlast.png',
        type: 'damage',
        limit: 8,
        description: 'é€ æˆ1.2å€æ³•æœ¯å¼ºåº¦çš„å†°éœœä¼¤å®³ï¼Œçˆ†å‡»ä¼¤å®³é¢å¤–å¢åŠ 200%',
        calculate: (char, combatContext) => {
            const baseMult = char.stats.iceLanceBaseMultiplier ?? 1.2;
            let damage = char.stats.spellPower * baseMult;

            // å†°å†·è¡€è„‰buffï¼šå†°éœœä¼¤å®³æé«˜50%
            if (combatContext?.icyVeinsBuff) {
                damage *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æ³•æœ¯ä¼¤å®³æé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                damage *= 1.1;
            }

            // 30çº§å¤©èµ‹ï¼šå†°å†»ä¹‹è§¦ - å†°æªæœ¯ä¼¤å®³æå‡25%
            if (char.talents?.[30] === 'frozen_touch') {
                damage *= 1.25;
            }

            // 20çº§å¤©èµ‹ï¼šå¯’å†°æŒ‡ - æ¶ˆè€—ä¸€å±‚å¯’å†°æŒ‡ï¼Œä¼¤å®³æé«˜100%ï¼ˆæˆ–150%å¦‚æœæœ‰æå¯’ç²¾é€šï¼‰
            const fingersOfFrost = combatContext?.fingersOfFrost || 0;
            let consumeFinger = false;
            if (char.talents?.[20] === 'fingers_of_frost' && fingersOfFrost > 0) {
                // 50çº§å¤©èµ‹ï¼šæå¯’ç²¾é€š - å¯’å†°æŒ‡æ•ˆæœæå‡è‡³150%
                const fingerBonus = char.talents?.[50] === 'glacial_mastery' ? 2.5 : 2;
                damage *= fingerBonus;
                consumeFinger = true;
            }

            // ===== 50çº§å¤©èµ‹ï¼šç»å¯¹é›¶åº¦ - å†°é£æš´æœŸé—´æ‰€æœ‰å†°éœœä¼¤å®³é¢å¤–+25% =====
            if (char.talents?.[50] === 'absolute_zero' && combatContext?.blizzardActive) {
                damage *= 1.25;
            }

            // æš´å‡»åˆ¤å®š
            let critRate = char.stats.critRate || 0;
            // 10çº§å¤©èµ‹ï¼šå¯’å†·åˆºéª¨ - æš´å‡»ç‡æé«˜10
            if (char.talents?.[10] === 'piercing_cold') {
                critRate += 10;
            }

            // ===== 50çº§å¤©èµ‹ï¼šå¯’å†°çªç ´ =====
            let critBreakthroughBonus = 1;
            let forcedCritConversion = false; // å†°é£æš´æœŸé—´å¼ºåˆ¶è½¬æ¢æ‰€æœ‰æš´å‡»

            if (char.talents?.[50] === 'frost_crit_breakthrough') {
                // å†°é£æš´æœŸé—´ï¼šæ‰€æœ‰æš´å‡»ç‡è½¬åŒ–ä¸ºä¼¤å®³åŠ æˆï¼Œä¸å†æš´å‡»
                if (combatContext?.blizzardActive) {
                    critBreakthroughBonus = 1 + (critRate / 100);
                    forcedCritConversion = true;
                    critRate = 0; // ä¸å†è¿›è¡Œæš´å‡»åˆ¤å®š
                } else {
                    // éå†°é£æš´æœŸé—´ï¼šè¶…è¿‡100%çš„æš´å‡»è½¬åŒ–ä¸ºä¼¤å®³
                    if (critRate > 100) {
                        const excessCrit = critRate - 100;
                        critBreakthroughBonus = 1 + (excessCrit / 100);
                        critRate = 100;
                    }
                }
            }

            damage *= critBreakthroughBonus;

            // å†°é£æš´DOTæœŸé—´å¿…å®šçˆ†å‡»ï¼ˆé™¤éè¢«å¯’å†°çªç ´è½¬æ¢ï¼‰
            let forceCrit = false;
            if (combatContext?.blizzardActive && !forcedCritConversion) {
                forceCrit = true;
            }

            const isCrit = !forcedCritConversion && (forceCrit || Math.random() < critRate / 100);
            if (isCrit) {
                // åŸºç¡€æš´å‡»ä¼¤å®³ + é¢å¤–200%ï¼ˆæˆ–300%å¦‚æœæœ‰æå¯’ç²¾é€šï¼‰
                const extraCritDamage = char.talents?.[50] === 'glacial_mastery' ? 3 : 2;
                damage *= (char.stats.critDamage + extraCritDamage);
            }

            return {
                damage: Math.floor(damage),
                isCrit,
                school: 'frost',
                consumeFingersOfFrost: consumeFinger,
                critConverted: forcedCritConversion // æ ‡è®°æš´å‡»è¢«è½¬æ¢
            };
        }
    },
    blizzard: {
        id: 'blizzard',
        name: 'å†°é£æš´',
        icon: 'ğŸŒ¨ï¸',
        iconUrl: 'icons/wow/vanilla/spells/bingfengbao.png',
        type: 'dot',
        limit: 2,
        description: 'DOTæŒç»­3å›åˆï¼Œæ¯å›åˆé€ æˆ1å€æ³•æœ¯å¼ºåº¦çš„å†°éœœä¼¤å®³ï¼ŒæŒç»­æœŸé—´å†°æªæœ¯å¿…å®šçˆ†å‡»',
        calculate: (char, combatContext) => {
            let damagePerTurn = char.stats.spellPower * 1;
            let duration = 3;

            // 50çº§å¤©èµ‹ï¼šç»å¯¹é›¶åº¦ - æŒç»­æ—¶é—´+2ï¼Œä¼¤å®³+50%
            if (char.talents?.[50] === 'absolute_zero') {
                duration = 5;
                damagePerTurn *= 1.5;
            }

            // å†°å†·è¡€è„‰buffï¼šå†°éœœä¼¤å®³æé«˜50%
            if (combatContext?.icyVeinsBuff) {
                damagePerTurn *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æ³•æœ¯ä¼¤å®³æé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                damagePerTurn *= 1.1;
            }

            return {
                dot: {
                    school: 'frost',
                    name: 'å†°é£æš´',
                    damagePerTurn: Math.floor(damagePerTurn),
                    duration: duration,
                    enableIceLanceCrit: true // æ ‡è®°å†°æªæœ¯å¿…å®šçˆ†å‡»
                }
            };
        }
    },
    frozen_orb: {
        id: 'frozen_orb',
        name: 'å¯’å†°å®ç ',
        icon: 'ğŸ”®',
        iconUrl : 'icons/wow/vanilla/spells/hanbingbaozhu.png',
        type: 'aoe_dot',
        limit: 2,
        description: 'å¯¹æ‰€æœ‰æ•Œæ–¹å•ä½æ–½åŠ DOTï¼ŒæŒç»­3å›åˆï¼Œæ¯å›åˆé€ æˆ0.5å€æ³•æœ¯å¼ºåº¦çš„ä¼¤å®³',
        calculate: (char, combatContext) => {
            let damagePerTurn = char.stats.spellPower * 0.5;
            let duration = 3;

            // 20çº§å¤©èµ‹ï¼šæ— å°½å¯’å†¬ - æŒç»­æ—¶é—´+2ï¼Œä¼¤å®³æé«˜åˆ°0.8å€
            if (char.talents?.[20] === 'endless_winter') {
                duration = 5;
                damagePerTurn = char.stats.spellPower * 0.8;
            }

            // å†°å†·è¡€è„‰buffï¼šå†°éœœä¼¤å®³æé«˜50%
            if (combatContext?.icyVeinsBuff) {
                damagePerTurn *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æ³•æœ¯ä¼¤å®³æé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                damagePerTurn *= 1.1;
            }

            // 50çº§å¤©èµ‹ï¼šç»å¯¹é›¶åº¦ - å†°é£æš´æœŸé—´æ‰€æœ‰å†°éœœä¼¤å®³é¢å¤–+25%
            if (char.talents?.[50] === 'absolute_zero' && combatContext?.blizzardActive) {
                damagePerTurn *= 1.25;
            }

            return {
                aoeDot: {
                    school: 'frost',
                    name: 'å¯’å†°å®ç ',
                    damagePerTurn: Math.floor(damagePerTurn),
                    duration: duration,
                    canGenerateFinger: char.talents?.[30] === 'orb_mastery'
                }
            };
        }
    },
    icy_veins: {
        id: 'icy_veins',
        name: 'å†°å†·è¡€è„‰',
        icon: 'ğŸ’ ',
        iconUrl : 'icons/wow/vanilla/spells/spell_frost_coldhearted.jpg',
        type: 'buff',
        limit: 1,
        description: 'ä½ é€ æˆçš„å†°éœœä¼¤å®³æé«˜50%ï¼Œæ€¥é€Ÿæé«˜50%ï¼ŒæŒç»­4å›åˆ',
        calculate: (char) => {
            return {
                buff: {
                    type: 'icy_veins',
                    frostDamageMult: 1.5,
                    hasteBonus: 50,
                    duration: 4
                }
            };
        }
    },
    comet_storm: {
        id: 'comet_storm',
        name: 'å½—æ˜Ÿé£æš´',
        icon: 'â˜„ï¸',
        iconUrl : 'icons/wow/vanilla/spells/huixingfengbao.png',
        type: 'aoe_damage',
        limit: 1,
        description: 'å¯¹æ‰€æœ‰æ•Œäººé€ æˆ3å€æ³•æœ¯å¼ºåº¦çš„ä¼¤å®³',
        calculate: (char, combatContext) => {
            let damage = char.stats.spellPower * 3;

            // å†°å†·è¡€è„‰buffï¼šå†°éœœä¼¤å®³æé«˜50%
            if (combatContext?.icyVeinsBuff) {
                damage *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æ³•æœ¯ä¼¤å®³æé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                damage *= 1.1;
            }

            // 50çº§å¤©èµ‹ï¼šç»å¯¹é›¶åº¦ - å†°é£æš´æœŸé—´æ‰€æœ‰å†°éœœä¼¤å®³é¢å¤–+25%
            if (char.talents?.[50] === 'absolute_zero' && combatContext?.blizzardActive) {
                damage *= 1.25;
            }

            // æš´å‡»åˆ¤å®š
            let critRate = char.stats.critRate || 0;
            if (char.talents?.[10] === 'piercing_cold') {
                critRate += 10;
            }

            // ===== 50çº§å¤©èµ‹ï¼šå¯’å†°çªç ´ =====
            let critBreakthroughBonus = 1;
            let forcedCritConversion = false;

            if (char.talents?.[50] === 'frost_crit_breakthrough') {
                if (combatContext?.blizzardActive) {
                    critBreakthroughBonus = 1 + (critRate / 100);
                    forcedCritConversion = true;
                    critRate = 0;
                } else if (critRate > 100) {
                    const excessCrit = critRate - 100;
                    critBreakthroughBonus = 1 + (excessCrit / 100);
                    critRate = 100;
                }
            }

            damage *= critBreakthroughBonus;

            const isCrit = !forcedCritConversion && Math.random() < critRate / 100;
            if (isCrit) {
                damage *= char.stats.critDamage;
            }

            return {
                aoeDamage: Math.floor(damage),
                isCrit,
                school: 'frost',
                generateFingerOnHit: char.talents?.[40] === 'glacial_spike',
                critConverted: forcedCritConversion
            };
        }
    },ice_barrier: {
        id: 'ice_barrier',
        name: 'å¯’å†°æŠ¤ä½“',
        icon: 'ğŸ§Š',
        iconUrl: 'icons/wow/vanilla/spells/Spell_Ice_Lament.png',
        type: 'shield',
        limit: 1,
        description: 'ä¸ºè‡ªå·±æ–½åŠ ä¸€ä¸ªæŠ¤ç›¾ï¼Œå¸æ”¶2.5å€æ³•æœ¯å¼ºåº¦çš„ä¼¤å®³ï¼ŒæŒç»­4å›åˆã€‚æŠ¤ç›¾å­˜åœ¨æ—¶å—å‡»æœ‰25%æ¦‚ç‡è·å¾—1å±‚å¯’å†°æŒ‡ã€‚',
        calculate: (char, combatContext) => {
            let shieldAmount = char.stats.spellPower * 2.5;

            // å†°å†·è¡€è„‰å¢å¼ºæŠ¤ç›¾
            if (combatContext?.icyVeinsBuff) {
                shieldAmount *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æŠ¤ç›¾é‡ä¹Ÿæé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                shieldAmount *= 1.1;
            }

            return {
                shield: {
                    type: 'ice_barrier',
                    name: 'å¯’å†°æŠ¤ä½“',
                    amount: Math.floor(shieldAmount),
                    maxAmount: Math.floor(shieldAmount),
                    duration: 4,
                    // å—å‡»æ—¶è§¦å‘æ•ˆæœ
                    onHitEffect: {
                        type: 'generate_finger',
                        chance: 0.25
                    }
                }
            };
        }
    },
    // åœ¨ SKILLS å¯¹è±¡ä¸­æ·»åŠ 
    conditional_frost_strike: {
        id: 'conditional_frost_strike',
        name: 'å†°éœœæ‰“å‡»ï¼ˆæ™ºèƒ½ï¼‰',
        icon: 'ğŸ§Š',
        iconUrl: 'icons/wow/vanilla/spells/Spell_Frost_IceStorm.png',
        type: 'conditional',  // æ–°ç±»å‹ï¼šæ¡ä»¶æŠ€èƒ½
        limit: 8,
        description: 'æœ‰å¯’å†°æŒ‡æ—¶é‡Šæ”¾å†°æªæœ¯ï¼Œå¦åˆ™é‡Šæ”¾å¯’å†°ç®­',

        // æ¡ä»¶é…ç½®
        condition: {
            type: 'has_buff',
            buffName: 'fingersOfFrost',  // æ£€æŸ¥å¯’å†°æŒ‡å±‚æ•°
            minStacks: 1
        },
        skillIfTrue: 'ice_lance',    // æ»¡è¶³æ¡ä»¶ç”¨å†°æª
        skillIfFalse: 'frostbolt',   // ä¸æ»¡è¶³ç”¨å†°ç®­

        // calculate ä¼šåœ¨æˆ˜æ–—ç³»ç»Ÿä¸­è¢«æ›¿æ¢ä¸ºå®é™…æŠ€èƒ½çš„ calculate
        calculate: (char, combatContext) => {
            // è¿™ä¸ªå‡½æ•°å®é™…ä¸Šä¸ä¼šè¢«ç›´æ¥è°ƒç”¨
            // æˆ˜æ–—ç³»ç»Ÿä¼šæ ¹æ®æ¡ä»¶é€‰æ‹©çœŸæ­£çš„æŠ€èƒ½
            return {};
        }
    },
};

const ZONES = {
    elwynn_forest: {
        id: 'elwynn_forest',
        name: 'è‰¾å°”æ–‡æ£®æ—',
        level: 1,
        type: 'explore',
        enemies: [
            { name: 'ç‹¼', hp: 30, attack: 5, defense: 2, exp: 10, gold: 5 },
            { name: 'åœŸåŒª', hp: 50, attack: 8, defense: 5, exp: 20, gold: 15 },
        ],
        resources: ['æœ¨æ', 'è‰è¯'],
        unlocked: true
    },
    westfall: {
        id: 'westfall',
        name: 'è¥¿éƒ¨è’é‡',
        level: 10,
        type: 'explore',
        enemies: [
            { name: 'æ”¶å‰²æœºå‚€å„¡', hp: 250, attack: 25, defense: 20, exp: 45, gold: 35 },
            { name: 'è¿ªè²äºšç›—è´¼', hp: 300, attack: 30, defense: 18, exp: 50, gold: 40 },
        ],
        resources: ['æœ¨æ', 'æ¯›çš®'],
        unlocked: false,
        unlockLevel: 10
    },
    redridge: {
        id: 'redridge',
        name: 'èµ¤è„Šå±±',
        level: 20,
        type: 'explore',
        enemies: [
            { name: 'è±ºç‹¼äºº', hp: 1500, attack: 55, defense: 40, exp: 80, gold: 70 },
            { name: 'é»‘çŸ³å…½äºº', hp: 2000, attack: 85, defense: 50, exp: 120, gold: 100 },
        ],
        resources: ['æœ¨æ', 'é“çŸ¿'],
        unlocked: false,
        unlockLevel: 20
    },
    barrens: {
        id: 'barrens',
        name: 'è´«ç˜ ä¹‹åœ°',
        level: 25,
        type: 'explore',
        enemies: [
            {
                name: 'é£é™©æŠ•èµ„å…¬å¸é›‡å‘˜',
                hp: 5000,
                attack: 100,
                defense: 90,
                exp: 1200,
                gold: 800
            },
            {
                name: 'è´«ç˜ ä¹‹åœ°å°é‡çŒª',
                hp: 8000,
                attack: 75,
                defense: 100,
                exp: 1100,
                gold: 900
            }
        ],
        resources: ['æ¯›çš®','é“çŸ¿'],
        unlocked: false,
        unlockLevel: 25
    },
    stranglethorn_vale: {
        id: 'stranglethorn_vale',
        name: 'è†æ£˜è°·',
        level: 30,
        type: 'explore',
        enemies: [
            {
                name: 'ä¸›æ—å¤§çŒ©çŒ©',
                hp: 9000,
                attack: 140,
                defense: 100,
                exp: 1700,
                gold: 1200
            },
            {
                name: 'è¡€é¡¶å·¨é­”',
                hp: 7000,
                attack: 150,
                defense: 110,
                exp: 1800,
                gold: 1200
            },
            {
                name: 'å·´å°”ç‘Ÿæ‹‰',
                hp: 15000,
                attack: 200,
                defense: 130,
                exp: 2500,
                gold: 1900
            },
            {
                name: 'é‚¦åŠ æ‹‰ä»€',
                hp: 12000,
                attack: 250,
                defense: 120,
                exp: 2500,
                gold: 2000
            }
        ],
        resources: ['æ¯›çš®', 'è‰è¯'],
        unlocked: false,
        unlockLevel: 30
    },
    dustwallow_marsh: {
        id: 'dustwallow_marsh',
        name: 'å°˜æ³¥æ²¼æ³½',
        level: 35,
        type: 'explore',
        enemies: [
            {
                name: 'å¥¥å¦®å…‹å¸Œäºšçš„çˆªç‰™',
                hp: 28000,
                attack: 280,
                defense: 200,
                exp: 2000,
                gold: 1800
            },
            {
                name: 'çŸ³æ§Œé£Ÿäººé­”',
                hp: 26000,
                attack: 250,
                defense: 240,
                exp: 1800,
                gold: 1600
            },
            {
                name: 'åˆ©é½¿é³„é±¼',
                hp: 30000,
                attack: 300,
                defense: 180,
                exp: 2200,
                gold: 1900
            }
        ],
        resources: ['è‰è¯', 'æ¯›çš®'],
        unlocked: false,
        unlockLevel: 35
    },
    desolace: {
        id: 'desolace',
        name: 'å‡„å‡‰ä¹‹åœ°',
        level: 35,
        type: 'explore',
        enemies: [
            {
                name: 'æ¯’åˆºé­ç¬è€…',
                hp: 28000,
                attack: 420,
                defense: 200,
                exp: 2000,
                gold: 1800
            },
            {
                name: 'è¨ç‰¹æ½œè¡Œè€…',
                hp: 26000,
                attack: 380,
                defense: 240,
                exp: 1800,
                gold: 1600
            },
            {
                name: 'åŠäººé©¬å¯æ±—',
                hp: 30000,
                attack: 450,
                defense: 180,
                exp: 2200,
                gold: 1900
            }
        ],
        resources: ['è‰è¯', 'æ¯›çš®'],
        unlocked: false,
        unlockLevel: 35
    },
    tanaris: {
        id: 'tanaris',
        name: 'å¡”çº³åˆ©æ–¯',
        level: 40,
        type: 'explore',
        enemies: [
            {
                name: 'æ²™é¡¹å·«åŒ»',
                hp: 42000,
                attack: 500,
                defense: 250,
                exp: 3000,
                gold: 2500
            },
            {
                name: 'é’¢è…­é’³å˜´é¾Ÿ',
                hp: 49000,
                attack: 550,
                defense: 300,
                exp: 3200,
                gold: 3000
            },
            {
                name: 'æé¡»èˆ¹é•¿',
                hp: 42000,
                attack: 600,
                defense: 280,
                exp: 3200,
                gold: 3000
            },
            {
                name: 'å®‰å›¾è‹å°”',
                hp: 47000,
                attack: 850,
                defense: 400,
                exp: 3500,
                gold: 4000
            }
        ],
        resources: ['è‰è¯', 'çŸ¿çŸ³', 'æ¯›çš®'],
        unlocked: false,
        unlockLevel: 40
    },
    scarlet_monastery: {
        id: 'scarlet_monastery',
        name: 'è¡€è‰²ä¿®é“é™¢',
        level: 45,
        type: 'explore',
        enemies: [
            {
                name: 'è¡€è‰²æ‹·é—®è€…',
                hp: 82000,
                attack: 1250,
                defense: 500,
                exp: 4000,
                gold: 4000
            },
            {
                name: 'è¡€è‰²åƒ§ä¾£',
                hp: 100000,
                attack: 1150,
                defense: 600,
                exp: 4500,
                gold: 5000
            },
            {
                name: 'è¡€è‰²æ‹›é­‚å¸ˆ',
                hp: 82000,
                attack: 1200,
                defense: 550,
                exp: 4500,
                gold: 5000
            },
            {
                name: 'è¡€è‰²å·«å¸ˆ',
                hp: 90000,
                attack: 1400,
                defense: 600,
                exp: 5000,
                gold: 5500
            }
        ],
        resources: ['è‰è¯', 'æ¯›çš®'],
        unlocked: false,
        unlockLevel: 45
    },
    blackrock_depths: {
        id: 'blackrock_depths',
        name: 'é»‘çŸ³æ·±æ¸Š',
        level: 50,
        type: 'explore',
        enemies: [
            {
                name: 'é»‘é“çŸ®äººå®ˆå«',
                hp: 132000,
                attack: 3200,
                defense: 1400,
                exp: 5000,
                gold: 5500
            },
            {
                name: 'è¢«å¥´å½¹çš„åœŸå…ƒç´ ',
                hp: 150000,
                attack: 2500,
                defense: 1900,
                exp: 5500,
                gold: 5000
            },
            {
                name: 'æˆ˜æ–—å‚€å„¡',
                hp: 182000,
                attack: 3500,
                defense: 1750,
                exp: 6500,
                gold: 6000
            }
        ],
        resources: ['é“çŸ¿', 'çŸ¿çŸ³'],
        unlocked: false,
        unlockLevel: 50
    },
    sunken_temple: {
        id: 'sunken_temple',
        name: 'æ²‰æ²¡çš„ç¥åº™',
        level: 50,
        type: 'explore',
        enemies: [
            {
                name: 'ç»¿é¾™å®ˆå«',
                hp: 140000,
                attack: 3100,
                defense: 1300,
                exp: 5600,
                gold: 5500
            },
            {
                name: 'æ½œä¼çš„é£Ÿè…è€…',
                hp: 150000,
                attack: 3300,
                defense: 1850,
                exp: 6600,
                gold: 5800
            },
            {
                name: 'å“ˆå¡ä¹‹å­',
                hp: 200000,
                attack: 3500,
                defense: 1950,
                exp: 7000,
                gold: 6500
            }
        ],
        resources: ['è‰è¯', 'é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 50
    },


    lower_blackrock_spire: {
        id: 'lower_blackrock_spire',
        name: 'é»‘çŸ³å¡”ä¸‹',
        level: 55,
        type: 'explore',
        enemies: [
            { name: 'é»‘é“åº§ç‹¼', hp: 230000, attack: 4800, defense: 2300, exp: 8000, gold: 7000 },
            { name: 'çƒŸç½‘å°èœ˜è››', hp: 200000, attack: 4500, defense: 2100, exp: 7600, gold: 6800 },
            { name: 'é£Ÿäººé­”æ³•å¸ˆ', hp: 260000, attack: 5200, defense: 2400, exp: 9000, gold: 7500 },
            { name: 'å…½äººå†›å®˜', hp: 280000, attack: 5600, defense: 2600, exp: 9500, gold: 8000 },
        ],
        resources: ['é“çŸ¿', 'é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 55
    },
    scholomance: {
        id: 'scholomance',
        name: 'é€šçµå­¦é™¢',
        level: 55,
        type: 'explore',
        enemies: [
            { name: 'é€šçµå­¦é™¢å­¦å¾’', hp: 220000, attack: 4800, defense: 2200, exp: 8400, gold: 7200 },
            { name: 'é»‘æš—å¬å”¤å¸ˆ', hp: 260000, attack: 5400, defense: 2500, exp: 9200, gold: 7800 },
            { name: 'åœ°ç©´èœ˜è››', hp: 240000, attack: 5200, defense: 2300, exp: 8800, gold: 7600 },
            { name: 'æ„é€ ä½“', hp: 320000, attack: 5000, defense: 3000, exp: 9800, gold: 8200 },
        ],
        resources: ['é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 55
    },
    stratholme: {
        id: 'stratholme',
        name: 'æ–¯å¦ç´¢å§†',
        level: 55,
        type: 'explore',
        enemies: [
            { name: 'è¡€è‰²æŒ‡æŒ¥å®˜', hp: 300000, attack: 5800, defense: 2700, exp: 10000, gold: 8500 },
            { name: 'è‹ç™½å°–å•¸è€…', hp: 260000, attack: 6000, defense: 2400, exp: 9800, gold: 8300 },
            { name: 'éª·é«…æ³•å¸ˆ', hp: 240000, attack: 5600, defense: 2300, exp: 9200, gold: 8000 },
            { name: 'è…çƒ‚æ†æ¶', hp: 350000, attack: 6200, defense: 3200, exp: 11000, gold: 9000 },
        ],
        resources: ['é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 55
    },
    upper_blackrock_spire: {
        id: 'upper_blackrock_spire',
        name: 'é»‘çŸ³å¡”ä¸Š',
        level: 60,
        type: 'explore',
        enemies: [
            { name: 'çƒˆç„°å«å£«çºµç«è€…', hp: 420000, attack: 7200, defense: 3400, exp: 14000, gold: 11000 },
            { name: 'ç£·å–‰ä¸­å«', hp: 500000, attack: 7600, defense: 4200, exp: 15000, gold: 12000 },
            { name: 'é»‘æ‰‹åˆºå®¢', hp: 380000, attack: 8500, defense: 3200, exp: 15500, gold: 12500 },
            { name: 'é»‘è‰²é›é¾™', hp: 560000, attack: 8200, defense: 4000, exp: 17000, gold: 13500 },
        ],
        resources: ['é“çŸ¿', 'é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 60
    },



};

const DROP_TABLES = {
    elwynn_forest: {
        equipment: [
            {
                id: 'EQ_001',
                chance: 0.05, // 5%
            },
            {
                id: 'EQ_002',
                chance: 0.05, // 5%
            },
            {
                id: 'EQ_003',
                chance: 0.001, // 0.1%
            },
            {
                id: 'EQ_004',
                chance: 0.001, // 0.1%
            },
            {
                id: 'EQ_005',
                chance: 0.05, // 5%
            }
        ],
        items: [
            {
                id: 'IT_001',
                chance: 0.05
            }
        ]
    },
    westfall: {
        equipment: [
            { id: 'EQ_006', chance: 0.03 },
            { id: 'EQ_007', chance: 0.03 },
            { id: 'EQ_008', chance: 0.03 },
            { id: 'EQ_009', chance: 0.03 },
            { id: 'EQ_010', chance: 0.03 },
            { id: 'EQ_011', chance: 0.03 },
            { id: 'EQ_012', chance: 0.03 },
            { id: 'EQ_013', chance: 0.001 } // 0.1%
        ]
    },
    redridge: {
        equipment: [
            { id: 'EQ_014', chance: 0.01 },   // 1%
            { id: 'EQ_015', chance: 0.01 },   // 1%
            { id: 'EQ_016', chance: 0.01 },   // 1%
            { id: 'EQ_017', chance: 0.01 },   // 1%
            { id: 'EQ_018', chance: 0.001 }  // 0.1%
        ]
    },
    barrens: {
        equipment: [
            { id: 'EQ_019', chance: 0.01 },   // 1%
            { id: 'EQ_020', chance: 0.003 },  // 0.3%
            { id: 'EQ_021', chance: 0.003 },  // 0.3%
            { id: 'EQ_022', chance: 0.01 },   // 1%
            { id: 'EQ_023', chance: 0.01 },   // 1%
            { id: 'EQ_024', chance: 0.001 },  // 0.1%
            { id: 'EQ_025', chance: 0.003 },  // 0.3%
            { id: 'EQ_026', chance: 0.003 }   // 0.3%
        ]
    },
    stranglethorn_vale: {
        equipment: [
            { id: 'EQ_027', chance: 0.01 },
            { id: 'EQ_028', chance: 0.01 },
            { id: 'EQ_029', chance: 0.01 },
            { id: 'EQ_030', chance: 0.001 },
            { id: 'EQ_031', chance: 0.003 },
            { id: 'EQ_032', chance: 0.003 }
        ],
        items: [
            { id: 'IT_STV_001', chance: 0.005 },
            { id: 'IT_STV_002', chance: 0.005 },
            { id: 'IT_STV_003', chance: 0.005 },
            { id: 'IT_STV_004', chance: 0.005 }
        ]
    },
    dustwallow_marsh: {
        items: [
            {
                id: 'IT_BLACK_DRAGON_PROOF',
                chance: 0.001   // 0.1%ï¼Œä½œä¸ºå‰§æƒ…é’¥åŒ™ï¼Œåˆç†ä½†ä¸æ³›æ»¥
            }
        ]
    },
    desolace: {
        equipment: [
            { id: 'EQ_033', chance: 0.003 }, // 0.3%
            { id: 'EQ_034', chance: 0.003 }, // 0.1%
            { id: 'EQ_035', chance: 0.01  }, // 1%
            { id: 'EQ_036', chance: 0.003 }, // 0.3%
            { id: 'EQ_037', chance: 0.003 }, // 0.3%
            { id: 'EQ_038', chance: 0.003 }, // 0.3%
            { id: 'EQ_039', chance: 0.003 }, // 0.3%
            { id: 'EQ_040', chance: 0.003 }  // 0.3%
        ]
    },
    tanaris: {
        equipment: [
            { id: 'EQ_041', chance: 0.001 }, // 0.1%
            { id: 'EQ_042', chance: 0.001 }, // 0.1%
            { id: 'EQ_043', chance: 0.003 }, // 0.3%
            { id: 'EQ_045', chance: 0.003 }, // 0.3%
            { id: 'EQ_046', chance: 0.003 }, // 0.3%
            { id: 'EQ_047', chance: 0.003 }, // 0.3%
            { id: 'EQ_048', chance: 0.01  }  // 1%
        ]
    },
    scarlet_monastery: {
        equipment: [
            { id: 'EQ_049', chance: 0.01 },   // 1%
            { id: 'EQ_050', chance: 0.003 },  // 0.3%
            { id: 'EQ_051', chance: 0.003 },  // 0.3%
            { id: 'EQ_052', chance: 0.01 },   // 1%
            { id: 'EQ_053', chance: 0.003 },  // 0.3%
            { id: 'EQ_054', chance: 0.003 },  // 0.3%
            { id: 'EQ_055', chance: 0.001 },  // 0.1%
            { id: 'EQ_056', chance: 0.003 },   // 0.3%
            { id: 'EQ_057', chance: 0.001 },  // 0.1%
            { id: 'EQ_058', chance: 0.003 },  // 0.3%
            { id: 'EQ_059', chance: 0.003 },  // 0.3%
            { id: 'EQ_060', chance: 0.003 },  // 0.3%
            { id: 'EQ_061', chance: 0.003 }   // 0.3%
        ]
    },
    blackrock_depths: {
        equipment: [
            { id: 'EQ_062', chance: 0.003 }, // 0.3%
            { id: 'EQ_063', chance: 0.003 }  // 0.3%
        ]
    },
    sunken_temple: {
        equipment: [
            { id: 'EQ_064', chance: 0.003 },  // 0.3%
            { id: 'EQ_065', chance: 0.003 },  // 0.3%
            { id: 'EQ_066', chance: 0.003 },  // 0.3%
            { id: 'EQ_067', chance: 0.003 },  // 0.3%
            { id: 'EQ_068', chance: 0.003 },  // 0.3%
            { id: 'EQ_069', chance: 0.003 },  // 0.3%
            { id: 'EQ_070', chance: 0.003 },  // 0.3%
            { id: 'EQ_071', chance: 0.001 },  // 0.1% ç¨€æœ‰
            { id: 'EQ_072', chance: 0.001 },  // 0.1% ç¨€æœ‰
            { id: 'EQ_073', chance: 0.001 }   // 0.1% ç¨€æœ‰
        ]
    },


    lower_blackrock_spire: {
        equipment: [
            { id: 'EQ_074', chance: 0.003 },  // å‹‡æ°”è…°å¸¦
            { id: 'EQ_075', chance: 0.003 },  // è¿…å½±è…°å¸¦
            { id: 'EQ_076', chance: 0.003 },  // è™”è¯šè…°å¸¦
            { id: 'EQ_077', chance: 0.003 },  // åšå­¦è€…è…°å¸¦
            { id: 'EQ_078', chance: 0.003 },  // å‹‡æ°”æ‰‹å¥—
            { id: 'EQ_079', chance: 0.003 },  // è¿…å½±æ‰‹å¥—
            { id: 'EQ_080', chance: 0.003 },  // è™”è¯šæ‰‹å¥—
            { id: 'EQ_081', chance: 0.003 },  // åšå­¦è€…æ‰‹å¥—
            { id: 'EQ_082', chance: 0.0015 }, // å–·æ¯’è€…
            { id: 'EQ_083', chance: 0.001 },  // çº¢æœ¨ä¹‹ç¯
            { id: 'EQ_084', chance: 0.0015 }, // å“ˆé›·è‚¯çš„é¡¹åœˆ
            { id: 'EQ_085', chance: 0.001 },  // ç‡ƒæ£˜å®é’»
            { id: 'EQ_086', chance: 0.001 }  // é»‘é¸­
        ]
    },
    scholomance: {
        equipment: [
            { id: 'EQ_090', chance: 0.003 },  // å‹‡æ°”å¤´ç›”
            { id: 'EQ_091', chance: 0.003 },  // è™”è¯šå¤´å† 
            { id: 'EQ_092', chance: 0.003 },  // è¿…å½±ç½©å¸½
            { id: 'EQ_093', chance: 0.003 },  // åšå­¦è€…å¤´å† 
            { id: 'EQ_087', chance: 0.001 },  // ä¸Šå¤éª¨å¼“
            { id: 'EQ_088', chance: 0.0008 }, // é™¢é•¿ä¹‹æ–
            { id: 'EQ_089', chance: 0.0015 }, // å™¬éª¨é“é’ˆ
            { id: 'EQ_094', chance: 0.0008 }  // è«é‡Œè¥¿å¥¥çš„ç»Ÿå¾¡æŒ‡ç¯
        ]
    },
    stratholme: {
        equipment: [
            { id: 'EQ_099', chance: 0.003 },  // å‹‡æ°”æŠ¤è…¿
            { id: 'EQ_100', chance: 0.003 },  // è¿…å½±æŠ¤è…¿
            { id: 'EQ_101', chance: 0.003 },  // è™”è¯šæŠ¤è…¿
            { id: 'EQ_102', chance: 0.003 },  // åšå­¦è€…æŠ¤è…¿
            { id: 'EQ_096', chance: 0.0015 }, // çŸ¥è¯†å®å…¸
            { id: 'EQ_097', chance: 0.0015 }, // ç§˜æœ¯ä¹‹æ˜Ÿ
            { id: 'EQ_098', chance: 0.001 },  // é»‘çˆµå£«æ–—ç¯·
            { id: 'EQ_095', chance: 0.0005 }  // ç‘æ–‡æˆ´å°”ä¹‹å‰‘
        ]
    },
    upper_blackrock_spire: {
        equipment: [
            { id: 'EQ_109', chance: 0.003 },  // å‹‡æ°”èƒ¸ç”²
            { id: 'EQ_110', chance: 0.003 },  // è¿…å½±å¤–å¥—
            { id: 'EQ_111', chance: 0.003 },  // è™”è¯šé•¿è¢
            { id: 'EQ_112', chance: 0.003 },  // åšå­¦è€…é•¿è¢
            { id: 'EQ_105', chance: 0.0015 }, // çŸ³æ¥ ä¹‹ç¯
            { id: 'EQ_106', chance: 0.0015 }, // ç—›è‹¦æŒ‡ç¯
            { id: 'EQ_107', chance: 0.0015 }, // é¾™äººä¹‹ç›¾
            { id: 'EQ_108', chance: 0.001 },  // é›·å¾·ä¹‹çœ¼
            { id: 'EQ_103', chance: 0.0005 }, // æ¶é­”ä¹‹å‡»
            { id: 'EQ_104', chance: 0.0005 }  // é›·å¾·åŒåˆƒ
        ]
    },



};

// ==================== è¡€è‰²ä¿®é“é™¢è£…å¤‡æ± ï¼ˆç”¨äºé“å…·åˆ¤å®šï¼‰ ====================
// è¯´æ˜ï¼šç›®å‰è¡€è‰²ä¿®é“é™¢åœ¨æœ¬æ¸¸æˆä¸­çš„æ‰è½è£…å¤‡æ¨¡æ¿ä¸º EQ_049 ~ EQ_061ã€‚
// å¦‚æœªæ¥æ‰©å±•è¡€è‰²ä¿®é“é™¢è£…å¤‡ï¼Œåªéœ€è¦æŠŠæ–°æ¨¡æ¿IDåŠ å…¥è¯¥é›†åˆå³å¯ã€‚
const SCARLET_MONASTERY_EQUIP_IDS = new Set([
    'EQ_049', 'EQ_050', 'EQ_051', 'EQ_052', 'EQ_053', 'EQ_054',
    'EQ_055', 'EQ_056', 'EQ_057', 'EQ_058', 'EQ_059', 'EQ_060', 'EQ_061'
]);

function isScarletMonasteryEquipment(eq) {
    if (!eq || eq.type !== 'equipment') return false;
    const tpl = FIXED_EQUIPMENTS?.[eq.id];
    // æœªæ¥å¦‚æœä½ ç»™è¡€è‰²è£…å¤‡åŠ äº† setId=scarlet_crusaderï¼Œä¹Ÿä¼šè‡ªåŠ¨è¯†åˆ«
    if (tpl?.setId === 'scarlet_crusader') return true;
    return SCARLET_MONASTERY_EQUIP_IDS.has(eq.id);
}


// ==================== è‰¾å°”æ–‡/è¥¿éƒ¨è’é‡/èµ¤è„Šå±±è£…å¤‡æ± ï¼ˆç”¨äºéœæ ¼å¾½ç« åˆ¤å®šï¼‰ ====================
// è¯´æ˜ï¼šå½“å‰ä¸‰å¼ åœ°å›¾åœ¨æœ¬æ¸¸æˆä¸­çš„æ‰è½è£…å¤‡æ¨¡æ¿ä¸º EQ_001 ~ EQ_018ã€‚
// å¦‚æœªæ¥æ‰©å±•è¿™ä¸‰å¼ åœ°å›¾çš„æ‰è½è£…å¤‡ï¼Œåªéœ€è¦æŠŠæ–°æ¨¡æ¿IDåŠ å…¥è¯¥é›†åˆå³å¯ã€‚
const HOGGER_BADGE_EQUIP_IDS = new Set([
    'EQ_001','EQ_002','EQ_003','EQ_004','EQ_005',                 // è‰¾å°”æ–‡æ£®æ—
    'EQ_006','EQ_007','EQ_008','EQ_009','EQ_010','EQ_011','EQ_012','EQ_013', // è¥¿éƒ¨è’é‡
    'EQ_014','EQ_015','EQ_016','EQ_017','EQ_018'                  // èµ¤è„Šå±±
]);

function isHoggerBadgeEquipment(eq) {
    if (!eq || eq.type !== 'equipment') return false;
    const tpl = FIXED_EQUIPMENTS?.[eq.id];
    // æœªæ¥å¦‚æœä½ ç»™ä¸‰å›¾è£…å¤‡åŠ äº† setId=elwynn_westfall_redridgeï¼Œä¹Ÿä¼šè‡ªåŠ¨è¯†åˆ«
    if (tpl?.setId === 'elwynn_westfall_redridge') return true;
    return HOGGER_BADGE_EQUIP_IDS.has(eq.id);
}


// ==================== è´«ç˜ ä¹‹åœ°è£…å¤‡æ± ï¼ˆç”¨äºè¿ªè²äºšå¾½ç« åˆ¤å®šï¼‰ ====================
// è¯´æ˜ï¼šå½“å‰è´«ç˜ ä¹‹åœ°åœ¨æœ¬æ¸¸æˆä¸­çš„æ‰è½è£…å¤‡æ¨¡æ¿ä¸º EQ_019 ~ EQ_026ã€‚
// å¦‚æœªæ¥æ‰©å±•è´«ç˜ ä¹‹åœ°æ‰è½è£…å¤‡ï¼Œåªéœ€è¦æŠŠæ–°æ¨¡æ¿IDåŠ å…¥è¯¥é›†åˆå³å¯ã€‚
const VANCLEEF_BADGE_EQUIP_IDS = new Set([
    'EQ_019','EQ_020','EQ_021','EQ_022','EQ_023','EQ_024','EQ_025','EQ_026'
]);

function isVancleefBadgeEquipment(eq) {
    if (!eq || eq.type !== 'equipment') return false;
    const tpl = FIXED_EQUIPMENTS?.[eq.id];
    // æœªæ¥å¦‚æœä½ ç»™è´«ç˜ ä¹‹åœ°è£…å¤‡åŠ äº† setId=barrensï¼Œä¹Ÿä¼šè‡ªåŠ¨è¯†åˆ«
    if (tpl?.setId === 'barrens') return true;
    return VANCLEEF_BADGE_EQUIP_IDS.has(eq.id);
}

// ==================== è†æ£˜è°·/å¡”çº³åˆ©æ–¯è£…å¤‡æ± ï¼ˆç”¨äºé»‘é¾™åŒ–èº«å¾½ç« åˆ¤å®šï¼‰ ====================
// è¯´æ˜ï¼šå½“å‰ä¸¤å¼ åœ°å›¾åœ¨æœ¬æ¸¸æˆä¸­çš„æ‰è½è£…å¤‡æ¨¡æ¿ä¸ºï¼š
// - è†æ£˜è°·ï¼šEQ_027 ~ EQ_032
// - å¡”çº³åˆ©æ–¯ï¼šEQ_041, EQ_042, EQ_043, EQ_045, EQ_046, EQ_047, EQ_048
// å¦‚æœªæ¥æ‰©å±•ä¸¤å¼ åœ°å›¾çš„æ‰è½è£…å¤‡ï¼Œåªéœ€è¦æŠŠæ–°æ¨¡æ¿IDåŠ å…¥è¯¥é›†åˆå³å¯ã€‚
const PRESTOR_BADGE_EQUIP_IDS = new Set([
    // è†æ£˜è°·
    'EQ_027', 'EQ_028', 'EQ_029', 'EQ_030', 'EQ_031', 'EQ_032',
    // å¡”çº³åˆ©æ–¯
    'EQ_041', 'EQ_042', 'EQ_043','EQ_044', 'EQ_045', 'EQ_046', 'EQ_047', 'EQ_048'
]);

function isPrestorBadgeEquipment(eq) {
    if (!eq || eq.type !== 'equipment') return false;
    const tpl = FIXED_EQUIPMENTS?.[eq.id];
    // æœªæ¥å¦‚æœä½ ç»™ä¸¤å›¾è£…å¤‡åŠ äº† setId=stranglethorn_tanarisï¼Œä¹Ÿä¼šè‡ªåŠ¨è¯†åˆ«
    if (tpl?.setId === 'stranglethorn_tanaris') return true;
    return PRESTOR_BADGE_EQUIP_IDS.has(eq.id);
}

const BLACKROCK_DEPTHS_EQUIP_IDS = new Set([
    'EQ_062', 'EQ_063', 'EQ_064', 'EQ_065', 'EQ_066', 'EQ_067',
    'EQ_068', 'EQ_069', 'EQ_070', 'EQ_071', 'EQ_072', 'EQ_073'
]);

function isBlackrockDepthsEquipment(eq) {
    if (!eq || eq.type !== 'equipment') return false;
    const tpl = FIXED_EQUIPMENTS?.[eq.id];
    if (tpl?.setId === 'blackrock_depths') return true;
    return BLACKROCK_DEPTHS_EQUIP_IDS.has(eq.id);
}

// ==================== é€šçµå­¦é™¢è£…å¤‡æ± ï¼ˆç”¨äºåŠ ä¸å¾½ç« åˆ¤å®šï¼‰ ====================
// è¯´æ˜ï¼šå½“å‰é€šçµå­¦é™¢åœ¨æœ¬æ¸¸æˆä¸­çš„æ‰è½è£…å¤‡æ¨¡æ¿ä¸º EQ_087 ~ EQ_094ã€‚
// å¦‚æœªæ¥æ‰©å±•é€šçµå­¦é™¢æ‰è½è£…å¤‡ï¼Œåªéœ€è¦æŠŠæ–°æ¨¡æ¿IDåŠ å…¥è¯¥é›†åˆå³å¯ã€‚
const SCHOLOMANCE_EQUIP_IDS = new Set([
    'EQ_087', 'EQ_088', 'EQ_089', 'EQ_090', 'EQ_091', 'EQ_092', 'EQ_093', 'EQ_094',
    // âœ… é»‘æš—é™¢é•¿åŠ ä¸æ–°å¢æ‰è½ï¼ˆT0 æŠ¤è‚©ï¼‰
    'EQ_113', 'EQ_114', 'EQ_115', 'EQ_116'
]);

function isScholomanceEquipment(eq) {
    if (!eq || eq.type !== 'equipment') return false;
    const tpl = FIXED_EQUIPMENTS?.[eq.id];
    // æœªæ¥å¦‚æœä½ ç»™é€šçµå­¦é™¢è£…å¤‡åŠ äº† setId=scholomanceï¼Œä¹Ÿä¼šè‡ªåŠ¨è¯†åˆ«
    if (tpl?.setId === 'scholomance') return true;
    return SCHOLOMANCE_EQUIP_IDS.has(eq.id);
}

// ==================== æ–¯å¦ç´¢å§†è£…å¤‡æ± ï¼ˆç”¨äºç‘æ–‡æˆ´å°”å¾½ç« åˆ¤å®šï¼‰ ====================
// è¯´æ˜ï¼šå½“å‰æ–¯å¦ç´¢å§†åœ¨æœ¬æ¸¸æˆä¸­çš„æ‰è½è£…å¤‡æ¨¡æ¿ä¸º EQ_095 ~ EQ_102ã€‚
// å¦‚æœªæ¥æ‰©å±•æ–¯å¦ç´¢å§†æ‰è½è£…å¤‡ï¼Œåªéœ€è¦æŠŠæ–°æ¨¡æ¿IDåŠ å…¥è¯¥é›†åˆå³å¯ã€‚
const STRATHOLME_EQUIP_IDS = new Set([
    'EQ_095', 'EQ_096', 'EQ_097', 'EQ_098',
    'EQ_099', 'EQ_100', 'EQ_101', 'EQ_102',
    // âœ… ç‘æ–‡æˆ´å°”ç”·çˆµæ–°å¢æ‰è½ï¼ˆT0 æˆ˜é´/ä¾¿é‹ï¼‰
    'EQ_117', 'EQ_118', 'EQ_119', 'EQ_120'
]);

function isStratholmeEquipment(eq) {
    if (!eq || eq.type !== 'equipment') return false;
    const tpl = FIXED_EQUIPMENTS?.[eq.id];
    // æœªæ¥å¦‚æœä½ ç»™æ–¯å¦ç´¢å§†è£…å¤‡åŠ äº† setId=stratholmeï¼Œä¹Ÿä¼šè‡ªåŠ¨è¯†åˆ«
    if (tpl?.setId === 'stratholme') return true;
    return STRATHOLME_EQUIP_IDS.has(eq.id);
}


// ==================== é»‘çŸ³å¡”ä¸Šè£…å¤‡æ± ï¼ˆç”¨äºé›·å¾·é»‘æ‰‹å¾½ç« åˆ¤å®šï¼‰ ====================
// è¯´æ˜ï¼šå½“å‰é»‘çŸ³å¡”ä¸Šåœ¨æœ¬æ¸¸æˆä¸­çš„æ‰è½è£…å¤‡æ¨¡æ¿ä¸º EQ_103 ~ EQ_112ã€‚
// å¦‚æœªæ¥æ‰©å±•é»‘çŸ³å¡”ä¸Šæ‰è½è£…å¤‡ï¼Œåªéœ€è¦æŠŠæ–°æ¨¡æ¿IDåŠ å…¥è¯¥é›†åˆå³å¯ã€‚
const UPPER_BLACKROCK_SPIRE_EQUIP_IDS = new Set([
    'EQ_103', 'EQ_104', 'EQ_105', 'EQ_106', 'EQ_107', 'EQ_108',
    'EQ_109', 'EQ_110', 'EQ_111', 'EQ_112',
    // âœ… é›·å¾·é»‘æ‰‹æ–°å¢æ‰è½ï¼ˆT0 æŠ¤è…•/è£¹è…•ï¼‰
    'EQ_121', 'EQ_122', 'EQ_123', 'EQ_124'
]);

function isUpperBlackrockSpireEquipment(eq) {
    if (!eq || eq.type !== 'equipment') return false;
    const tpl = FIXED_EQUIPMENTS?.[eq.id];
    // æœªæ¥å¦‚æœä½ ç»™é»‘çŸ³å¡”ä¸Šè£…å¤‡åŠ äº† setId=upper_blackrock_spireï¼Œä¹Ÿä¼šè‡ªåŠ¨è¯†åˆ«
    if (tpl?.setId === 'upper_blackrock_spire') return true;
    return UPPER_BLACKROCK_SPIRE_EQUIP_IDS.has(eq.id);
}




// ==================== å¾½ç« å‡çº§è§„åˆ™ï¼ˆå¤ç”¨â€œè¡€è‰²åå­—å†›å¾½ç« â€çš„é€šç”¨æ¨¡å¼ï¼‰ ====================
// ä»¥åæ–°å¢ Boss å¾½ç« ï¼šåªéœ€è¦åœ¨è¿™é‡ŒåŠ ä¸€æ¡è§„åˆ™ + åœ¨ USE_ITEM é‡Œè®©è¯¥å¾½ç« èµ°åŒä¸€å¥—å…¥å£å³å¯ã€‚
const BADGE_UPGRADE_RULES = {
    IT_SCARLET_CRUSADER_BADGE: {
        badgeId: 'IT_SCARLET_CRUSADER_BADGE',
        title: 'è¡€è‰²åå­—å†›çš„å¾½ç« ',
        zoneLabel: 'è¡€è‰²ä¿®é“é™¢',
        inc: 2,
        cap: 100,
        isEligible: isScarletMonasteryEquipment,
        theme: { border: '#c62828', title: '#ff6b6b', shadow: 'rgba(198,40,40,0.25)' }
    },
    IT_HOGGER_BADGE: {
        badgeId: 'IT_HOGGER_BADGE',
        title: 'éœæ ¼çš„æ²¾è¡€å¾½ç« ',
        zoneLabel: 'è‰¾å°”æ–‡æ£®æ— / è¥¿éƒ¨è’é‡ / èµ¤è„Šå±±',
        inc: 2,
        cap: 100,
        isEligible: isHoggerBadgeEquipment,
        theme: { border: '#8d6e63', title: '#ffd700', shadow: 'rgba(141,110,99,0.25)' }
    },
    IT_VANCLEEF_BADGE: {
        badgeId: 'IT_VANCLEEF_BADGE',
        title: 'è¿ªè²äºšå¾½ç« ',
        zoneLabel: 'è´«ç˜ ä¹‹åœ°',
        inc: 2,
        cap: 100,
        isEligible: isVancleefBadgeEquipment,
        theme: { border: '#263238', title: '#90caf9', shadow: 'rgba(38,50,56,0.25)' }
    },
    IT_PRESTOR_BADGE: {
        badgeId: 'IT_PRESTOR_BADGE',
        title: 'é»‘é¾™åŒ–èº«å¾½ç« ',
        zoneLabel: 'è†æ£˜è°· / å¡”çº³åˆ©æ–¯',
        inc: 2,
        cap: 100,
        isEligible: isPrestorBadgeEquipment,
        theme: { border: '#2b2d42', title: '#b388ff', shadow: 'rgba(179,136,255,0.22)' }
    },
    IT_THAURISSAN_BADGE: {
        badgeId: 'IT_THAURISSAN_BADGE',
        title: 'ç´¢ç‘æ£®å¤§å¸çš„å¾½ç« ',
        zoneLabel: 'æ²‰æ²¡çš„ç¥åº™ / é»‘çŸ³æ·±æ¸Š',
        inc: 2,
        cap: 100,
        isEligible: isBlackrockDepthsEquipment,
        theme: { border: '#c62828', title: '#ff6b6b', shadow: 'rgba(198,40,40,0.25)' }
    },

    IT_GANDLING_BADGE: {
        badgeId: 'IT_GANDLING_BADGE',
        title: 'åŠ ä¸çš„å¾½ç« ',
        zoneLabel: 'é€šçµå­¦é™¢',
        inc: 2,
        cap: 100,
        isEligible: isScholomanceEquipment,
        theme: { border: '#4a148c', title: '#ce93d8', shadow: 'rgba(74,20,140,0.25)' }
    },

    IT_RIVENDARE_BADGE: {
        badgeId: 'IT_RIVENDARE_BADGE',
        title: 'ç‘æ–‡æˆ´å°”ç”·çˆµçš„å¾½ç« ',
        zoneLabel: 'æ–¯å¦ç´¢å§†',
        inc: 2,
        cap: 100,
        isEligible: isStratholmeEquipment,
        theme: { border: '#263238', title: '#b388ff', shadow: 'rgba(38,50,56,0.25)' }
    },

    IT_REND_BADGE: {
        badgeId: 'IT_REND_BADGE',
        title: 'é›·å¾·é»‘æ‰‹çš„å¾½ç« ',
        zoneLabel: 'é»‘çŸ³å¡”ä¸Š',
        inc: 2,
        cap: 100,
        isEligible: isUpperBlackrockSpireEquipment,
        theme: { border: '#4e342e', title: '#ffab91', shadow: 'rgba(78,52,46,0.25)' }
    },
};

const FIXED_EQUIPMENTS = {
    EQ_001: {
        id: 'EQ_001',
        name: 'åˆå¿ƒè€…çš„ç›¾ç‰Œ',
        icon: "icons/wow/vanilla/armor/INV_Shield_09.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'green',

        setId: 'beginner_set',
        setName: 'åˆå¿ƒè€…å¥—è£…',

        level: 8,
        maxLevel: 100,
        baseStats: {
            armor: 10,
            blockValue: 20,
            blockRate: 5
        },
        growth: {
            armor: 2,
            blockValue: 2,
            blockRate: 2
        }
    },
    EQ_002: {
        id: 'EQ_002',
        name: 'åˆå¿ƒè€…çš„å°åˆ€',
        icon: "icons/wow/vanilla/weapons/INV_Sword_12.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'green',

        setId: 'beginner_set',
        setName: 'åˆå¿ƒè€…å¥—è£…',

        level: 8,
        maxLevel: 100,
        baseStats: {
            attack: 20,
            critRate: 3,
            critDamage: 0.10
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_003: {
        id: 'EQ_003',
        name: 'ç¥ç§˜æ£®æ—åŠå ',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Necklace_11.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',

        setId: 'secret_set',
        setName: 'ç¥ç§˜å¥—è£…',

        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            versatility: 10
        },
        growth: {
            hp: 2,
            versatility: 2
        }
    },
    EQ_004: {
        id: 'EQ_004',
        name: 'ç¥ç§˜æ£®æ—æˆ’æŒ‡',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_12.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'blue',

        setId: 'secret_set',
        setName: 'ç¥ç§˜å¥—è£…',

        level: 1,
        maxLevel: 100,
        baseStats: {
            mp: 100,
            versatility: 10
        },
        growth: {
            mp: 2,
            versatility: 2
        }
    },
    EQ_005: {
        id: 'EQ_005',
        name: 'åˆå¿ƒè€…çš„æ‹æ–',
        icon: "icons/wow/vanilla/weapons/INV_Staff_02.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'green',

        setId: 'beginner_set',
        setName: 'åˆå¿ƒè€…å¥—è£…',

        level: 8,
        maxLevel: 100,
        baseStats: {
            spellPower: 30
        },
        growth: {
            spellPower: 2
        }
    },
    REBIRTH_INVITATION: {
        id: 'REBIRTH_INVITATION',
        name: 'ç ´ç¢æ—¶ç©ºçš„é‚€è¯·å‡½',
        type: 'consumable',
        rarity: 'purple',
        icon: 'icons/wow/vanilla/items/INV_Misc_Note_04.png',
        canUse: true,
        description: 'ä½¿ç”¨åè§£é”é‡ç”Ÿè½®å›'
    }
    ,
    EQ_006: {
        id: 'EQ_006',
        name: 'æ—…è¡Œè€…çš„å¤´ç›”',
        icon: 'icons/wow/vanilla/armor/INV_Helmet_16.png',
        type: 'equipment',
        slot: 'head',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 150,
            armor: 30
        },
        growth: {
            hp: 2,
            armor: 2
        }
    },
    EQ_007: {
        id: 'EQ_007',
        name: 'æ—…è¡Œè€…çš„æŠ¤è‚©',
        icon: 'icons/wow/vanilla/armor/INV_Shoulder_08.png',
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 120,
            armor: 25,
            spellPower: 15
        },
        growth: {
            hp: 2,
            armor: 2,
            spellPower: 2
        }
    },
    EQ_008: {
        id: 'EQ_008',
        name: 'æ—…è¡Œè€…çš„èƒ¸ç”²',
        icon: 'icons/wow/vanilla/armor/INV_Shirt_01.png',
        type: 'equipment',
        slot: 'chest',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 20
        },
        growth: {
            hp: 2,
            armor: 2
        }
    },
    EQ_009: {
        id: 'EQ_009',
        name: 'æ—…è¡Œè€…çš„æŠ¤è…•',
        icon: 'icons/wow/vanilla/armor/INV_Bracer_11.png',
        type: 'equipment',
        slot: 'wrist',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 100,
            armor: 20,
            attack: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            attack: 2
        }
    },
    EQ_010: {
        id: 'EQ_010',
        name: 'æ—…è¡Œè€…çš„æ‰‹å¥—',
        icon: 'icons/wow/vanilla/armor/INV_Gauntlets_05.png',
        type: 'equipment',
        slot: 'hands',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 120,
            armor: 10,
            attack: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            attack: 2
        }
    },
    EQ_011: {
        id: 'EQ_011',
        name: 'æ—…è¡Œè€…çš„æŠ¤è…¿',
        icon: 'icons/wow/vanilla/armor/INV_Pants_01.png',
        type: 'equipment',
        slot: 'legs',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 20,
            spellPower: 15
        },
        growth: {
            hp: 2,
            armor: 2,
            spellPower: 2
        }
    },
    EQ_012: {
        id: 'EQ_012',
        name: 'æ—…è¡Œè€…çš„å¸ƒé´',
        icon: 'icons/wow/vanilla/armor/INV_Boots_05.png',
        type: 'equipment',
        slot: 'feet',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 150,
            armor: 30
        },
        growth: {
            hp: 2,
            armor: 2
        }
    },
    EQ_013: {
        id: 'EQ_013',
        name: 'ç¥ç§˜å±±è„‰æˆ’æŒ‡',
        icon: 'icons/wow/vanilla/armor/INV_Jewelry_Ring_31.png',
        type: 'equipment',
        slot: 'ring2',
        rarity: 'blue',

        level: 1,
        maxLevel: 100,
        baseStats: {
            mastery: 10
        },
        growth: {
            mastery: 2
        }
    },EQ_014: {
        id: 'EQ_014',
        name: 'å±±è„‰å«å£«ä¹‹åˆº',
        icon: 'icons/wow/vanilla/weapons/INV_Sword_12.png',
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'green',
        level: 1,
        maxLevel: 100,
        baseStats: {
            attack: 120,
            versatility: 10,
            mastery: 10
        },
        growth: {
            attack: 2,
            versatility: 2,
            mastery: 2
        }
    },
    EQ_015: {
        id: 'EQ_015',
        name: 'å±±è„‰å«å£«ä¹‹å™¬',
        icon: 'icons/wow/vanilla/weapons/INV_Staff_06.png',
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'green',
        level: 1,
        maxLevel: 100,
        baseStats: {
            spellPower: 180,
            versatility: 10,
            mastery: 10
        },
        growth: {
            spellPower: 2,
            versatility: 2,
            mastery: 2
        }
    },
    EQ_016: {
        id: 'EQ_016',
        name: 'å±±è„‰å«å£«ä¹‹ç›¾',
        icon: 'icons/wow/vanilla/armor/INV_Shield_13.png',
        type: 'equipment',
        slot: 'offHand',
        rarity: 'green',
        level: 1,
        maxLevel: 100,
        baseStats: {
            blockRate: 15,
            blockValue: 80,
            mastery: 10
        },
        growth: {
            blockRate: 2,
            blockValue: 2,
            mastery: 2
        }
    },
    EQ_017: {
        id: 'EQ_017',
        name: 'å±±è„‰å«å£«é­”å…¸',
        icon: 'icons/wow/vanilla/items/INV_Misc_Orb_02.png',
        type: 'equipment',
        slot: 'offHand',
        rarity: 'green',
        level: 1,
        maxLevel: 100,
        baseStats: {
            spellPower: 100,
            versatility: 10,
            mastery: 20
        },
        growth: {
            spellPower: 2,
            versatility: 2,
            mastery: 2
        }
    },
    EQ_018: {
        id: 'EQ_018',
        name: 'å±±è„‰å«å£«ä¹‹å¿ƒ',
        icon: 'icons/wow/vanilla/trade/INV_Stone_01.png',
        type: 'equipment',
        slot: 'trinket1',
        rarity: 'blue',
        level: 1,
        maxLevel: 100,
        baseStats: {
            spellPower: 120,
            attack: 80,
            mastery: 10,
            versatility: 10
        },
        growth: {
            spellPower: 2,
            attack: 2,
            mastery: 2,
            versatility: 2
        }
    },EQ_019: {
        id: 'EQ_019',
        name: 'å°–ç‰™æ‰‹å¥—',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_18.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'green',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 30,
            critRate: 2,
            critDamage: 0.10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_020: {
        id: 'EQ_020',
        name: 'å°–ç‰™æŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_02.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 300,
            armor: 40,
            critRate: 3,
            critDamage: 0.10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_021: {
        id: 'EQ_021',
        name: 'å°–ç‰™é“ ç”²',
        icon: "icons/wow/vanilla/armor/INV_Chest_Leather_08.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 300,
            armor: 40,
            critRate: 3,
            critDamage: 0.10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_022: {
        id: 'EQ_022',
        name: 'å°–ç‰™è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_10.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'green',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 30,
            critRate: 2,
            critDamage: 0.10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_023: {
        id: 'EQ_023',
        name: 'å°–ç‰™è¶³å«',
        icon: "icons/wow/vanilla/armor/INV_Boots_05.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'green',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 250,
            armor: 30,
            critRate: 2,
            critDamage: 0.10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_024: {
        id: 'EQ_024',
        name: 'æ¯’è›‡',
        icon: "icons/wow/vanilla/weapons/INV_Weapon_Bow_10.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            attack: 250,
            critRate: 20,
            critDamage: 0.5,  // 50% é¢å¤–æš´å‡»ä¼¤å®³
            versatility: 5
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2,
            versatility: 2
        }
    },
    EQ_025: {
        id: 'EQ_025',
        name: 'ç”Ÿå‘½ä¹‹æ ¹',
        icon: "icons/wow/vanilla/weapons/INV_Staff_26.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 1,
        maxLevel: 100,
        baseStats: {
            spellPower: 200,
            hp: 300,
            versatility: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            versatility: 2
        }
    },
    EQ_026: {
        id: 'EQ_026',
        name: 'å…‹é›·ä»€ä¹‹èƒŒ',
        icon: "icons/wow/vanilla/armor/INV_Shield_18.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 1,
        maxLevel: 100,
        baseStats: {
            blockRate: 20,
            blockValue: 100,
            hp: 400
        },
        growth: {
            blockRate: 2,
            blockValue: 2,
            hp: 2
        }
    },
    EQ_027: {
        id: 'EQ_027',
        name: 'é”ˆæ°´å¤´ç›”',
        icon: "icons/wow/vanilla/armor/INV_Helmet_20.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'green',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 300,
            armor: 40,
            haste: 5,
            mastery: 5
        },
        growth: {
            hp: 2,
            armor: 2,
            haste: 2,
            mastery: 2
        }
    },

    EQ_028: {
        id: 'EQ_028',
        name: 'é”ˆæ°´æŠ¤è‚©',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_06.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'green',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 220,
            armor: 35,
            haste: 5,
            mastery: 5
        },
        growth: {
            hp: 2,
            armor: 2,
            haste: 2,
            mastery: 2
        }
    },

    EQ_029: {
        id: 'EQ_029',
        name: 'é”ˆæ°´æŠ¤è…•',
        icon: "icons/wow/vanilla/armor/INV_Bracer_03.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'green',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 30,
            haste: 5,
            mastery: 5
        },
        growth: {
            hp: 2,
            armor: 2,
            haste: 2,
            mastery: 2
        }
    },
    EQ_030: {
        id: 'EQ_030',
        name: 'ä¹”ä¸¹æ³•æ–',
        icon: "icons/wow/vanilla/weapons/INV_Wand_06.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            mastery: 10,
            haste: 10,
            versatility: 10,
            critRate: 10
        },
        growth: {
            spellPower: 2,
            mastery: 2,
            haste: 2,
            versatility: 2,
            critRate: 2
        }
    },
    EQ_031: {
        id: 'EQ_031',
        name: 'çŸ­æš‚èƒ½é‡æŠ¤ç¬¦',
        icon: "icons/wow/vanilla/items/INV_Misc_StoneTablet_11.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 150
        },
        growth: {
            spellPower: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [0, 4],
            spellPowerBonus: 600
        }
    },
    EQ_032: {
        id: 'EQ_032',
        name: 'å¼ºæ”»æŠ¤ç¬¦',
        icon: "icons/wow/vanilla/items/INV_Misc_Head_Troll_01.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 150
        },
        growth: {
            attack: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [0, 4],
            attackBonus: 600
        }
    },
    IT_BLACK_DRAGON_PROOF: {
        id: 'IT_BLACK_DRAGON_PROOF',
        name: 'é»‘é¾™åŒ–èº«çš„è¯æ˜',
        icon: "icons/wow/vanilla/items/INV_Misc_Head_Dragon_01.png",
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        description: 'ä½¿ç”¨åï¼Œæ­éœ²çœŸç›¸ï¼Œè§£é”éšè—Bossã€æ™®ç‘æ–¯æ‰˜å¥³å£«ã€‘'
    },
    EQ_033: {
        id: 'EQ_033',
        name: 'å¤©é€‰è€…å°è®°',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Talisman_08.png",
        type: 'equipment',
        slot: 'trinket1',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            versatility: 10,
            haste: 10,
            mastery: 10,
            critRate: 10
        },
        growth: {
            hp: 2,
            versatility: 2,
            haste: 2,
            mastery: 2,
            critRate: 2
        }
    },
    EQ_034: {
        id: 'EQ_034',
        name: 'ç—›å‡»ä¹‹åˆƒ',
        icon: "icons/wow/vanilla/weapons/INV_Sword_36.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 350,
            critRate: 15,
            critDamage: 0.40
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_035: {
        id: 'EQ_035',
        name: 'çƒ­æƒ…æš—å½±å é¥°',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Necklace_07.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'green',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 200,
            hp: 500
        },
        growth: {
            spellPower: 2,
            hp: 2
        }
    },
    EQ_036: {
        id: 'EQ_036',
        name: 'è±ç‘Ÿå¾·æ–¯ä¹‹çœ¼',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_08.png",
        type: 'equipment',
        slot: 'ring2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 200,
            hp: 300,
            critRate: 5
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2
        }
    },
    EQ_037: {
        id: 'EQ_037',
        name: 'å‘æ˜å®¶çš„èšç„¦å‰‘',
        icon: "icons/wow/vanilla/weapons/INV_Sword_14.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            critRate: 15,
            critDamage: 0.40
        },
        growth: {
            spellPower: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_038: {
        id: 'EQ_038',
        name: 'å…ƒç´ çŸ³è„ŠæŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_04.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 400,
            armor: 50,
            blockRate: 5
        },
        growth: {
            hp: 2,
            armor: 2,
            blockRate: 2
        }
    },
    EQ_039: {
        id: 'EQ_039',
        name: 'é»‘çŸ³æˆ’æŒ‡',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_17.png",
        type: 'equipment',
        slot: 'ring2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 200,
            hp: 300,
            armor: 50,
            versatility: 5
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            versatility: 2
        }
    },
    EQ_040: {
        id: 'EQ_040',
        name: 'å‰å…¹æ´›å…‹çš„é«˜ç§‘æŠ€åœ†ç›¾',
        icon: "icons/wow/vanilla/armor/INV_Shield_10.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 600,
            armor: 100,
            blockRate: 20,
            blockValue: 200
        },
        growth: {
            hp: 2,
            armor: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_041: {
        id: 'EQ_041',
        name: 'åå‡»è€…æ¡‘è¨æ–¯',
        icon: "icons/wow/vanilla/weapons/INV_Sword_45.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 500,
            versatility: 20,
            haste: 20
        },
        growth: {
            attack: 2,
            versatility: 2,
            haste: 2
        }
    },
    EQ_042: {
        id: 'EQ_042',
        name: 'ä¿æŠ¤è€…åŠ è¨æ–¯',
        icon: "icons/wow/vanilla/weapons/INV_Sword_43.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 500,
            mastery: 20,
            critRate: 20
        },
        growth: {
            attack: 2,
            mastery: 2,
            critRate: 2
        }
    },
    EQ_043: {
        id: 'EQ_043',
        name: 'ç¥–ç©†æ‹‰æ©çš„èƒ½é‡æ³•æ–',
        icon: "icons/wow/vanilla/weapons/INV_Staff_10.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 550,
            critRate: 15,
            mastery: 15
        },
        growth: {
            spellPower: 2,
            critRate: 2,
            mastery: 2
        }
    },
    EQ_044: {
        id: 'EQ_044',
        name: 'é­ç¬è€…è‹è¨æ–¯',
        icon: "icons/wow/vanilla/weapons/INV_Sword_40.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'orange',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1200,
            mastery: 10,
            haste: 10,
            versatility: 10
        },
        growth: {
            attack: 2,
            mastery: 2,
            haste: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'basic_attack_repeat',
            chance: 0.5
        },
        synth: { from: ['EQ_041', 'EQ_042'], requireLevel: 100 }
    },
    EQ_045: {
        id: 'EQ_045',
        name: 'å¤§åè›‹é¢å…·',
        icon: "icons/wow/vanilla/items/INV_Banner_01.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 100,
            hp: 300,
            armor: 50,
            versatility: 5
        },
        growth: {
            spellPower: 2,
            hp: 2,
            armor: 2,
            versatility: 2
        }
    },
    EQ_046: {
        id: 'EQ_046',
        name: 'ç‹‚ä¹±è€…çš„æ‹¥æŠ±',
        icon: "icons/wow/vanilla/abilities/Ability_Mount_WhiteDireWolf.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 100,
            hp: 400,
            armor: 50,
            critRate: 5
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2
        }
    },
    EQ_047: {
        id: 'EQ_047',
        name: 'å¤§åè›‹è‚©ç”²',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_01.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 300,
            armor: 50,
            versatility: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            versatility: 2
        }
    },
    EQ_048: {
        id: 'EQ_048',
        name: 'é—ªäº®è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_22.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'green',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 300,
            armor: 40,
            versatility: 5
        },
        growth: {
            hp: 2,
            armor: 2,
            versatility: 2
        }
    },
    // ==================== è¡€è‰²ä¿®é“é™¢è£…å¤‡ ====================
    EQ_049: {
        id: 'EQ_049',
        name: 'è¡€è‰²åå­—å†›è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_16.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'green',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            armor: 50,
            versatility: 10,
            blockRate: 2
        },
        growth: {
            hp: 2,
            armor: 2,
            versatility: 2,
            blockRate: 2
        }
    },
    EQ_050: {
        id: 'EQ_050',
        name: 'è¡€è‰²åå­—å†›æŠ¤èƒ¸',
        icon: "icons/wow/vanilla/armor/INV_Chest_Chain_16.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 600,
            armor: 80,
            mastery: 10,
            blockRate: 3
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2
        }
    },
    EQ_051: {
        id: 'EQ_051',
        name: 'è¡€è‰²åå­—å†›æŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_06.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 600,
            armor: 80,
            mastery: 10,
            versatility: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_052: {
        id: 'EQ_052',
        name: 'è¡€è‰²åå­—å†›æŠ¤æ‰‹',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_26.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'green',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            armor: 50,
            mastery: 10,
            blockRate: 2
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2
        }
    },
    EQ_053: {
        id: 'EQ_053',
        name: 'è¡€è‰²åå­—å†›æˆ˜é´',
        icon: "icons/wow/vanilla/armor/INV_Boots_02.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'blue',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            armor: 50,
            versatility: 10,
            blockRate: 3
        },
        growth: {
            hp: 2,
            armor: 2,
            versatility: 2,
            blockRate: 2
        }
    },
    EQ_054: {
        id: 'EQ_054',
        name: 'è¡€è‰²åå­—å†›è…•ç”²',
        icon: "icons/wow/vanilla/armor/INV_Bracer_16.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'blue',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            armor: 50,
            mastery: 10,
            blockValue: 50
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockValue: 2
        }
    },
    EQ_055: {
        id: 'EQ_055',
        name: 'èµ«æ´›å¾·çš„è‚©é“ ',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_25.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            armor: 50,
            critRate: 5,
            haste: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            haste: 2
        }
    },
    EQ_056: {
        id: 'EQ_056',
        name: 'åœ£ä½¿æŠ¤ç¬¦',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Amulet_01.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 800,
            mastery: 10,
            versatility: 10,
            spellPower: 300
        },
        growth: {
            hp: 2,
            mastery: 2,
            versatility: 2,
            spellPower: 2
        }
    },
    EQ_057: {
        id: 'EQ_057',
        name: 'ç ´åè€…',
        icon: "icons/wow/vanilla/weapons/INV_Axe_11.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 750,
            critRate: 20,
            versatility: 10,
            critDamage: 0.5
        },
        growth: {
            attack: 2,
            critRate: 2,
            versatility: 2,
            critDamage: 2
        },
        specialEffect: {
            type: 'proc_stat',
            trigger: 'turn_start',
            chance: 0.20,
            stats: { attack: 500 },
            scaleWithLevel: true
        }

    },

    EQ_058: {
        id: 'EQ_058',
        name: 'å…¬æ­£ä¹‹æ‰‹',
        icon: "icons/wow/vanilla/weapons/INV_Mace_14.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 800,
            spellPower: 650,
            mastery: 20,
            versatility: 10
        },
        growth: {
            hp: 2,
            spellPower: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_059: {
        id: 'EQ_059',
        name: 'è¡€è‰²æŒ‡æŒ¥å®˜ä¹‹ç›¾',
        icon: "icons/wow/vanilla/armor/INV_Shield_06.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1000,
            armor: 120,
            mastery: 20,
            blockRate: 20,
            blockValue: 300
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_060: {
        id: 'EQ_060',
        name: 'å¹»å½±æ³•æ–',
        icon: "icons/wow/vanilla/weapons/INV_Staff_13.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 750,
            critRate: 10,
            versatility: 20,
            haste: 20
        },
        growth: {
            spellPower: 2,
            critRate: 2,
            versatility: 2,
            haste: 2
        },
        specialEffect: {
            type: 'proc_stat',
            trigger: 'turn_start',
            chance: 0.20,
            stats: { spellPower: 500 },
            scaleWithLevel: true
        }
    },
    EQ_061: {
        id: 'EQ_061',
        name: 'é—å¿˜å…ˆçŸ¥å®ç ',
        icon: "icons/wow/vanilla/items/INV_Misc_Orb_02.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 500,
            mastery: 10,
            versatility: 10,
            haste: 10
        },
        growth: {
            spellPower: 2,
            mastery: 2,
            versatility: 2,
            haste: 2
        }
    },
    EQ_062: {
        id: 'EQ_062',
        name: 'æ­£ä¹‰ä¹‹æ‰‹',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Talisman_01.png",
        type: 'equipment',
        slot: 'trinket1',
        rarity: 'blue',

        level: 0,
        maxLevel: 100,

        baseStats: {
            attack: 350,
            haste: 10
        },
        growth: {
            attack: 2,
            haste: 2
        },

        specialEffect: {
            type: 'basic_attack_repeat',
            chance: 0.20
        }
    },
    EQ_063: {
        id: 'EQ_063',
        name: 'è¡€èš€ä¹‹åˆƒ',
        icon: "icons/wow/vanilla/weapons/INV_Weapon_ShortBlade_15.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',

        level: 0,
        maxLevel: 100,

        baseStats: {
            attack: 800,
            haste: 20,
            mastery: 20
        },
        growth: {
            attack: 2,
            haste: 2,
            mastery: 2
        },

        specialEffect: {
            type: 'basic_attack_repeat',
            chance: 0.20
        }
    },
    // ==================== æ²‰é»˜çš„ç¥åº™è£…å¤‡ ====================
    EQ_064: {
        id: 'EQ_064',
        name: 'æ„å¿—ä¹‹åŠ›',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Talisman_07.png",
        type: 'equipment',
        slot: 'trinket1',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1000,
            mastery: 10,
            blockRate: 5,
            blockValue: 300
        },
        growth: {
            hp: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_065: {
        id: 'EQ_065',
        name: 'è‡³é«˜å¾½è®°ä¹‹ç›¾',
        icon: "icons/wow/vanilla/armor/INV_Shield_15.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1200,
            armor: 150,
            blockRate: 25,
            blockValue: 400,
            mastery: 15
        },
        growth: {
            hp: 2,
            armor: 2,
            blockRate: 2,
            blockValue: 2,
            mastery: 2
        }
    },
    EQ_066: {
        id: 'EQ_066',
        name: 'æˆ˜å£«çš„æ‹¥æŠ±',
        icon: "icons/wow/vanilla/armor/INV_Chest_Chain_15.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setName: 'æ‹¥æŠ±å¥—è£…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1000,
            armor: 120,
            attack: 200,
            versatility: 10,
            critRate: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            attack: 2,
            versatility: 2,
            critRate: 2
        }
    },
    EQ_067: {
        id: 'EQ_067',
        name: 'é£è›‡çš„æ‹¥æŠ±',
        icon: "icons/wow/vanilla/armor/INV_Chest_Leather_09.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'embrace_set',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 800,
            armor: 80,
            spellPower: 300,
            haste: 15,
            critRate: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            spellPower: 2,
            haste: 2,
            critRate: 2
        }
    },
    EQ_068: {
        id: 'EQ_068',
        name: 'é˜¿å¡”è±é¢„è¨€è€…æ³•è¡£',
        icon: "icons/wow/vanilla/armor/INV_Chest_Cloth_43.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 600,
            spellPower: 400,
            mastery: 20
        },
        growth: {
            hp: 2,
            spellPower: 2,
            mastery: 20
        }
    },
    EQ_069: {
        id: 'EQ_069',
        name: 'é¾™ä¹‹å¬å”¤',
        icon: "icons/wow/vanilla/weapons/INV_Sword_39.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 800,
            versatility: 60
        },
        growth: {
            attack: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'map_slayer',
            bonusDamageVsMap: 0.1  // åœ°å›¾æˆ˜æ–—+10%ä¼¤å®³
        },
    },
    EQ_070: {
        id: 'EQ_070',
        name: 'ä¼Šå…°å°¼åº“æ–¯ä¹‹è§’',
        icon: "icons/wow/vanilla/armor/INV_Helmet_08.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1000,
            armor: 100,
            mastery: 20
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2
        }
    },
    EQ_071: {
        id: 'EQ_071',
        name: 'å·¨é¾™ä¹‹çœ¼',
        icon: "icons/wow/vanilla/items/INV_Misc_Eye_01.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 400,
            haste: 10
        },
        growth: {
            spellPower: 2,
            haste: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [1, 2],
            spellPowerBonus: 500
        }
    },
    EQ_072: {
        id: 'EQ_072',
        name: 'ä¼Šå…°å°¼åº“æ–¯çš„ç²¾å',
        icon: "icons/wow/vanilla/spells/Spell_Nature_AbolishMagic.png",
        type: 'equipment',
        slot: 'trinket1',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1500,
            mastery: 10,
            versatility: 30,
        },
        growth: {
            hp: 2,
            mastery: 2,
            versatility: 2,
        }
    },
    EQ_073: {
        id: 'EQ_073',
        name: 'å“ˆå¡çš„æ¯’ç‰™',
        icon: "icons/wow/vanilla/weapons/INV_Weapon_ShortBlade_25.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 600,
            haste: 25,
            mastery : 25,
        },
        growth: {
            spellPower: 2,
            haste: 2,
            mastery : 2,

        }
    },

    // ==================== é»‘çŸ³å¡”ä¸‹ï¼ˆ55çº§ï¼‰è£…å¤‡ ====================
    EQ_074: {
        id: 'EQ_074',
        name: 'å‹‡æ°”è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_34.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 900,
            armor: 120,
            mastery: 15,
            blockRate: 3,
            blockValue: 150
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_075: {
        id: 'EQ_075',
        name: 'è¿…å½±è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_03.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 300,
            hp: 450,
            armor: 70,
            critRate: 10,
            haste: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            haste: 2
        }
    },
    EQ_076: {
        id: 'EQ_076',
        name: 'è™”è¯šè…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_10.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 450,
            hp: 650,
            mastery: 15,
            versatility: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_077: {
        id: 'EQ_077',
        name: 'åšå­¦è€…è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_08.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 550,
            hp: 500,
            haste: 20,
            critRate: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            haste: 2,
            critRate: 2
        }
    },
    EQ_078: {
        id: 'EQ_078',
        name: 'å‹‡æ°”æŠ¤æ‰‹',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_26.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 850,
            armor: 110,
            mastery: 20,
            blockRate: 3,
            blockValue: 150
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_079: {
        id: 'EQ_079',
        name: 'è¿…å½±æ‰‹å¥—',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_24.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 350,
            hp: 450,
            armor: 70,
            critRate: 10,
            mastery: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            mastery: 2
        }
    },
    EQ_080: {
        id: 'EQ_080',
        name: 'è™”è¯šæ‰‹å¥—',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_14.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 500,
            hp: 650,
            mastery: 20,
            haste: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            haste: 2
        }
    },
    EQ_081: {
        id: 'EQ_081',
        name: 'åšå­¦è€…æ‰‹å¥—',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_17.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 600,
            hp: 500,
            haste: 20,
            mastery: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            haste: 2,
            mastery: 2
        }
    },
    EQ_082: {
        id: 'EQ_082',
        name: 'å–·æ¯’è€…',
        icon: "icons/wow/vanilla/weapons/INV_Wand_10.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 950,
            haste: 30,
            mastery: 25,
        },
        growth: {
            attack: 2,
            haste: 2,
            mastery: 2,
            critRate: 2
        }
    },
    EQ_083: {
        id: 'EQ_083',
        name: 'çº¢æœ¨ä¹‹ç¯',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_05.png",
        type: 'equipment',
        slot: 'ring2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1200,
            versatility: 20,
            mastery: 20
        },
        growth: {
            hp: 2,
            versatility: 2,
            mastery: 2
        }
    },
    EQ_084: {
        id: 'EQ_084',
        name: 'å“ˆé›·è‚¯çš„é¡¹åœˆ',
        icon: "icons/wow/vanilla/armor/INV_Belt_14.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1500,
            attack: 200,
            spellPower: 200,
            haste: 10,
            versatility: 10
        },
        growth: {
            hp: 2,
            attack: 2,
            spellPower: 2,
            haste: 2,
            versatility: 2
        }
    },
    EQ_085: {
        id: 'EQ_085',
        name: 'ç‡ƒæ£˜å®é’»',
        icon: "icons/wow/vanilla/items/ranjibaozuan.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 300,
            critRate: 10,
            mastery: 10
        },
        growth: {
            spellPower: 2,
            critRate: 2,
            mastery: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [1, 2],
            spellPowerBonus: 800
        }
    },
    EQ_086: {
        id: 'EQ_086',
        name: 'é»‘é¸­',
        icon: "icons/wow/vanilla/weapons/INV_Sword_13.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1050,
            critRate: 25,
            critDamage: 0.5,
            versatility: 20
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2,
            versatility: 2
        }
    },

    // ==================== é€šçµå­¦é™¢ï¼ˆ55çº§ï¼‰è£…å¤‡ ====================
    EQ_087: {
        id: 'EQ_087',
        name: 'ä¸Šå¤éª¨å¼“',
        icon: "icons/wow/vanilla/weapons/INV_Weapon_Bow_12.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1000,
            critRate: 20,
            haste: 20,
            mastery: 20
        },
        growth: {
            attack: 2,
            critRate: 2,
            haste: 2,
            mastery: 2
        }
    },
    EQ_088: {
        id: 'EQ_088',
        name: 'é™¢é•¿ä¹‹æ–',
        icon: "icons/wow/vanilla/weapons/INV_Staff_13.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 950,
            critRate: 25,
            mastery: 25,
            versatility: 20
        },
        growth: {
            spellPower: 2,
            critRate: 2,
            mastery: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [2, 3],
            spellPowerBonus: 800
        }
    },
    EQ_089: {
        id: 'EQ_089',
        name: 'å™¬éª¨é“é’ˆ',
        icon: "icons/wow/vanilla/weapons/INV_Wand_07.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 550,
            haste: 20,
            mastery: 20,
            critRate: 10
        },
        growth: {
            spellPower: 2,
            haste: 2,
            mastery: 2,
            critRate: 2
        }
    },
    EQ_090: {
        id: 'EQ_090',
        name: 'å‹‡æ°”å¤´ç›”',
        icon: "icons/wow/vanilla/armor/INV_Helmet_02.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1300,
            armor: 120,
            mastery: 10,
            blockRate: 4,
            blockValue: 150
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_091: {
        id: 'EQ_091',
        name: 'è™”è¯šå¤´å† ',
        icon: "icons/wow/vanilla/armor/INV_Crown_01.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 300,
            hp: 850,
            mastery: 10,
            versatility: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_092: {
        id: 'EQ_092',
        name: 'è¿…å½±ç½©å¸½',
        icon: "icons/wow/vanilla/armor/INV_Helmet_41.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 300,
            hp: 750,
            armor: 90,
            critRate: 10,
            haste: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            haste: 2
        }
    },
    EQ_093: {
        id: 'EQ_093',
        name: 'åšå­¦è€…å¤´å† ',
        icon: "icons/wow/vanilla/armor/INV_Crown_02.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 650,
            critRate: 10,
            haste: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            haste: 2
        }
    },
    EQ_094: {
        id: 'EQ_094',
        name: 'è«é‡Œè¥¿å¥¥çš„ç»Ÿå¾¡æŒ‡ç¯',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_16.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 700,
            mastery: 20,
            versatility: 20
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2
        }
    },

    // ==================== æ–¯å¦ç´¢å§†ï¼ˆ55çº§ï¼‰è£…å¤‡ ====================
    EQ_095: {
        id: 'EQ_095',
        name: 'ç‘æ–‡æˆ´å°”ä¹‹å‰‘',
        icon: "icons/wow/vanilla/weapons/INV_Sword_17.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1100,
            critRate: 30,
            critDamage: 0.6,
            versatility: 30
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2,
            versatility: 2
        },
        specialEffect: {
            // æ¯å›åˆ20%æ¦‚ç‡ï¼šæœ¬å›åˆæ”»å‡»å¼ºåº¦+1500
            //ï¼ˆé€šç”¨ç»“æ„ï¼štype=proc_stat, trigger=turn_startï¼‰
            type: 'proc_stat',
            trigger: 'turn_start',
            chance: 0.20,
            stats: { attack: 800 },
            scaleWithLevel: true
        }
    },
    EQ_096: {
        id: 'EQ_096',
        name: 'çŸ¥è¯†å®å…¸',
        icon: "icons/wow/vanilla/items/INV_Misc_Book_05.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 650,
            mastery: 25,
            haste: 20,
            versatility: 15
        },
        growth: {
            spellPower: 2,
            mastery: 2,
            haste: 2,
            versatility: 2
        }
    },
    EQ_097: {
        id: 'EQ_097',
        name: 'ç§˜æœ¯ä¹‹æ˜Ÿ',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Talisman_08.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 550,
            hp: 1500,
            haste: 20,
            critRate: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            haste: 2,
            critRate: 2
        }
    },
    EQ_098: {
        id: 'EQ_098',
        name: 'é»‘çˆµå£«æ–—ç¯·',
        icon: "icons/wow/vanilla/armor/INV_Misc_Cape_20.png",
        type: 'equipment',
        slot: 'cloak',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 900,
            armor: 120,
            versatility: 25,
            haste: 15,
            critRate: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            versatility: 2,
            haste: 2,
            critRate: 2
        }
    },
    EQ_099: {
        id: 'EQ_099',
        name: 'å‹‡æ°”æŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_04.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1200,
            armor: 150,
            mastery: 10,
            blockRate: 4,
            blockValue: 150
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_100: {
        id: 'EQ_100',
        name: 'è¿…å½±æŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_02.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 250,
            hp: 700,
            armor: 90,
            critRate: 10,
            mastery: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            mastery: 2
        }
    },
    EQ_101: {
        id: 'EQ_101',
        name: 'è™”è¯šæŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_08.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 300,
            hp: 950,
            mastery: 15,
            haste: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            haste: 2
        }
    },
    EQ_102: {
        id: 'EQ_102',
        name: 'åšå­¦è€…æŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_06.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 850,
            critRate: 10,
            versatility: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            versatility: 2
        }
    },

    // ==================== é»‘çŸ³å¡”ä¸Šï¼ˆ60çº§ï¼‰è£…å¤‡ ====================
    EQ_103: {
        id: 'EQ_103',
        name: 'æ¶é­”ä¹‹å‡»',
        icon: "icons/wow/vanilla/weapons/INV_Weapon_ShortBlade_25.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1000,
            critRate: 20,
            critDamage: 0.5,
            mastery: 25,
            versatility: 20
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2,
            mastery: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'basic_attack_repeat',
            chance: 0.50
        }
    },
    EQ_104: {
        id: 'EQ_104',
        name: 'é›·å¾·åŒåˆƒ',
        icon: "icons/wow/vanilla/weapons/INV_Sword_40.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1300,
            critRate: 20,
            critDamage: 0.6,
            haste: 25,
            versatility: 20
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2,
            haste: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'basic_attack_repeat',
            chance: 0.40
        }
    },
    EQ_105: {
        id: 'EQ_105',
        name: 'çŸ³æ¥ ä¹‹ç¯',
        icon: "icons/wow/vanilla/items/INV_Misc_Root_02.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1300,
            versatility: 25,
            mastery: 25
        },
        growth: {
            hp: 2,
            versatility: 2,
            mastery: 2
        }
    },
    EQ_106: {
        id: 'EQ_106',
        name: 'ç—›è‹¦æŒ‡ç¯',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_16.png",
        type: 'equipment',
        slot: 'ring2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 900,
            attack: 250,
            spellPower: 250,
            critRate: 10,
            haste: 15
        },
        growth: {
            hp: 2,
            attack: 2,
            spellPower: 2,
            critRate: 2,
            haste: 2
        }
    },
    EQ_107: {
        id: 'EQ_107',
        name: 'é¾™äººä¹‹ç›¾',
        icon: "icons/wow/vanilla/armor/INV_Shield_20.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1600,
            armor: 200,
            mastery: 20,
            blockRate: 25,
            blockValue: 600
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_108: {
        id: 'EQ_108',
        name: 'é›·å¾·ä¹‹çœ¼',
        icon: "icons/wow/vanilla/armor/INV_Helmet_46.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 450,
            critRate: 10,
            mastery: 10
        },
        growth: {
            attack: 2,
            spellPower: 2,
            critRate: 2,
            mastery: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [1, 2],
            attackBonus: 1200,
        }
    },
    EQ_109: {
        id: 'EQ_109',
        name: 'å‹‡æ°”èƒ¸ç”²',
        icon: "icons/wow/vanilla/armor/INV_Chest_Plate03.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1500,
            armor: 180,
            mastery: 10,
            blockRate: 4,
            blockValue: 250
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_110: {
        id: 'EQ_110',
        name: 'è¿…å½±å¤–å¥—',
        icon: "icons/wow/vanilla/armor/INV_Chest_Leather_07.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 350,
            hp: 900,
            armor: 100,
            critRate: 10,
            mastery: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            mastery: 2
        }
    },
    EQ_111: {
        id: 'EQ_111',
        name: 'è™”è¯šé•¿è¢',
        icon: "icons/wow/vanilla/armor/INV_Chest_Cloth_11.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 1200,
            mastery: 15,
            haste: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            haste: 2
        }
    },
    EQ_112: {
        id: 'EQ_112',
        name: 'åšå­¦è€…é•¿è¢',
        icon: "icons/wow/vanilla/armor/INV_Chest_Cloth_25.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 1100,
            critRate: 10,
            mastery: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            mastery: 2
        }
    },

    // ==================== é»‘æš—é™¢é•¿åŠ ä¸ï¼ˆ60çº§ä¸–ç•Œé¦–é¢†ï¼‰æ–°å¢ï¼šT0 å¥—è£…æŠ¤è‚© ====================
    // è®¾è®¡è¯´æ˜ï¼šæ•´ä½“æ•°å€¼ç•¥é«˜äº 55 çº§å‰¯æœ¬æ‰è½çš„ T0 å¥—è£…æ•£ä»¶ï¼ˆè…°å¸¦/æ‰‹å¥—/å¤´ç›”/æŠ¤è…¿ï¼‰ï¼Œä½†ä¸è¶…è¿‡ 60 çº§èƒ¸ç”²å¼ºåº¦å¤ªå¤šã€‚
    EQ_113: {
        id: 'EQ_113',
        name: 'å‹‡æ°”è‚©ç”²',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_30.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1400,
            armor: 180,
            mastery: 15,
            blockRate: 4,
            blockValue: 280
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_114: {
        id: 'EQ_114',
        name: 'è¿…å½±æŠ¤è‚©',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_07.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 320,
            hp: 750,
            armor: 100,
            critRate: 10,
            versatility: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            versatility: 2
        }
    },
    EQ_115: {
        id: 'EQ_115',
        name: 'è™”è¯šè¡¬è‚©',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_09.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 300,
            hp: 1000,
            mastery: 15,
            versatility: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_116: {
        id: 'EQ_116',
        name: 'åšå­¦è€…è¡¬è‚©',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_23.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 950,
            critRate: 15,
            mastery: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            mastery: 2
        }
    },

    // ==================== ç‘æ–‡æˆ´å°”ç”·çˆµï¼ˆ60çº§ä¸–ç•Œé¦–é¢†ï¼‰æ–°å¢ï¼šT0 å¥—è£…æˆ˜é´/ä¾¿é‹ ====================
    // è®¾è®¡è¯´æ˜ï¼šæ•°å€¼å¤§å°å‚è€ƒ T0 æŠ¤è‚©ï¼ˆEQ_113~EQ_116ï¼‰ï¼Œå¹¶é€‚å½“è°ƒæ•´å‰¯å±æ€§ä»¥æ‹‰å¼€å·®å¼‚ã€‚
    EQ_117: {
        id: 'EQ_117',
        name: 'å‹‡æ°”æˆ˜é´',
        icon: "icons/wow/vanilla/armor/INV_Boots_Plate_03.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1350,
            armor: 190,
            mastery: 12,
            blockRate: 4,
            blockValue: 300
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_118: {
        id: 'EQ_118',
        name: 'è¿…å½±é•¿é´',
        icon: "icons/wow/vanilla/armor/INV_Boots_04.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 280,
            hp: 780,
            armor: 110,
            critRate: 10,
            mastery: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            mastery: 2
        }
    },
    EQ_119: {
        id: 'EQ_119',
        name: 'è™”è¯šè½¯é‹',
        icon: "icons/wow/vanilla/armor/INV_Boots_05.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 260,
            hp: 980,
            mastery: 15,
            haste: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            haste: 2
        }
    },
    EQ_120: {
        id: 'EQ_120',
        name: 'åšå­¦è€…é•¿é´',
        icon: "icons/wow/vanilla/armor/INV_Boots_02.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 330,
            hp: 920,
            critRate: 10,
            haste: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            haste: 2
        }
    },

    // ==================== é›·å¾·Â·é»‘æ‰‹ï¼ˆ60çº§ä¸–ç•Œé¦–é¢†ï¼‰æ–°å¢ï¼šT0 å¥—è£…æŠ¤è…•/è£¹è…• ====================
    // è®¾è®¡è¯´æ˜ï¼šæ•°å€¼å¤§å°å‚è€ƒ T0 æŠ¤è‚©ï¼ˆEQ_113~EQ_116ï¼‰ï¼Œå¹¶é€‚å½“è°ƒæ•´å‰¯å±æ€§ä»¥æ‹‰å¼€å·®å¼‚ã€‚
    EQ_121: {
        id: 'EQ_121',
        name: 'å‹‡æ°”æŠ¤è…•',
        icon: "icons/wow/vanilla/armor/INV_Bracer_18.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1280,
            armor: 165,
            mastery: 10,
            blockValue: 250,
            magicResist: 40
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockValue: 2,
            magicResist: 2
        }
    },
    EQ_122: {
        id: 'EQ_122',
        name: 'è¿…å½±æŠ¤è…•',
        icon: "icons/wow/vanilla/armor/INV_Bracer_07.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 240,
            hp: 760,
            armor: 85,
            mastery: 10,
            haste: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            mastery: 2,
            haste: 2
        }
    },
    EQ_123: {
        id: 'EQ_123',
        name: 'è™”è¯šæŠ¤è…•',
        icon: "icons/wow/vanilla/armor/INV_Belt_31.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 240,
            hp: 980,
            haste: 10,
            versatility: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            haste: 2,
            versatility: 2
        }
    },
    EQ_124: {
        id: 'EQ_124',
        name: 'åšå­¦è€…è…•è½®',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_23.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 280,
            hp: 930,
            mastery: 10,
            versatility: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2
        }
    },

    EQ_HOGGER_001: {
        id: 'EQ_HOGGER_001',
        name: 'éœæ ¼çš„æ¯›çš®æŠ«é£',
        icon: 'icons/wow/vanilla/armor/INV_Misc_Cape_10.png',
        type: 'equipment',
        slot: 'cloak',
        rarity: 'blue',
        setId: 'hogger_gather_set',
        setName: 'éœæ ¼çš„æˆ˜åˆ©å“',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 100,
            armor: 20,
            proficiency: 10  // é‡‡é›†ç†Ÿç»ƒ
        },
        growth: {
            hp: 2,
            armor: 2,
            proficiency: 2
        }
    },
    EQ_HOGGER_002: {
        id: 'EQ_HOGGER_002',
        name: 'éœæ ¼çš„ç ç‰™å¤´ç›”',
        icon: 'icons/wow/vanilla/armor/INV_Helmet_03.png',
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        setId: 'hogger_gather_set',
        setName: 'éœæ ¼çš„æˆ˜åˆ©å“',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 150,
            armor: 30,
            precision: 10  // é‡‡é›†ç²¾ç»†
        },
        growth: {
            hp: 2,
            armor: 2,
            precision: 2
        }
    },
    EQ_HOGGER_003: {
        id: 'EQ_HOGGER_003',
        name: 'éœæ ¼çš„å…½çš®èƒ¸ç”²',
        icon: 'icons/wow/vanilla/armor/INV_Chest_Leather_01.png',
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'hogger_gather_set',
        setName: 'éœæ ¼çš„æˆ˜åˆ©å“',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 40,
            perception: 10  // é‡‡é›†æ„ŸçŸ¥
        },
        growth: {
            hp: 2,
            armor: 2,
            perception: 2
        }
    },
    EQ_VANCLEEF_001: {
        id: 'EQ_VANCLEEF_001',
        name: 'æš´é£åŸå·¥å¤´çš„é“²å­',
        icon: 'icons/wow/vanilla/items/INV_Misc_Shovel_01.png',
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            proficiency: 20,
            precision: 20,
            perception: 20  // é‡‡é›†æ„ŸçŸ¥
        },
        growth: {
            hp: 2,
            armor: 2,
            perception: 2
        }
    },
};

//èµ¤è„Šå±±5ä»¶å›¾é‰´100çº§ç‚¹äº®æ•ˆæœ
const REDRIDGE_LV100_SET = ['EQ_014', 'EQ_015', 'EQ_016', 'EQ_017', 'EQ_018'];
// è´«ç˜ ä¹‹åœ°æ¯’è›‡çš„æ‹¥æŠ±6ä»¶è£…å¤‡å…¨éƒ¨è¾¾åˆ°è¿‡Lv.100 â†’ å…¨é˜Ÿçˆ†å‡»ç‡+5
const BARRENS_LV100_SET = ['EQ_019', 'EQ_020', 'EQ_021', 'EQ_022', 'EQ_023', 'EQ_024'];

//è†æ£˜è°·6ä»¶100çº§å›¾é‰´ç‚¹äº®æ•ˆæœ
const STRANGLETHORN_LV100_SET = ['EQ_027', 'EQ_028', 'EQ_029', 'EQ_030', 'EQ_031', 'EQ_032'];

// å‡„å‡‰ä¹‹åœ° 6 ä»¶è£…å¤‡å…¨éƒ¨è¾¾åˆ°è¿‡ Lv.100 â†’ å…¨é˜Ÿç²¾é€š +5
const DESOLACE_LV100_SET = ['EQ_035', 'EQ_036', 'EQ_037', 'EQ_038', 'EQ_039', 'EQ_040'];
// è¡€è‰²ä¿®é“é™¢ 13 ä»¶è£…å¤‡å…¨éƒ¨è¾¾åˆ°è¿‡ Lv.100 â†’ å…¨é˜Ÿæ”»å‡»å¼ºåº¦+200 æ³•æœ¯å¼ºåº¦+200
const SCARLET_MONASTERY_LV100_SET = [
    'EQ_049', 'EQ_050', 'EQ_051', 'EQ_052', 'EQ_053', 'EQ_054',
    'EQ_055', 'EQ_056', 'EQ_057', 'EQ_058', 'EQ_059', 'EQ_060', 'EQ_061'
];
// æ²‰æ²¡çš„ç¥åº™10ä»¶ 10å…¨èƒ½
const SUNKEN_TEMPLE_LV100_SET = ['EQ_064', 'EQ_065', 'EQ_066', 'EQ_067', 'EQ_068', 'EQ_069', 'EQ_070', 'EQ_071', 'EQ_072', 'EQ_073'];

// é»‘çŸ³å¡”ä¸‹14ä»¶ 10æš´å‡»
const LOWER_BLACKROCK_SPIRE_LV100_SET = ['EQ_074', 'EQ_075', 'EQ_076', 'EQ_077', 'EQ_078', 'EQ_069', 'EQ_079', 'EQ_080', 'EQ_081', 'EQ_082', 'EQ_083', 'EQ_084', 'EQ_085', 'EQ_086'];

// é€šçµå­¦é™¢8ä»¶ 10ç²¾é€š
const SCHOLOMANCE_LV100_SET = ['EQ_087', 'EQ_088', 'EQ_089', 'EQ_090', 'EQ_091', 'EQ_092', 'EQ_093', 'EQ_094'];

// æ–¯å¦ç´¢å§†8ä»¶ 10æ€¥é€Ÿ
const STRATHOLME_lv100_SET = ['EQ_095', 'EQ_096', 'EQ_097', 'EQ_098', 'EQ_099', 'EQ_100', 'EQ_101', 'EQ_102'];

// é»‘çŸ³å¡”ä¸Š10ä»¶ 500æ”»å‡»å¼ºåº¦/æ³•æœ¯å¼ºåº¦
const UPPER_BLACKROCK_SPIRE_LV100_SET = ['EQ_103', 'EQ_104', 'EQ_105', 'EQ_106', 'EQ_107', 'EQ_108', 'EQ_109', 'EQ_110', 'EQ_111', 'EQ_112'];

// ==================== å›¾é‰´é›†é½æ•ˆæœé…ç½® ====================
const CODEX_SET_EFFECTS = [
    {
        id: 'redridge',
        name: 'èµ¤è„Šå±±',
        equipIds: REDRIDGE_LV100_SET,
        effect: 'å…¨é˜Ÿå…¨èƒ½ +5',
        color: '#4CAF50'
    },
    {
        id: 'barrens',
        name: 'è´«ç˜ ä¹‹åœ°',
        equipIds: BARRENS_LV100_SET,
        effect: 'å…¨é˜Ÿçˆ†å‡»ç‡ +5%',
        color: '#ff9800'
    },
    {
        id: 'stranglethorn',
        name: 'è†æ£˜è°·',
        equipIds: STRANGLETHORN_LV100_SET,
        effect: 'å…¨é˜Ÿæ€¥é€Ÿ +5',
        color: '#2196F3'
    },
    {
        id: 'desolace',
        name: 'å‡„å‡‰ä¹‹åœ°',
        equipIds: DESOLACE_LV100_SET,
        effect: 'å…¨é˜Ÿç²¾é€š +5',
        color: '#9C27B0'
    },
    {
        id: 'scarlet_monastery',
        name: 'è¡€è‰²ä¿®é“é™¢',
        equipIds: SCARLET_MONASTERY_LV100_SET,
        effect: 'å…¨é˜Ÿæ”»å‡» +200ï¼Œæ³•å¼º +200',
        color: '#f44336'
    },
    {
        id: 'susas',
        name: 'é­ç¬è€…è‹è¨æ–¯',
        equipIds: ['EQ_044'],
        effect: 'å…¨é˜Ÿå…¨èƒ½ +5ï¼Œæ€¥é€Ÿ +10ï¼Œç²¾é€š +10',
        color: '#ff8000'
    },
    {
        id: 'sunken_temple',
        name: 'æ²‰æ²¡çš„ç¥åº™',
        equipIds: SUNKEN_TEMPLE_LV100_SET,
        effect: 'å…¨é˜Ÿå…¨èƒ½ +10',
        color: '#00bcd4'
    },
    {
        id: 'lower_blackrock_spire',
        name: 'é»‘çŸ³å¡”ä¸‹',
        equipIds: LOWER_BLACKROCK_SPIRE_LV100_SET,
        effect: 'å…¨é˜Ÿæš´å‡» +10',
        color: '#ff9800'
    },
    {
        id: 'scholomance',
        name: 'é€šçµå­¦é™¢',
        equipIds: SCHOLOMANCE_LV100_SET,
        effect: 'å…¨é˜Ÿç²¾é€š +10',
        color: '#9C27B0'
    },
    {
        id: 'stratholme',
        name: 'æ–¯å¦ç´¢å§†',
        equipIds: STRATHOLME_lv100_SET,
        effect: 'å…¨é˜Ÿæ€¥é€Ÿ +10',
        color: '#2196F3'
    },
    {
        id: 'upper_blackrock_spire',
        name: 'é»‘çŸ³å¡”ä¸Š',
        equipIds: UPPER_BLACKROCK_SPIRE_LV100_SET,
        effect: 'å…¨é˜Ÿæ”»å‡» +500ï¼Œæ³•å¼º +500',
        color: '#f44336'
    },
];

// ==================== RARITY COLORS ====================
const RARITY_COLORS = {
    white: '#d9d9d9',
    green: '#1eff00',
    blue: '#0070dd',
    purple: '#a335ee',
    orange: '#ff8000',
    gold: '#ffd700'
};

const getRarityColor = (rarity) => {
    if (!rarity) return '#4a3c2a';
    return RARITY_COLORS[rarity] || '#4a3c2a';
};

// ==================== è®¡ç®—è§’è‰²é‡‡é›†å±æ€§ ====================
// ==================== è®¡ç®—è§’è‰²é‡‡é›†å±æ€§ï¼ˆå«è£…å¤‡åŠ æˆï¼‰ ====================
function calculateGatherStats(character) {
    const classData = CLASSES[character.classId];
    const baseGather = classData.baseGatherStats || { proficiency: 5, precision: 5, perception: 5 };

    // åŸºç¡€å€¼ + ç­‰çº§åŠ æˆ
    const levelBonus = Math.floor(character.level / 5);

    // è£…å¤‡åŠ æˆ
    let equipProficiency = 0;
    let equipPrecision = 0;
    let equipPerception = 0;

    Object.values(character.equipment || {}).forEach(item => {
        if (item && item.stats) {
            equipProficiency += item.stats.proficiency || 0;
            equipPrecision += item.stats.precision || 0;
            equipPerception += item.stats.perception || 0;
        }
    });

    // âœ… ç§æ—é‡‡é›†å±æ€§åŠ æˆï¼ˆä¾‹å¦‚ï¼šä¾å„’ã€ç†Ÿç¨”ã€‘ï¼‰
    const raceTrait = RACE_TRAITS?.[character.race];
    const gatherBonus = raceTrait?.gatherStatBonus || {};

    return {
        proficiency: baseGather.proficiency + levelBonus + equipProficiency + (gatherBonus.proficiency || 0),
        precision: baseGather.precision + levelBonus + equipPrecision + (gatherBonus.precision || 0),
        perception: baseGather.perception + levelBonus + equipPerception + (gatherBonus.perception || 0),
    };
}

// ==================== è®¡ç®—å»ºç­‘äº§å‡º ====================
function calculateBuildingProduction(building, workers, gameState) {
    if (!workers || workers.length === 0) return 0;

    const buildingData = RESOURCE_BUILDINGS[building];
    if (!buildingData) return 0;

    // ===== ç ”ç©¶åŠ æˆï¼ˆæŒ‰èµ„æºç±»å‹ç”Ÿæ•ˆï¼‰ =====
    // ä¾‹ï¼šä¼æœ¨ç²¾é€š(effect='wood') ä¼šæå‡ resourceType='wood' çš„äº§å‡º
    let researchBonus = 0;
    const resType = buildingData.resourceType;
    const researchLv = gameState?.research || {};
    Object.entries(researchLv).forEach(([rid, lv]) => {
        const r = RESEARCH?.[rid];
        if (r && r.effect === resType) {
            researchBonus += (r.bonus || 0) * (lv || 0);
        }
    });

    let totalProduction = 0;

    workers.forEach(charId => {
        const char = gameState.characters.find(c => c.id === charId);
        if (!char) return;

        const gatherStats = calculateGatherStats(char);
        const weights = buildingData.statWeights;

        // æ•ˆç‡è®¡ç®—ï¼šåŸºç¡€äº§é‡ * (1 + åŠ æƒå±æ€§/100)
        const weightedStat =
            gatherStats.proficiency * weights.proficiency +
            gatherStats.precision * weights.precision +
            gatherStats.perception * weights.perception;

        let efficiency = 1 + weightedStat / 10;

        // ===== æ–°å¢ï¼šå¥—è£…æ•ˆæœ gatherEfficiency =====
        const setBonuses = getSetBonusesForCharacter(char);
        for (const set of setBonuses) {
            for (const tier of set.activated) {
                if (tier.bonus?.gatherEfficiency) {
                    efficiency *= (1 + tier.bonus.gatherEfficiency);
                }
            }
        }

        // ç ”ç©¶æ•ˆç‡ï¼ˆä¼æœ¨/é‡‡çŸ¿/é‡‡é›†æ‰€/æŒ–æ¯›çš®ç­‰ï¼‰
        if (researchBonus > 0) {
            efficiency *= (1 + researchBonus);
        }

        const production = buildingData.baseProduction * efficiency;

        // ç²¾ç»†å±æ€§ï¼šæœ‰æ¦‚ç‡è·å¾—åŒå€äº§å‡º
        const doubleChance = gatherStats.precision / 200;
        const finalProduction = Math.random() < doubleChance ? production * 2 : production;

        totalProduction += finalProduction;
    });

    // âœ… æˆå°±ï¼šæ‰€æœ‰å»ºç­‘äº§é‡åŠ æˆï¼ˆå»ºè®¾è€…ç³»åˆ—ç­‰ï¼‰
    const achResourceBonus = getAchievementResourceBonus(gameState);
    return totalProduction * (1 + achResourceBonus);
}

const ITEMS = {
    IT_001: {
        id: 'IT_001',
        name: 'ç ´çƒ‚çš„æ¯›çš®',
        type: 'junk',
        rarity: 'white',
        sellPrice: 200,
        icon: 'icons/wow/vanilla/items/INV_Banner_03.png'
    },
    IT_STV_001: {
        id: 'IT_STV_001',
        name: 'è†æ£˜è°·çš„é’å±±Â·ç¬¬ä¸€ç« ',
        type: 'junk',
        rarity: 'white',
        sellPrice: 5000
    },
    IT_STV_002: {
        id: 'IT_STV_002',
        name: 'è†æ£˜è°·çš„é’å±±Â·ç¬¬äºŒç« ',
        type: 'junk',
        rarity: 'white',
        sellPrice: 5000
    },
    IT_STV_003: {
        id: 'IT_STV_003',
        name: 'è†æ£˜è°·çš„é’å±±Â·ç¬¬ä¸‰ç« ',
        type: 'junk',
        rarity: 'white',
        sellPrice: 5000
    },
    IT_STV_004: {
        id: 'IT_STV_004',
        name: 'è†æ£˜è°·çš„é’å±±Â·ç¬¬å››ç« ',
        type: 'junk',
        rarity: 'white',
        sellPrice: 5000
    },
    // é»‘é¾™åŒ–èº«çš„è¯æ˜
    IT_BLACK_DRAGON_PROOF: {
        id: 'IT_BLACK_DRAGON_PROOF',
        name: 'é»‘é¾™åŒ–èº«çš„è¯æ˜',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Head_Dragon_01.png',
        description: 'ä½¿ç”¨åï¼Œæ­éœ²çœŸç›¸ï¼Œè§£é”éšè—Bossã€æ™®ç‘æ–¯æ‰˜å¥³å£«ã€‘'
    },
    // éœæ ¼çš„æ²¾è¡€å¾½ç« ï¼ˆéœæ ¼æ‰è½ï¼‰
    IT_HOGGER_BADGE: {
        id: 'IT_HOGGER_BADGE',
        name: 'éœæ ¼çš„æ²¾è¡€å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_ArmorKit_01.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€è‰¾å°”æ–‡æ£®æ—ï¼Œè¥¿éƒ¨è’é‡ï¼Œèµ¤è„Šå±±ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // è¡€è‰²åå­—å†›çš„å¾½ç« ï¼ˆè£‚é­‚è€…è¨å°”è¯ºæ–¯æ‰è½ï¼‰
    IT_SCARLET_CRUSADER_BADGE: {
        id: 'IT_SCARLET_CRUSADER_BADGE',
        name: 'è¡€è‰²åå­—å†›çš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_ArmorKit_10.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€è¡€è‰²ä¿®é“é™¢ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // è¿ªè²äºšå¾½ç« ï¼ˆèŒƒå…‹é‡Œå¤«æ‰è½ï¼‰
    IT_VANCLEEF_BADGE: {
        id: 'IT_VANCLEEF_BADGE',
        name: 'è¿ªè²äºšå¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/armor/INV_Jewelry_Talisman_05.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€è´«ç˜ ä¹‹åœ°ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // é»‘é¾™åŒ–èº«å¾½ç« ï¼ˆæ™®ç‘æ–¯æ‰˜æ‰è½ï¼‰
    IT_PRESTOR_BADGE: {
        id: 'IT_PRESTOR_BADGE',
        name: 'é»‘é¾™åŒ–èº«å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/armor/INV_Jewelry_Talisman_12.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€è†æ£˜è°·ï¼Œå¡”çº³åˆ©æ–¯ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // ç´¢ç‘æ£®å¤§å¸çš„å¾½ç« ï¼ˆè¾¾å°”æˆˆç´¢ç‘æ£®æ‰è½ï¼‰
    IT_THAURISSAN_BADGE: {
        id: 'IT_THAURISSAN_BADGE',
        name: 'ç´¢ç‘æ£®å¤§å¸çš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Rune_04.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€æ²‰æ²¡çš„ç¥åº™ï¼Œé»‘çŸ³æ·±æ¸Šã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    }
    ,

// åŠ ä¸çš„å¾½ç« ï¼ˆé»‘æš—é™¢é•¿åŠ ä¸æ‰è½ï¼‰
    IT_GANDLING_BADGE: {
        id: 'IT_GANDLING_BADGE',
        name: 'åŠ ä¸çš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Rune_08.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€é€šçµå­¦é™¢ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // ç‘æ–‡æˆ´å°”ç”·çˆµçš„å¾½ç« ï¼ˆç‘æ–‡æˆ´å°”ç”·çˆµæ‰è½ï¼‰
    IT_RIVENDARE_BADGE: {
        id: 'IT_RIVENDARE_BADGE',
        name: 'ç‘æ–‡æˆ´å°”ç”·çˆµçš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Rune_07.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€æ–¯å¦ç´¢å§†ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // é›·å¾·é»‘æ‰‹çš„å¾½ç« ï¼ˆé›·å¾·é»‘æ‰‹æ‰è½ï¼‰
    IT_REND_BADGE: {
        id: 'IT_REND_BADGE',
        name: 'é›·å¾·é»‘æ‰‹çš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Rune_02.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€é»‘çŸ³å¡”ä¸Šã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    }

};


const BUILDINGS = {
    house: { id: 'house', name: 'æ°‘å±…', cost: { gold: 100, wood: 50 }, production: { population: 2 }, consumption: {} },

};

function ItemIcon({ item, size = 28 }) {
    const src = item?.iconUrl || item?.icon;
    const isImg = typeof src === 'string' && (src.includes('/') || src.endsWith('.png'));

    if (isImg) {
        return (
            <img
                src={src}
                alt={item?.name || 'icon'}
                style={{ width: size, height: size, objectFit: 'contain', imageRendering: 'pixelated' }}
            />
        );
    }
    return <span style={{ fontSize: size }}>{src || 'ğŸ“¦'}</span>;
}

function SlotIcon({ slot, size = 28 }) {
    const info = EQUIPMENT_SLOTS?.[slot];
    // æ²¡æœ‰å›¾ç‰‡æ—¶å›é€€åˆ° emoji
    return <span style={{ fontSize: size }}>{info?.icon || "ğŸ“¦"}</span>;
}


const RESEARCH = {
    // æ¯çº§æå‡ 3%ï¼ˆ0.03ï¼‰
    lumber_mastery: {
        id: 'lumber_mastery',
        name: 'ä¼æœ¨ç²¾é€š',
        description: 'æå‡ä¼æœ¨æ•ˆç‡',
        baseCost: 500,
        effect: 'wood',
        bonus: 0.03,
    },
    mining_mastery: {
        id: 'mining_mastery',
        name: 'é‡‡çŸ¿ç²¾é€š',
        description: 'æå‡é‡‡çŸ¿æ•ˆç‡',
        baseCost: 500,
        effect: 'ironOre',
        bonus: 0.03,
    },

    // âœ… å‡»è´¥èŒƒå…‹é‡Œå¤«åè§£é”
    gathering_efficiency: {
        id: 'gathering_efficiency',
        name: 'é‡‡é›†ç²¾é€š',
        description: 'æå‡é‡‡é›†æ‰€é‡‡é›†è‰è¯çš„æ•ˆç‡ï¼ˆå‡»è´¥èŒƒå…‹é‡Œå¤«åè§£é”ï¼‰',
        baseCost: 1500,
        effect: 'herb',
        bonus: 0.03,
        unlockBoss: 'vancleef',
    },
    skinning_efficiency: {
        id: 'skinning_efficiency',
        name: 'æ•çŒç²¾é€š',
        description: 'æå‡çŒäººå°å±‹è·å–æ¯›çš®çš„æ•ˆç‡ï¼ˆå‡»è´¥èŒƒå…‹é‡Œå¤«åè§£é”ï¼‰',
        baseCost: 1500,
        effect: 'leather',
        bonus: 0.03,
        unlockBoss: 'vancleef',
    },

    // âœ… å‡»è´¥æ™®ç‘æ–¯æ‰˜å¥³å£«åè§£é”
    siphon_mastery: {
        id: 'siphon_mastery',
        name: 'æ±²é­”ç²¾é€š',
        description: 'æå‡é­”åŠ›ä¹‹æºæ±²å–é­”æ³•ç²¾åçš„æ•ˆç‡ï¼ˆå‡»è´¥æ™®ç‘æ–¯æ‰˜å¥³å£«åè§£é”ï¼‰',
        baseCost: 5000,
        effect: 'magicEssence',
        bonus: 0.03,
        unlockBoss: 'prestor_lady',
    },
    cast_iron_mastery: {
        id: 'cast_iron_mastery',
        name: 'é“¸é“ç²¾é€š',
        description: 'æå‡é“¸é€ å‚ç‚¼åˆ¶é“é”­çš„æ•ˆç‡ï¼ˆå‡»è´¥æ™®ç‘æ–¯æ‰˜å¥³å£«åè§£é”ï¼‰',
        baseCost: 5000,
        effect: 'ironIngot',
        bonus: 0.03,
        unlockBoss: 'prestor_lady',
    },
    // âœ… å‡»è´¥è£‚é­‚è€…è¨å°”è¯ºæ–¯åè§£é”
    alchemy_mastery: {
        id: 'siphon_mastery',
        name: 'ç‚¼é‡‘ç²¾é€š',
        description: 'æå‡ç‚¼é‡‘æœ¯æ•ˆç‡ï¼ˆå‡»è´¥è£‚é­‚è€…è¨å°”è¯ºæ–¯åè§£é”ï¼‰',
        baseCost: 10000,
        effect: 'alchemyOil',
        bonus: 0.03,
        unlockBoss: 'thalnos',
    },
};

const ACHIEVEMENTS = {
    novice: { id: 'novice', name: 'åˆå‡ºèŒ…åº', description: 'è§’è‰²å‡çº§åˆ°10çº§', condition: (state) => state.characters.some(c => c.level >= 10), reward: { expBonus: 0.02 }, icon: 'âš”ï¸' },
    first_blood: { id: 'first_blood', name: 'åˆæˆ˜å‘Šæ·', description: 'å®Œæˆç¬¬ä¸€æ¬¡æˆ˜æ–—', condition: (state) => state.stats.battlesWon >= 1, reward: { goldBonus: 0.05 }, icon: 'ğŸ©¸' },
    tenli_po_sword_saint: {
        id: 'tenli_po_sword_saint',
        name: 'åé‡Œå¡å‰‘åœ£',
        description: 'åœ¨LV1åŒºåŸŸã€è‰¾å°”æ–‡æ£®æ—ã€‘å‡»æ€100000ä¸ªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        // è®¡æ•°æ¥æºï¼šstate.zoneKillCounts.elwynn_forestï¼ˆè·¨ä¸–ç´¯è®¡ï¼‰
        condition: (state) => (state.zoneKillCounts?.elwynn_forest || 0) >= 100000,
        // åœ°å›¾åŒºåŸŸæˆ˜æ–—ï¼šæ€»ä¼¤å®³ +5%
        reward: { mapDamageBonus: 0.05 },
        icon: 'ğŸ—¡ï¸'
    },

    // âœ… æ–°å¢ï¼šæŒç»­æˆ˜æ–—ç³»åˆ—ï¼ˆåœ°å›¾ç´¯è®¡å‡»æ€ï¼Œè·¨ä¸–ç´¯è®¡ï¼‰
    continuous_battle_1: {
        id: 'continuous_battle_1',
        name: 'æŒç»­æˆ˜æ–—â… ',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€1ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 10000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_2: {
        id: 'continuous_battle_2',
        name: 'æŒç»­æˆ˜æ–—â…¡',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€5ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 50000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_3: {
        id: 'continuous_battle_3',
        name: 'æŒç»­æˆ˜æ–—â…¢',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€10ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 100000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_4: {
        id: 'continuous_battle_4',
        name: 'æŒç»­æˆ˜æ–—â…£',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€50ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 500000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_5: {
        id: 'continuous_battle_5',
        name: 'æŒç»­æˆ˜æ–—â…¤',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€100ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 1000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_6: {
        id: 'continuous_battle_6',
        name: 'æŒç»­æˆ˜æ–—â…¥',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€500ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 5000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_7: {
        id: 'continuous_battle_7',
        name: 'æŒç»­æˆ˜æ–—â…¦',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€1000ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 10000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_8: {
        id: 'continuous_battle_8',
        name: 'æŒç»­æˆ˜æ–—â…§',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€5000ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 50000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_9: {
        id: 'continuous_battle_9',
        name: 'æŒç»­æˆ˜æ–—â…¨',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€1äº¿åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 100000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_10: {
        id: 'continuous_battle_10',
        name: 'æŒç»­æˆ˜æ–—â…©',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€5äº¿åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 500000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },

    // âœ… æ–°å¢ï¼šé¦–é¢†æ€æ‰‹ç³»åˆ—ï¼ˆç´¯è®¡å‡»æ€ä»»æ„BOSSï¼Œè·¨ä¸–ç´¯è®¡ï¼‰
    boss_killer_1: {
        id: 'boss_killer_1',
        name: 'é¦–é¢†æ€æ‰‹â… ',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 10æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 10,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_2: {
        id: 'boss_killer_2',
        name: 'é¦–é¢†æ€æ‰‹â…¡',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 50æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 50,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_3: {
        id: 'boss_killer_3',
        name: 'é¦–é¢†æ€æ‰‹â…¢',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 100æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 100,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_4: {
        id: 'boss_killer_4',
        name: 'é¦–é¢†æ€æ‰‹â…£',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 500æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 500,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_5: {
        id: 'boss_killer_5',
        name: 'é¦–é¢†æ€æ‰‹â…¤',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 1000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 1000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_6: {
        id: 'boss_killer_6',
        name: 'é¦–é¢†æ€æ‰‹â…¥',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 5000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 5000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_7: {
        id: 'boss_killer_7',
        name: 'é¦–é¢†æ€æ‰‹â…¦',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 10000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 10000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_8: {
        id: 'boss_killer_8',
        name: 'é¦–é¢†æ€æ‰‹â…§',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 50000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 50000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_9: {
        id: 'boss_killer_9',
        name: 'é¦–é¢†æ€æ‰‹â…¨',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 100000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 100000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_10: {
        id: 'boss_killer_10',
        name: 'é¦–é¢†æ€æ‰‹â…©',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 500000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 500000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },


    collector: { id: 'collector', name: 'æ”¶è—å®¶', description: 'æ”¶é›†10ç§ä¸åŒç‰©å“', condition: (state) => state.codex.length >= 10, reward: { dropBonus: 0.1 }, icon: 'ğŸ“¦' },

    // âœ… å»ºè®¾è€…ç³»åˆ—ï¼šç´¯è®¡å»ºé€ å»ºç­‘æ•°é‡ï¼ˆå«æ—§å»ºç­‘ & åŠŸèƒ½å»ºç­‘ï¼‰
    builder_1: {
        id: 'builder_1',
        name: 'å»ºè®¾è€…â… ',
        description: 'ç´¯è®¡å»ºé€ 10åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 10,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_2: {
        id: 'builder_2',
        name: 'å»ºè®¾è€…â…¡',
        description: 'ç´¯è®¡å»ºé€ 50åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 50,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_3: {
        id: 'builder_3',
        name: 'å»ºè®¾è€…â…¢',
        description: 'ç´¯è®¡å»ºé€ 100åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 100,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_4: {
        id: 'builder_4',
        name: 'å»ºè®¾è€…â…£',
        description: 'ç´¯è®¡å»ºé€ 200åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 200,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_5: {
        id: 'builder_5',
        name: 'å»ºè®¾è€…â…¤',
        description: 'ç´¯è®¡å»ºé€ 500åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 500,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_6: {
        id: 'builder_6',
        name: 'å»ºè®¾è€…â…¥',
        description: 'ç´¯è®¡å»ºé€ 1000åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 1000,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_7: {
        id: 'builder_7',
        name: 'å»ºè®¾è€…â…¦',
        description: 'ç´¯è®¡å»ºé€ 2000åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 2000,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_8: {
        id: 'builder_8',
        name: 'å»ºè®¾è€…â…§',
        description: 'ç´¯è®¡å»ºé€ 5000åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 5000,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_9: {
        id: 'builder_9',
        name: 'å»ºè®¾è€…â…¨',
        description: 'ç´¯è®¡å»ºé€ 10000åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 10000,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_10: {
        id: 'builder_10',
        name: 'å»ºè®¾è€…â…©',
        description: 'ç´¯è®¡å»ºé€ 20000åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 20000,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    susas: {
        id: 'susas',
        name: 'é­ç¬è€…è‹è¨æ–¯',
        description: 'ç‚¹äº®ã€é­ç¬è€…è‹è¨æ–¯ã€‘Lv.100 å›¾é‰´',
        condition: (state) => Array.isArray(state.codexEquipLv100) && state.codexEquipLv100.includes('EQ_044'),
        reward: { dropBonus: 0.05 },
        icon: 'ğŸ´â€â˜ ï¸'
    },

    // âœ… æ–°å¢ï¼šé“å¿ƒæ¾„æ¾ˆç³»åˆ—ï¼ˆBOSSæŒ‘æˆ˜å»¶åå¤±è´¥ç´¯è®¡ï¼‰
    dao_xin_cheng_che_1: {
        id: 'dao_xin_cheng_che_1',
        name: 'é“å¿ƒæ¾„æ¾ˆâ… ',
        description: 'åœ¨BOSSæŒ‘æˆ˜ä¸­è¶…è¿‡4å›åˆåæˆ˜æ–—å¤±è´¥ç´¯è®¡è¾¾åˆ°100æ¬¡',
        condition: (state) => (state.stats?.bossLateRoundDefeats || 0) >= 100,
        reward: { bossHpPct: 0.05 },
        icon: 'ğŸ§˜'
    },
    dao_xin_cheng_che_2: {
        id: 'dao_xin_cheng_che_2',
        name: 'é“å¿ƒæ¾„æ¾ˆâ…¡',
        description: 'åœ¨BOSSæŒ‘æˆ˜ä¸­è¶…è¿‡4å›åˆåæˆ˜æ–—å¤±è´¥ç´¯è®¡è¾¾åˆ°1000æ¬¡',
        condition: (state) => (state.stats?.bossLateRoundDefeats || 0) >= 1000,
        reward: { bossHpPct: 0.05 },
        icon: 'ğŸ§˜'
    },

    // âœ… æ–°å¢ï¼šæˆ‘é‡ç”Ÿäº†ç³»åˆ—ï¼ˆç´¯è®¡é‡ç”Ÿæ¬¡æ•°ï¼‰
    reborn_1: {
        id: 'reborn_1',
        name: 'æˆ‘é‡ç”Ÿäº†â… ',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°10æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 10,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_2: {
        id: 'reborn_2',
        name: 'æˆ‘é‡ç”Ÿäº†â…¡',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°20æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 20,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_3: {
        id: 'reborn_3',
        name: 'æˆ‘é‡ç”Ÿäº†â…¢',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°50æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 50,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_4: {
        id: 'reborn_4',
        name: 'æˆ‘é‡ç”Ÿäº†â…£',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°100æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 100,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_5: {
        id: 'reborn_5',
        name: 'æˆ‘é‡ç”Ÿäº†â…¤',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°200æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 200,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_6: {
        id: 'reborn_6',
        name: 'æˆ‘é‡ç”Ÿäº†â…¥',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°500æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 500,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_7: {
        id: 'reborn_7',
        name: 'æˆ‘é‡ç”Ÿäº†â…¦',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°1000æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 1000,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_8: {
        id: 'reborn_8',
        name: 'æˆ‘é‡ç”Ÿäº†â…§',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°2000æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 2000,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_9: {
        id: 'reborn_9',
        name: 'æˆ‘é‡ç”Ÿäº†â…¨',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°5000æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 5000,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_10: {
        id: 'reborn_10',
        name: 'æˆ‘é‡ç”Ÿäº†â…©',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°10000æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 10000,
        reward: { goldBonus: 0.50 },
        icon: 'â™»ï¸'
    },

    // âœ… æ–°å¢ï¼šä½ä¿åˆé»‘äº†ç³»åˆ—ï¼ˆç´¯è®¡é¢†å–å®ä¼Ÿå®åº“å¥–åŠ±æ¬¡æ•°ï¼‰
    low_welfare_1: {
        id: 'low_welfare_1',
        name: 'ä½ä¿åˆé»‘äº†â… ',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±1æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 1,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_2: {
        id: 'low_welfare_2',
        name: 'ä½ä¿åˆé»‘äº†â…¡',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±5æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 5,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_3: {
        id: 'low_welfare_3',
        name: 'ä½ä¿åˆé»‘äº†â…¢',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±10æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 10,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_4: {
        id: 'low_welfare_4',
        name: 'ä½ä¿åˆé»‘äº†â…£',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±20æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 20,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_5: {
        id: 'low_welfare_5',
        name: 'ä½ä¿åˆé»‘äº†â…¤',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±50æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 50,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_6: {
        id: 'low_welfare_6',
        name: 'ä½ä¿åˆé»‘äº†â…¥',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±100æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 100,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_7: {
        id: 'low_welfare_7',
        name: 'ä½ä¿åˆé»‘äº†â…¦',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±200æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 200,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_8: {
        id: 'low_welfare_8',
        name: 'ä½ä¿åˆé»‘äº†â…§',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±500æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 500,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_9: {
        id: 'low_welfare_9',
        name: 'ä½ä¿åˆé»‘äº†â…¨',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±1000æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 1000,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_10: {
        id: 'low_welfare_10',
        name: 'ä½ä¿åˆé»‘äº†â…©',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±2000æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 2000,
        reward: { expBonus: 0.20 },
        icon: 'ğŸ¦'
    },
};

const WORLD_BOSSES = {
    hogger: { id: 'hogger', name: 'éœæ ¼',icon:'icons/wow/vanilla/boss/hogger.png', hp: 18000, attack: 150, defense: 70, rewards: { gold: 5000, exp: 5500 } },
    vancleef: { id: 'vancleef', name: 'è‰¾å¾·æ¸©Â·èŒƒå…‹é‡Œå¤«', icon: 'icons/wow/vanilla/boss/vancleef.png', hp: 140000, attack: 550, defense: 350, rewards: { gold: 25000, exp: 19800 }, unlockLevel: 30 },
    prestor_lady: {
        id: 'prestor_lady',
        name: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
        icon: 'icons/wow/vanilla/boss/prestor_lady.jpg', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 800000,
        attack: 1500,
        defense: 800,
        rewards: { gold: 100000, exp: 80000 },
        // ç‰¹æ®Šè§£é”æ¡ä»¶ï¼šéœ€è¦ä½¿ç”¨ã€é»‘é¾™åŒ–èº«çš„è¯æ˜ã€‘ç‰©å“
        unlockCondition: {
            requireItem: 'IT_BLACK_DRAGON_PROOF'
        }
    },
    thalnos: {
        id: 'thalnos',
        name: 'è£‚é­‚è€…è¨å°”è¯ºæ–¯',
        icon: 'icons/wow/vanilla/boss/thalnos.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 1000000,
        attack: 1800,
        defense: 750,
        rewards: { gold: 120000, exp: 95000 },
        unlockLevel: 50
    },

    // âœ… æ–°å¢ï¼š50çº§ä¸–ç•Œé¦–é¢† - è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸
    dagran_thaurissan: {
        id: 'dagran_thaurissan',
        name: 'è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸',
        icon: 'icons/wow/vanilla/boss/dagran_thaurissan.png',
        hp: 1500000,
        attack: 3000,
        defense: 1000,
        rewards: { gold: 300000, exp: 165000 },
        unlockLevel: 50
    },

// âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - é»‘æš—é™¢é•¿åŠ ä¸
    darkmaster_gandling: {
        id: 'darkmaster_gandling',
        name: 'é»‘æš—é™¢é•¿åŠ ä¸',
        icon: 'icons/wow/vanilla/boss/darkmaster_gandling.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 2200000,
        attack: 3600,
        defense: 1200,
        rewards: { gold: 450000, exp: 240000 },
        unlockLevel: 60
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - ç‘æ–‡æˆ´å°”ç”·çˆµï¼ˆæ–¯å¦ç´¢å§†ï¼‰
    baron_rivendare: {
        id: 'baron_rivendare',
        name: 'ç‘æ–‡æˆ´å°”ç”·çˆµ',
        icon: 'icons/wow/vanilla/boss/baron_rivendare.png',
        hp: 2600000,
        attack: 4000,
        defense: 1350,
        rewards: { gold: 550000, exp: 300000 },
        unlockLevel: 60
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - é›·å¾·Â·é»‘æ‰‹ï¼ˆé»‘çŸ³å¡”ä¸Šï¼‰
    rend_blackhand: {
        id: 'rend_blackhand',
        name: 'é›·å¾·Â·é»‘æ‰‹',
        icon: 'icons/wow/vanilla/boss/rend_blackhand.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 3000000,
        attack: 4000,
        defense: 1400,
        rewards: { gold: 580000, exp: 350000 },
        unlockLevel: 60
    },



};

// è£…å¤‡æ§½ä½å®šä¹‰
const EQUIPMENT_SLOTS = {
    head: { name: 'å¤´éƒ¨', icon: 'â›‘ï¸' },
    neck: { name: 'é¡¹é“¾', icon: 'ğŸ“¿' },
    shoulder: { name: 'è‚©è†€', icon: 'ğŸ½' },
    cloak: { name: 'æŠ«é£', icon: 'ğŸ§¥' },
    chest: { name: 'èƒ¸ç”²', icon: 'ğŸ›¡ï¸' },
    wrist: { name: 'æ‰‹è…•', icon: 'âŒš' },
    hands: { name: 'æ‰‹å¥—', icon: 'ğŸ§¤' },
    belt: { name: 'è…°å¸¦', icon: 'ğŸ§·' },
    legs: { name: 'è…¿éƒ¨', icon: 'ğŸ‘–' },
    feet: { name: 'é‹å­', icon: 'ğŸ‘¢' },
    ring1: { name: 'æˆ’æŒ‡1', icon: 'ğŸ’' },
    ring2: { name: 'æˆ’æŒ‡2', icon: 'ğŸ’' },
    trinket1: { name: 'é¥°å“1', icon: 'âœ¨' },
    trinket2: { name: 'é¥°å“2', icon: 'âœ¨' },
    mainHand: { name: 'ä¸»æ‰‹', icon: 'âš”ï¸' },
    offHand: { name: 'å‰¯æ‰‹', icon: 'ğŸ›¡ï¸' }
};

const SET_BONUSES = {
    beginner_set: {
        name: 'åˆå¿ƒè€…å¥—è£…',
        tiers: [
            { count: 2, bonus: { expBonus: 0.20 } },
        ]
    },
    traveler_set: {
        name: 'æ—…è¡Œè€…å¥—è£…',
        tiers: [
            {
                count: 6,
                bonus: {
                    expBonus: 0.40
                }
            }
        ]
    },venom_embrace: {
        name: 'æ¯’è›‡çš„æ‹¥æŠ±',
        tiers: [
            { count: 3, bonus: { versatility: 10 } },
            { count: 6, bonus: { critRate: 10, critDamage: 0.30 } }  // 10%çˆ†å‡»ç‡ + 30%æš´å‡»ä¼¤å®³
        ]
    },scarlet_crusader: {
        name: 'è¡€è‰²åå­—å†›',
        tiers: [
            { count: 3, bonus: { armor: 100, blockValue: 50 } },
            { count: 6, bonus: { hp: 1000, blockRate: 5 } }
        ]
    },hogger_gather_set: {
        name: 'éœæ ¼çš„æˆ˜åˆ©å“',
        tiers: [
            { count: 3, bonus: { gatherEfficiency: 0.15 } }  // 3ä»¶å¥—é¢å¤–+15%é‡‡é›†æ•ˆç‡
        ]

    },
    valor_set: {
        name: 'å‹‡æ°”',
        tiers: [
            { count: 2, bonus: { hp: 500, armor: 80, mastery: 10 } },
            { count: 4, bonus: { blockRate: 5, blockValue: 300 } },
            { count: 8, bonus: { hp: 2000, attack:500 } }
        ]
    },
    swiftshadow_set: {
        name: 'è¿…å½±',
        tiers: [
            { count: 2, bonus: { attack: 200, haste: 10 } },
            { count: 4, bonus: { critRate: 10, critDamage: 0.30 } },
            { count: 8, bonus: { hp: 1000, versatility:20 } }
        ]
    },
    devout_set: {
        name: 'è™”è¯š',
        tiers: [
            { count: 2, bonus: { spellPower: 250, mastery: 10 } },
            { count: 4, bonus: { hp: 800, versatility: 15 } },
            { count: 8, bonus: { hp: 1500, spellPower:500 } }
        ]
    },
    scholar_set: {
        name: 'åšå­¦è€…',
        tiers: [
            { count: 2, bonus: { spellPower: 250, versatility: 10 } },
            { count: 4, bonus: { critRate: 10, mastery: 15 } },
            { count: 8, bonus: { hp: 1000, versatility:20 } }
        ]
    }
};

// ==================== BOSS DATA ====================
const BOSS_DATA = {
    hogger: {
        id: 'hogger',
        name: 'éœæ ¼',
        maxHp: 18000,
        attack: 150,
        defense: 70,
        cycle: ['summon', 'strike', 'strike', 'strike'],
        summonCount: 2,
        heavyMultiplier: 2.5,
        minion: {
            name: 'è±ºç‹¼äººå°å¼Ÿ',
            maxHp: 300,
            attack: 75,
            defense: 20
        },
        rewards: {
            gold: 5000,
            exp: 5500,
            items: [
                { id: 'REBIRTH_INVITATION' },
                { id: 'EQ_HOGGER_001' , chance: 0.15 },  // æ–°å¢ï¼šéœæ ¼çš„æ¯›çš®æŠ«é£
                { id: 'EQ_HOGGER_002' , chance: 0.15 },  // æ–°å¢ï¼šéœæ ¼çš„ç ç‰™å¤´ç›”
                { id: 'EQ_HOGGER_003' , chance: 0.15 },   // æ–°å¢ï¼šéœæ ¼çš„å…½çš®èƒ¸ç”²
                { id: 'IT_HOGGER_BADGE', chance: 0.8 }
            ]
        }
    },
    vancleef: {
        id: 'vancleef',
        name: 'è‰¾å¾·æ¸©Â·èŒƒå…‹é‡Œå¤«',
        maxHp: 140000,
        attack: 550,
        defense: 350,
        // æŠ€èƒ½å¾ªç¯ï¼šè‡´æ­»æ‰“å‡» â†’ ç«ç‚®æ‰‹å‡†å¤‡ â†’ è‡´æ­»æ‰“å‡» â†’ ç™»ä¸Šç”²æ¿
        cycle: ['mortal_strike', 'summon_cannoneers', 'mortal_strike', 'board_the_deck'],
        // è‡´æ­»æ‰“å‡»ï¼š3å€æ”»å‡»
        mortalStrikeMultiplier: 3,
        // è‡´æ­»æ‰“å‡»debuffï¼šå‡ç–—50%æŒç»­2å›åˆ
        mortalStrikeDebuff: {
            healingReduction: 0.5,
            duration: 2
        },
        // ç«ç‚®æ‰‹é…ç½®
        minion: {
            name: 'è¿ªè²äºšç«ç‚®æ‰‹',
            maxHp: 600,
            attack: 0, // ç«ç‚®æ‰‹ä¸æ™®æ”»ï¼ŒåªAOE
            defense: 300,
            aoeDamageMultiplier: 0.7 // å¯¹å…¨é˜Ÿé€ æˆbossæ”»å‡»Ã—0.7çš„ä¼¤å®³
        },
        summonCount: 3,
        rewards: {
            gold: 25000,
            exp: 19800,
            items: [
                { id: 'IT_VANCLEEF_BADGE', chance: 0.8 },
                { id: 'EQ_VANCLEEF_001' , chance: 0.25 },
            ]
        }
    },
    prestor_lady: {
        id: 'prestor_lady',
        name: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
        maxHp: 800000,
        attack: 1500,
        defense: 800,
        // æŠ€èƒ½å¾ªç¯ï¼šè°æŠ¥ â†’ é»‘é¾™ä¹‹ç‚ â†’ å°–ç‰™ä¸åˆ©çˆª â†’ æ™®é€šæ”»å‡»
        cycle: ['espionage', 'black_dragon_flame', 'fangs_and_claws', 'normal_attack'],
        // è°æŠ¥ï¼šæ€»å…±10å€æ”»å‡»çš„æš—å½±ä¼¤å®³ï¼Œåˆ†æ•£ç«™ä½åªæ‰“å¦å…‹
        espionageDamageMultiplier: 10,
        // é»‘é¾™ä¹‹ç‚ï¼šæ¯å±‚DOT 0.2å€æ”»å‡»
        blackFlameDoTMultiplier: 0.2,
        // å°–ç‰™ä¸åˆ©çˆªï¼š3å€æ”»å‡» + æµè¡€DOT
        fangsMultiplier: 3,
        bleedDoTMultiplier: 0.8,
        bleedDuration: 3,
        rewards: {
            gold: 100000,
            exp: 80000,
            items: [
                // å¯ä»¥æ·»åŠ é»‘é¾™ä¸»é¢˜ç´«è£…æ‰è½
                { id: 'IT_PRESTOR_BADGE', chance: 0.8 }
            ]
        }
    },
    thalnos: {
        id: 'thalnos',
        name: 'è£‚é­‚è€…è¨å°”è¯ºæ–¯',
        maxHp: 1000000,
        attack: 1800,
        defense: 750,
        // æŠ€èƒ½å¾ªç¯ï¼šçµé­‚å¼ºé£ â†’ å •è½çš„åå­—å†› â†’ æ”¾é€çµé­‚ â†’ çµé­‚æ”¶å‰²è€…
        cycle: ['soul_storm', 'fallen_crusaders', 'banish_soul', 'soul_reaper'],

        // çµé­‚å¼ºé£ï¼šæ”»å‡»Ã—1.5ä¼¤å®³ + DOTï¼ˆæ¯å›åˆæ”»å‡»Ã—1.5ï¼ŒæŒç»­3å›åˆï¼‰
        soulStormMultiplier: 1.5,
        soulStormDoTMultiplier: 1.5,
        soulStormDoTDuration: 3,

        // æ”¾é€çµé­‚ï¼šæ”»å‡»Ã—4ä¼¤å®³ + ææƒ§3å›åˆ
        banishSoulMultiplier: 4,
        fearDuration: 2,

        // å •è½çš„åå­—å†›é…ç½®
        minion: {
            name: 'å •è½åå­—å†›',
            maxHp: 20000,
            attack: 1800, // ç­‰äºbossæ”»å‡»
            defense: 750
        },
        summonCount: 5,
        // çµé­‚æ”¶å‰²è€…ï¼š(åå­—å†›æ•°é‡+3) Ã— bossæ”»å‡» çš„æš—å½±ä¼¤å®³
        soulReaperBaseMultiplier: 1.5, // åŸºç¡€å€ç‡ï¼ˆæ— åå­—å†›æ—¶ï¼‰

        rewards: {
            gold: 130000,
            exp: 105000,
            items: [
                // âœ… è¨å°”è¯ºæ–¯ä¸“å±æ‰è½
                { id: 'IT_SCARLET_CRUSADER_BADGE', chance: 0.8 }
            ]
        }
    },

    // âœ… æ–°å¢ï¼šè¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸ï¼ˆç«ç„° / ç‰©ç†æ··åˆï¼‰
    dagran_thaurissan: {
        id: 'dagran_thaurissan',
        name: 'è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸',
        maxHp: 1500000,
        attack: 3000,
        defense: 1000,

        // æŠ€èƒ½å¾ªç¯ï¼šçƒˆç„°æ‰“å‡» â†’ ç†”å²©çˆ†è£‚ â†’ çƒˆç„°æ‰“å‡» â†’ æˆ˜æ–—æ€’å¼
        cycle: ['flame_strike', 'lava_burst', 'flame_strike', 'battle_shout'],

        // çƒˆç„°æ‰“å‡»ï¼šå¯¹å¦å…‹é€ æˆ 3Ã—ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—ï¼‰+ 3Ã—ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡ï¼‰
        flameStrikeFireMultiplier: 3,
        flameStrikePhysicalMultiplier: 5,

        // ç†”å²©çˆ†è£‚ï¼šéšæœºç›®æ ‡ 2Ã—ç«ç„°ä¼¤å®³ï¼Œå¹¶ç•™ä¸‹ç¼çƒ§DOTï¼ˆ1.5Ã—æ”»å‡»ï¼ŒæŒç»­3å›åˆï¼‰
        lavaBurstMultiplier: 2,
        burnDoTMultiplier: 1.5,
        burnDoTDuration: 3,

        // æˆ˜æ–—æ€’å¼ï¼šæœ¬åœºæˆ˜æ–—BOSSæ”»å‡» +10%ï¼Œå¯å åŠ 
        battleShoutAttackPct: 0.10,

        rewards: {
            gold: 300000,
            exp: 165000,
            items: [
                { id: 'IT_THAURISSAN_BADGE', chance: 0.8 }
            ]
        }
    },

// âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - é»‘æš—é™¢é•¿åŠ ä¸ï¼ˆé€šçµå­¦é™¢ï¼‰
    darkmaster_gandling: {
        id: 'darkmaster_gandling',
        name: 'é»‘æš—é™¢é•¿åŠ ä¸',
        maxHp: 2200000,
        attack: 3600,
        defense: 1200,

        // æŠ€èƒ½å¾ªç¯ï¼šæš—å½±ç®­ â†’ å¬å”¤äº¡çµå­¦å¾’ â†’ æš—å½±è¯…å’’ â†’ é»‘æš—é£æš´
        cycle: ['shadow_bolt', 'summon_apprentices', 'shadow_curse', 'dark_storm'],

        // æš—å½±ç®­ï¼šå¯¹å¦å…‹é€ æˆ 5 Ã— Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
        shadowBoltMultiplier: 5,

        // é»‘æš—é£æš´ï¼š3 Ã— Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ˆåˆ†æ•£ï¼šéšæœºå•ä½“ï¼›é›†ä¸­ï¼šå…¨ä½“ï¼‰
        darkStormMultiplier: 3,

        // æš—å½±è¯…å’’ï¼šç›®æ ‡é­”æ³•æŠ—æ€§é™ä½ 100ï¼ŒæŒç»­ 4 å›åˆï¼ˆå…è®¸ä¸ºè´Ÿï¼ŒæŒ‰ magicresist_k å…¬å¼å¢ä¼¤ï¼‰
        shadowCurseMagicResistDown: 100,
        shadowCurseDuration: 4,

        // äº¡çµå­¦å¾’ï¼šå¬å”¤ 2 ä¸ªï¼Œæ”»å‡»/é˜²å¾¡ä¸Bossç›¸åŒï¼Œè¡€é‡ 20ä¸‡ï¼›æ¯å›åˆéšæœºé‡Šæ”¾æš—å½±ç®­ï¼ˆ2 Ã— Bossæ”»å‡»ï¼‰
        summonCount: 2,
        minion: {
            name: 'äº¡çµå­¦å¾’',
            maxHp: 200000,
            attack: 3600,
            defense: 1200
        },
        minionShadowBoltMultiplier: 2,

        rewards: {
            gold: 450000,
            exp: 240000,
            items: [
                // âœ… æ–°å¢ï¼šT0 å¥—è£…æŠ¤è‚©ï¼ˆæ¯ä»¶ 20%ï¼‰
                { id: 'EQ_113', chance: 0.2 },  // å‹‡æ°”æŠ¤è‚©
                { id: 'EQ_114', chance: 0.2 },  // è¿…å½±æŠ¤è‚©
                { id: 'EQ_115', chance: 0.2 },  // è™”è¯šæŠ¤è‚©
                { id: 'EQ_116', chance: 0.2 },  // åšå­¦è€…æŠ¤è‚©
                { id: 'IT_GANDLING_BADGE', chance: 0.8 }
            ]
        }
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - ç‘æ–‡æˆ´å°”ç”·çˆµï¼ˆæ–¯å¦ç´¢å§†ï¼‰
    baron_rivendare: {
        id: 'baron_rivendare',
        name: 'ç‘æ–‡æˆ´å°”ç”·çˆµ',
        maxHp: 2600000,
        attack: 4000,
        defense: 1350,

        // æŠ€èƒ½å¾ªç¯ï¼šé¡ºåŠˆæ–© â†’ è‡´æ­»æ‰“å‡» â†’ å¬å”¤éª·é«…å¤§å†› â†’ æš—å½±éœ‡å‡»
        cycle: ['cleave', 'mortal_strike', 'summon_skeleton_army', 'shadow_shock'],

        // é¡ºåŠˆæ–©ï¼šåˆ†æ•£ç«™ä½æ‰“å¦å…‹ / é›†ä¸­ç«™ä½æ‰“å…¨ä½“ï¼ˆ5Ã—æ”»å‡»ï¼Œç‰©ç†ï¼Œå¯æ ¼æŒ¡/æŠ¤ç”²ï¼‰
        cleaveMultiplier: 5,

        // è‡´æ­»æ‰“å‡»ï¼š4Ã—æ”»å‡»ï¼ˆç‰©ç†ï¼‰+ å‡ç–—50% debuffï¼ˆå‚è€ƒèŒƒå…‹é‡Œå¤«ï¼‰
        mortalStrikeMultiplier: 4,
        mortalStrikeDebuff: {
            healingReduction: 0.5,
            duration: 2
        },

        // æš—å½±éœ‡å‡»ï¼š3Ã—æ”»å‡»æš—å½±ä¼¤å®³ + DOTï¼ˆæ¯å›åˆ1.5Ã—æ”»å‡»ï¼ŒæŒç»­3å›åˆï¼‰
        shadowShockMultiplier: 3,
        shadowShockDotMultiplier: 1.5,
        shadowShockDotDuration: 3,

        // å¬å”¤éª·é«…å¤§å†›ï¼šå¬å”¤5ä¸ªéª·é«…ï¼Œå¯¹å¦å…‹æŒ¥ç ï¼ˆ1.2Ã—æ”»å‡»ï¼Œç‰©ç†ï¼‰
        summonCount: 5,
        skeletonSlashMultiplier: 1.2,
        minion: {
            name: 'éª·é«…æˆ˜å£«',
            maxHp: 180000,
            attack: 4000,
            defense: 1100
        },

        rewards: {
            gold: 550000,
            exp: 300000,
            items: [
                // âœ… æ–°å¢ï¼šT0 å¥—è£…æˆ˜é´/ä¾¿é‹ï¼ˆæ¯ä»¶ 20%ï¼‰
                { id: 'EQ_117', chance: 0.2 },  // å‹‡æ°”æˆ˜é´
                { id: 'EQ_118', chance: 0.2 },  // è¿…å½±æˆ˜é´
                { id: 'EQ_119', chance: 0.2 },  // è™”è¯šä¾¿é‹
                { id: 'EQ_120', chance: 0.2 },  // åšå­¦è€…ä¾¿é‹
                { id: 'IT_RIVENDARE_BADGE', chance: 0.8 }
            ]
        }
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - é›·å¾·Â·é»‘æ‰‹ï¼ˆé»‘çŸ³å¡”ä¸Šï¼‰
    rend_blackhand: {
        id: 'rend_blackhand',
        name: 'é›·å¾·Â·é»‘æ‰‹',
        maxHp: 3000000,
        attack: 4000,
        defense: 1400,

        // æŠ€èƒ½å¾ªç¯ï¼šçƒˆç„°åæ¯ â†’ é¡ºåŠˆæ–© â†’ çƒˆç„°åæ¯ â†’ è·³è·ƒæ–©å‡»
        cycle: ['flame_breath', 'cleave', 'flame_breath', 'leap_slash'],

        // çƒˆç„°åæ¯ï¼šå¯¹å¦å…‹ 4Ã—æ”»å‡» ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡ï¼‰
        // å¹¶å¯¹å…¨é˜Ÿè¿½åŠ ä¸€æ¬¡â€œå¦å…‹å®é™…æ‰¿ä¼¤â€çš„ç«ç„°ä¼¤å®³ï¼ˆè®¡ç®—å„è‡ªé­”æŠ—ï¼‰
        flameBreathMultiplier: 4,

        // é¡ºåŠˆæ–©ï¼šåˆ†æ•£=æ‰“å¦å…‹ï¼›é›†ä¸­=æ‰“å…¨ä½“ï¼ˆ2Ã—æ”»å‡»ï¼Œç‰©ç†ï¼Œå¯æ ¼æŒ¡/æŠ¤ç”²ï¼‰
        cleaveMultiplier: 2,

        // è·³è·ƒæ–©å‡»ï¼šé›†ä¸­=æ‰“å¦å…‹ï¼›åˆ†æ•£=éšæœºéå¦å…‹ï¼ˆ4Ã—æ”»å‡»ï¼Œç‰©ç†ï¼Œå¯æ ¼æŒ¡/æŠ¤ç”²ï¼‰
        leapSlashMultiplier: 4,

        rewards: {
            gold: 580000,
            exp: 350000,
            items: [
                // âœ… æ–°å¢ï¼šT0 å¥—è£…æŠ¤è…•/è£¹è…•ï¼ˆæ¯ä»¶ 20%ï¼‰
                { id: 'EQ_121', chance: 0.2 },  // å‹‡æ°”æŠ¤è…•
                { id: 'EQ_122', chance: 0.2 },  // è¿…å½±æŠ¤è…•
                { id: 'EQ_123', chance: 0.2 },  // è™”è¯šè£¹è…•
                { id: 'EQ_124', chance: 0.2 },  // åšå­¦è€…è£¹è…•
                { id: 'IT_REND_BADGE', chance: 0.8 }
            ]
        }
    }

};

// ==================== ç¾ç»Šåç§°æ˜ å°„ ====================
const BOND_NAMES = {
    baoernai: 'åŒ…äºŒå¥¶',
    jianyue: 'ç®€çº¦è€Œä¸ç®€å•'
};

// ==================== UTILS ====================
function formatItemStatValue(stat, valueRaw) {
    const v = Number(valueRaw) || 0;

    const percentStats = new Set(['critRate', 'blockRate']);

    if (percentStats.has(stat)) {
        return `${(v).toFixed(1)}%`;
    }

    if (stat === 'critDamage') {
        return v <= 1
            ? `${Math.floor(v * 100)}%`
            : `${Math.floor(v)}`;
    }

    return `${Math.floor(v)}`;
}


function mergeEquipments(eqA, eqB) {
    if (eqA.id !== eqB.id) return null;

    const newLevel = Math.min(100, (eqA.currentLevel || 0) + (eqB.currentLevel || 0) + 1);

    return {
        ...eqA,
        currentLevel: newLevel,
        stats: scaleStats(eqA.baseStats, eqA.growth, newLevel)
    };
}


function getEquipmentTemplate(templateId) {
    // å¸¸è§„æ‰è½è£…å¤‡ï¼šFIXED_EQUIPMENTS
    // ä»»åŠ¡/å‰§æƒ…å¥–åŠ±è£…å¤‡ï¼šQUEST_REWARD_EQUIPMENTS
    return FIXED_EQUIPMENTS?.[templateId] || QUEST_REWARD_EQUIPMENTS?.[templateId];
}

function createEquipmentInstance(templateId) {
    const tpl = getEquipmentTemplate(templateId);

    if (!tpl) {
        console.error(`[createEquipmentInstance] è£…å¤‡æ¨¡æ¿ä¸å­˜åœ¨: ${templateId}`);
        return null;
    }

    const level = Number.isFinite(Number(tpl.level)) ? Number(tpl.level) : 0;

    return {
        ...tpl,
        instanceId: `eq_${Date.now()}_${Math.random()}`,
        qualityColor: getRarityColor(tpl.rarity),
        currentLevel: level,
        stats: scaleStats(tpl.baseStats || {}, tpl.growth || {}, level)
    };
}

function getSetBonusesForCharacter(character) {
    // character.equipment: { weapon, armor, ... } æ¯ä¸ª slot å¯èƒ½æ˜¯ null æˆ–è£…å¤‡å®ä¾‹
    const eqList = Object.values(character.equipment || {}).filter(Boolean);
    if (eqList.length === 0) return [];

    // ç»Ÿè®¡å¥—è£… id / åç§°ï¼ˆæ ¹æ®ä½ è£…å¤‡æ•°æ®ç»“æ„æ”¹å­—æ®µåï¼‰
    // è¿™é‡Œä¼˜å…ˆç”¨ setId / setNameï¼Œå¦‚æœä½ æ˜¯ç”¨ tpl.set å°±æ”¹ä¸€ä¸‹
    const countBySet = new Map(); // setId -> { setId, setName, count }
    for (const eq of eqList) {
        const setId = eq.setId || eq.set || null;
        const setName = eq.setName || eq.set || eq.setId || null;
        if (!setId) continue;

        const prev = countBySet.get(setId) || { setId, setName, count: 0 };
        prev.count += 1;
        countBySet.set(setId, prev);
    }

    // ä½ çš„å¥—è£…è§„åˆ™è¡¨ï¼šSET_BONUSESï¼ˆä½ å¯ä»¥è‡ªå·±å®šä¹‰ï¼‰
    // ä¾‹ï¼š
    // const SET_BONUSES = {
    //   wolf: { name:'ç‹¼ç‹', tiers:[ {count:2, bonus:{atkPct:0.1}}, {count:4, bonus:{hpPct:0.15}} ] }
    // }
    if (typeof SET_BONUSES === 'undefined') return []; // å…¼å®¹ä½ ç›®å‰è¿˜æ²¡åŠ  set è¡¨

    const active = [];
    for (const { setId, setName, count } of countBySet.values()) {
        const def = SET_BONUSES[setId];
        if (!def) continue;

        // æ‰¾åˆ°å·²æ¿€æ´»çš„ tier
        const tiers = Array.isArray(def.tiers) ? def.tiers : [];
        const activated = tiers.filter(t => count >= t.count);

        if (activated.length > 0) {
            active.push({
                setId,
                name: def.name || setName || setId,
                count,
                activated,
            });
        }
    }

    // å›ºå®šæ’åºï¼šæ¿€æ´»å¤šçš„åœ¨å‰
    active.sort((a, b) => (b.activated.length - a.activated.length) || (b.count - a.count));
    return active;
}

function formatBonusText(bonusObj) {
    const entries = Object.entries(bonusObj || {});
    if (entries.length === 0) return '';

    const nameMap = {
        atkPct: 'æ”»å‡»',
        hpPct: 'ç”Ÿå‘½',
        bossHpPct: 'BOSSæˆ˜æ–—ç”Ÿå‘½',
        expBonus: 'ç»éªŒå€¼å¢å¹…',
        goldBonus: 'é‡‘å¸å¢å¹…',
        dropBonus: 'æ‰è½å¢å¹…',
        resourceBonus: 'æ‰€æœ‰å»ºç­‘äº§é‡',
        mapDamageBonus: 'åœ°å›¾æˆ˜æ–—ä¼¤å®³',
        versatility: 'å…¨èƒ½',
    };

    return entries.map(([k, v]) => {
        if (typeof v === 'number') {
            // æ˜ç¡®æŒ‰ç™¾åˆ†æ¯”å±•ç¤ºçš„å­—æ®µ
            if (k.endsWith('Pct') || k === 'expBonus' || k === 'goldBonus' || k === 'dropBonus' || k === 'resourceBonus' || k === 'mapDamageBonus') {
                return `${nameMap[k] || k} +${Math.round(v * 100)}%`;
            }
            return `${nameMap[k] || k} +${v}`;
        }
        return `${nameMap[k] || k} +${String(v)}`;
    }).join('ï¼Œ');
}



function formatStatForDisplay(stat, value) {
    if (stat === 'critRate' || stat === 'blockRate' || stat === 'expBonus') {
        return `${Math.floor(value * 100)}%`;
    }
    return Math.floor(value);
}

// åœ°å›¾ç´¯è®¡å‡»æ€æ•°ï¼ˆè·¨åŒºåŸŸç´¯è®¡ï¼‰ï¼šç”¨äºæˆå°±ã€æŒç»­æˆ˜æ–—â… ~â…©ã€‘ç­‰
function getTotalMapKills(state) {
    const counts = (state?.zoneKillCounts && typeof state.zoneKillCounts === 'object' && !Array.isArray(state.zoneKillCounts))
        ? state.zoneKillCounts
        : {};

    return Object.values(counts).reduce((sum, v) => sum + (Math.max(0, Math.floor(Number(v) || 0))), 0);
}

// ä¸»åŸç´¯è®¡å»ºç­‘å»ºé€ æ•°ï¼šç”¨äºæˆå°±ã€å»ºè®¾è€…â… ~â…©ã€‘ç­‰
// è¯´æ˜ï¼šå…¼å®¹æ—§ç³»ç»Ÿï¼ˆstate.buildingsï¼‰ä¸æ–°ç³»ç»Ÿï¼ˆstate.functionalBuildingsï¼‰
function getTotalBuildingsBuilt(state) {
    const buildings = (state?.buildings && typeof state.buildings === 'object' && !Array.isArray(state.buildings))
        ? state.buildings
        : {};
    const functional = (state?.functionalBuildings && typeof state.functionalBuildings === 'object' && !Array.isArray(state.functionalBuildings))
        ? state.functionalBuildings
        : {};

    const sumObj = (obj) => Object.values(obj).reduce((sum, v) => sum + Math.max(0, Math.floor(Number(v) || 0)), 0);
    return sumObj(buildings) + sumObj(functional);
}

// ä¸–ç•Œé¦–é¢†ç´¯è®¡å‡»æ€æ•°ï¼ˆè·¨ä¸–ç´¯è®¡ï¼‰ï¼šç”¨äºæˆå°±ã€é¦–é¢†æ€æ‰‹â… ~â…©ã€‘ç­‰
function getTotalWorldBossKills(state) {
    const counts = (state?.worldBossKillCounts && typeof state.worldBossKillCounts === 'object' && !Array.isArray(state.worldBossKillCounts))
        ? state.worldBossKillCounts
        : {};

    return Object.values(counts).reduce((sum, v) => sum + Math.max(0, Math.floor(Number(v) || 0)), 0);
}


// âœ… æˆå°±ï¼šå…¨é˜Ÿç”Ÿå‘½ç™¾åˆ†æ¯”åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
function getAchievementHpPctBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.hpPct) {
            bonus += Number(a.reward.hpPct) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.02 = +2%
}

// âœ… æˆå°±ï¼šä»…BOSSæˆ˜æ–—ç”Ÿå‘½ç™¾åˆ†æ¯”åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
// è¯´æ˜ï¼šåªåœ¨ BOSS æˆ˜æ–—åˆå§‹åŒ–æ—¶åº”ç”¨ï¼ˆè§ START_BOSS_COMBATï¼‰
function getAchievementBossHpPctBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.bossHpPct) {
            bonus += Number(a.reward.bossHpPct) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.05 = +5%
}

// âœ… æˆå°±ï¼šå…¨é˜Ÿç»éªŒè·å–åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
function getAchievementExpBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.expBonus) {
            bonus += Number(a.reward.expBonus) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.02 = +2%
}

// âœ… æˆå°±ï¼šé‡‘å¸è·å–åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
function getAchievementGoldBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.goldBonus) {
            bonus += Number(a.reward.goldBonus) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.05 = +5%
}

// âœ… æ€»é‡‘å¸è·å–åŠ æˆï¼šæˆå°±é‡‘å¸å¢å¹… + è½®å›é‡‘å¸å¢å¹…ï¼ˆåŠ æ³•å åŠ ï¼‰
function getTotalGoldBonus(state) {
    const ach = Number(getAchievementGoldBonus(state)) || 0;
    const rebirth = Number(state?.rebirthBonuses?.gold) || 0;
    return Math.max(0, ach + rebirth);
}

// åŸºç¡€é‡‘å¸ baseGoldï¼Œåº”ç”¨é‡‘å¸è·å–åŠ æˆï¼šeffective = floor(baseGold * (1 + bonus))
function getEffectiveGoldGain(baseGold, state) {
    const base = Number(baseGold) || 0;
    if (base <= 0) return 0;
    const bonus = getTotalGoldBonus(state);
    if (!Number.isFinite(bonus) || bonus <= 0) return Math.floor(base);
    return Math.floor(base * (1 + bonus));
}


function getAchievementDropBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.dropBonus) {
            bonus += a.reward.dropBonus;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.05 = +5%
}

// âœ… åŠŸèƒ½å»ºç­‘ï¼šå¯»é¾™ä¼šæ‰è½åŠ æˆï¼ˆæ¯çº§+5%ï¼Œ20çº§=+100%ï¼‰
function getDragonSeekersGuildDropBonus(state) {
    const level = Math.max(0, Math.floor(Number(state?.functionalBuildings?.dragon_seekers_guild) || 0));
    // æ¯çº§ +5% æ‰è½æ¦‚ç‡ï¼ˆçº¿æ€§ï¼‰ï¼Œæœ€å¤š +100%
    return Math.min(1, level * 0.05);
}

// âœ… æ€»æ‰è½åŠ æˆï¼šæˆå°±æ‰è½å¢å¹… + å¯»é¾™ä¼šæ‰è½å¢å¹…
// è§„åˆ™ï¼šå°†å„æ¥æºçš„â€œæ‰è½å¢å¹…â€å…ˆçº¿æ€§ç›¸åŠ ï¼Œå†ä½œç”¨åˆ°åŸºç¡€æ¦‚ç‡ï¼šeffective = base * (1 + bonus)ï¼Œæœ€åå°é¡¶ 100%
function getTotalDropBonus(state) {
    const ach = Number(getAchievementDropBonus(state)) || 0;
    const guild = Number(getDragonSeekersGuildDropBonus(state)) || 0;
    return Math.max(0, ach + guild);
}

// åŸºç¡€æ¦‚ç‡ baseChanceï¼ˆ0~1ï¼‰ï¼Œåº”ç”¨æ‰è½åŠ æˆå¹¶å°é¡¶ 1
function getEffectiveDropChance(baseChance, state) {
    const base = Math.max(0, Math.min(1, Number(baseChance) || 0));
    if (base <= 0) return 0;
    const bonus = getTotalDropBonus(state);
    return Math.min(1, base * (1 + bonus));
}

// âœ… æˆå°±ï¼šå»ºç­‘äº§é‡åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
function getAchievementResourceBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.resourceBonus) {
            bonus += Number(a.reward.resourceBonus) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.02 = +2%
}

// âœ… æˆå°±ï¼šåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
// æ³¨æ„ï¼šä¸è£…å¤‡ç‰¹æ•ˆï¼ˆå¦‚ map_slayerï¼‰çš„åŠ æˆå°†åœ¨æˆ˜æ–—è®¡ç®—å¤„â€œä¹˜ç®—â€ï¼ˆè§ getMapDamageDealtMultï¼‰
function getAchievementMapDamageBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.mapDamageBonus) {
            bonus += Number(a.reward.mapDamageBonus) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.05 = +5%
}

// âœ… æˆå°±ï¼šå…¨é˜Ÿå…¨èƒ½åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
function getAchievementVersatilityBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.versatility) {
            bonus += Number(a.reward.versatility) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 2 è¡¨ç¤º +2 å…¨èƒ½
}


function getAchievementMapDamageDealtMult(state) {
    const bonus = getAchievementMapDamageBonus(state);
    if (!Number.isFinite(bonus) || bonus <= 0) return 1;
    return 1 + bonus;
}

function addEquipmentIdToCodex(state, equipmentId) {
    if (!equipmentId) return state;
    const current = Array.isArray(state.codex) ? state.codex : [];
    if (current.includes(equipmentId)) return state;
    return { ...state, codex: [...current, equipmentId] };
}

function addEquipmentIdToLv100Codex(state, equipmentId) {
    if (!equipmentId) return state;
    const cur = Array.isArray(state.codexEquipLv100) ? state.codexEquipLv100 : [];
    if (cur.includes(equipmentId)) return state;
    return { ...state, codexEquipLv100: [...cur, equipmentId] };
}


function addJunkIdToCodex(state, junkId) {
    if (!junkId) return state;
    const current = Array.isArray(state.codexJunk) ? state.codexJunk : [];
    if (current.includes(junkId)) return state;
    return { ...state, codexJunk: [...current, junkId] };
}

function learnNewSkills(character) {
    const classData = CLASSES[character.classId];
    const learned = new Set(character.skills || []);

    // âœ… ç§æ—é¢å¤–æŠ€èƒ½ï¼šéšæ—¶ç¡®ä¿æ‹¥æœ‰ï¼ˆç”¨äºæ—§è§’è‰²è¡¥é½ / æ–°å¢ç§æ—è¢«åŠ¨ï¼‰
    const raceExtraSkills = RACE_TRAITS?.[character.race]?.extraSkills || [];
    raceExtraSkills.forEach(sid => {
        if (sid) learned.add(sid);
    });

    classData.skills.forEach(({ level, skillId }) => {
        if (character.level >= level && !learned.has(skillId)) {
            learned.add(skillId);
        }
    });

    return Array.from(learned);
}

// è®¡ç®—â€œå…¨é˜Ÿå…‰ç¯â€å€ç‡ï¼šåªè¦é˜Ÿé‡Œæœ‰äººç‚¹äº†ï¼Œå°±å…¨é˜Ÿåƒåˆ°
function getPartyAuraMultipliers(characters) {
    let hpMul = 1;
    let spellPowerMul = 1;

    (characters || []).forEach(c => {
        const t = c.talents || {};
        // 30çº§ï¼šçœŸè¨€æœ¯è€ï¼ˆå…¨é˜ŸHP+10%ï¼‰
        if (t[30] === 'pwt') hpMul *= 1.10;

        // 30çº§ï¼šç¥åœ£å¯è¿ªï¼ˆå…¨é˜Ÿæ³•å¼º+5%ï¼‰
        if (t[30] === 'holy_enlight') spellPowerMul *= 1.05;

        // å†°éœœæ³•å¸ˆ40çº§ï¼šå¥¥æœ¯æ™ºæ…§ï¼ˆå…¨é˜Ÿæ³•å¼º+10%ï¼‰
        if (t[40] === 'arcane_intellect') spellPowerMul *= 1.10;
    });

    return { hpMul, spellPowerMul };
}

// ç”¨åŒä¸€å¥—å…‰ç¯å€ç‡ï¼Œé‡ç®—å…¨é˜Ÿ statsï¼ˆå…³é”®ï¼šå…‰ç¯è¦å…¨é˜Ÿä¸€èµ·é‡ç®—ï¼‰
function recalcPartyStats(gameState,characters) {
    const auras = getPartyAuraMultipliers(characters);
    return (characters || []).map(c => {
        const next = { ...c };
        next.stats = calculateTotalStats(next, auras, gameState);
        return next;
    });
}


// è®¡ç®—è§’è‰²æ€»å±æ€§ï¼ˆåŸºç¡€+è£…å¤‡ï¼‰
function calculateTotalStats(character, partyAuras = { hpMul: 1, spellPowerMul: 1 }, gameState) {
    const classData = CLASSES[character.classId];

    // å…ˆç®— max
    let totalStats = {
        hp: classData.baseStats.hp + (character.level - 1) * 10,
        mp: classData.baseStats.mp + (character.level - 1) * 5,
        attack: classData.baseStats.attack + (character.level - 1) * 2,
        spellPower: classData.baseStats.spellPower + (character.level - 1) * 2,
        armor: classData.baseStats.armor + (character.level - 1) * 3,
        magicResist: classData.baseStats.magicResist + (character.level - 1) * 1,
        blockValue: classData.baseStats.blockValue || 0,

        haste: 0,
        critRate: 5,
        critDamage: 2.0,
        mastery: 0,
        versatility: 0,
        blockRate: 0,
        expBonus: 0,

        // å¤©èµ‹/çŠ¶æ€ç”¨ï¼šå—åˆ°ä¼¤å®³ä¹˜åŒºï¼ˆ1=ä¸å˜ï¼Œ0.8=å‡ä¼¤20%ï¼‰
        damageTakenMult: 1
    };

    // ==================== RACE (PASSIVE) ====================
    // ç§æ—è¢«åŠ¨ï¼šç›´æ¥åŠ åˆ°é¢æ¿å±æ€§é‡Œï¼Œåç»­ç²¾é€š/å¤©èµ‹/è£…å¤‡ç­‰ä¼šä¸€èµ·ç»“ç®—
    const raceTrait = RACE_TRAITS?.[character.race];
    if (raceTrait?.statBonus) {
        for (const [k, v] of Object.entries(raceTrait.statBonus)) {
            totalStats[k] = (totalStats[k] || 0) + v;
        }
    }

// âœ… æ—¶é—´æ®µå±æ€§åŠ æˆï¼ˆä¾‹å¦‚ï¼šæš—å¤œç²¾çµã€ç²¾çµç²¾é­„ã€‘ï¼‰
// çº¦å®šï¼šdayStart(å«)~nightStart(ä¸å«) ä¸ºâ€œç™½å¤©â€ï¼Œå…¶ä½™ä¸ºâ€œå¤œæ™šâ€
    if (raceTrait?.timeBasedStatBonus) {
        const cfg = raceTrait.timeBasedStatBonus || {};
        const dayStart = Number.isFinite(Number(cfg.dayStart)) ? Number(cfg.dayStart) : 6;
        const nightStart = Number.isFinite(Number(cfg.nightStart)) ? Number(cfg.nightStart) : 18;

        const hour = new Date().getHours();
        const isDay = dayStart < nightStart
            ? (hour >= dayStart && hour < nightStart)
            : (hour >= dayStart || hour < nightStart);

        const bonus = (isDay ? cfg.dayBonus : cfg.nightBonus) || {};
        if (bonus && typeof bonus === 'object') {
            for (const [k, v] of Object.entries(bonus)) {
                totalStats[k] = (totalStats[k] || 0) + (Number(v) || 0);
            }
        }
    }


    // å¥—è£…åŠ æˆï¼ˆexpBonus / goldBonus / dropBonus ç­‰ï¼‰
    const setBonuses = getSetBonusesForCharacter(character);
    for (const set of setBonuses) {
        for (const tier of set.activated) {
            for (const [k, v] of Object.entries(tier.bonus || {})) {
                totalStats[k] = (totalStats[k] || 0) + v;
            }
        }
    }

    // é‡ç”Ÿå…¨å±€åŠ æˆ
    totalStats.expBonus = (totalStats.expBonus || 0) + (gameState?.rebirthBonuses?.exp || 0);

    // âœ… åŠŸèƒ½å»ºç­‘ï¼šè®­ç»ƒå‡äººç»éªŒåŠ æˆï¼ˆæ¯åº§ +1%ï¼‰
    const trainingCount = Math.max(0, Math.floor(Number(gameState?.functionalBuildings?.training_dummy) || 0));
    if (trainingCount > 0) {
        totalStats.expBonus = (totalStats.expBonus || 0) + trainingCount * 0.01;
    }

    // âœ… æˆå°±ï¼šç»éªŒè·å–åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
    const achExpBonus = getAchievementExpBonus(gameState);
    if (Number.isFinite(achExpBonus) && achExpBonus !== 0) {
        totalStats.expBonus = (totalStats.expBonus || 0) + achExpBonus;
    }

    // ==================== å›¾é‰´ Lv.100 é›†é½åŠ æˆï¼ˆå…¨é˜Ÿæ°¸ä¹…ï¼‰ ====================
    const codexLv100 = Array.isArray(gameState?.codexEquipLv100) ? gameState.codexEquipLv100 : [];
    const codexLv100Set = new Set(codexLv100);

    if (codexLv100Set.size) {
        const addBonus = (bonus = {}) => {
            for (const [k, v] of Object.entries(bonus)) {
                totalStats[k] = (totalStats[k] || 0) + v;
            }
        };

        const codexBonusRules = [
            { ids: REDRIDGE_LV100_SET, bonus: { versatility: 5 } }, // èµ¤è„Šå±±ï¼šå…¨é˜Ÿå…¨èƒ½ +5
            { ids: BARRENS_LV100_SET, bonus: { critRate: 5 } }, // è´«ç˜ ä¹‹åœ°ï¼šå…¨é˜Ÿæš´å‡»ç‡ +5
            { ids: STRANGLETHORN_LV100_SET, bonus: { haste: 5 } }, // è†æ£˜è°·ï¼šå…¨é˜Ÿæ€¥é€Ÿ +5
            { ids: DESOLACE_LV100_SET, bonus: { mastery: 5 } }, // å‡„å‡‰ä¹‹åœ°ï¼šå…¨é˜Ÿç²¾é€š +5
            { ids: SCARLET_MONASTERY_LV100_SET, bonus: { attack: 200, spellPower: 200 } }, // è¡€è‰²ä¿®é“é™¢ï¼šå…¨é˜Ÿæ”»å‡» +200ï¼Œæ³•å¼º +200
            { ids: ['EQ_044'], bonus: { versatility: 5, haste: 10, mastery: 10 } }, // é­ç¬è€…è‹è¨æ–¯ï¼šå…¨èƒ½ +5ï¼Œæ€¥é€Ÿ +10ï¼Œç²¾é€š +10
            { ids: SUNKEN_TEMPLE_LV100_SET, bonus: { versatility: 10 } }, // æ²‰æ²¡çš„ç¥åº™ï¼šå…¨é˜Ÿå…¨èƒ½ +10
            { ids: LOWER_BLACKROCK_SPIRE_LV100_SET, bonus: { critRate: 10 } }, // é»‘çŸ³å¡”ä¸‹ï¼šå…¨é˜Ÿæš´å‡» +10
            { ids: SCHOLOMANCE_LV100_SET, bonus: { mastery: 10 } }, // é€šçµå­¦é™¢ï¼šå…¨é˜Ÿç²¾é€š +10
            { ids: STRATHOLME_lv100_SET, bonus: { haste: 10 } }, // æ–¯å¦ç´¢å§†ï¼šå…¨é˜Ÿæ€¥é€Ÿ +10
            { ids: UPPER_BLACKROCK_SPIRE_LV100_SET, bonus: { attack: 500, spellPower: 500 } }, // é»‘çŸ³å¡”ä¸Šï¼šå…¨é˜Ÿæ”»å‡» +500ï¼Œæ³•å¼º +500
        ];

        for (const rule of codexBonusRules) {
            if (rule.ids.every(id => codexLv100Set.has(id))) {
                addBonus(rule.bonus);
            }
        }
    }

    // ç®€çº¦è€Œä¸ç®€å•ç¾ç»Šï¼šå•ä¸€èŒä¸šé˜Ÿä¼æ™®é€šæ”»å‡»ä¼¤å®³æé«˜150%
    if (gameState?.rebirthBonds?.includes('jianyue')) {
        const allSameClass =
            (gameState?.characters?.length || 0) > 0 &&
            gameState.characters.every(c => c.classId === gameState.characters[0].classId);

        if (allSameClass) {
            totalStats.basicAttackMultiplier = (totalStats.basicAttackMultiplier || 1) * 2.5;
        }
    }

    Object.values(character.equipment || {}).forEach(item => {
        if (item && item.stats) {
            Object.entries(item.stats).forEach(([stat, value]) => {
                totalStats[stat] = (totalStats[stat] || 0) + value;
            });

        }
    });

    // ==================== TALENTS (PASSIVE) ====================
    // ä»…å¤„ç†â€œæ°¸ä¹…/æˆ˜æ–—ä¸­å§‹ç»ˆç”Ÿæ•ˆâ€çš„è¢«åŠ¨ï¼šå¦‚æŠ¤ç”²+100ã€å§¿æ€ç­‰ã€‚
    // æˆ˜æ–—å†…â€œå å±‚â€ç±»å¤©èµ‹ï¼ˆè´¨æœ´/æ ¼æŒ¡å¤§å¸ˆï¼‰åœ¨æˆ˜æ–—ç³»ç»Ÿé‡Œå¤„ç†ã€‚
    const t = character.talents || {};
    if (character.classId === 'protection_warrior') {
        // 10çº§ï¼šå ç”²è¿‡ - æŠ¤ç”² +100ï¼ˆæˆ˜æ–—ä¸­ç”Ÿæ•ˆï¼›æ­¤æ¸¸æˆåªæœ‰æˆ˜æ–—ç”¨æŠ¤ç”²ï¼Œæ‰€ä»¥ç›´æ¥åŠ åˆ°æ€»æŠ¤ç”²ï¼‰
        if (t[10] === 'armor_up') {
            totalStats.armor = (totalStats.armor || 0) + 100;
        }

        // 20çº§ï¼šå§¿æ€ä¸‰é€‰ä¸€
        if (t[20] === 'defense_stance') {
            totalStats.damageTakenMult = (totalStats.damageTakenMult || 1) * 0.8; // å—åˆ°ä¼¤å®³ -20%
        } else if (t[20] === 'battle_stance') {
            totalStats.attack = (totalStats.attack || 0) * 1.10; // æ”»å‡»å¼ºåº¦ +10%
        } else if (t[20] === 'berserk_stance') {
            totalStats.critRate = (totalStats.critRate || 0) + 8;      // æš´å‡» +8%
            totalStats.critDamage = (totalStats.critDamage || 2.0) + 0.20; // æš´å‡»ä¼¤å®³ +20%ï¼ˆä»¥å€ç‡åŠ æˆï¼‰
        }
    }

    // ==================== ç²¾é€šï¼šç²¾ç¡®æ ¼æŒ¡ ====================
    if (character.classId === 'protection_warrior') {
        const mastery = totalStats.mastery || 0;

        // (10 + mastery / 2)%
        const masteryBonusPct = (10 + mastery / 2) / 100;

        // åªæ”¾å¤§â€œåŸå§‹æ ¼æŒ¡ç‡ / åŸå§‹æ ¼æŒ¡å€¼â€
        //totalStats.blockRate += totalStats.blockRate * masteryBonusPct;
        totalStats.blockValue += totalStats.blockValue * masteryBonusPct;
    }

    // ==================== æˆ’å¾‹ç‰§å¸ˆç²¾é€šï¼šæ•‘èµï¼ˆ1çº§è¢«åŠ¨ï¼‰ ====================
    if (character.classId === 'discipline_priest') {
        const mastery = Number(totalStats.mastery) || 0;

        // åŸºç¡€æ•‘èµ 20% + ç²¾é€š/5 %
        const atonementRate =
            0.20 + (mastery / 5) / 100;

        totalStats.atonement = {
            healingRate: atonementRate
        };

        // ï¼ˆæ ·ä¾‹ï¼‰50çº§å¤©èµ‹ï¼šç¥åœ£åŒ–èº« - æ³•æœ¯å¼ºåº¦æé«˜20%
        if (t[50] === 'holy_avatar') {
            totalStats.spellPower = (totalStats.spellPower || 0) * 1.2;
        }
    }

    // ==================== å†°éœœæ³•å¸ˆç²¾é€šï¼šæ·±å†¬ä¹‹å¯’ï¼ˆ1çº§è¢«åŠ¨ï¼‰ ====================
    if (character.classId === 'frost_mage') {
        const mastery = Number(totalStats.mastery) || 0;
        // åŸºç¡€ 120% + ç²¾é€š/2 %
        const iceLanceBaseMultiplier =
            1.20 + (mastery / 2) / 100;

        totalStats.iceLanceBaseMultiplier = iceLanceBaseMultiplier;
    }


    // ==================== æˆå°±ï¼šå…¨é˜Ÿå…¨èƒ½åŠ æˆï¼ˆå¦‚ã€é¦–é¢†æ€æ‰‹â… ~â…©ã€‘ï¼‰ ====================
    const achVersatilityBonus = getAchievementVersatilityBonus(gameState);
    if (Number.isFinite(achVersatilityBonus) && achVersatilityBonus !== 0) {
        totalStats.versatility = (Number(totalStats.versatility) || 0) + achVersatilityBonus;
    }

// ==================== æˆå°±ï¼šå…¨é˜Ÿç”Ÿå‘½ç™¾åˆ†æ¯”åŠ æˆï¼ˆå¦‚ã€æŒç»­æˆ˜æ–—â… ~â…©ã€‘ï¼‰ ====================
    // è§„åˆ™ï¼šhpPct ä¸ºåŠ æ³•å åŠ ï¼Œç„¶åä½œä¸ºä¹˜åŒºä½œç”¨åœ¨æœ€ç»ˆ hp ä¸Š
    const achHpPctBonus = getAchievementHpPctBonus(gameState);
    if (Number.isFinite(achHpPctBonus) && achHpPctBonus > 0) {
        totalStats.hp = (Number(totalStats.hp) || 0) * (1 + achHpPctBonus);
    }

    totalStats.maxHp = Math.floor((totalStats.hp || 0) * (partyAuras.hpMul || 1));
    totalStats.maxMp = totalStats.mp;

    // âœ… å…³é”®ï¼šä¿ç•™æ—§çš„ currentHp/currentMpï¼Œä¸è¦ç›´æ¥é‡ç½®ä¸ºæ»¡
    const prevHp = character.stats?.currentHp ?? totalStats.maxHp;
    const prevMp = character.stats?.currentMp ?? totalStats.maxMp;

    totalStats.currentHp = Math.min(totalStats.maxHp, Math.max(0, prevHp));
    totalStats.currentMp = Math.min(totalStats.maxMp, Math.max(0, prevMp));
    totalStats.spellPower = Math.floor((totalStats.spellPower || 0) * (partyAuras.spellPowerMul || 1));

    return totalStats;
}

function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
}

/**
 * æŒ‰ level(0~100) å°† baseStats ç¼©æ”¾åˆ° baseStats * growth
 * - level = 0   => baseStats
 * - level = 100 => baseStats * growth
 * - ä¸­é—´çº¿æ€§æ’å€¼ï¼šbase * (1 + (level/100) * (growth - 1))
 */
function scaleStats(baseStats = {}, growth = {}, level = 0) {
    const lv = clamp(Number(level) || 0, 0, 100);
    const t = lv / 100;

    const scaled = {};

    for (const [stat, baseValRaw] of Object.entries(baseStats)) {
        const baseVal = Number(baseValRaw) || 0;

        const g = Number(growth?.[stat]);
        const growthMul = Number.isFinite(g) ? g : 1;

        const mul = 1 + t * (growthMul - 1);
        scaled[stat] = baseVal * mul; // âœ… ä¿ç•™å°æ•°
    }

    return scaled;
}

// ==================== TRINKET: æŠ€èƒ½æ å¼ºåŒ–ï¼ˆç¬¬1/ç¬¬4æ ¼ç­‰ï¼‰ ====================
// çº¦å®šï¼šspecialEffect.type === 'skill_slot_buff'
// specialEffect.slots: [0..7]ï¼ˆ0=ç¬¬ä¸€æ ¼ï¼‰
// specialEffect.attackBonus / spellPowerBonusï¼šåœ¨è¯¥æŠ€èƒ½æ ¼é‡Šæ”¾æŠ€èƒ½æ—¶ï¼Œä¸´æ—¶åŠ åˆ°è§’è‰²è®¡ç®—ç”¨é¢æ¿
// ä¸è£…å¤‡æ•°å€¼ä¸€è‡´ï¼šæ»¡çº§(100)è§†ä¸º*2ï¼Œå› æ­¤è¿™é‡Œä¹Ÿåšçº¿æ€§ç¼©æ”¾ï¼šmul = 1 + level/100
function getSkillSlotBuffBonus(character, slotIndex) {
    const idx = Number(slotIndex);
    if (!Number.isFinite(idx)) return { attackBonus: 0, spellPowerBonus: 0 };

    const eqList = Object.values(character?.equipment || {}).filter(Boolean);
    if (eqList.length === 0) return { attackBonus: 0, spellPowerBonus: 0 };

    let attackBonus = 0;
    let spellPowerBonus = 0;

    for (const eq of eqList) {
        const effects = getEquipmentSpecialEffectList(eq);
        if (effects.length === 0) continue;

        for (const se of effects) {
            if (!se || se.type !== 'skill_slot_buff') continue;

            const slots = Array.isArray(se.slots) ? se.slots : [];
            if (!slots.includes(idx)) continue;

            // çº¿æ€§ç¼©æ”¾ï¼šlv0=1x, lv100=2x
            const lv = clamp(Number(eq.currentLevel ?? eq.level) || 0, 0, 100);
            const mul = 1 + (lv / 100);

            attackBonus += (Number(se.attackBonus) || 0) * mul;
            spellPowerBonus += (Number(se.spellPowerBonus) || 0) * mul;
        }
    }

    return {
        attackBonus: Math.floor(attackBonus),
        spellPowerBonus: Math.floor(spellPowerBonus)
    };
}

// æ£€æŸ¥è§’è‰²æ˜¯å¦æœ‰æ™®æ”»é‡å¤ç‰¹æ•ˆï¼Œè¿”å›è§¦å‘æ¦‚ç‡
function getBasicAttackRepeatChance(character) {
    const eqList = Object.values(character?.equipment || {}).filter(Boolean);
    for (const eq of eqList) {
        const effects = getEquipmentSpecialEffectList(eq);
        if (effects.length === 0) continue;

        for (const se of effects) {
            if (se && se.type === 'basic_attack_repeat') {
                return se.chance || 0;
            }
        }
    }
    return 0;
}

// ==================== è£…å¤‡ç‰¹æ•ˆï¼šåœ°å›¾å± æˆ®ï¼ˆåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼‰ ====================
// æ•°æ®çº¦å®šï¼š
// specialEffect: {
//   type: 'map_slayer',
//   bonusDamageVsMap: 0.25  // åœ°å›¾æˆ˜æ–—+25%ä¼¤å®³
// }
// è¯´æ˜ï¼š
// - ä»…åœ¨ã€Œåœ°å›¾æˆ˜æ–—ã€(stepCombatRounds) ç”Ÿæ•ˆ
// - æ”¯æŒæœªæ¥å‡ºç°å¤šä»¶åŒç±»ç‰¹æ•ˆæ—¶å åŠ ï¼ˆåŠ æ³•å åŠ ï¼‰
function getMapSlayerDamageDealtMult(character) {
    const eqList = Object.values(character?.equipment || {}).filter(Boolean);
    if (eqList.length === 0) return 1;

    let bonus = 0;
    for (const eq of eqList) {
        const effects = getEquipmentSpecialEffectList(eq);
        if (effects.length === 0) continue;
        for (const se of effects) {
            if (!se || se.type !== 'map_slayer') continue;
            bonus += Number(se.bonusDamageVsMap) || 0;
        }
    }

    // é˜²å¾¡æ€§ï¼šé¿å…å‡ºç°è´Ÿå€¼æˆ– NaN
    if (!Number.isFinite(bonus) || bonus <= 0) return 1;

    return 1 + bonus;
}

// âœ… åœ°å›¾æˆ˜æ–—æ€»ä¼¤å®³å€ç‡
// - è£…å¤‡ç‰¹æ•ˆï¼ˆmap_slayerï¼‰å†…éƒ¨ï¼šåŠ æ³•å åŠ  => 1 + Î£bonus
// - æˆå°±ï¼ˆmapDamageBonusï¼‰å†…éƒ¨ï¼šåŠ æ³•å åŠ  => 1 + Î£bonus
// - ä¸¤è€…ä¹‹é—´ï¼šä¹˜ç®—ï¼ˆç”¨æˆ·éœ€æ±‚ï¼šæˆå°±åœ°å›¾ä¼¤å®³ ä¸ è£…å¤‡ç‰¹æ•ˆä¼¤å®³ ä¹˜ç®—ï¼‰
function getMapDamageDealtMult(character, gameState) {
    const equipMult = getMapSlayerDamageDealtMult(character);
    const achMult = getAchievementMapDamageDealtMult(gameState);

    const m1 = (Number.isFinite(equipMult) && equipMult > 0) ? equipMult : 1;
    const m2 = (Number.isFinite(achMult) && achMult > 0) ? achMult : 1;
    return m1 * m2;
}

// ==================== è£…å¤‡ç‰¹æ•ˆï¼šé€šç”¨ã€Œæ¦‚ç‡è§¦å‘å±æ€§å¢ç›Šã€æ¡†æ¶ ====================
// ç›®æ ‡ï¼šæ”¯æŒç±»ä¼¼â€œæ¯å›åˆXX%æ¦‚ç‡è·å¾—XXXXå±æ€§ï¼ˆä»…æœ¬å›åˆç”Ÿæ•ˆï¼‰â€çš„ç‰¹æ•ˆï¼Œå¹¶ä¾¿äºåç»­æ‰©å±•æ›´å¤šè§¦å‘æ—¶æœºã€‚
//
// æ•°æ®çº¦å®šï¼ˆç¤ºä¾‹ï¼‰ï¼š
// specialEffect: {
//   type: 'proc_stat',
//   trigger: 'turn_start',         // è§¦å‘æ—¶æœºï¼ˆç›®å‰å®ç°ï¼šturn_startï¼‰
//   chance: 0.20,                  // 0~1
//   stats: { attack: 1500 },       // ä»»æ„å±æ€§é”®ï¼ˆattack / spellPower / critRate ...ï¼‰
//   scaleWithLevel: false          // å¯é€‰ï¼šæ˜¯å¦æŒ‰è£…å¤‡ç­‰çº§ç¼©æ”¾ï¼ˆlv0=1x, lv100=2xï¼‰
// }
//
// ä¹Ÿæ”¯æŒæœªæ¥åœ¨è£…å¤‡ä¸Šæ–°å¢ï¼šspecialEffects: []ï¼ˆå¤šæ¡ç‰¹æ•ˆï¼‰

const STAT_LABELS = {
    hp: 'ç”Ÿå‘½å€¼',
    mp: 'æ³•åŠ›å€¼',
    attack: 'æ”»å‡»å¼ºåº¦',
    spellPower: 'æ³•æœ¯å¼ºåº¦',
    armor: 'æŠ¤ç”²',
    magicResist: 'é­”æ³•æŠ—æ€§',
    haste: 'æ€¥é€Ÿ',
    critRate: 'æš´å‡»ç‡',
    critDamage: 'æš´å‡»ä¼¤å®³',
    mastery: 'ç²¾é€š',
    versatility: 'å…¨èƒ½',
    blockRate: 'æ ¼æŒ¡ç‡',
    blockValue: 'æ ¼æŒ¡å€¼',
    proficiency: 'ç†Ÿç»ƒ',
    precision: 'ç²¾ç»†',
    perception: 'æ„ŸçŸ¥',
};

function getEquipmentSpecialEffectList(eq) {
    const list = [];
    if (Array.isArray(eq?.specialEffects)) list.push(...eq.specialEffects);
    if (eq?.specialEffect) list.push(eq.specialEffect);
    return list.filter(Boolean);
}

function formatProcStatBonusText(bonus = {}) {
    const entries = Object.entries(bonus).filter(([, v]) => Number(v) !== 0);
    if (entries.length === 0) return '';

    return entries.map(([stat, valueRaw]) => {
        const name = STAT_LABELS[stat] || stat;
        const v = Number(valueRaw) || 0;

        // ä¸è£…å¤‡é¢æ¿ä¸€è‡´çš„å±•ç¤ºä¹ æƒ¯
        if (stat === 'critRate' || stat === 'blockRate') {
            return `${name} +${v.toFixed(1)}%`;
        }
        if (stat === 'critDamage') {
            return v <= 1 ? `${name} +${Math.floor(v * 100)}%` : `${name} +${Math.floor(v)}`;
        }
        return `${name} +${Math.floor(v)}`;
    }).join('ï¼Œ');
}

/**
 * é€šç”¨ï¼šæ·éª°è§¦å‘ã€Œproc_statã€ç±»å‹çš„è£…å¤‡ç‰¹æ•ˆï¼ˆè¿”å›æœ¬å›åˆåº”ä¸´æ—¶åŠ åˆ°é¢æ¿çš„å±æ€§ï¼‰
 * @param character è§’è‰²å¯¹è±¡ï¼ˆéœ€å« equipmentï¼‰
 * @param trigger   è§¦å‘ç‚¹ï¼ˆä¾‹å¦‚ï¼š'turn_start'ï¼‰
 * @returns {{ bonus: Object, triggered: Array<{label: string, bonus: Object, chance: number}> }}
 */
function rollProcStatEffects(character, trigger) {
    const eqList = Object.values(character?.equipment || {}).filter(Boolean);
    const totalBonus = {};
    const triggered = [];

    for (const eq of eqList) {
        const effects = getEquipmentSpecialEffectList(eq);
        if (effects.length === 0) continue;

        for (const se of effects) {
            if (!se || se.type !== 'proc_stat') continue;
            if (se.trigger !== trigger) continue;

            const chance = Math.max(0, Math.min(1, Number(se.chance) || 0));
            if (chance <= 0) continue;

            if (Math.random() >= chance) continue;

            const stats = se.stats && typeof se.stats === 'object' ? se.stats : {};

            // å¯é€‰ï¼šæŒ‰è£…å¤‡ç­‰çº§ç¼©æ”¾ï¼ˆä¸è£…å¤‡å±æ€§ä¸€è‡´ï¼šlv0=1x, lv100=2xï¼‰
            const lv = clamp(Number(eq.currentLevel ?? eq.level) || 0, 0, 100);
            const mul = se.scaleWithLevel ? (1 + (lv / 100)) : 1;

            const applied = {};
            for (const [stat, valRaw] of Object.entries(stats)) {
                const baseVal = Number(valRaw) || 0;
                if (!Number.isFinite(baseVal) || baseVal === 0) continue;

                const add = baseVal * mul;
                applied[stat] = (applied[stat] || 0) + add;
                totalBonus[stat] = (totalBonus[stat] || 0) + add;
            }

            // è¾“å‡ºç»™æ—¥å¿—ç”¨ï¼šä¼˜å…ˆç”¨ç‰¹æ•ˆè‡ªå®šä¹‰åï¼Œå…¶æ¬¡è£…å¤‡å
            const label = se.name || eq.name || 'è£…å¤‡ç‰¹æ•ˆ';
            triggered.push({ label, bonus: applied, chance });
        }
    }

    // ç»Ÿä¸€å‘ä¸‹å–æ•´ï¼Œé¿å…å°æ•°æ±¡æŸ“
    for (const k of Object.keys(totalBonus)) {
        totalBonus[k] = Math.floor(Number(totalBonus[k]) || 0);
    }
    triggered.forEach(t => {
        for (const k of Object.keys(t.bonus || {})) {
            t.bonus[k] = Math.floor(Number(t.bonus[k]) || 0);
        }
    });

    return { bonus: totalBonus, triggered };
}

// ==================== BOSSæˆ˜æ–—ä¸€æ­¥æ¨è¿›å‡½æ•° ====================
function stepBossCombat(state) {
    if (!state.bossCombat) return state;

    let combat = { ...state.bossCombat };
    combat.logs = combat.logs || [];
    let logs = [...combat.logs];

    const boss = BOSS_DATA[combat.bossId];
    if (!boss) return state;

    combat.round += 1;
    // âœ… æ·»åŠ è¾…åŠ©å‡½æ•°ï¼Œåˆ›å»ºå¸¦å›åˆæ•°çš„æ—¥å¿—å¯¹è±¡
    const currentRound = combat.round;
    const addLog = (text, type = 'normal') => {
        logs.push({ round: currentRound, text, type });
    };
    // ===== æŠ¤ç›¾å¸æ”¶ä¼¤å®³è¾…åŠ©å‡½æ•° =====
    const applyShieldAbsorb = (playerState, damage, logs, currentRound) => {
        if (!playerState.buffs || damage <= 0) {
            return { finalDamage: damage, absorbed: 0 };
        }

        // æ‰¾åˆ°æœ‰æ•ˆçš„æŠ¤ç›¾buff
        const shieldBuff = playerState.buffs.find(b =>
            b.type && b.amount > 0 && ['ice_barrier', 'holy_barrier'].includes(b.type)
        );

        if (!shieldBuff) {
            return { finalDamage: damage, absorbed: 0 };
        }

        // è®¡ç®—å¸æ”¶é‡
        const absorbed = Math.min(shieldBuff.amount, damage);
        shieldBuff.amount -= absorbed;
        const finalDamage = damage - absorbed;

        // æŠ¤ç›¾å—å‡»è§¦å‘æ•ˆæœï¼ˆå¯’å†°æŠ¤ä½“ï¼š25%æ¦‚ç‡è·å¾—å¯’å†°æŒ‡ï¼‰
        if (shieldBuff.onHitEffect?.type === 'generate_finger') {
            if (playerState.char.classId === 'frost_mage' && Math.random() < shieldBuff.onHitEffect.chance) {
                playerState.fingersOfFrost = (playerState.fingersOfFrost || 0) + 1;
                addLog(`ã€${shieldBuff.name}ã€‘è§¦å‘ï¼š${playerState.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${playerState.fingersOfFrost}å±‚`);
            }
        }

        // æŠ¤ç›¾ç ´ç¢
        if (shieldBuff.amount <= 0) {
            addLog(`${playerState.char.name} çš„ã€${shieldBuff.name}ã€‘æŠ¤ç›¾ç ´ç¢ï¼`);
            const idx = playerState.buffs.findIndex(b => b.type === shieldBuff.type);
            if (idx !== -1) {
                playerState.buffs.splice(idx, 1);
            }
        }

        return { finalDamage, absorbed };
    };

    // ==================== ç§æ—ï¼šçŸ®äººã€çŸ³åƒå½¢æ€ã€‘ ====================
    // æ•ˆæœï¼šæˆ˜æ–—ä¸­é¦–æ¬¡å—åˆ°ã€è¯…å’’ã€‘ä¸ã€ä¸­æ¯’ã€‘æ•ˆæœæ—¶å…ç–«ï¼ˆæ¯ç§å„ 1 æ¬¡ï¼‰ã€‚
    // è¯´æ˜ï¼šè¿™é‡Œåªåšâ€œåˆ¤å®š+æ¶ˆè€—æ¬¡æ•°+å†™æ—¥å¿—â€ï¼Œå…·ä½“æ•ˆæœçš„åº”ç”¨ç‚¹ï¼ˆdebuff/dotï¼‰éœ€è¦è°ƒç”¨å®ƒã€‚
    const ensureRacialFlags = (ps) => {
        if (!ps || typeof ps !== 'object') return {};
        if (!ps.racialFlags || typeof ps.racialFlags !== 'object') ps.racialFlags = {};
        if (ps.racialFlags.stoneformCurseUsed === undefined) ps.racialFlags.stoneformCurseUsed = false;
        if (ps.racialFlags.stoneformPoisonUsed === undefined) ps.racialFlags.stoneformPoisonUsed = false;
        return ps.racialFlags;
    };

    const tryFirstDebuffImmunity = (ps, kind, idx = null, sourceName = '') => {
        if (!ps || ps.currentHp <= 0) return false;

        const raceTrait = RACE_TRAITS?.[ps?.char?.race];
        const enabled = !!raceTrait?.firstDebuffImmunity?.[kind];
        if (!enabled) return false;

        const flags = ensureRacialFlags(ps);
        const flagKey = kind === 'curse'
            ? 'stoneformCurseUsed'
            : (kind === 'poison' ? 'stoneformPoisonUsed' : null);
        if (!flagKey) return false;
        if (flags[flagKey]) return false;

        // æ¶ˆè€—æ¬¡æ•°
        flags[flagKey] = true;

        const kindText = kind === 'curse' ? 'è¯…å’’' : (kind === 'poison' ? 'ä¸­æ¯’' : kind);
        const posText = (Number.isFinite(Number(idx)) && idx !== null) ? `ä½ç½®${Number(idx) + 1} ` : '';
        const srcText = sourceName ? `ï¼ˆ${sourceName}ï¼‰` : '';
        addLog(`ã€çŸ³åƒå½¢æ€ã€‘è§¦å‘ï¼š${posText}${ps.char?.name || ''} å…ç–«äº†æœ¬åœºæˆ˜æ–—çš„é¦–æ¬¡${kindText}æ•ˆæœ${srcText}`);
        return true;
    };

    // ==================== ç©å®¶é˜¶æ®µ ====================

    // ç©å®¶å›åˆç»“æŸæ—¶çš„ buff/debuff ç»“ç®—ï¼ˆç”¨äºâ€œææƒ§â€ç­‰è·³è¿‡è¡ŒåŠ¨çš„æƒ…å†µï¼‰
    const tickPlayerDurations = (p, i) => {
        // buff duration å‡å°‘
        if (p.buffs && p.buffs.length > 0) {
            p.buffs = p.buffs
                .map(b => {
                    if (b.duration !== undefined) {
                        b.duration -= 1;
                    }
                    return b;
                })
                .filter(b => {
                    // æŠ¤ç›¾ï¼šæŒç»­æ—¶é—´åˆ°æœŸæˆ–å¸æ”¶é‡è€—å°½éƒ½ç§»é™¤
                    if (b.type && ['ice_barrier', 'holy_barrier'].includes(b.type)) {
                        if ((b.duration ?? 999) <= 0 || (b.amount ?? 0) <= 0) {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€${b.name}ã€‘æŠ¤ç›¾æ¶ˆå¤±`);
                            return false;
                        }
                        return true;
                    }
                    return (b.duration ?? 999) > 0;
                });
        }

        // debuff duration å‡å°‘ï¼ˆè‡´æ­»æ‰“å‡»å‡ç–—/ææƒ§ç­‰ï¼‰
        if (p.debuffs) {
            Object.keys(p.debuffs).forEach(key => {
                if (p.debuffs[key]?.duration !== undefined) {
                    p.debuffs[key].duration -= 1;
                    if (p.debuffs[key].duration <= 0) {
                        delete p.debuffs[key];

                        // âœ… ä¸åŒdebuffæ˜¾ç¤ºä¸åŒæ¶ˆå¤±æ–‡æ¡ˆ
                        if (key === 'mortalStrike') {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€è‡´æ­»æ‰“å‡»ã€‘å‡ç–—æ•ˆæœæ¶ˆå¤±`);
                        } else if (key === 'fear') {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€ææƒ§ã€‘æ•ˆæœæ¶ˆå¤±`);
                        } else if (key === 'shadowCurse') {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€æš—å½±è¯…å’’ã€‘æ•ˆæœæ¶ˆå¤±`);
                        } else {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€${key}ã€‘æ•ˆæœæ¶ˆå¤±`);
                        }
                    }
                }
            });
        }
        // æ•‘èµ duration å‡å°‘ï¼ˆä»…å½“å¸¦ duration æ—¶æ‰é€’å‡ï¼›ç²¾é€šè¢«åŠ¨/å¸¸é©»æ•‘èµä¸å—å½±å“ï¼‰
        if (p.char?.stats?.atonement && p.char.stats.atonement.duration !== undefined) {
            p.char.stats.atonement.duration -= 1;
            if (p.char.stats.atonement.duration <= 0) {
                delete p.char.stats.atonement;
                addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€æ•‘èµã€‘æ•ˆæœç»“æŸ`);
            }
        }

    };

    for (let i = 0; i < combat.playerStates.length; i++) {
        const p = combat.playerStates[i];
        if (p.currentHp <= 0) continue;

        // ===== 50çº§å¤©èµ‹ï¼šå¹»æƒ³æ›²ï¼ˆæ¯å›åˆè·å¾—1å±‚ï¼Œå½±å“ä¸‹ä¸€ä¸ªç¥åœ£æ–°æ˜Ÿï¼‰ =====
        if (p.char?.classId === 'discipline_priest' && p.char?.talents?.[50] === 'fantasia') {
            p.fantasiaStacks = (p.fantasiaStacks || 0) + 1;
            addLog(`ã€å¹»æƒ³æ›²ã€‘ä½ç½®${i + 1} ${p.char.name} è·å¾—1å±‚ï¼ˆå½“å‰${p.fantasiaStacks}å±‚ï¼‰`);
        }

        // ==================== ææƒ§ï¼šè·³è¿‡æœ¬å›åˆè¡ŒåŠ¨ ====================
        // è¯´æ˜ï¼šæ¯æ¬¡ stepBossCombat è§†ä¸ºâ€œ1å›åˆâ€ï¼Œææƒ§æœŸé—´è¯¥è§’è‰²ä¸é‡Šæ”¾æŠ€èƒ½ï¼›
        // ä½†ä»ç„¶ä¼šæ¶ˆè€—æœ¬å›åˆï¼ˆæŠ€èƒ½è½®è½¬ç»§ç»­å‰è¿›ï¼‰ï¼Œå¹¶æ­£å¸¸ç»“ç®— buff/debuff æŒç»­æ—¶é—´ã€‚
        if (p.debuffs?.fear?.duration > 0) {
            // ä»ç„¶æ¨è¿›æŠ€èƒ½è½®è½¬ï¼ˆè¡¨ç¤ºè¿™ä¸€å›åˆè¢«æµªè´¹ï¼‰
            if (Array.isArray(p.validSkills) && p.validSkills.length > 0) {
                p.skillIndex = (p.skillIndex || 0) + 1;
            }

            addLog(`ä½ç½®${i + 1} ${p.char.name} å› ã€ææƒ§ã€‘æ— æ³•è¡ŒåŠ¨ï¼ˆå‰©ä½™${p.debuffs.fear.duration}å›åˆï¼‰`, 'debuff');
            tickPlayerDurations(p, i);
            continue;
        }

        // é˜²å¾¡ï¼šæç«¯æƒ…å†µä¸‹æ²¡æœ‰æŠ€èƒ½è¡¨
        if (!Array.isArray(p.validSkills) || p.validSkills.length === 0) {
            addLog(`ä½ç½®${i + 1} ${p.char.name} æ²¡æœ‰å¯ç”¨æŠ€èƒ½ï¼Œè·³è¿‡è¡ŒåŠ¨`, 'warning');
            tickPlayerDurations(p, i);
            continue;
        }

        const slotIndex = p.skillIndex % p.validSkills.length;
        let skillId = p.validSkills[p.skillIndex % p.validSkills.length];
        p.skillIndex += 1;
        let skill = SKILLS[skillId];

        // ===== æ–°å¢ï¼šå¤„ç†æ¡ä»¶æŠ€èƒ½ =====
        if (skill && skill.type === 'conditional') {
            const condition = skill.condition;
            let conditionMet = false;

            if (condition.type === 'has_buff') {
                if (condition.buffName === 'fingersOfFrost') {
                    conditionMet = (p.fingersOfFrost || 0) >= (condition.minStacks || 1);
                }
            }

            const actualSkillId = conditionMet ? skill.skillIfTrue : skill.skillIfFalse;
            skillId = actualSkillId;
            skill = SKILLS[actualSkillId];

            addLog(`ã€æ™ºèƒ½æŠ€èƒ½ã€‘${p.char.name}ï¼š${conditionMet ? 'æœ‰å¯’å†°æŒ‡â†’å†°æªæœ¯' : 'æ— å¯’å†°æŒ‡â†’å¯’å†°ç®­'}`);
        }
        // ===== æ¡ä»¶æŠ€èƒ½å¤„ç†ç»“æŸ =====

        if (!skill) {
            tickPlayerDurations(p, i);
            continue;
        }

        // ==================== è£…å¤‡ç‰¹æ•ˆï¼šå›åˆå¼€å§‹æ¦‚ç‡å±æ€§å¢ç›Šï¼ˆä»…æœ¬å›åˆï¼‰ ====================
        const { bonus: turnProcBonus, triggered: turnProcTriggered } = rollProcStatEffects(p.char, 'turn_start');
        if (turnProcTriggered.length > 0) {
            turnProcTriggered.forEach(tp => {
                const t = formatProcStatBonusText(tp.bonus);
                if (t) addLog(`ã€${tp.label}ã€‘è§¦å‘ï¼š${t}ï¼ˆæœ¬å›åˆï¼‰`);
            });
        }

        // é¥°å“/è£…å¤‡ç‰¹æ•ˆï¼šæŠ€èƒ½æ å¼ºåŒ–
        const slotBuff = getSkillSlotBuffBonus(p.char, slotIndex);

        // è®¡ç®—æœ¬å›åˆç”¨äºæŠ€èƒ½ç»“ç®—çš„é¢æ¿ï¼ˆä¸ä¼šå†™å›è§’è‰²æœ¬ä½“ï¼‰
        const calcStats = {
            ...p.char.stats,
            attack: (p.char.stats.attack || 0) + (p.talentBuffs?.attackFlat || 0) + (slotBuff.attackBonus || 0),
            blockValue: (p.char.stats.blockValue || 0) + (p.talentBuffs?.blockValueFlat || 0),
            spellPower: (p.char.stats.spellPower || 0) + (p.talentBuffs?.spellPowerFlat || 0) + (slotBuff.spellPowerBonus || 0)
        };

        // å åŠ æœ¬å›åˆè§¦å‘çš„ä¸´æ—¶å±æ€§
        Object.entries(turnProcBonus || {}).forEach(([stat, add]) => {
            calcStats[stat] = (calcStats[stat] || 0) + (Number(add) || 0);
        });

        const charForCalc = {
            ...p.char,
            stats: calcStats
        };

        // combatContext
        const icyVeinsBuff = p.buffs?.some(b => b.type === 'icy_veins');
        const blizzardActive = combat.bossDots?.some(d => d.name === 'å†°é£æš´' && d.sourcePlayerId === p.char.id) ||
            combat.minions?.some(m => m.dots?.some(d => d.name === 'å†°é£æš´' && d.sourcePlayerId === p.char.id));

        const combatContext = {
            fortuneMisfortuneStacks: p.fortuneMisfortuneStacks || 0,
            fantasiaStacks: p.fantasiaStacks || 0,
            icyVeinsBuff,
            blizzardActive,
            fingersOfFrost: p.fingersOfFrost || 0
        };
        const result = skill.calculate(charForCalc, combatContext);

        // ç›®æ ‡é€‰æ‹©é€»è¾‘ - æ£€æŸ¥ç«ç‚®æ‰‹æ˜¯å¦å…ç–«
        let targetType = 'boss';
        let targetIndex = -1;

        // æ£€æŸ¥æ˜¯å¦æœ‰å¯æ”»å‡»çš„å°å¼Ÿï¼ˆæ’é™¤å…ç–«çŠ¶æ€çš„ç«ç‚®æ‰‹ï¼‰
        const attackableMinions = combat.minions
            .map((m, idx) => ({ idx, hp: m.hp, immune: m.immune }))
            .filter(m => m.hp > 0 && !m.immune);

        if (!combat.strategy.priorityBoss && attackableMinions.length > 0) {
            attackableMinions.sort((a, b) => a.hp - b.hp);
            targetIndex = attackableMinions[0].idx;
            targetType = 'minion';
        }

        // buffä¼¤å®³åŠ æˆ
        let buffDamageDealtMult = 1;
        if (p.buffs) {
            p.buffs.forEach(b => {
                if (b.damageDealtMult) {
                    buffDamageDealtMult *= b.damageDealtMult;
                }
            });
        }

        // æ™®é€šæ”»å‡»æ‰§è¡Œå‡½æ•°
        const executeBasicAttackDamage = (isRepeat = false) => {
            const basicSkill = SKILLS['basic_attack'];
            const basicResult = basicSkill.calculate(charForCalc, combatContext);

            if (basicResult.damage) {
                let damage = basicResult.damage * buffDamageDealtMult;
                const targetDefense = targetType === 'boss' ? boss.defense : (boss.minion?.defense || boss.cannoneer?.defense || 0);
                const actualDamage = Math.max(1, Math.floor(damage - targetDefense));

                if (targetType === 'boss') {
                    combat.bossHp -= actualDamage;
                } else {
                    // æ£€æŸ¥å…ç–«
                    if (combat.minions[targetIndex]?.immune) {
                        addLog(`ä½ç½®${i + 1} ${p.char.name} çš„æ”»å‡»è¢«ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                        return 0;
                    }
                    combat.minions[targetIndex].hp -= actualDamage;
                }

                const repeatText = isRepeat ? '(é­ç¬è€…è‹è¨æ–¯)' : '';
                const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                addLog(`ä½ç½®${i + 1} ${p.char.name} ä½¿ç”¨ æ™®é€šæ”»å‡»${repeatText} å¯¹ ${targetType === 'boss' ? boss.name : minionName} é€ æˆ ${actualDamage} ä¼¤å®³${basicResult.isCrit ? 'ï¼ˆæš´å‡»ï¼‰' : ''}`);

                if (basicResult.holySwordDamage && basicResult.holySwordDamage > 0) {
                    const holySwordActualDamage = Math.max(1, Math.floor(basicResult.holySwordDamage));

                    if (targetType === 'boss') {
                        combat.bossHp -= holySwordActualDamage;
                    } else if (!combat.minions[targetIndex]?.immune) {
                        combat.minions[targetIndex].hp -= holySwordActualDamage;
                    }

                    addLog(`ã€åœ£å‰‘ã€‘è§¦å‘ï¼š${p.char.name} é¢å¤–é€ æˆ ${holySwordActualDamage} ç‚¹çœŸå®ä¼¤å®³`);
                }

                return actualDamage;
            }
            return 0;
        };

        // AOEä¼¤å®³å¤„ç†
        if (result.aoeDamage) {
            let damage = result.aoeDamage * buffDamageDealtMult;
            const skillName = skill.name || 'æŠ€èƒ½';

            // å¯¹ Boss é€ æˆä¼¤å®³
            if (combat.bossHp > 0) {
                combat.bossHp -= damage;
                addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skillName}å¯¹ ${boss.name} é€ æˆ ${Math.floor(damage)} ä¼¤å®³${result.isCrit ? 'ï¼ˆæš´å‡»ï¼ï¼‰' : ''}`);

                if (result.isCrit && result.dotOnCrit) {
                    combat.bossDots = combat.bossDots || [];
                    combat.bossDots.push({ ...result.dotOnCrit, sourcePlayerId: p.char.id });
                    addLog(`â†’ ${boss.name} è·å¾—ã€é‡ä¼¤ã€‘ï¼Œå°†æŒç»­å—åˆ° DOT ä¼¤å®³`);
                }

                if (result.generateFingerOnHit && p.char.classId === 'frost_mage') {
                    p.fingersOfFrost = (p.fingersOfFrost || 0) + 1;
                    addLog(`ã€å†°å·çªè¿›ã€‘è§¦å‘ï¼š${p.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${p.fingersOfFrost}å±‚`);
                }

                if (p.char.talents?.[30] === 'demoralizing_shout') {
                    if (!combat.bossDebuffs?.demoralizingShout) {
                        combat.bossDebuffs = combat.bossDebuffs || {};
                        combat.bossDebuffs.demoralizingShout = { damageMult: 0.8 };
                        addLog(`ã€æŒ«å¿—æ€’å¼ã€‘è§¦å‘ï¼šæ‰€æœ‰æ•Œäººé€ æˆçš„ä¼¤å®³é™ä½20%`);
                    }
                }
            }

            // å¯¹æ‰€æœ‰å°å¼Ÿé€ æˆä¼¤å®³ï¼ˆæ£€æŸ¥å…ç–«ï¼‰
            combat.minions.forEach((m, idx) => {
                if (m.hp <= 0) return;

                // æ£€æŸ¥å…ç–«çŠ¶æ€
                if (m.immune) {
                    addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skillName}è¢« ç«ç‚®æ‰‹${idx + 1}ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                    return;
                }

                m.hp -= damage;
                const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skillName}å¯¹ ${minionName}${idx + 1} é€ æˆ ${Math.floor(damage)} ä¼¤å®³${result.isCrit ? 'ï¼ˆæš´å‡»ï¼ï¼‰' : ''}`);

                if (result.isCrit && result.dotOnCrit) {
                    m.dots = m.dots || [];
                    m.dots.push({ ...result.dotOnCrit, sourcePlayerId: p.char.id });
                    addLog(`â†’ ${minionName}${idx + 1} è·å¾—ã€é‡ä¼¤ã€‘ï¼Œå°†æŒç»­å—åˆ° DOT ä¼¤å®³`);
                }

                if (result.generateFingerOnHit && p.char.classId === 'frost_mage') {
                    p.fingersOfFrost = (p.fingersOfFrost || 0) + 1;
                    addLog(`ã€å†°å·çªè¿›ã€‘è§¦å‘ï¼š${p.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${p.fingersOfFrost}å±‚`);
                }
            });

            // å±±ä¸˜ä¹‹ç‹å¤©èµ‹å¤„ç†
            if (p.char.talents?.[30] === 'mountain_king' && Math.random() < 0.5) {
                const extraResult = skill.calculate(charForCalc);
                const extraDamage = extraResult.aoeDamage * buffDamageDealtMult;

                addLog(`ã€å±±ä¸˜ä¹‹ç‹ã€‘è§¦å‘ï¼šé›·éœ†ä¸€å‡»å†æ¬¡é‡Šæ”¾ï¼`);

                if (combat.bossHp > 0) {
                    combat.bossHp -= extraDamage;
                    addLog(`ä½ç½®${i + 1} ${p.char.name} çš„é›·éœ†ä¸€å‡»(å±±ä¸˜ä¹‹ç‹)å¯¹ ${boss.name} é€ æˆ ${Math.floor(extraDamage)} ä¼¤å®³${extraResult.isCrit ? 'ï¼ˆæš´å‡»ï¼ï¼‰' : ''}`);

                    if (extraResult.isCrit && extraResult.dotOnCrit) {
                        combat.bossDots = combat.bossDots || [];
                        combat.bossDots.push({ ...extraResult.dotOnCrit, sourcePlayerId: p.char.id });
                        addLog(`â†’ ${boss.name} è·å¾—ã€é‡ä¼¤ã€‘`);
                    }
                }

                combat.minions.forEach((m, idx) => {
                    if (m.hp <= 0) return;
                    if (m.immune) {
                        addLog(`é›·éœ†ä¸€å‡»(å±±ä¸˜ä¹‹ç‹)è¢« ç«ç‚®æ‰‹${idx + 1}ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                        return;
                    }
                    m.hp -= extraDamage;
                    const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                    addLog(`ä½ç½®${i + 1} ${p.char.name} çš„é›·éœ†ä¸€å‡»(å±±ä¸˜ä¹‹ç‹)å¯¹ ${minionName}${idx + 1} é€ æˆ ${Math.floor(extraDamage)} ä¼¤å®³${extraResult.isCrit ? 'ï¼ˆæš´å‡»ï¼ï¼‰' : ''}`);

                    if (extraResult.isCrit && extraResult.dotOnCrit) {
                        m.dots = m.dots || [];
                        m.dots.push({ ...extraResult.dotOnCrit, sourcePlayerId: p.char.id });
                    }
                });
            }
        }
        // å•ä½“ä¼¤å®³å¤„ç†
        else if (result.damage) {
            let damage = result.damage;

            // å¤©èµ‹åŠ æˆ
            if (p.char.talents?.[10] === 'shadow_amp' && result.school === 'shadow') {
                damage *= 1.2;
            }
            if (p.char.talents?.[20] === 'dark_side' && skillId === 'mind_blast') {
                damage *= 1.8;
            }
            damage *= buffDamageDealtMult;

            // æ³•æœ¯æ˜“ä¼¤
            const isSpellSchool = (result.school === 'holy' || result.school === 'shadow');
            let takenMult = 1;
            if (isSpellSchool) {
                const vuln = combat.bossDebuffs?.spell_vuln;
                if (vuln) takenMult *= (vuln.mult ?? 1);
            }
            damage = Math.floor(damage * takenMult);

            const targetDefense = targetType === 'boss' ? boss.defense : (boss.minion?.defense || boss.cannoneer?.defense || 0);

            // æ£€æŸ¥ç›®æ ‡æ˜¯å¦å…ç–«
            if (targetType === 'minion' && combat.minions[targetIndex]?.immune) {
                addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skill.name}è¢«ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
            } else {
                const actualDamage = Math.max(1, damage - targetDefense);

                if (targetType === 'boss') {
                    combat.bossHp -= actualDamage;
                } else {
                    combat.minions[targetIndex].hp -= actualDamage;
                }

                const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                addLog(`ä½ç½®${i + 1} ${p.char.name} ä½¿ç”¨ ${skill.name} å¯¹ ${targetType === 'boss' ? boss.name : minionName} é€ æˆ ${actualDamage} ä¼¤å®³${result.isCrit ? 'ï¼ˆæš´å‡»ï¼‰' : ''}`);

                // æ•‘èµæœºåˆ¶
                if (p.char.stats.atonement) {
                    // æ£€æŸ¥å‡ç–—debuff
                    let healingMult = 1;
                    if (p.debuffs?.mortalStrike) {
                        healingMult = 1 - (p.debuffs.mortalStrike.healingReduction || 0);
                    }
                    const healFromAtonement = Math.floor(actualDamage * p.char.stats.atonement.healingRate * healingMult);
                    const maxHp = p.char.stats.maxHp || 0;
                    const actualHeal = Math.min(healFromAtonement, maxHp - p.currentHp);
                    p.currentHp += actualHeal;

                    let healLog = `å› ä¸ºæ•‘èµæ¢å¤ ${actualHeal} ç‚¹ç”Ÿå‘½`;
                    if (healingMult < 1) {
                        healLog += `ï¼ˆå—åˆ°è‡´æ­»æ‰“å‡»å‡ç–—${Math.round((1 - healingMult) * 100)}%ï¼‰`;
                    }
                    addLog(healLog);
                }

                // é­ç¬è€…è‹è¨æ–¯ç‰¹æ•ˆ
                if (skillId === 'basic_attack') {
                    const repeatChance = getBasicAttackRepeatChance(p.char);
                    if (repeatChance > 0 && Math.random() < repeatChance) {
                        addLog(`ã€é­ç¬è€…è‹è¨æ–¯ã€‘è§¦å‘ï¼šå†æ¬¡å‘åŠ¨æ™®é€šæ”»å‡»ï¼`);
                        executeBasicAttackDamage(true);
                    }
                }
            }
        }

        // æ²»ç–—å¤„ç† - éœ€è¦è€ƒè™‘å‡ç–—debuff
        if (result.healAll) {
            let heal = Math.floor(result.healAll);
            combat.playerStates.forEach(ps => {
                if (ps.currentHp > 0) {
                    // æ£€æŸ¥å‡ç–—debuff
                    let healingMult = 1;
                    if (ps.debuffs?.mortalStrike) {
                        healingMult = 1 - (ps.debuffs.mortalStrike.healingReduction || 0);
                    }
                    const actualHeal = Math.floor(heal * healingMult);
                    const newHp = Math.min(ps.char.stats.maxHp, ps.currentHp + actualHeal);
                    ps.currentHp = newHp;
                    ps.char.stats.currentHp = newHp;
                }
            });
            addLog(`ä½ç½®${i + 1} ${p.char.name} å…¨é˜Ÿæ²»ç–— ${heal}`);
        }

        // æ•‘èµå¤„ç†ï¼ˆapplyAtonementï¼‰
        if (result.applyAtonement) {
            const dur = Number(result.applyAtonement.duration) || 2;

            combat.playerStates.forEach(ps => {
                if (ps.currentHp > 0) {
                    const existingRate = ps.char?.stats?.atonement?.healingRate;
                    const healingRate = (typeof existingRate === 'number') ? existingRate : 0.20;

                    ps.char.stats.atonement = {
                        healingRate,
                        duration: dur
                    };
                }
            });

            addLog(`ä½ç½®${i + 1} ${p.char.name} ä¸ºå…¨é˜Ÿæ–½åŠ ã€æ•‘èµã€‘ï¼ŒæŒç»­ ${dur} å›åˆ`);
        }

        // è‹¦ä¿®æŠ€èƒ½å¤„ç† - éœ€è¦è€ƒè™‘å‡ç–—debuff
        if (result.penanceHeal) {
            const frontPlayer = combat.playerStates.find(ps => ps.currentHp > 0);
            if (frontPlayer) {
                const fortuneStacks = p.fortuneMisfortuneStacks || 0;
                let healAmount = result.penanceHeal;

                // æ£€æŸ¥å‡ç–—debuff
                let healingMult = 1;
                if (frontPlayer.debuffs?.mortalStrike) {
                    healingMult = 1 - (frontPlayer.debuffs.mortalStrike.healingReduction || 0);
                }
                healAmount = Math.floor(healAmount * healingMult);

                const newHp = Math.min(frontPlayer.char.stats.maxHp, frontPlayer.currentHp + healAmount);
                const actualHeal = newHp - frontPlayer.currentHp;
                frontPlayer.currentHp = newHp;

                let healText = `ä½ç½®${i + 1} ${p.char.name} è‹¦ä¿®æ²»ç–— ${frontPlayer.char.name} ${actualHeal}`;
                if (fortuneStacks > 0 && p.char.talents?.[40] === 'fortune_misfortune') {
                    healText += `ï¼ˆç¥¸ç¦ç›¸ä¾ ${fortuneStacks} å±‚åŠ æˆï¼‰`;
                }
                if (healingMult < 1) {
                    healText += `ï¼ˆå—åˆ°è‡´æ­»æ‰“å‡»å‡ç–—${Math.round((1 - healingMult) * 100)}%ï¼‰`;
                }
                addLog(healText);

                // ç»ˆæè‹¦ä¿®ä¼¤å®³
                if (result.penanceDamage) {
                    const targetDefense = targetType === 'boss' ? boss.defense : (boss.minion?.defense || boss.cannoneer?.defense || 0);

                    if (targetType === 'minion' && combat.minions[targetIndex]?.immune) {
                        addLog(`ã€ç»ˆæè‹¦ä¿®ã€‘è¢«ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                    } else {
                        const actualDamage = Math.max(1, Math.floor(result.penanceDamage * buffDamageDealtMult - targetDefense));

                        if (targetType === 'boss') {
                            combat.bossHp -= actualDamage;
                        } else if (targetIndex >= 0) {
                            combat.minions[targetIndex].hp -= actualDamage;
                        } else {
                            combat.bossHp -= actualDamage;
                        }

                        addLog(`ä½ç½®${i + 1} ${p.char.name}ã€ç»ˆæè‹¦ä¿®ã€‘é€ æˆ ${actualDamage} ä¼¤å®³`);
                    }
                }

                // äº‰åˆ†å¤ºç§’
                if (result.applyHasteBuff) {
                    p.buffs = p.buffs || [];
                    p.buffs.push({
                        type: 'haste',
                        hasteBonus: result.applyHasteBuff.hasteBonus,
                        duration: result.applyHasteBuff.duration
                    });
                    addLog(`ã€äº‰åˆ†å¤ºç§’ã€‘è§¦å‘ï¼š${p.char.name} æ€¥é€Ÿ+${result.applyHasteBuff.hasteBonus}%ï¼ŒæŒç»­${result.applyHasteBuff.duration}å›åˆ`);
                }

                if (result.clearFortuneStacks) {
                    p.fortuneMisfortuneStacks = 0;
                }
            }
        }

        // DOTå¤„ç†
        if (result.dot) {
            if (result.dot.name === 'å†°é£æš´') {
                if (targetType === 'boss') {
                    combat.bossDots = combat.bossDots || [];
                    combat.bossDots.push({ ...result.dot, sourcePlayerId: p.char.id });
                    addLog(`ä½ç½®${i + 1} ${p.char.name} å¯¹ ${boss.name} æ–½æ”¾ã€å†°é£æš´ã€‘ï¼ŒæŒç»­${result.dot.duration}å›åˆ`);
                } else if (targetIndex >= 0 && !combat.minions[targetIndex]?.immune) {
                    combat.minions[targetIndex].dots = combat.minions[targetIndex].dots || [];
                    combat.minions[targetIndex].dots.push({ ...result.dot, sourcePlayerId: p.char.id });
                    addLog(`ä½ç½®${i + 1} ${p.char.name} å¯¹ ç«ç‚®æ‰‹${targetIndex + 1} æ–½æ”¾å†°é£æš´ï¼`);
                } else if (targetIndex >= 0 && combat.minions[targetIndex]?.immune) {
                    addLog(`å†°é£æš´è¢« ç«ç‚®æ‰‹${targetIndex + 1}ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                }
            }
        }

        // AOE DOTï¼ˆå¯’å†°å®ç ï¼‰
        if (result.aoeDot) {
            if (combat.bossHp > 0) {
                combat.bossDots = combat.bossDots || [];
                combat.bossDots.push({ ...result.aoeDot, sourcePlayerId: p.char.id });
                addLog(`ä½ç½®${i + 1} ${p.char.name} å¯¹ ${boss.name} æ–½æ”¾ã€${result.aoeDot.name}ã€‘ï¼ŒæŒç»­${result.aoeDot.duration}å›åˆ`);
            }
            combat.minions.forEach((m, idx) => {
                if (m.hp <= 0) return;
                if (m.immune) {
                    addLog(`ã€${result.aoeDot.name}ã€‘è¢« ç«ç‚®æ‰‹${idx + 1}ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                    return;
                }
                m.dots = m.dots || [];
                m.dots.push({ ...result.aoeDot, sourcePlayerId: p.char.id });
                addLog(`ä½ç½®${i + 1} ${p.char.name} å¯¹ ç«ç‚®æ‰‹${idx + 1} æ–½æ”¾ã€${result.aoeDot.name}ã€‘ï¼ŒæŒç»­${result.aoeDot.duration}å›åˆ`);
            });
        }

        // buffå¤„ç†
        if (result.buff) {
            p.buffs = p.buffs || [];
            p.buffs.push({ ...result.buff });

            if (result.buff.damageTakenMult) {
                const damageReduction = Math.round((1 - result.buff.damageTakenMult) * 100);
                let buffText = `ä½ç½®${i + 1} ${p.char.name} å¼€å¯ç›¾å¢™ï¼Œå—åˆ°ä¼¤å®³é™ä½${damageReduction}%ï¼ˆæŒç»­${result.buff.duration}å›åˆï¼‰`;
                if (result.buff.damageDealtMult && result.buff.damageDealtMult > 1) {
                    const damageIncrease = Math.round((result.buff.damageDealtMult - 1) * 100);
                    buffText += `ï¼Œé€ æˆä¼¤å®³æé«˜${damageIncrease}%`;
                }
                addLog(buffText);
            }

            if (result.buff.type === 'icy_veins') {
                addLog(`ä½ç½®${i + 1} ${p.char.name} å¼€å¯ã€å†°å†·è¡€è„‰ã€‘ï¼šå†°éœœä¼¤å®³+50%ï¼Œæ€¥é€Ÿ+50%ï¼ŒæŒç»­${result.buff.duration}å›åˆ`);
            }
        }

        // ===== æŠ¤ç›¾æŠ€èƒ½å¤„ç† =====
        if (result.shield) {
            // ç¥åœ£éšœå£ï¼šå¯¹å…¨é˜Ÿæ–½åŠ æŠ¤ç›¾ï¼›å…¶ä»–æŠ¤ç›¾é»˜è®¤åªç»™è‡ªå·±
            combat.playerStates.forEach((ps, j) => {
                if (result.shield.type !== 'holy_barrier' && j !== i) return;
                if (ps.currentHp <= 0) return;

                ps.buffs = ps.buffs || [];

                // æ£€æŸ¥æ˜¯å¦å·²æœ‰åŒç±»å‹æŠ¤ç›¾
                const existingIdx = ps.buffs.findIndex(b => b.type === result.shield.type);
                if (existingIdx !== -1) {
                    const oldShield = ps.buffs[existingIdx];
                    ps.buffs[existingIdx] = {
                        ...result.shield,
                        amount: Math.max(oldShield.amount, result.shield.amount)
                    };
                    addLog(`ä½ç½®${j + 1} ${ps.char.name} åˆ·æ–°ã€${result.shield.name}ã€‘æŠ¤ç›¾ï¼Œå¸æ”¶é‡ï¼š${ps.buffs[existingIdx].amount}`);
                } else {
                    ps.buffs.push({ ...result.shield });
                    addLog(`ä½ç½®${j + 1} ${ps.char.name} è·å¾—ã€${result.shield.name}ã€‘æŠ¤ç›¾ï¼Œå¯å¸æ”¶ ${result.shield.amount} ç‚¹ä¼¤å®³`);
                }
            });
        }

        // å¤©èµ‹è§¦å‘
        if (skillId === 'basic_attack' && p.char.talents?.[10] === 'plain') {
            p.talentBuffs.attackFlat = (p.talentBuffs.attackFlat || 0) + 5;
            addLog(`ã€è´¨æœ´ã€‘è§¦å‘ï¼šæ”»å‡»+5`);
        }

        if ((skillId === 'smite' || skillId === 'mind_blast') && p.char.talents?.[40] === 'fortune_misfortune') {
            p.fortuneMisfortuneStacks = (p.fortuneMisfortuneStacks || 0) + 1;
            addLog(`ã€ç¥¸ç¦ç›¸ä¾ã€‘${p.char.name} å±‚æ•°+1ï¼Œå½“å‰${p.fortuneMisfortuneStacks}å±‚`);
        }

        // å†°éœœæ³•å¸ˆå¤©èµ‹
        if (skillId === 'frostbolt' && result.triggerFrostboltTalents) {
            if (p.char.talents?.[10] === 'lingering_cold') {
                p.talentBuffs = p.talentBuffs || {};
                p.talentBuffs.spellPowerFlat = (p.talentBuffs.spellPowerFlat || 0) + 5;
                addLog(`ã€å»¶ç»µå¯’å†·ã€‘è§¦å‘ï¼š${p.char.name} æ³•æœ¯å¼ºåº¦+5`);
            }

            if (p.char.talents?.[20] === 'fingers_of_frost' && Math.random() < 0.5) {
                p.fingersOfFrost = (p.fingersOfFrost || 0) + 1;
                addLog(`ã€å¯’å†°æŒ‡ã€‘è§¦å‘ï¼š${p.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${p.fingersOfFrost}å±‚`);
            }

            if (p.char.talents?.[20] === 'cold_wisdom' || p.char.talents?.[30] === 'cold_intuition') {
                const triggerChance = p.char.talents?.[30] === 'cold_intuition' ? 0.4 : 0.25;
                if (Math.random() < triggerChance) {
                    const blizzardSkill = SKILLS['blizzard'];
                    const blizzardResult = blizzardSkill.calculate(charForCalc, combatContext);

                    if (targetType === 'boss') {
                        combat.bossDots = combat.bossDots || [];
                        combat.bossDots.push({ ...blizzardResult.dot, sourcePlayerId: p.char.id });
                        addLog(`ã€å†°å†·æ™ºæ…§ã€‘è§¦å‘ï¼š${p.char.name} é¢å¤–å¯¹ ${boss.name} æ–½æ”¾å†°é£æš´ï¼`);
                    } else if (targetIndex >= 0 && !combat.minions[targetIndex]?.immune) {
                        combat.minions[targetIndex].dots = combat.minions[targetIndex].dots || [];
                        combat.minions[targetIndex].dots.push({ ...blizzardResult.dot, sourcePlayerId: p.char.id });
                        addLog(`ã€å†°å†·æ™ºæ…§ã€‘è§¦å‘ï¼š${p.char.name} é¢å¤–å¯¹ ç«ç‚®æ‰‹${targetIndex + 1} æ–½æ”¾å†°é£æš´ï¼`);
                    }
                }
            }
        }

        if (skillId === 'ice_lance' && result.consumeFingersOfFrost) {
            p.fingersOfFrost = Math.max(0, (p.fingersOfFrost || 0) - 1);
            addLog(`ã€å¯’å†°æŒ‡ã€‘æ¶ˆè€—1å±‚ï¼Œ${p.char.name} å‰©ä½™${p.fingersOfFrost}å±‚`);
        }

        // ===== 50çº§å¤©èµ‹ï¼šå¹»æƒ³æ›² - ç¥åœ£æ–°æ˜Ÿæ–½æ”¾åæ¸…ç©ºå±‚æ•° =====
        if (result.clearFantasiaStacks) {
            const used = Number(result.fantasiaStacksUsed) || (p.fantasiaStacks || 0);
            p.fantasiaStacks = 0;
            addLog(`ã€å¹»æƒ³æ›²ã€‘${p.char.name} æ¶ˆè€—${used}å±‚ï¼Œå¼ºåŒ–æœ¬æ¬¡ç¥åœ£æ–°æ˜Ÿåæ¸…ç©ºå±‚æ•°`);
        }

        // æœ¬è§’è‰²è¡ŒåŠ¨ç»“æŸï¼šç»“ç®—æŒç»­æ—¶é—´
        tickPlayerDurations(p, i);
    }

    // ç¾ç»Šæ•ˆæœ
    if (state.rebirthBonds?.includes('baoernai')) {
        const priests = combat.playerStates.filter(p => p.char.classId === 'discipline_priest' && p.currentHp > 0).length;
        const warriors = combat.playerStates.filter(p => p.char.classId === 'protection_warrior' && p.currentHp > 0).length;
        if (warriors === 1 && priests === 2) {
            const warrior = combat.playerStates.find(p => p.char.classId === 'protection_warrior' && p.currentHp > 0);
            if (warrior) {
                const blockValue = (warrior.char.stats.blockValue || 0) + (warrior.talentBuffs?.blockValueFlat || 0);
                const aoeDamage = Math.floor(blockValue * 0.8);
                if (aoeDamage > 0) {
                    combat.bossHp -= aoeDamage;
                    combat.minions.forEach(m => {
                        if (m.hp > 0 && !m.immune) {
                            m.hp -= aoeDamage;
                        }
                    });
                    addLog(`ã€åŒ…äºŒå¥¶ç¾ç»Šã€‘é˜²æŠ¤æˆ˜å£«å¯¹æ‰€æœ‰æ•Œäººé€ æˆ ${aoeDamage} é¢å¤–ä¼¤å®³ï¼ˆåŸºäºæ ¼æŒ¡å€¼ï¼‰`);
                }
            }
        }
    }

    // DOT ç»“ç®—
    if (combat.bossDots) {
        combat.bossDots = combat.bossDots.filter(dot => {
            const dmg = Math.max(1, Math.floor(dot.damagePerTurn));
            combat.bossHp -= dmg;

            const dotName = dot.name || 'é‡ä¼¤';
            addLog(`ã€${dotName}ã€‘å¯¹ ${boss.name} é€ æˆ ${dmg} DOT ä¼¤å®³ï¼ˆå‰©ä½™${dot.duration - 1}å›åˆï¼‰`);

            if (dot.sourcePlayerId) {
                const sourcePlayer = combat.playerStates.find(p => p.char.id === dot.sourcePlayerId);
                if (sourcePlayer && sourcePlayer.char.talents?.[30] === 'brutal_momentum' && sourcePlayer.currentHp > 0) {
                    const healAmount = Math.floor(dmg * 1.5);
                    const maxHp = sourcePlayer.char.stats.maxHp || 0;
                    const actualHeal = Math.min(healAmount, maxHp - sourcePlayer.currentHp);
                    if (actualHeal > 0) {
                        sourcePlayer.currentHp += actualHeal;
                        addLog(`ã€æ®‹æš´åŠ¨åŠ›ã€‘è§¦å‘ï¼š${sourcePlayer.char.name} æ²»ç–— ${actualHeal} ç‚¹ç”Ÿå‘½`);
                    }
                }

                if (dot.canGenerateFinger && sourcePlayer && sourcePlayer.char.talents?.[30] === 'orb_mastery') {
                    if (Math.random() < 0.25) {
                        sourcePlayer.fingersOfFrost = (sourcePlayer.fingersOfFrost || 0) + 1;
                        addLog(`ã€å®ç ç²¾é€šã€‘è§¦å‘ï¼š${sourcePlayer.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${sourcePlayer.fingersOfFrost}å±‚`);
                    }
                }
            }

            dot.duration -= 1;
            return dot.duration > 0;
        });
    }

    // å°å¼ŸDOTç»“ç®—
    combat.minions = combat.minions.map((m, idx) => {
        if (m.hp <= 0) return m;
        if (m.dots && m.dots.length > 0) {
            m.dots = m.dots.filter(dot => {
                // å…ç–«çŠ¶æ€ä¸‹DOTä¸é€ æˆä¼¤å®³
                if (m.immune) {
                    dot.duration -= 1;
                    return dot.duration > 0;
                }

                const dmg = Math.max(1, Math.floor(dot.damagePerTurn));
                m.hp -= dmg;

                const dotName = dot.name || 'é‡ä¼¤';
                const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                addLog(`ã€${dotName}ã€‘å¯¹ ${minionName}${idx + 1} é€ æˆ ${dmg} DOT ä¼¤å®³ï¼ˆå‰©ä½™${dot.duration - 1}å›åˆï¼‰`);

                if (dot.sourcePlayerId) {
                    const sourcePlayer = combat.playerStates.find(p => p.char.id === dot.sourcePlayerId);
                    if (sourcePlayer && sourcePlayer.char.talents?.[30] === 'brutal_momentum' && sourcePlayer.currentHp > 0) {
                        const healAmount = Math.floor(dmg * 1.5);
                        const maxHp = sourcePlayer.char.stats.maxHp || 0;
                        const actualHeal = Math.min(healAmount, maxHp - sourcePlayer.currentHp);
                        if (actualHeal > 0) {
                            sourcePlayer.currentHp += actualHeal;
                            addLog(`ã€æ®‹æš´åŠ¨åŠ›ã€‘è§¦å‘ï¼š${sourcePlayer.char.name} æ²»ç–— ${actualHeal} ç‚¹ç”Ÿå‘½`);
                        }
                    }

                    if (dot.canGenerateFinger && sourcePlayer && sourcePlayer.char.talents?.[30] === 'orb_mastery') {
                        if (Math.random() < 0.25) {
                            sourcePlayer.fingersOfFrost = (sourcePlayer.fingersOfFrost || 0) + 1;
                            addLog(`ã€å®ç ç²¾é€šã€‘è§¦å‘ï¼š${sourcePlayer.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${sourcePlayer.fingersOfFrost}å±‚`);
                        }
                    }
                }

                dot.duration -= 1;
                return dot.duration > 0;
            });
        }
        return m;
    });

    // ==================== Bossé˜¶æ®µ ====================
    const pickAlivePlayerIndex = () => {
        for (let idx = 0; idx < combat.playerStates.length; idx++) {
            const p = combat.playerStates[idx];
            if ((p.currentHp ?? 0) > 0) return idx;
        }
        return -1;
    };

    const getBuffBlockRate = (playerState) => {
        const buffs = Array.isArray(playerState?.buffs) ? playerState.buffs : [];
        return buffs.reduce((sum, b) => sum + (b?.blockRate || 0), 0);
    };

    const calcMitigatedAndBlockedDamage = (playerState, rawDamage, isHeavy = false) => {
        const armor = playerState?.char?.stats?.armor || 0;
        const dr = getArmorDamageReduction(armor);
        let dmg = applyPhysicalMitigation(rawDamage, armor);

        // ===== 50çº§å¤©èµ‹ï¼šæ ¼æŒ¡çªç ´ =====
        let baseBlockRate = playerState?.char?.stats?.blockRate || 0;
        const buffBlockRate = getBuffBlockRate(playerState);
        let totalBlockRate = baseBlockRate + buffBlockRate;
        let blockBreakthroughBonusValue = 0;

        if (playerState?.char?.talents?.[50] === 'block_breakthrough' && totalBlockRate > 95) {
            const excessBlockRate = totalBlockRate - 95;
            blockBreakthroughBonusValue = Math.floor(
                (playerState?.char?.stats?.blockValue || 0) * (excessBlockRate / 100)
            );
            totalBlockRate = 95;
        }

        const blockChance = Math.max(0, Math.min(0.95, totalBlockRate / 100));

        let blockedAmount = 0;
        if (Math.random() < blockChance) {
            const blockValue = Math.floor(
                (playerState?.char?.stats?.blockValue || 0) + (playerState?.talentBuffs?.blockValueFlat || 0)
            );
            blockedAmount = Math.min(Math.max(0, dmg - 1), Math.max(0, blockValue));
            dmg = Math.max(1, dmg - blockedAmount);
        }

        const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
        let buffTakenMult = 1;
        if (playerState.buffs) {
            playerState.buffs.forEach(b => {
                if (b.damageTakenMult) {
                    buffTakenMult *= b.damageTakenMult;
                }
            });
            playerState.buffs = playerState.buffs.filter(b => (b.duration ?? 999) > 0);
        }

        const finalTakenMult = takenMult * buffTakenMult;
        const demoralizingShoutMult = combat.bossDebuffs?.demoralizingShout?.damageMult ?? 1;
        const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
        dmg = Math.max(1, Math.floor(dmg * finalTakenMult * demoralizingShoutMult * versTakenMult));

        return { damage: dmg, dr, blockedAmount, isHeavy };
    };

    // Boss è¡ŒåŠ¨
    const bossAction = boss.cycle[(combat.round - 1) % boss.cycle.length];

    // ==================== èŒƒå…‹é‡Œå¤«ç‰¹æ®ŠæŠ€èƒ½å¤„ç† ====================
    if (combat.bossId === 'vancleef') {
        // è‡´æ­»æ‰“å‡»
        if (bossAction === 'mortal_strike') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.mortalStrikeMultiplier || 3));
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);

                // åœ¨è‡´æ­»æ‰“å‡»æ‰£è¡€å‰æ·»åŠ æŠ¤ç›¾å¤„ç†
                const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';

                // æ–½åŠ å‡ç–—debuff
                target.debuffs = target.debuffs || {};
                target.debuffs.mortalStrike = {
                    healingReduction: boss.mortalStrikeDebuff.healingReduction,
                    duration: boss.mortalStrikeDebuff.duration
                };

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€è‡´æ­»æ‰“å‡»ã€‘å¯¹ ä½ç½®${tIdx + 1} é€ æˆ ${shieldResult.finalDamage} ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                addLog(`â†’ ä½ç½®${tIdx + 1} å—åˆ°ã€è‡´æ­»æ‰“å‡»ã€‘ï¼šå—åˆ°æ²»ç–—æ•ˆæœé™ä½50%ï¼ŒæŒç»­2å›åˆ`);
            }
        }
        // ç«ç‚®æ‰‹å‡†å¤‡
        else if (bossAction === 'summon_cannoneers') {
            const aliveMinions = (combat.minions || []).filter(m => (m.hp ?? 0) > 0);
            const need = Math.max(0, (boss.summonCount || 3) - aliveMinions.length);

            for (let i = 0; i < need; i++) {
                combat.minions.push({
                    hp: boss.minion.maxHp,
                    maxHp: boss.minion.maxHp,
                    attack: boss.minion.attack,
                    defense: boss.minion.defense,
                    isCannoneer: true,
                    immune: false,
                    dots: []
                });
            }

            if (need > 0) {
                addLog(`ã€${boss.name}ã€‘å¤§å–Šï¼š"ç«ç‚®æ‰‹å‡†å¤‡ï¼" å¬å”¤äº† ${need} ä¸ª${boss.minion.name}`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å¬å”¤ç«ç‚®æ‰‹ï¼Œä½†åœºä¸Šç«ç‚®æ‰‹å·²æ»¡`);
            }
        }
        // ç™»ä¸Šç”²æ¿
        else if (bossAction === 'board_the_deck') {
            const aliveMinions = combat.minions.filter(m => m.hp > 0 && m.isCannoneer);
            if (aliveMinions.length > 0) {
                combat.minions.forEach(m => {
                    if (m.hp > 0 && m.isCannoneer) {
                        m.immune = true;
                    }
                });
                addLog(`ã€${boss.name}ã€‘å¤§å–Šï¼š"ç™»ä¸Šç”²æ¿ï¼" æ‰€æœ‰ç«ç‚®æ‰‹è·å¾—å…ç–«ä¼¤å®³æ•ˆæœï¼`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å‘½ä»¤ç«ç‚®æ‰‹ç™»ä¸Šç”²æ¿ï¼Œä½†åœºä¸Šæ²¡æœ‰ç«ç‚®æ‰‹`);
            }
        }
    }
    // ==================== æ™®ç‘æ–¯æ‰˜å¥³å£«æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'prestor_lady') {
        // è°æŠ¥ï¼šå¯¹å½“å‰ç›®æ ‡å’Œå‘¨å›´é˜Ÿå‹é€ æˆæ€»å…±bossæ”»å‡»åŠ›Ã—10çš„æš—å½±ä¼¤å®³
        // é›†ä¸­ç«™ä½ï¼šä¼¤å®³ç”±æ‰€æœ‰å­˜æ´»è§’è‰²åˆ†æ‹…
        // åˆ†æ•£ç«™ä½ï¼šåªæ‰“1å·ä½å¦å…‹
        if (bossAction === 'espionage') {
            const totalDamage = Math.floor((boss.attack || 0) * (boss.espionageDamageMultiplier || 10));
            const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);

            if (alivePlayers.length === 0) {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è°æŠ¥ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            } else if (combat.strategy.stance === 'dispersed') {
                // åˆ†æ•£ç«™ä½ï¼šåªæ‰“1å·ä½
                const tIdx = pickAlivePlayerIndex();
                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    // æš—å½±ä¼¤å®³ï¼Œä½¿ç”¨é­”æ³•æŠ—æ€§å‡å…
                    const magicResist = target.char?.stats?.magicResist || 0;
                    const resistReduction = getMagicResistDamageReduction(magicResist); // ç»Ÿä¸€çš„é­”æŠ—å…¬å¼ï¼ˆè§ magicresist_kï¼‰
                    let damage = Math.floor(totalDamage * (1 - resistReduction));

                    // åº”ç”¨å—ä¼¤å‡å…
                    const takenMult = target.char?.stats?.damageTakenMult ?? 1;
                    let buffTakenMult = 1;
                    if (target.buffs) {
                        target.buffs.forEach(b => {
                            if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                        });
                    }
                    const versTakenMult = getVersatilityDamageTakenMult(target.char?.stats?.versatility);

                    damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * versTakenMult));

                    // è°æŠ¥ä¹Ÿè¦ç»è¿‡æŠ¤ç›¾
                    const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è°æŠ¥ã€‘ï¼ˆåˆ†æ•£ç«™ä½ï¼‰å¯¹ ä½ç½®${tIdx + 1} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³${shieldText}`);
                }
            } else {
                // é›†ä¸­ç«™ä½ï¼šä¼¤å®³åˆ†æ‘Šç»™æ‰€æœ‰å­˜æ´»è§’è‰²
                const damagePerPlayer = Math.floor(totalDamage / alivePlayers.length);

                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è°æŠ¥ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰ï¼Œ${alivePlayers.length}åè§’è‰²åˆ†æ‘Šä¼¤å®³`);

                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;

                    const magicResist = ps.char?.stats?.magicResist || 0;
                    const resistReduction = getMagicResistDamageReduction(magicResist);
                    let damage = Math.floor(damagePerPlayer * (1 - resistReduction));

                    const takenMult = ps.char?.stats?.damageTakenMult ?? 1;
                    let buffTakenMult = 1;
                    if (ps.buffs) {
                        ps.buffs.forEach(b => {
                            if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                        });
                    }
                    const versTakenMult = getVersatilityDamageTakenMult(ps.char?.stats?.versatility);

                    damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * versTakenMult));

                    // è°æŠ¥ä¹Ÿè¦ç»è¿‡æŠ¤ç›¾
                    const shieldResult = applyShieldAbsorb(ps, damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è°æŠ¥ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰å¯¹ ä½ç½®${pIdx + 1} ${ps.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³${shieldText}`);
                });
            }
        }
        // é»‘é¾™ä¹‹ç‚ï¼šå¯¹æ‰€æœ‰è§’è‰²æ–½åŠ 1å±‚é»‘é¾™ä¹‹ç‚DOT
        else if (bossAction === 'black_dragon_flame') {
            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é»‘é¾™ä¹‹ç‚ã€‘ï¼Œæ‰€æœ‰è§’è‰²è·å¾—1å±‚é»‘é¾™ä¹‹ç‚ï¼`);

            combat.playerStates.forEach((ps, pIdx) => {
                if (ps.currentHp <= 0) return;

                // åˆå§‹åŒ–ç©å®¶DOTæ•°ç»„
                ps.dots = ps.dots || [];

                // æ£€æŸ¥æ˜¯å¦å·²æœ‰é»‘é¾™ä¹‹ç‚DOTï¼Œå¦‚æœæœ‰åˆ™å åŠ å±‚æ•°
                const existingFlame = ps.dots.find(d => d.name === 'é»‘é¾™ä¹‹ç‚');
                if (existingFlame) {
                    existingFlame.stacks = (existingFlame.stacks || 1) + 1;
                    existingFlame.damagePerTurn = Math.floor(
                        (boss.attack || 0) * (boss.blackFlameDoTMultiplier || 0.2) * existingFlame.stacks
                    );
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} çš„é»‘é¾™ä¹‹ç‚å åŠ è‡³ ${existingFlame.stacks} å±‚`);
                } else {
                    ps.dots.push({
                        name: 'é»‘é¾™ä¹‹ç‚',
                        type: 'dot',
                        school: 'shadow',
                        stacks: 1,
                        damagePerTurn: Math.floor((boss.attack || 0) * (boss.blackFlameDoTMultiplier || 0.2)),
                        duration: 999, // æŒç»­æ•´åœºæˆ˜æ–—
                        isPermanent: true
                    });
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} è·å¾—é»‘é¾™ä¹‹ç‚ï¼ˆ1å±‚ï¼‰`);
                }
            });
        }
        // å°–ç‰™ä¸åˆ©çˆªï¼šå¯¹1å·ä½é€ æˆ3å€æ”»å‡»ä¼¤å®³ + æµè¡€DOT
        else if (bossAction === 'fangs_and_claws') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.fangsMultiplier || 3));
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);

                target.currentHp -= damage;

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€å°–ç‰™ä¸åˆ©çˆªã€‘å¯¹ ä½ç½®${tIdx + 1} é€ æˆ ${damage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}ï¼‰`);

                // æ–½åŠ æµè¡€DOT
                target.dots = target.dots || [];
                const bleedDamage = Math.floor((boss.attack || 0) * (boss.bleedDoTMultiplier || 0.8));

                // æ£€æŸ¥æ˜¯å¦å·²æœ‰æµè¡€DOTï¼Œå¦‚æœæœ‰åˆ™åˆ·æ–°æŒç»­æ—¶é—´
                const existingBleed = target.dots.find(d => d.name === 'æ’•è£‚ä¼¤å£');
                if (existingBleed) {
                    existingBleed.duration = boss.bleedDuration || 3;
                    addLog(`â†’ ä½ç½®${tIdx + 1} çš„ã€æ’•è£‚ä¼¤å£ã€‘æŒç»­æ—¶é—´åˆ·æ–°`);
                } else {
                    target.dots.push({
                        name: 'æ’•è£‚ä¼¤å£',
                        type: 'dot',
                        school: 'physical',
                        damagePerTurn: bleedDamage,
                        duration: boss.bleedDuration || 3
                    });
                    addLog(`â†’ ä½ç½®${tIdx + 1} è·å¾—ã€æ’•è£‚ä¼¤å£ã€‘ï¼šæ¯å›åˆ ${bleedDamage} ç‚¹æµè¡€ä¼¤å®³ï¼ŒæŒç»­ ${boss.bleedDuration || 3} å›åˆ`);
                }
            }
        }
        // æ™®é€šæ”»å‡»
        else if (bossAction === 'normal_attack') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor(boss.attack || 0);
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, false);

                target.currentHp -= damage;

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                addLog(`ã€${boss.name}ã€‘æ™®é€šæ”»å‡» ä½ç½®${tIdx + 1} é€ æˆ ${damage} ç‚¹ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}ï¼‰`);
            }
        }
    }
    // ==================== éœæ ¼æŠ€èƒ½å¤„ç†ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰ ====================
    else if (combat.bossId === 'hogger') {
        if (bossAction === 'summon') {
            const aliveMinions = (combat.minions || []).filter(m => (m.hp ?? 0) > 0);
            const need = Math.max(0, (boss.summonCount || 0) - aliveMinions.length);

            for (let i = 0; i < need; i++) {
                combat.minions.push({
                    hp: boss.minion.maxHp,
                    maxHp: boss.minion.maxHp,
                    attack: boss.minion.attack,
                    defense: boss.minion.defense,
                });
            }

            if (need > 0) {
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€å¬å”¤ã€‘å‘¼å«äº† ${need} ä¸ª${boss.minion.name}`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å¬å”¤ï¼Œä½†åœºä¸Šå°å¼Ÿå·²æ»¡`);
            }
        }

        if (bossAction === 'strike') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.heavyMultiplier || 1));
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);

                target.currentHp -= damage;

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€é‡å‡»ã€‘å¯¹ ä½ç½®${tIdx + 1} é€ æˆ ${damage} ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}ï¼‰`);
            }
        }
    }// ==================== è£‚é­‚è€…è¨å°”è¯ºæ–¯æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'thalnos') {
        // çµé­‚å¼ºé£ï¼šå¯¹éšæœºç›®æ ‡ï¼ˆåˆ†æ•£ï¼‰æˆ–æ‰€æœ‰ç›®æ ‡ï¼ˆé›†ä¸­ï¼‰é€ æˆä¼¤å®³+DOT
        if (bossAction === 'soul_storm') {
            const baseDamage = Math.floor((boss.attack || 0) * (boss.soulStormMultiplier || 1.5));
            const dotDamage = Math.floor((boss.attack || 0) * (boss.soulStormDoTMultiplier || 1.5));
            const dotDuration = boss.soulStormDoTDuration || 3;

            if (combat.strategy.stance === 'dispersed') {
                // åˆ†æ•£ç«™ä½ï¼šåªæ‰“éšæœºä¸€ä¸ªç›®æ ‡
                const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
                if (alivePlayers.length > 0) {
                    const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                    const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);

                    if (tIdx >= 0) {
                        const target = combat.playerStates[tIdx];
                        const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, baseDamage, false);

                        // æŠ¤ç›¾å¸æ”¶
                        const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                        target.currentHp -= shieldResult.finalDamage;

                        const drPct = Math.round(dr * 100);
                        const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                        const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                        addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çµé­‚å¼ºé£ã€‘ï¼ˆåˆ†æ•£ç«™ä½ï¼‰å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);

                        // æ–½åŠ DOT
                        target.dots = target.dots || [];
                        target.dots.push({
                            name: 'çµé­‚å¼ºé£',
                            type: 'dot',
                            school: 'shadow',
                            damagePerTurn: dotDamage,
                            duration: dotDuration
                        });
                        addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} è·å¾—ã€çµé­‚å¼ºé£ã€‘ï¼šæ¯å›åˆ ${dotDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ŒæŒç»­ ${dotDuration} å›åˆ`);
                    }
                }
            } else {
                // é›†ä¸­ç«™ä½ï¼šå¯¹æ‰€æœ‰å­˜æ´»è§’è‰²é€ æˆä¼¤å®³+DOT
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çµé­‚å¼ºé£ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰ï¼Œæ‰€æœ‰è§’è‰²å—åˆ°ä¼¤å®³ï¼`);

                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;

                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(ps, baseDamage, false);

                    // æŠ¤ç›¾å¸æ”¶
                    const shieldResult = applyShieldAbsorb(ps, damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);

                    // æ–½åŠ DOT
                    ps.dots = ps.dots || [];
                    ps.dots.push({
                        name: 'çµé­‚å¼ºé£',
                        type: 'dot',
                        school: 'shadow',
                        damagePerTurn: dotDamage,
                        duration: dotDuration
                    });
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} è·å¾—ã€çµé­‚å¼ºé£ã€‘DOT`);
                });
            }
        }
        // å •è½çš„åå­—å†›ï¼šå¬å”¤5ä¸ªåå­—å†›
        else if (bossAction === 'fallen_crusaders') {
            const aliveMinions = (combat.minions || []).filter(m => (m.hp ?? 0) > 0);
            const need = Math.max(0, (boss.summonCount || 5) - aliveMinions.length);

            for (let i = 0; i < need; i++) {
                combat.minions.push({
                    hp: boss.minion.maxHp,
                    maxHp: boss.minion.maxHp,
                    attack: boss.attack, // æ”»å‡»ç­‰äºbossæ”»å‡»
                    defense: boss.minion.defense,
                    isCrusader: true,
                    dots: []
                });
            }

            if (need > 0) {
                addLog(`ã€${boss.name}ã€‘å¬å”¤äº† ${need} ä¸ª${boss.minion.name}ï¼`);
                addLog(`â†’ åå­—å†›å±æ€§ï¼šHP ${boss.minion.maxHp}ï¼Œæ”»å‡» ${boss.attack}`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å¬å”¤åå­—å†›ï¼Œä½†åœºä¸Šåå­—å†›å·²æ»¡`);
            }
        }
        // æ”¾é€çµé­‚ï¼šå¯¹éšæœºç›®æ ‡é€ æˆé«˜é¢ä¼¤å®³+ææƒ§
        else if (bossAction === 'banish_soul') {
            const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
            if (alivePlayers.length > 0) {
                // éšæœºé€‰æ‹©ä¸€ä¸ªç›®æ ‡
                const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);

                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    const raw = Math.floor((boss.attack || 0) * (boss.banishSoulMultiplier || 4));
                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);

                    // æŠ¤ç›¾å¸æ”¶
                    const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æ”¾é€çµé­‚ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);

                    // æ–½åŠ ææƒ§debuff
                    target.debuffs = target.debuffs || {};
                    target.debuffs.fear = {
                        duration: boss.fearDuration || 3
                    };
                    addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} é™·å…¥ã€ææƒ§ã€‘ï¼æ— æ³•è¡ŒåŠ¨ ${boss.fearDuration || 3} å›åˆ`);
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æ”¾é€çµé­‚ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }
        // çµé­‚æ”¶å‰²è€…ï¼šå¯¹æ‰€æœ‰ç›®æ ‡é€ æˆ(åå­—å†›æ•°é‡*2+3)Ã—æ”»å‡»çš„æš—å½±ä¼¤å®³
        else if (bossAction === 'soul_reaper') {
            const aliveCrusaders = (combat.minions || []).filter(m => m.hp > 0 && m.isCrusader).length;
            const multiplier = aliveCrusaders + (boss.soulReaperBaseMultiplier || 3);
            const totalDamage = Math.floor((boss.attack || 0) * multiplier);

            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çµé­‚æ”¶å‰²è€…ã€‘ï¼å½“å‰åå­—å†›æ•°é‡ï¼š${aliveCrusaders}ï¼Œä¼¤å®³å€ç‡ï¼š${multiplier}å€`);

            combat.playerStates.forEach((ps, pIdx) => {
                if (ps.currentHp <= 0) return;

                // æš—å½±ä¼¤å®³ï¼Œä½¿ç”¨é­”æ³•æŠ—æ€§å‡å…
                const magicResist = ps.char?.stats?.magicResist || 0;
                const resistReduction = getMagicResistDamageReduction(magicResist);
                let damage = Math.floor(totalDamage * (1 - resistReduction));

                // åº”ç”¨å—ä¼¤å‡å…
                const takenMult = ps.char?.stats?.damageTakenMult ?? 1;
                let buffTakenMult = 1;
                if (ps.buffs) {
                    ps.buffs.forEach(b => {
                        if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                    });
                }
                const versTakenMult = getVersatilityDamageTakenMult(ps.char?.stats?.versatility);

                damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * versTakenMult));

                // æŠ¤ç›¾å¸æ”¶
                const shieldResult = applyShieldAbsorb(ps, damage, logs, currentRound);
                ps.currentHp -= shieldResult.finalDamage;

                const resistPct = Math.round(resistReduction * 100);
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resistPct}%${shieldText}ï¼‰`);
            });
        }
    }

    // ==================== è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'dagran_thaurissan') {
        // æœ¬Bosséœ€è¦åœ¨æˆ˜æ–—ä¸­è®°å½•â€œæˆ˜æ–—æ€’å¼â€å å±‚
        combat.bossBuffs = combat.bossBuffs || {};
        combat.bossBuffs.battleShoutStacks = combat.bossBuffs.battleShoutStacks || 0;

        const shoutPct = Number(boss.battleShoutAttackPct ?? 0.10);
        const getEffectiveAttack = () => {
            const stacks = combat.bossBuffs.battleShoutStacks || 0;
            return Math.floor((boss.attack || 0) * (1 + stacks * shoutPct));
        };

        // ç«ç„°ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆå¹¶å¥—ç”¨ä¼¤å®³å‡å…/å…¨èƒ½ï¼‰
        const calcFireDamage = (playerState, rawDamage) => {
            const magicResist = playerState?.char?.stats?.magicResist || 0;
            const resistReduction = getMagicResistDamageReduction(magicResist);
            let damage = Math.floor((rawDamage || 0) * (1 - resistReduction));

            // åº”ç”¨å—ä¼¤å‡å…
            const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (playerState?.buffs) {
                playerState.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }
            const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * versTakenMult));

            return { damage, resistReduction };
        };

        // çƒˆç„°æ‰“å‡»ï¼šå¯¹å½“å‰å¦å…‹é€ æˆ 3Ã—ç«ç„°ä¼¤å®³ + 3Ã—ç‰©ç†ä¼¤å®³ï¼ˆå¯æ ¼æŒ¡ï¼‰
        if (bossAction === 'flame_strike') {
            const tIdx = pickAlivePlayerIndex(); // 1å·ä½ï¼ˆå¦å…‹ä½ï¼‰
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const atk = getEffectiveAttack();

                // â‘  ç«ç„°ä¼¤å®³
                const rawFire = Math.floor(atk * (boss.flameStrikeFireMultiplier || 3));
                const fireRes = calcFireDamage(target, rawFire);
                const shieldResultFire = applyShieldAbsorb(target, fireRes.damage, logs, currentRound);
                target.currentHp -= shieldResultFire.finalDamage;

                const fireResPct = Math.round(fireRes.resistReduction * 100);
                const fireShieldText = shieldResultFire.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResultFire.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çƒˆç„°æ‰“å‡»ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResultFire.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${fireResPct}%${fireShieldText}ï¼‰`);

                // â‘¡ ç‰©ç†ä¼¤å®³ï¼ˆå¯æ ¼æŒ¡ï¼‰
                if (target.currentHp > 0) {
                    const rawPhys = Math.floor(atk * (boss.flameStrikePhysicalMultiplier || 3));
                    const { damage: physDmg, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, rawPhys, true);

                    const shieldResultPhys = applyShieldAbsorb(target, physDmg, logs, currentRound);
                    target.currentHp -= shieldResultPhys.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResultPhys.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResultPhys.absorbed}` : '';
                    addLog(`â†’ åŒæ—¶é€ æˆ ${shieldResultPhys.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çƒˆç„°æ‰“å‡»ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

        // ç†”å²©çˆ†è£‚ï¼šå¯¹éšæœºç›®æ ‡é€ æˆ 3Ã—ç«ç„°ä¼¤å®³ï¼Œå¹¶ç•™ä¸‹ç¼çƒ§DOTï¼ˆ1.5Ã—æ”»å‡»ï¼ŒæŒç»­3å›åˆï¼‰
        else if (bossAction === 'lava_burst') {
            const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
            if (alivePlayers.length > 0) {
                const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);

                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    const atk = getEffectiveAttack();

                    const raw = Math.floor(atk * (boss.lavaBurstMultiplier || 3));
                    const fireRes = calcFireDamage(target, raw);

                    const shieldResult = applyShieldAbsorb(target, fireRes.damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const fireResPct = Math.round(fireRes.resistReduction * 100);
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ç†”å²©çˆ†è£‚ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${fireResPct}%${shieldText}ï¼‰`);

                    // æ–½åŠ ç¼çƒ§DOT
                    const dotDamage = Math.floor(atk * (boss.burnDoTMultiplier || 1.5));
                    const dotDuration = boss.burnDoTDuration || 3;

                    target.dots = target.dots || [];
                    const existing = target.dots.find(d => d.name === 'ç¼çƒ§');
                    if (existing) {
                        existing.damagePerTurn = dotDamage;
                        existing.duration = dotDuration;
                        existing.school = 'fire';
                        addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} çš„ã€ç¼çƒ§ã€‘æŒç»­æ—¶é—´åˆ·æ–°ï¼ˆæ¯å›åˆ ${dotDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ŒæŒç»­ ${dotDuration} å›åˆï¼‰`);
                    } else {
                        target.dots.push({
                            name: 'ç¼çƒ§',
                            type: 'dot',
                            school: 'fire',
                            damagePerTurn: dotDamage,
                            duration: dotDuration
                        });
                        addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} è·å¾—ã€ç¼çƒ§ã€‘ï¼šæ¯å›åˆ ${dotDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ŒæŒç»­ ${dotDuration} å›åˆ`);
                    }
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ç†”å²©çˆ†è£‚ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

        // æˆ˜æ–—æ€’å¼ï¼šæ”»å‡» +10%ï¼Œå¯å åŠ ï¼ŒæŒç»­æ•´åœºæˆ˜æ–—
        else if (bossAction === 'battle_shout') {
            combat.bossBuffs.battleShoutStacks += 1;
            const stacks = combat.bossBuffs.battleShoutStacks;
            const totalPct = Math.round(stacks * shoutPct * 100);
            const curAtk = getEffectiveAttack();
            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æˆ˜æ–—æ€’å¼ã€‘ï¼šæ”»å‡»æé«˜ +${Math.round(shoutPct * 100)}%ï¼ˆå½“å‰${stacks}å±‚ï¼Œæ€»æå‡${totalPct}%ï¼‰ï¼Œå½“å‰æ”»å‡» ${curAtk}`);
        }
    }


    // ==================== é»‘æš—é™¢é•¿åŠ ä¸æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'darkmaster_gandling') {
        // æš—å½±ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆè€ƒè™‘ã€æš—å½±è¯…å’’ã€‘é­”æŠ—é™ä½ï¼‰
        const getEffectiveMagicResist = (playerState) => {
            const base = playerState?.char?.stats?.magicResist || 0;
            const curseDelta = playerState?.debuffs?.shadowCurse?.magicResistDelta || 0;
            return base + curseDelta;
        };

        const calcShadowDamage = (playerState, rawDamage) => {
            const magicResist = getEffectiveMagicResist(playerState);
            const resistReduction = getMagicResistDamageReduction(magicResist);
            let damage = Math.floor((rawDamage || 0) * (1 - resistReduction));

            // åº”ç”¨å—ä¼¤å‡å…
            const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (playerState?.buffs) {
                playerState.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }
            const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * versTakenMult));

            return { damage, resistReduction, magicResist };
        };

        // æš—å½±ç®­ï¼šå¯¹å¦å…‹é€ æˆ5å€æ”»å‡»çš„æš—å½±ä¼¤å®³
        if (bossAction === 'shadow_bolt') {
            const tIdx = pickAlivePlayerIndex(); // 1å·ä½ï¼ˆå¦å…‹ä½ï¼‰
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.shadowBoltMultiplier || 5));
                const shadowRes = calcShadowDamage(target, raw);

                const shieldResult = applyShieldAbsorb(target, shadowRes.damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(shadowRes.resistReduction * 100);
                const mrText = Number(shadowRes.magicResist) < 0 ? `ï¼ˆæœ‰æ•ˆé­”æŠ— ${Math.floor(shadowRes.magicResist)}ï¼‰` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æš—å½±ç®­ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æš—å½±ç®­ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }
        // å¬å”¤äº¡çµå­¦å¾’
        else if (bossAction === 'summon_apprentices') {
            const aliveMinions = (combat.minions || []).filter(m => (m.hp ?? 0) > 0 && m.isApprentice);
            const need = Math.max(0, (boss.summonCount || 2) - aliveMinions.length);

            for (let i = 0; i < need; i++) {
                combat.minions.push({
                    hp: boss.minion.maxHp,
                    maxHp: boss.minion.maxHp,
                    attack: boss.attack,
                    defense: boss.defense,
                    isApprentice: true,
                    dots: []
                });
            }

            if (need > 0) {
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€å¬å”¤äº¡çµå­¦å¾’ã€‘å¬å”¤äº† ${need} ä¸ª${boss.minion.name}ï¼`);
                addLog(`â†’ ${boss.minion.name} å±æ€§ï¼šHP ${boss.minion.maxHp}ï¼Œæ”»å‡»/é˜²å¾¡ = Bossï¼›æ¯å›åˆéšæœºé‡Šæ”¾ã€æš—å½±ç®­ã€‘ï¼ˆ2Ã—Bossæ”»å‡»ï¼‰`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å¬å”¤äº¡çµå­¦å¾’ï¼Œä½†åœºä¸Šäº¡çµå­¦å¾’å·²æ»¡`);
            }
        }
        // æš—å½±è¯…å’’ï¼šéšæœºç›®æ ‡ï¼Œé­”æŠ— -100ï¼ŒæŒç»­4å›åˆ
        else if (bossAction === 'shadow_curse') {
            const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
            if (alivePlayers.length > 0) {
                const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);

                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    target.debuffs = target.debuffs || {};

                    const duration = boss.shadowCurseDuration || 4;
                    const delta = -Math.abs(Number(boss.shadowCurseMagicResistDown || 100));

                    // âœ… çŸ®äººï¼šçŸ³åƒå½¢æ€ - æœ¬åœºé¦–æ¬¡è¯…å’’å…ç–«
                    if (tryFirstDebuffImmunity(target, 'curse', tIdx, 'æš—å½±è¯…å’’')) {
                        addLog(`â†’ ã€æš—å½±è¯…å’’ã€‘è¢«å…ç–«ï¼Œæœªäº§ç”Ÿæ•ˆæœ`, 'debuff');
                    } else {
                        target.debuffs.shadowCurse = {
                            type: 'curse',
                            magicResistDelta: delta,
                            duration
                        };

                        addLog(`ã€${boss.name}ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} æ–½æ”¾ã€æš—å½±è¯…å’’ã€‘ï¼šé­”æ³•æŠ—æ€§ ${delta}ï¼ŒæŒç»­ ${duration} å›åˆ`, 'debuff');
                    }
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æš—å½±è¯…å’’ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }
        // é»‘æš—é£æš´ï¼š3å€æ”»å‡»æš—å½±ä¼¤å®³ï¼ˆåˆ†æ•£ï¼šéšæœºå•ä½“ï¼›é›†ä¸­ï¼šå…¨ä½“ï¼‰
        else if (bossAction === 'dark_storm') {
            const raw = Math.floor((boss.attack || 0) * (boss.darkStormMultiplier || 3));

            if (combat.strategy.stance === 'dispersed') {
                const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
                if (alivePlayers.length > 0) {
                    const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                    const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);

                    if (tIdx >= 0) {
                        const target = combat.playerStates[tIdx];
                        const shadowRes = calcShadowDamage(target, raw);

                        const shieldResult = applyShieldAbsorb(target, shadowRes.damage, logs, currentRound);
                        target.currentHp -= shieldResult.finalDamage;

                        const resPct = Math.round(shadowRes.resistReduction * 100);
                        const mrText = Number(shadowRes.magicResist) < 0 ? `ï¼ˆæœ‰æ•ˆé­”æŠ— ${Math.floor(shadowRes.magicResist)}ï¼‰` : '';
                        const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                        addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é»‘æš—é£æš´ã€‘ï¼ˆåˆ†æ•£ç«™ä½ï¼‰å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
                    }
                } else {
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é»‘æš—é£æš´ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é»‘æš—é£æš´ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰ï¼Œæ‰€æœ‰è§’è‰²å—åˆ°ä¼¤å®³ï¼`);

                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;

                    const shadowRes = calcShadowDamage(ps, raw);
                    const shieldResult = applyShieldAbsorb(ps, shadowRes.damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(shadowRes.resistReduction * 100);
                    const mrText = Number(shadowRes.magicResist) < 0 ? `ï¼ˆæœ‰æ•ˆé­”æŠ— ${Math.floor(shadowRes.magicResist)}ï¼‰` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
                });
            }
        }
    }

    // ==================== ç‘æ–‡æˆ´å°”ç”·çˆµæŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'baron_rivendare') {
        // æš—å½±ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆå¹¶å¥—ç”¨ä¼¤å®³å‡å…/å…¨èƒ½ï¼‰
        const calcShadowDamage = (playerState, rawDamage) => {
            const magicResist = playerState?.char?.stats?.magicResist || 0;
            const resistReduction = getMagicResistDamageReduction(magicResist);
            let damage = Math.floor((rawDamage || 0) * (1 - resistReduction));

            // åº”ç”¨å—ä¼¤å‡å…
            const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (playerState?.buffs) {
                playerState.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }
            const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * versTakenMult));

            return { damage, resistReduction, magicResist };
        };

        // é¡ºåŠˆæ–©ï¼šåˆ†æ•£=æ‰“å¦å…‹ï¼›é›†ä¸­=æ‰“å…¨ä½“ï¼ˆ5Ã—æ”»å‡»ï¼Œç‰©ç†ï¼‰
        if (bossAction === 'cleave') {
            const raw = Math.floor((boss.attack || 0) * (boss.cleaveMultiplier || 5));

            if (combat.strategy.stance === 'dispersed') {
                const tIdx = pickAlivePlayerIndex();
                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);
                    const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼ˆåˆ†æ•£ç«™ä½ï¼‰å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                } else {
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰ï¼Œæ‰€æœ‰è§’è‰²å—åˆ°ä¼¤å®³ï¼`);
                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;
                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(ps, raw, true);
                    const shieldResult = applyShieldAbsorb(ps, damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                });
            }
        }

        // è‡´æ­»æ‰“å‡»ï¼šå¯¹å¦å…‹ 4Ã—æ”»å‡»ç‰©ç†ä¼¤å®³ + å‡ç–—50%
        else if (bossAction === 'mortal_strike') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.mortalStrikeMultiplier || 4));
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);

                const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                // æ–½åŠ å‡ç–—debuffï¼ˆå‚è€ƒèŒƒå…‹é‡Œå¤«ï¼‰
                target.debuffs = target.debuffs || {};
                target.debuffs.mortalStrike = {
                    healingReduction: boss.mortalStrikeDebuff?.healingReduction ?? 0.5,
                    duration: boss.mortalStrikeDebuff?.duration ?? 2
                };

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è‡´æ­»æ‰“å‡»ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰ï¼Œå¹¶æ–½åŠ ã€è‡´æ­»æ‰“å‡»ã€‘å‡ç–—${Math.round((boss.mortalStrikeDebuff?.healingReduction ?? 0.5) * 100)}%ï¼ˆæŒç»­${boss.mortalStrikeDebuff?.duration ?? 2}å›åˆï¼‰`, 'debuff');
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è‡´æ­»æ‰“å‡»ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

        // å¬å”¤éª·é«…å¤§å†›ï¼šå¬å”¤5ä¸ªéª·é«…ï¼ˆå¡«å……åˆ°ä¸Šé™ï¼‰
        else if (bossAction === 'summon_skeleton_army') {
            const aliveSkeletons = (combat.minions || []).filter(m => (m.hp ?? 0) > 0 && m.isSkeleton);
            const need = Math.max(0, (boss.summonCount || 5) - aliveSkeletons.length);

            for (let i = 0; i < need; i++) {
                combat.minions.push({
                    hp: boss.minion.maxHp,
                    maxHp: boss.minion.maxHp,
                    attack: boss.attack,
                    defense: boss.minion.defense,
                    isSkeleton: true,
                    dots: []
                });
            }

            if (need > 0) {
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€å¬å”¤éª·é«…å¤§å†›ã€‘å¬å”¤äº† ${need} ä¸ª${boss.minion.name}ï¼`);
                addLog(`â†’ ${boss.minion.name}ï¼šHP ${boss.minion.maxHp}ï¼ŒæŒ¥ç æ”»å‡» = ${boss.skeletonSlashMultiplier || 1.2}Ã—Bossæ”»å‡»ï¼ˆåªæ”»å‡»å¦å…‹ï¼‰`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å¬å”¤éª·é«…å¤§å†›ï¼Œä½†åœºä¸Šéª·é«…å·²æ»¡`);
            }
        }

        // æš—å½±éœ‡å‡»ï¼šå¯¹å¦å…‹ 3Ã—æ”»å‡»æš—å½±ä¼¤å®³ + DOTï¼ˆ1.5Ã—æ”»å‡»ï¼ŒæŒç»­3å›åˆï¼‰
        else if (bossAction === 'shadow_shock') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];

                const raw = Math.floor((boss.attack || 0) * (boss.shadowShockMultiplier || 3));
                const shadowRes = calcShadowDamage(target, raw);
                const shieldResult = applyShieldAbsorb(target, shadowRes.damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(shadowRes.resistReduction * 100);
                const mrText = Number(shadowRes.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(shadowRes.magicResist)}ï¼‰` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æš—å½±éœ‡å‡»ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);

                // æ–½åŠ DOT
                const dotDamage = Math.floor((boss.attack || 0) * (boss.shadowShockDotMultiplier || 1.5));
                const dotDuration = boss.shadowShockDotDuration || 3;

                target.dots = target.dots || [];
                const existing = target.dots.find(d => d.name === 'æš—å½±éœ‡å‡»');
                if (existing) {
                    existing.damagePerTurn = dotDamage;
                    existing.duration = dotDuration;
                    existing.school = 'shadow';
                    addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} çš„ã€æš—å½±éœ‡å‡»ã€‘æŒç»­æ—¶é—´åˆ·æ–°ï¼ˆæ¯å›åˆ ${dotDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ŒæŒç»­ ${dotDuration} å›åˆï¼‰`);
                } else {
                    target.dots.push({
                        name: 'æš—å½±éœ‡å‡»',
                        type: 'dot',
                        school: 'shadow',
                        damagePerTurn: dotDamage,
                        duration: dotDuration
                    });
                    addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} è·å¾—ã€æš—å½±éœ‡å‡»ã€‘ï¼šæ¯å›åˆ ${dotDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ŒæŒç»­ ${dotDuration} å›åˆ`);
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æš—å½±éœ‡å‡»ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }
    }

    // ==================== é›·å¾·Â·é»‘æ‰‹æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'rend_blackhand') {
        // ç«ç„°ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆå¹¶å¥—ç”¨ä¼¤å®³å‡å…/å…¨èƒ½ï¼‰
        const calcFireDamage = (playerState, rawDamage) => {
            const magicResist = playerState?.char?.stats?.magicResist || 0;
            const resistReduction = getMagicResistDamageReduction(magicResist);
            let damage = Math.floor((rawDamage || 0) * (1 - resistReduction));

            // åº”ç”¨å—ä¼¤å‡å…
            const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (playerState?.buffs) {
                playerState.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }
            const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * versTakenMult));

            return { damage, resistReduction, magicResist };
        };

        // æŠ€èƒ½1ï¼šçƒˆç„°åæ¯
        // å¯¹å¦å…‹é€ æˆ 4Ã—æ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡ï¼‰ï¼Œå¹¶å¯¹å…¨é˜Ÿè¿½åŠ ä¸€æ¬¡â€œå¦å…‹å®é™…æ‰¿ä¼¤â€çš„ç«ç„°ä¼¤å®³
        if (bossAction === 'flame_breath') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.flameBreathMultiplier || 4));
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);
                const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çƒˆç„°åæ¯ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);

                const splashBase = shieldResult.finalDamage;
                if (splashBase <= 0) {
                    addLog(`â†’ çƒˆç„°åæ¯çš„ç‰©ç†ä¼¤å®³è¢«å®Œå…¨å¸æ”¶ï¼Œæœªè§¦å‘é¢å¤–ç«ç„°ä¼¤å®³`);
                } else {
                    addLog(`â†’ çƒˆç„°å–·æ¶Œï¼šå…¨é˜Ÿé¢å¤–å—åˆ°ä¸€æ¬¡ç«ç„°ä¼¤å®³ï¼ˆåŸºå‡† ${splashBase}ï¼ŒæŒ‰å„è‡ªé­”æŠ—ç»“ç®—ï¼‰`);
                    combat.playerStates.forEach((ps, pIdx) => {
                        if (ps.currentHp <= 0) return;

                        const fireRes = calcFireDamage(ps, splashBase);
                        const shieldRes2 = applyShieldAbsorb(ps, fireRes.damage, logs, currentRound);
                        ps.currentHp -= shieldRes2.finalDamage;

                        const resPct = Math.round(fireRes.resistReduction * 100);
                        const mrText = Number(fireRes.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fireRes.magicResist)}ï¼‰` : '';
                        const shieldText2 = shieldRes2.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldRes2.absorbed}` : '';
                        addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldRes2.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText2}ï¼‰`);
                    });
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çƒˆç„°åæ¯ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

            // æŠ€èƒ½2ï¼šé¡ºåŠˆæ–©
        // åˆ†æ•£ï¼šæ‰“å¦å…‹ï¼›é›†ä¸­ï¼šæ‰“å…¨ä½“ï¼ˆ2Ã—æ”»å‡»ï¼Œç‰©ç†ï¼‰
        else if (bossAction === 'cleave') {
            const raw = Math.floor((boss.attack || 0) * (boss.cleaveMultiplier || 2));

            if (combat.strategy.stance === 'dispersed') {
                const tIdx = pickAlivePlayerIndex();
                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);
                    const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼ˆåˆ†æ•£ç«™ä½ï¼‰å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                } else {
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰ï¼Œæ‰€æœ‰è§’è‰²å—åˆ°ä¼¤å®³ï¼`);
                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;
                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(ps, raw, true);
                    const shieldResult = applyShieldAbsorb(ps, damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                });
            }
        }

            // æŠ€èƒ½3ï¼šè·³è·ƒæ–©å‡»
        // é›†ä¸­ï¼šæ‰“å¦å…‹ï¼›åˆ†æ•£ï¼šéšæœºéå¦å…‹ï¼ˆ4Ã—æ”»å‡»ï¼Œç‰©ç†ï¼‰
        else if (bossAction === 'leap_slash') {
            const tankIdx = pickAlivePlayerIndex();
            if (tankIdx < 0) {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è·³è·ƒæ–©å‡»ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            } else {
                const raw = Math.floor((boss.attack || 0) * (boss.leapSlashMultiplier || 4));

                let targetIdx = tankIdx;
                let modeText = 'ï¼ˆé›†ä¸­ç«™ä½ï¼‰';

                if (combat.strategy.stance === 'dispersed') {
                    const candidates = combat.playerStates
                        .map((ps, idx) => ({ ps, idx }))
                        .filter(o => (o.ps?.currentHp ?? 0) > 0 && o.idx !== tankIdx)
                        .map(o => o.idx);

                    if (candidates.length > 0) {
                        targetIdx = candidates[Math.floor(Math.random() * candidates.length)];
                        modeText = 'ï¼ˆåˆ†æ•£ç«™ä½ï¼šéšæœºç›®æ ‡ï¼‰';
                    } else {
                        modeText = 'ï¼ˆåˆ†æ•£ç«™ä½ï¼šä»…å‰©å¦å…‹ï¼‰';
                    }
                }

                const target = combat.playerStates[targetIdx];
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);
                const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è·³è·ƒæ–©å‡»ã€‘${modeText}å‘½ä¸­ ä½ç½®${targetIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
            }
        }
    }

// ==================== å°å¼Ÿè¡ŒåŠ¨ ====================
    for (let i = 0; i < (combat.minions || []).length; i++) {
        const m = combat.minions[i];
        if ((m.hp ?? 0) <= 0) continue;

        // èŒƒå…‹é‡Œå¤«çš„ç«ç‚®æ‰‹ï¼šå¯¹å…¨é˜Ÿé€ æˆAOEä¼¤å®³
        if (combat.bossId === 'vancleef' && m.isCannoneer) {
            const baseAoeDamage = Math.floor((boss.attack || 0) * (boss.minion.aoeDamageMultiplier || 0.5));

            combat.playerStates.forEach((ps, pIdx) => {
                if (ps.currentHp <= 0) return;

                const armor = ps.char?.stats?.armor || 0;
                const dr = getArmorDamageReduction(armor);
                let dmg = applyPhysicalMitigation(baseAoeDamage, armor);

                // å—ä¼¤ä¹˜åŒº
                const takenMult = ps.char?.stats?.damageTakenMult ?? 1;
                let buffTakenMult = 1;
                if (ps.buffs) {
                    ps.buffs.forEach(b => {
                        if (b.damageTakenMult) {
                            buffTakenMult *= b.damageTakenMult;
                        }
                    });
                }
                const demoralizingShoutMult = combat.bossDebuffs?.demoralizingShout?.damageMult ?? 1;
                const versTakenMult = getVersatilityDamageTakenMult(ps.char?.stats?.versatility);
                dmg = Math.max(1, Math.floor(dmg * takenMult * buffTakenMult * demoralizingShoutMult * versTakenMult));

                // æŠ¤ç›¾å¸æ”¶
                const shieldResult = applyShieldAbsorb(ps, dmg, logs, currentRound);
                ps.currentHp -= shieldResult.finalDamage;

                // âœ… ä¿®å¤ï¼šè®¡ç®— drPct
                const drPct = Math.round(dr * 100);
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.minion.name}${i + 1}ã€‘ç‚®å‡» ä½ç½®${pIdx + 1} ${ps.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${shieldText}ï¼‰`);
            });
        }
// åŠ ä¸çš„äº¡çµå­¦å¾’ï¼šæ¯å›åˆéšæœºé‡Šæ”¾æš—å½±ç®­
        else if (combat.bossId === 'darkmaster_gandling' && m.isApprentice) {
            const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
            if (alivePlayers.length <= 0) break;

            // éšæœºé€‰æ‹©ä¸€ä¸ªç›®æ ‡
            const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
            const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);
            if (tIdx < 0) continue;

            const target = combat.playerStates[tIdx];

            // è®¡ç®—æœ‰æ•ˆé­”æŠ—ï¼ˆè€ƒè™‘ã€æš—å½±è¯…å’’ã€‘ï¼‰
            const baseMR = target.char?.stats?.magicResist || 0;
            const curseDelta = target.debuffs?.shadowCurse?.magicResistDelta || 0;
            const effectiveMR = baseMR + curseDelta;

            const raw = Math.floor((boss.attack || 0) * (boss.minionShadowBoltMultiplier || 2));
            const resistReduction = getMagicResistDamageReduction(effectiveMR);
            let damage = Math.floor(raw * (1 - resistReduction));

            // åº”ç”¨å—ä¼¤å‡å…
            const takenMult = target?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (target?.buffs) {
                target.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }
            const versTakenMult = getVersatilityDamageTakenMult(target?.char?.stats?.versatility);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * versTakenMult));

            // æŠ¤ç›¾å¸æ”¶
            const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
            target.currentHp -= shieldResult.finalDamage;

            const resPct = Math.round(resistReduction * 100);
            const mrText = effectiveMR < 0 ? `ï¼ˆæœ‰æ•ˆé­”æŠ— ${Math.floor(effectiveMR)}ï¼‰` : '';
            const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
            const minionName = boss.minion?.name || 'äº¡çµå­¦å¾’';
            addLog(`ã€${minionName}${i + 1}ã€‘æ–½æ”¾ã€æš—å½±ç®­ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
        }

        // ç‘æ–‡æˆ´å°”ç”·çˆµçš„éª·é«…ï¼šå¯¹å¦å…‹ï¼ˆ1å·ä½ï¼‰æŒ¥ç æ”»å‡»
        else if (combat.bossId === 'baron_rivendare' && m.isSkeleton) {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx < 0) break;

            const target = combat.playerStates[tIdx];
            const raw = Math.floor((boss.attack || 0) * (boss.skeletonSlashMultiplier || 1.2));
            const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, false);

            const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
            target.currentHp -= shieldResult.finalDamage;

            const drPct = Math.round(dr * 100);
            const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
            const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
            const minionName = boss.minion?.name || 'éª·é«…æˆ˜å£«';
            addLog(`ã€${minionName}${i + 1}ã€‘æŒ¥ç  ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
        }
// éœæ ¼çš„å°å¼Ÿï¼šæ™®é€šæ”»å‡»
        else {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx < 0) break;

            const target = combat.playerStates[tIdx];
            const raw = Math.floor(m.attack || 0);
            const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, false);

            target.currentHp -= damage;

            const drPct = Math.round(dr * 100);
            const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
            const minionName = boss.minion?.name || 'å°å¼Ÿ';
            addLog(`ã€${minionName}ã€‘æ”»å‡» ä½ç½®${tIdx + 1} é€ æˆ ${damage} ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}ï¼‰`);
        }
        // è¨å°”è¯ºæ–¯çš„åå­—å†›ï¼šå¯¹å¦å…‹ï¼ˆ1å·ä½ï¼‰é€ æˆæ™®é€šæ”»å‡»
        if (combat.bossId === 'thalnos' && m.isCrusader) {
            const tIdx = pickAlivePlayerIndex(); // æ€»æ˜¯æ‰“1å·ä½ï¼ˆå¦å…‹ï¼‰
            if (tIdx < 0) break;

            const target = combat.playerStates[tIdx];
            const raw = Math.floor(m.attack || boss.attack || 0);
            const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, false);

            // æŠ¤ç›¾å¸æ”¶
            const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
            target.currentHp -= shieldResult.finalDamage;

            const drPct = Math.round(dr * 100);
            const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
            const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
            addLog(`ã€${boss.minion.name}${i + 1}ã€‘æ”»å‡» ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
        }
    }

    // æ¸…ç†æ­»äº¡å°å¼Ÿ
    combat.minions = (combat.minions || []).filter(m => (m.hp ?? 0) > 0);

    // ==================== ç©å®¶èº«ä¸Šçš„DOTç»“ç®— ====================
    combat.playerStates.forEach((ps, pIdx) => {
        if (ps.currentHp <= 0) return;
        if (!ps.dots || ps.dots.length === 0) return;

        ps.dots = ps.dots.filter(dot => {
            // âœ… çŸ®äººï¼šçŸ³åƒå½¢æ€ - æœ¬åœºé¦–æ¬¡ä¸­æ¯’å…ç–«
            // çº¦å®šï¼špoison DOT ä½¿ç”¨ school: 'poison'ï¼ˆæˆ–æ˜¾å¼ type/isPoison æ ‡è®°ï¼‰
            const isPoisonDot = dot?.school === 'poison' || dot?.type === 'poison' || dot?.isPoison === true;
            if (isPoisonDot && tryFirstDebuffImmunity(ps, 'poison', pIdx, dot?.name || 'ä¸­æ¯’')) {
                addLog(`â†’ ã€${dot?.name || 'ä¸­æ¯’'}ã€‘è¢«å…ç–«ï¼Œæœªäº§ç”Ÿä¼¤å®³`, 'debuff');
                return false;
            }

            // DOTä¼¤å®³ç±»å‹ï¼š
            // - physicalï¼šæ²¿ç”¨ç°æœ‰é€»è¾‘ï¼ˆä¸»è¦ç”¨äºâ€œæµè¡€â€ï¼‰
            // - å…¶ä»–ï¼ˆfire/shadow/...ï¼‰ï¼šæŒ‰é­”æŠ—å‡ä¼¤ï¼ˆæ»¡è¶³â€œç«ç„°ä¼¤å®³è®¡ç®—é­”æŠ—â€è®¾è®¡ï¼‰
            const versTakenMult = getVersatilityDamageTakenMult(ps.char?.stats?.versatility);

            let base = Math.floor(dot.damagePerTurn || 0);
            let extraText = '';

            if (dot.school && dot.school !== 'physical') {
                const magicResist = ps.char?.stats?.magicResist || 0;
                const resistReduction = getMagicResistDamageReduction(magicResist);
                base = Math.floor(base * (1 - resistReduction));
                extraText = `ï¼ˆé­”æŠ—å‡ä¼¤${Math.round(resistReduction * 100)}%ï¼‰`;
            }

            const dmg = Math.max(1, Math.floor(base * versTakenMult));
            ps.currentHp -= dmg;

            const stackText = dot.stacks ? `ï¼ˆ${dot.stacks}å±‚ï¼‰` : '';
            addLog(`ã€${dot.name}ã€‘${stackText}å¯¹ ä½ç½®${pIdx + 1} ${ps.char.name} é€ æˆ ${dmg} ç‚¹${dot.school === 'physical' ? 'æµè¡€' : ''}ä¼¤å®³${extraText}ï¼ˆå‰©ä½™${dot.duration - 1}å›åˆï¼‰`);

            // æ°¸ä¹…DOTä¸å‡å°‘æŒç»­æ—¶é—´
            if (!dot.isPermanent) {
                dot.duration -= 1;
            }
            return dot.duration > 0 || dot.isPermanent;
        });
    });

    // ==================== èƒœè´Ÿåˆ¤å®š ====================
    const allPlayersDead = combat.playerStates.every(p => p.currentHp <= 0);
    const bossDead = combat.bossHp <= 0;

    if (bossDead || allPlayersDead) {
        let newState = {
            ...state,
            bossCombat: null
        };

        if (bossDead) {
            addLog('â˜…â˜…â˜… èƒœåˆ©ï¼è·å¾—å¥–åŠ± â˜…â˜…â˜…');

            // ===== ä¸–ç•ŒBossé‡ç”Ÿå†·å´ï¼š30åˆ†é’Ÿ =====
            newState.bossCooldowns = {
                ...(newState.bossCooldowns || {}),
                [combat.bossId]: 30 * 60
            };

            // ===== è·¨ä¸–ç´¯è®¡å‡»æ€æ¬¡æ•°ï¼ˆç”¨äºè§£é”è‡ªåŠ¨å‡»æ€ï¼‰ =====
            newState.worldBossKillCounts = {
                ...(newState.worldBossKillCounts || {}),
                [combat.bossId]: (newState.worldBossKillCounts?.[combat.bossId] || 0) + 1
            };

            if (!newState.defeatedBosses) newState.defeatedBosses = [];
            if (!newState.defeatedBosses.includes(combat.bossId)) {
                newState.defeatedBosses = [...newState.defeatedBosses, combat.bossId];
            }

            const alreadyDefeated = (state.defeatedBosses || []).includes('hogger');
            if (bossDead && combat.bossId === 'hogger' && !alreadyDefeated) {
                newState.showHoggerPlot = true;
            }

            newState.resources = {
                ...newState.resources,
                gold: newState.resources.gold + getEffectiveGoldGain(boss.rewards.gold, newState)
            };

            newState.characters = newState.characters.map(char => {
                const p = combat.playerStates.find(ps => ps.char.id === char.id);
                if (!p) return char;

                let gainedExp = boss.rewards.exp * (1 + (char.stats.expBonus || 0));
                let newChar = { ...char, exp: char.exp + gainedExp };

                while (newChar.exp >= newChar.expToNext && newChar.level < 200) {
                    newChar.level += 1;
                    newChar.exp -= newChar.expToNext;
                    newChar.expToNext = Math.floor(100 * Math.pow(1.2, newChar.level - 1));
                    newChar.skills = learnNewSkills(newChar);
                }

                newChar.stats = calculateTotalStats(newChar, undefined, state);
                return newChar;
            });

            boss.rewards.items.forEach(itemTpl => {
                const dropId = (typeof itemTpl === 'string') ? itemTpl : itemTpl?.id;
                if (!dropId) return;

                if (newState.dropFilters?.[dropId] === false) return;

                // ===== æ¦‚ç‡åˆ¤å®šï¼ˆå åŠ æ‰è½å¢å¹…ï¼šæˆå°± + å¯»é¾™ä¼šï¼‰ =====
                const baseDropChance = itemTpl?.chance ?? 1;  // é»˜è®¤100%
                const dropChance = getEffectiveDropChance(baseDropChance, newState);
                if (Math.random() > dropChance) return;   // æœªå‘½ä¸­åˆ™è·³è¿‡

                if (FIXED_EQUIPMENTS?.[dropId]) {
                    const inst = createEquipmentInstance(dropId);
                    newState.inventory.push(inst);
                    newState = addEquipmentIdToCodex(newState, dropId);
                    return;
                }

                const tpl = ITEMS?.[dropId];
                if (tpl) {
                    newState.inventory.push({
                        ...tpl,
                        instanceId: `inv_${Date.now()}_${Math.random()}`,
                        id: tpl.id,
                    });
                    newState = addJunkIdToCodex(newState, dropId);
                    return;
                }

                newState.inventory.push({
                    instanceId: `boss_${Date.now()}_${Math.random()}`,
                    id: dropId,
                    name: dropId,
                    type: 'junk',
                });
            });

        } else {
            addLog('Ã—Ã—Ã— å¤±è´¥ï¼Œå…¨é˜Ÿé˜µäº¡ Ã—Ã—Ã—');

            // âœ… ç»Ÿè®¡ï¼šBOSSæŒ‘æˆ˜è¶…è¿‡4å›åˆåå¤±è´¥æ¬¡æ•°ï¼ˆç”¨äºæˆå°±ã€é“å¿ƒæ¾„æ¾ˆâ… /â…¡ã€‘ï¼‰
            if ((combat.round || 0) > 4) {
                const prev = newState.stats?.bossLateRoundDefeats || 0;
                newState.stats = { ...(newState.stats || {}), bossLateRoundDefeats: prev + 1 };
            }
        }

        const bossLogEntry = {
            id: `bosslog_${Date.now()}_${Math.random()}`,
            timestamp: Date.now(),
            characterName: 'é˜Ÿä¼',
            zoneName: 'ä¸–ç•Œé¦–é¢†',
            enemyName: boss.name,
            result: bossDead ? 'victory' : 'defeat',
            logs: logs,
            rewards: bossDead
                ? { gold: boss.rewards.gold, exp: boss.rewards.exp }
                : { gold: 0, exp: 0 },
        };

        newState.combatLogs = [bossLogEntry, ...(newState.combatLogs || [])].slice(0, 50);

        return newState;
    }

    // ç»§ç»­æˆ˜æ–—
    combat.logs = logs.slice(-50);

    const syncedCharacters = (state.characters || []).map(c => {
        const ps = combat.playerStates?.find(p => p.char?.id === c.id);
        if (!ps) return c;

        const maxHp = c.stats?.maxHp ?? ps.char?.stats?.maxHp ?? 0;
        const nextHp = Math.min(maxHp, Math.max(0, Math.floor(ps.currentHp ?? 0)));

        return {
            ...c,
            stats: { ...c.stats, currentHp: nextHp }
        };
    });

    return { ...state, characters: syncedCharacters, bossCombat: combat };
}


// ==================== INITIAL STATE ====================
const initialState = {
    currentMenu: 'map',
    frame: 0,      // æ€»å¸§
    lifeFrame: 0,  // æœ¬ä¸–å¸§
    // å½“å‰æ—¶é—´æ®µï¼ˆç”¨äºæš—å¤œç²¾çµã€ç²¾çµç²¾é­„ã€‘ç­‰æ—¶é—´æ®µè¢«åŠ¨ï¼›6:00-18:00=dayï¼‰
    nightElfSpiritPhase: (() => {
        const h = new Date().getHours();
        const cfg = RACE_TRAITS?.['æš—å¤œç²¾çµ']?.timeBasedStatBonus || {};
        const dayStart = Number.isFinite(Number(cfg.dayStart)) ? Number(cfg.dayStart) : 6;
        const nightStart = Number.isFinite(Number(cfg.nightStart)) ? Number(cfg.nightStart) : 18;
        const isDay = dayStart < nightStart
            ? (h >= dayStart && h < nightStart)
            : (h >= dayStart || h < nightStart);
        return isDay ? 'day' : 'night';
    })(),
    characters: [],
    characterSlots: 1,
    maxCharacterSlots: 15,
    resources: {
        gold: 500,
        wood: 200,
        ironOre: 50,
        ironIngot: 10,
        herb: 30,
        leather: 20,
        magicEssence: 5,
        alchemyOil: 5,
        population: 0,
        maxPopulation: 0,
    },
    buildings: {},  // â† æ·»åŠ è¿™ä¸€è¡Œ
    // åŠŸèƒ½å»ºç­‘æ•°é‡
    functionalBuildings: {},
    // èµ„æºå»ºç­‘å·¥äººåˆ†é… { buildingId: [charId1, charId2, ...] }
    resourceAssignments: {},
    research: {},
    currentResearch: null,
    researchProgress: 0,
    inventory: [],
    inventorySize: 80,
    inventorySizeExtra: 0,
    achievements: {},
    codex: [],
    codexJunk: [],
    zones: JSON.parse(JSON.stringify(ZONES)),
    assignments: {},
    combatLogs: [],
    stats: { battlesWon: 0, totalDamage: 0, totalHealing: 0, bossLateRoundDefeats: 0, grandVaultPicks: 0 },
    // åœ°å›¾åŒºåŸŸå‡»æ€ç»Ÿè®¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä¸ä¼šéšè½®å›/é‡ç”Ÿé‡ç½®ï¼‰
    // ä¾‹å¦‚ï¼š{ elwynn_forest: 12345 }
    zoneKillCounts: {},
    worldBossProgress: {},
    lastOnlineTime: Date.now(),
    offlineRewards: null,
    dropFilters: {}, // { [itemId]: true/false }  true=å…è®¸æ‰è½  false=ç¦æ­¢æ‰è½
    codexEquipLv100: [], // è®°å½•æ›¾ç»åˆ°è¿‡Lv100çš„è£…å¤‡æ¨¡æ¿idï¼ˆæ°¸ä¹…äº®æ¡†ï¼‰
    prepareBoss: null, // å½“å‰å‡†å¤‡æŒ‘æˆ˜çš„bossId
    bossTeam: [null, null, null], // 3ä¸ªä½ç½®çš„charId
    bossStrategy: { priorityBoss: true, stance: 'dispersed' }, // ç­–ç•¥
    bossCombat: null, // æ­£åœ¨è¿›è¡Œçš„bossæˆ˜çŠ¶æ€

    bossCooldowns: {}, // { [bossId]: remainingSeconds } ä¸–ç•ŒBossé‡ç”Ÿå†·å´ï¼ˆç§’ï¼‰

    // ===== ä¸–ç•Œé¦–é¢†è‡ªåŠ¨å‡»æ€ï¼ˆè·¨ä¸–ç´¯è®¡ï¼‰ =====
    // worldBossKillCounts: { [bossId]: number }   æ‰€æœ‰ä¸–(é‡ç”Ÿ)ç´¯è®¡å‡»æ€æ¬¡æ•°
    // worldBossAutoKill:  { [bossId]: boolean }  æ˜¯å¦å¼€å¯â€œCDç»“æŸåè‡ªåŠ¨å‡»æ€â€
    worldBossKillCounts: {},
    worldBossAutoKill: {},

    // ===== å®ä¼Ÿå®åº“ï¼ˆæ¯æ—¥æ—©ä¸Š 9 ç‚¹åˆ·æ–°ï¼‰ =====
    // dayKeyï¼šä»¥â€œæ—©ä¸Š9ç‚¹â€ä¸ºåˆ†ç•Œçš„æ—¥å‘¨æœŸæ ‡è¯†ï¼ˆä¾‹å¦‚ 2026-02-02ï¼‰
    // rowsï¼šå½“æ—¥å®åº“å†…å®¹ï¼ˆæŒä¹…åŒ–ï¼Œé¿å…åå¤æ‰“å¼€åˆ·æ–°ä¸åŒç»“æœï¼‰
    // claimedDayKeyï¼šå·²é¢†å–çš„æ—¥å‘¨æœŸï¼ˆç”¨äºâ€œå½“æ—¥å·²é¢†å–â€åˆ¤å®šï¼‰
    grandVault: {
        dayKey: '',
        rows: null,
        // { [badgeId]: [templateId1, templateId2, templateId3] }
        badgePicks: {},
        claimedDayKey: '',
        lastRefreshAt: 0,
        claimedAt: 0,
    },

    showHoggerPlot: false,
    showRebirthConfirm: false,
    showRebirthPlot: null,
    // è¡€è‰²åå­—å†›çš„å¾½ç« ï¼šé€‰æ‹©ç›®æ ‡è£…å¤‡çš„ä¸´æ—¶çŠ¶æ€
    showScarletBadgeModal: false,
    pendingScarletBadgeInstanceId: null,
    pendingBadgeItemId: null,
    rebirthCount: 0,
    rebirthUnlocked: false,
    rebirthBonuses: {
        exp: 0,
        gold: 0,
        drop: 0,
        researchSpeed: 0
    },
    rebirthBonds: [],
    defeatedBosses: [], // æœ¬ä¸–å‡»æ€çš„Bossåˆ—è¡¨
    questProgress: {
        // ä»»åŠ¡é“¾è¿›åº¦
        // vancleef_wanted: {
        //     status: 'in_progress',
        //     currentStep: 'step_2_investigate',
        //     flags: ['knows_background', 'suspicious_of_nobles'],
        //     completedSteps: ['step_1_accept', 'step_1b_background'],
        //     completedBranch: null  // 'suppress_vancleef' æˆ– 'slay_prestor'
        // }
    },
    questItems: [],  // ä»»åŠ¡ç‰©å“
    completedQuestBranches: [],  // å·²å®Œæˆçš„ä»»åŠ¡åˆ†æ”¯ï¼ˆç”¨äºæˆå°±ç­‰ï¼‰
    questTitles: []  // è·å¾—çš„ç§°å·
};

// ==================== BASE64 ENCODING (æ”¯æŒä¸­æ–‡) ====================
function encodeBase64(str) {
    // å…ˆç”¨ encodeURIComponent è½¬æ¢æˆ UTF-8ï¼Œå†ç”¨ btoa ç¼–ç 
    return btoa(unescape(encodeURIComponent(str)));
}

function decodeBase64(str) {
    // å…ˆç”¨ atob è§£ç ï¼Œå†ç”¨ decodeURIComponent è½¬å› UTF-8
    return decodeURIComponent(escape(atob(str)));
}

// ==================== LOCAL STORAGE ====================
const SAVE_KEY = 'wow_idle_game_save';

function saveToLocalStorage(state) {
    try {
        const saveData = JSON.stringify(state);
        localStorage.setItem(SAVE_KEY, saveData);
    } catch (e) {
        console.error('Failed to save to localStorage:', e);
    }
}

function loadFromLocalStorage() {
    try {
        const saveData = localStorage.getItem(SAVE_KEY);
        if (saveData) {
            return JSON.parse(saveData);
        }
    } catch (e) {
        console.error('Failed to load from localStorage:', e);
    }
    return null;
}

// ==================== OFFLINE REWARDS CALCULATOR ====================
function calculateOfflineRewards(state, offlineSeconds) {
    const MAX_OFFLINE_SECONDS = 2 * 24 * 60 * 60;
    const actualSeconds = Math.min(offlineSeconds, MAX_OFFLINE_SECONDS);

    let rewards = {
        gold: 0,
        exp: {},
        items: [],
        kingdomResources: {},   // âœ… æ–°å¢ï¼šä¸»åŸèµ„æº
        researchProgress: 0,
        combats: 0,
        // ç¦»çº¿æœŸé—´å„åœ°å›¾åŒºåŸŸçš„å‡»æ€æ•°ï¼ˆcombat è§†ä¸ºå‡»æ€ 1 ä¸ªæ€ªç‰©ï¼‰
        killsByZone: {}
    };
    Object.entries(state.assignments).forEach(([charId, zoneId]) => {
        const character = state.characters.find(c => c.id === charId);
        const zone = state.zones[zoneId];

        if (character && zone && zone.enemies) {
            const combatsPerSecond = 0.1;
            const totalCombats = Math.floor(actualSeconds * combatsPerSecond);

            rewards.combats += totalCombats;

            // âœ… ç¦»çº¿æˆ˜æ–—ä¹Ÿè®¡å…¥åœ°å›¾åŒºåŸŸå‡»æ€è®¡æ•°ï¼ˆç”¨äºæˆå°±ï¼šåé‡Œå¡å‰‘åœ£ç­‰ï¼‰
            rewards.killsByZone[zoneId] = (rewards.killsByZone[zoneId] || 0) + totalCombats;

            for (let i = 0; i < totalCombats; i++) {
                const enemy = zone.enemies[Math.floor(Math.random() * zone.enemies.length)];
                rewards.gold += getEffectiveGoldGain(enemy.gold, state);

                if (!rewards.exp[charId]) {
                    rewards.exp[charId] = 0;
                }
                rewards.exp[charId] += enemy.exp * (1 + (character.stats?.expBonus || 0));

                if (Math.random() < 0.1 && zone.resources) {
                    const resourceName = zone.resources[Math.floor(Math.random() * zone.resources.length)];
                    rewards.kingdomResources[resourceName] = (rewards.kingdomResources[resourceName] || 0) + 1;
                }

                const dropTable = DROP_TABLES[zone.id];
                if (dropTable?.equipment) {
                    const allowDrop = (id) => state.dropFilters?.[id] !== false; // é»˜è®¤å…è®¸
                    dropTable.equipment.filter(drop => allowDrop(drop.id)).forEach(drop => {
                        const base = (drop.chance ?? 0);
                        const effective = getEffectiveDropChance(base, state);
                        if (Math.random() < effective) {
                            const inst = createEquipmentInstance(drop.id);
                            if (inst) rewards.items.push(inst);
                        }
                    });

                }
            }
        }
    });

    if (state.currentResearch) {
        const research = RESEARCH[state.currentResearch];
        if (research) {
            const level = state.research[state.currentResearch] || 0;
            const cost = Math.floor(research.baseCost * Math.pow(1.2, level));
            const progressPerSecond = state.resources.gold >= cost ? 1 : 0;
            rewards.researchProgress = actualSeconds * progressPerSecond;
        }
    }

    return {
        rewards,
        actualSeconds,
        maxSeconds: MAX_OFFLINE_SECONDS
    };
}

const ARMOR_DR_CAP = 0.99;
const ARMOR_K = 3000; // ä½ å¯ä»¥è°ƒå‚ï¼š1000/5000/10000...

// ==================== é­”æŠ—å‡ä¼¤ï¼ˆç»Ÿä¸€å…¬å¼ï¼‰ ====================
// ç»Ÿä¸€é­”æŠ—ç³»æ•°ï¼ˆè°ƒå‚åªæ”¹è¿™é‡Œï¼‰
const magicresist_k = 800;

// è¿”å› 0~1 çš„å‡ä¼¤æ¯”ä¾‹ï¼ˆå…è®¸ä¸ºè´Ÿï¼Œä»£è¡¨æ˜“ä¼¤ï¼›ä¾‹å¦‚ -0.2 è¡¨ç¤ºå¤šåƒ20%ä¼¤å®³ï¼‰
function getMagicResistDamageReduction(magicResist) {
    const mr = Number(magicResist) || 0;
    const denom = mr + magicresist_k;

    // é¿å… mr æ°å¥½ç­‰äº -K æ—¶é™¤ 0 å¯¼è‡´æ•°å€¼çˆ†ç‚¸
    if (Math.abs(denom) < 1e-9) {
        return mr >= 0 ? 0.999 : -0.999;
    }

    return mr / denom;
}

function getArmorDamageReduction(armor) {
    const a = Math.max(0, armor || 0);
    const dr = a / (a + ARMOR_K);
    return Math.min(ARMOR_DR_CAP, dr);
}

function applyPhysicalMitigation(rawDamage, armor) {
    const dr = getArmorDamageReduction(armor);
    const reduced = rawDamage * (1 - dr);
    return Math.max(1, Math.floor(reduced)); // è‡³å°‘1ç‚¹ä¼¤å®³
}


// ==================== å…¨èƒ½å‡ä¼¤ï¼ˆå—åˆ°ä¼¤å®³ï¼‰ ====================
// è§„åˆ™ï¼šå…¨èƒ½å±æ€§è¿˜èƒ½æä¾›å‡ä¼¤ï¼Œæ•°å€¼ä¸ºï¼ˆå…¨èƒ½/20ï¼‰% ï¼Œä¸Šé™50%
// ä¾‹å¦‚ï¼šå…¨èƒ½=20 => 1%å‡ä¼¤ï¼›å…¨èƒ½=1000 => 50%å‡ä¼¤ï¼ˆå°é¡¶ï¼‰
const VERSATILITY_DR_CAP = 0.5;

// è¿”å› 0~0.5 çš„å‡ä¼¤æ¯”ä¾‹ï¼ˆå¦‚ 0.12 è¡¨ç¤º12%å‡ä¼¤ï¼‰
function getVersatilityDamageReduction(versatility) {
    const v = Math.max(0, Number(versatility) || 0);
    // ï¼ˆå…¨èƒ½/20ï¼‰% => (v/20)/100 => v/2000
    return Math.min(VERSATILITY_DR_CAP, v / 2000);
}

// è¿”å› 0.5~1 çš„ä¹˜åŒºï¼ˆå¦‚ 0.88 è¡¨ç¤ºæ‰¿å—88%ä¼¤å®³ï¼‰
function getVersatilityDamageTakenMult(versatility) {
    return 1 - getVersatilityDamageReduction(versatility);
}


// ==================== COMBAT SYSTEM ====================
// å°†æˆ˜æ–—æ‹†æˆâ€œå¤š tick å¤šå›åˆâ€æ¨è¿›ï¼šè¿™æ · UI èƒ½å®æ—¶çœ‹åˆ°è¡€é‡å˜åŒ–
function createCombatState(character, enemy, skillSlots) {
    // æˆ˜æ–—å†… buffsï¼ˆä¸æ”¹è§’è‰²æœ¬ä½“ï¼‰
    let buffs = []; // { blockRate, duration }

    // ä¿ç•™ 8 ä¸ªæ§½ä½é¡ºåºï¼šç©º/æ— æ•ˆ => rest
    const slots8 = Array.from({ length: 8 }, (_, i) => (skillSlots?.[i] ?? ''));

    const validSkills = slots8.map(sid => (sid && SKILLS[sid]) ? sid : 'rest');

    // ä¿é™©ï¼šå¦‚æœ rest ä¸å­˜åœ¨ï¼Œè‡³å°‘ä¸ä¼šå´©ï¼ˆå¯é€‰ï¼‰
    for (let i = 0; i < validSkills.length; i++) {
        if (!SKILLS[validSkills[i]]) validSkills[i] = 'basic_attack';
    }

    return {
        enemy: { ...enemy },
        enemyHp: enemy.hp,
        round: 0,
        skillIndex: 0,
        buffs,
        enemyDebuffs: [], // æ€ªç‰©èº«ä¸Šçš„ debuff
        validSkills,
        talentBuffs: { attackFlat: 0, blockValueFlat: 0, spellPowerFlat: 0 },
        fortuneMisfortuneStacks: 0, // ç¥¸ç¦ç›¸ä¾å±‚æ•°
        fantasiaStacks: 0,          // å¹»æƒ³æ›²å±‚æ•°ï¼ˆæˆ’å¾‹ç‰§å¸ˆ50çº§å¤©èµ‹ï¼Œä»…æœ¬åœºæˆ˜æ–—ï¼‰
        fingersOfFrost: 0,          // å¯’å†°æŒ‡å±‚æ•°
        logs: [],
        startedAt: Date.now(),
    };
}

function stepCombatRounds(character, combatState, roundsPerTick = 1, gameState) {
    let logs = [...(combatState.logs || [])];

    let charHp = Number.isFinite(character?.stats?.currentHp)
        ? character.stats.currentHp
        : (character?.stats?.maxHp ?? character?.stats?.hp ?? 0);

    let enemyHp = combatState.enemyHp ?? combatState.enemy?.hp ?? 0;
    let round = combatState.round ?? 0;
    let skillIndex = combatState.skillIndex ?? 0;

    // âœ… åœ°å›¾æˆ˜æ–—æ€»ä¼¤å®³åŠ æˆï¼ˆè£…å¤‡ç‰¹æ•ˆ + æˆå°±åŠ æˆï¼ŒäºŒè€…ä¹˜ç®—ï¼‰
    const mapDamageDealtMult = getMapDamageDealtMult(character, gameState);

    // buffs
    let buffs = Array.isArray(combatState.buffs) ? [...combatState.buffs] : [];
    // enemy debuffs
    let enemyDebuffs = Array.isArray(combatState.enemyDebuffs) ? [...combatState.enemyDebuffs] : [];

    // å¤©èµ‹å å±‚ï¼ˆä»…æœ¬åœºæˆ˜æ–—æœ‰æ•ˆï¼‰
    let talentBuffs = combatState.talentBuffs
        ? { ...combatState.talentBuffs }
        : { attackFlat: 0, blockValueFlat: 0, spellPowerFlat: 0 };

    // ç¥¸ç¦ç›¸ä¾å±‚æ•°
    let fortuneMisfortuneStacks = combatState.fortuneMisfortuneStacks || 0;
    // å¹»æƒ³æ›²å±‚æ•°ï¼ˆä»…æœ¬åœºæˆ˜æ–—ï¼‰
    let fantasiaStacks = combatState.fantasiaStacks || 0;
    // å¯’å†°æŒ‡å±‚æ•°
    let fingersOfFrost = combatState.fingersOfFrost || 0;

    const validSkills = Array.isArray(combatState.validSkills) && combatState.validSkills.length > 0
        ? combatState.validSkills
        : (() => {
            const slots8 = Array.from({ length: 8 }, (_, i) => (character.skillSlots?.[i] ?? ''));
            const v = slots8.map(sid => (sid && SKILLS[sid]) ? sid : 'rest');

            for (let i = 0; i < v.length; i++) {
                if (!SKILLS[v[i]]) v[i] = 'basic_attack';
            }
            return v;
        })();

    const getBuffBlockRate = () =>
        buffs.reduce((sum, b) => sum + (b.blockRate || 0), 0);

    const tickBuffs = () => {
        buffs = buffs
            .map(b => ({ ...b, duration: (b.duration ?? 0) - 1 }))
            .filter(b => {
                // æŠ¤ç›¾ï¼šæŒç»­æ—¶é—´åˆ°æœŸæˆ–å¸æ”¶é‡è€—å°½éƒ½ç§»é™¤
                if (b.type && ['ice_barrier', 'holy_barrier'].includes(b.type)) {
                    return (b.duration ?? 0) > 0 && (b.amount ?? 0) > 0;
                }
                // å…¶ä»–buffåªçœ‹æŒç»­æ—¶é—´
                return (b.duration ?? 0) > 0;
            });
    };
    const tickEnemyDebuffs = () => {
        enemyDebuffs = enemyDebuffs
            .map(d => ({ ...d, duration: (d.duration ?? 0) - 1 }))
            .filter(d => (d.duration ?? 0) > 0);
    };

    const maxRounds = 200;

    for (let i = 0; i < roundsPerTick; i++) {
        if (charHp <= 0 || enemyHp <= 0 || round >= maxRounds) break;

        round++;

        // ===== 50çº§å¤©èµ‹ï¼šå¹»æƒ³æ›²ï¼ˆæ¯å›åˆ+1å±‚ï¼Œå½±å“ä¸‹ä¸€ä¸ªç¥åœ£æ–°æ˜Ÿï¼‰ =====
        if (character?.classId === 'discipline_priest' && character?.talents?.[50] === 'fantasia') {
            fantasiaStacks = (fantasiaStacks || 0) + 1;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'å¹»æƒ³æ›²',
                text: `ã€å¹»æƒ³æ›²ã€‘è·å¾—1å±‚ï¼ˆå½“å‰${fantasiaStacks}å±‚ï¼‰`
            });
        }

        // ===== è§’è‰²å›åˆ =====
        let currentSkillId = validSkills[skillIndex % validSkills.length];
        let skill = SKILLS[currentSkillId];

        // ===== æ–°å¢ï¼šå¤„ç†æ¡ä»¶æŠ€èƒ½ =====
        if (skill && skill.type === 'conditional') {
            const condition = skill.condition;
            let conditionMet = false;

            // æ£€æŸ¥æ¡ä»¶ç±»å‹
            if (condition.type === 'has_buff') {
                // æ£€æŸ¥æ˜¯å¦æœ‰æŒ‡å®šbuff/å±‚æ•°
                if (condition.buffName === 'fingersOfFrost') {
                    conditionMet = (fingersOfFrost || 0) >= (condition.minStacks || 1);
                }
                // å¯ä»¥æ‰©å±•å…¶ä»–buffæ£€æŸ¥...
            }

            // æ ¹æ®æ¡ä»¶é€‰æ‹©å®é™…æŠ€èƒ½
            const actualSkillId = conditionMet ? skill.skillIfTrue : skill.skillIfFalse;
            currentSkillId = actualSkillId;
            skill = SKILLS[actualSkillId];

            // è®°å½•æ—¥å¿—
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'æ™ºèƒ½æŠ€èƒ½',
                text: `ã€å†°éœœæ‰“å‡»ã€‘åˆ¤æ–­ï¼š${conditionMet ? 'æœ‰å¯’å†°æŒ‡â†’å†°æªæœ¯' : 'æ— å¯’å†°æŒ‡â†’å¯’å†°ç®­'}`
            });
        }

        const slotIndex = skillIndex % validSkills.length;

        // âœ… ç§æ—ï¼šæš—å¤œç²¾çµã€éšéã€‘
        // æ•ˆæœï¼šåœ°å›¾æˆ˜æ–—ç¬¬1æ ¼(ç´¢å¼•0)æŠ€èƒ½é€ æˆçš„ä¼¤å®³æé«˜20%ï¼ˆä¹˜ç®—ï¼‰
        const raceTraitCombat = RACE_TRAITS?.[character?.race];
        let racialSlotDamageMult = 1;
        if (slotIndex === 0) {
            const m = Number(raceTraitCombat?.mapFirstSlotDamageMult);
            if (Number.isFinite(m) && m > 0) racialSlotDamageMult *= m;
        }

        // âœ… ç§æ—ï¼šé€šç”¨â€œå‰Næ ¼ä¼¤å®³ä¹˜åŒºâ€ï¼ˆä¾‹å¦‚ï¼šå…½äººã€è¡€æ€§ç‹‚æ€’ã€‘ï¼‰
        const firstNSlotCfg = raceTraitCombat?.firstNSlotDamageMult;
        if (firstNSlotCfg && typeof firstNSlotCfg === 'object') {
            const n = Math.max(0, Math.floor(Number(firstNSlotCfg.n) || 0));
            const m = Number(firstNSlotCfg.mult);
            if (n > 0 && slotIndex < n && Number.isFinite(m) && m > 0) {
                racialSlotDamageMult *= m;
            }
        }

        // ==================== è£…å¤‡ç‰¹æ•ˆï¼šå›åˆå¼€å§‹æ¦‚ç‡å±æ€§å¢ç›Šï¼ˆä»…æœ¬å›åˆï¼‰ ====================
        const { bonus: turnProcBonus, triggered: turnProcTriggered } = rollProcStatEffects(character, 'turn_start');
        if (turnProcTriggered.length > 0) {
            turnProcTriggered.forEach(tp => {
                const t = formatProcStatBonusText(tp.bonus);
                if (t) {
                    logs.push({
                        round,
                        kind: 'proc',
                        actor: character.name,
                        proc: tp.label,
                        text: `ã€${tp.label}ã€‘è§¦å‘ï¼š${t}ï¼ˆæœ¬å›åˆï¼‰`
                    });
                }
            });
        }

        // é¥°å“/è£…å¤‡ç‰¹æ•ˆï¼šæŠ€èƒ½æ å¼ºåŒ–ï¼ˆä¾‹å¦‚ï¼šç¬¬1æ ¼ä¸ç¬¬4æ ¼ï¼‰
        const slotBuff = getSkillSlotBuffBonus(character, slotIndex);

        // è®¡ç®—æœ¬å›åˆç”¨äºæŠ€èƒ½ç»“ç®—çš„é¢æ¿ï¼ˆä¸ä¼šå†™å›è§’è‰²æœ¬ä½“ï¼‰
        const calcStats = {
            ...character.stats,
            attack: (character.stats.attack || 0) + (talentBuffs.attackFlat || 0) + (slotBuff.attackBonus || 0),
            blockValue: (character.stats.blockValue || 0) + (talentBuffs.blockValueFlat || 0),
            spellPower: (character.stats.spellPower || 0) + (talentBuffs.spellPowerFlat || 0) + (slotBuff.spellPowerBonus || 0),
        };

        // å åŠ æœ¬å›åˆè§¦å‘çš„ä¸´æ—¶å±æ€§
        Object.entries(turnProcBonus || {}).forEach(([stat, add]) => {
            calcStats[stat] = (calcStats[stat] || 0) + (Number(add) || 0);
        });

        const charForCalc = {
            ...character,
            stats: calcStats
        };


        // å†°å†·è¡€è„‰æ˜¯å¦å¼€å¯ï¼ˆbuff å†…å« icyVeinsBuffï¼‰
        const icyVeinsBuff = buffs.some(b => b.type === 'icy_veins');
        // å†°é£æš´DOTæœŸé—´ -> å†°æªå¿…çˆ†
        const blizzardActive = enemyDebuffs.some(d =>
            d.type === 'dot' &&
            d.name === 'å†°é£æš´' &&
            d.enableIceLanceCrit === true
        );

        // ä¼ å…¥combatContextç»™æŠ€èƒ½è®¡ç®—ï¼ˆç”¨äºç¥¸ç¦ç›¸ä¾ç­‰ï¼‰
        const combatContext = {
            fortuneMisfortuneStacks,
            fantasiaStacks,
            fingersOfFrost,
            icyVeinsBuff,
            blizzardActive
        };

        const result = skill.calculate(charForCalc, combatContext);

        // ===== æ–°å¢ï¼šé›·éœ†ä¸€å‡»ï¼ˆå•ä½“é«˜ä¼¤ + æš´å‡»æ—¶æ–½åŠ é‡ä¼¤DOTï¼‰=====
        if (result.aoeDamage) {
            let damage = result.aoeDamage;

            // 40çº§å¤©èµ‹ï¼šæ— åšä¸æ‘§ä¹‹åŠ› - ç›¾å¢™æœŸé—´ä¼¤å®³æé«˜50%
            let buffDamageDealtMult = 1;
            buffs.forEach(b => {
                if (b.damageDealtMult) {
                    buffDamageDealtMult *= b.damageDealtMult;
                }
            });
            damage *= buffDamageDealtMult;

            // âœ… ç§æ—ï¼šæš—å¤œç²¾çµã€éšéã€‘ï¼ˆåœ°å›¾æˆ˜æ–—ç¬¬1æ ¼æŠ€èƒ½ä¼¤å®³+20%ï¼Œä¹˜ç®—ï¼‰
            damage *= racialSlotDamageMult;

            // âœ… è£…å¤‡ç‰¹æ•ˆï¼šåœ°å›¾å± æˆ®ï¼ˆåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼‰
            damage *= mapDamageDealtMult;

            // å…¨èƒ½ç­‰é€šç”¨ä¹˜åŒºå·²åœ¨ä¸Šå±‚calculateä¸­å¤„ç†ï¼Œè¿™é‡Œç›´æ¥æ‰£é˜²å¾¡
            const actualDamage = Math.max(1, Math.floor(damage - (combatState.enemy?.defense ?? 0)));
            enemyHp -= actualDamage;

            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: combatState.enemy?.name,
                value: actualDamage,
                type: 'damage',
                isCrit: result.isCrit
            });

            // æš´å‡»æ—¶æ–½åŠ é‡ä¼¤DOTï¼ˆä¸ç°æœ‰DOTç»“æ„å…¼å®¹ï¼‰
            if (result.isCrit && result.dotOnCrit) {
                enemyDebuffs.push({
                    type: 'dot',
                    sourceSkillId: currentSkillId,
                    sourceSkillName: skill.name,
                    damagePerTurn: Math.floor((result.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult),
                    duration: result.dotOnCrit.duration
                });

                logs.push({
                    round,
                    actor: character.name,
                    action: `${skill.name}(é‡ä¼¤)`,
                    target: combatState.enemy?.name,
                    value: Math.floor((result.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult),
                    type: 'debuff',
                    text: `ã€é‡ä¼¤ã€‘æ–½åŠ ï¼šæ¯å›åˆ ${Math.floor((result.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult)} ä¼¤å®³ï¼ŒæŒç»­ ${result.dotOnCrit.duration} å›åˆ`
                });
            }

            // 30çº§å¤©èµ‹ï¼šæŒ«å¿—æ€’å¼ - é›·éœ†ä¸€å‡»æ–½åŠ debuffï¼Œæ•Œäººé€ æˆçš„ä¼¤å®³é™ä½20%
            if (character.talents?.[30] === 'demoralizing_shout') {
                const existingShout = enemyDebuffs.find(d => d.type === 'demoralizing_shout');
                if (!existingShout) {
                    enemyDebuffs.push({
                        type: 'demoralizing_shout',
                        damageMult: 0.8,  // é€ æˆä¼¤å®³é™ä½20%
                        duration: 999     // æŒç»­æ•´åœºæˆ˜æ–—
                    });
                    logs.push({
                        round,
                        kind: 'proc',
                        actor: character.name,
                        proc: 'æŒ«å¿—æ€’å¼',
                        text: 'ã€æŒ«å¿—æ€’å¼ã€‘è§¦å‘ï¼šæ•Œäººé€ æˆçš„ä¼¤å®³é™ä½20%'
                    });
                }
            }

            // 30çº§å¤©èµ‹ï¼šå±±ä¸˜ä¹‹ç‹ - é›·éœ†ä¸€å‡»æœ‰50%å‡ ç‡å†æ¬¡é‡Šæ”¾ä¸€æ¬¡
            if (character.talents?.[30] === 'mountain_king' && Math.random() < 0.5) {
                const extraResult = skill.calculate(charForCalc);
                const extraDamage = Math.max(1, Math.floor((extraResult.aoeDamage * racialSlotDamageMult * mapDamageDealtMult) - (combatState.enemy?.defense ?? 0)));
                enemyHp -= extraDamage;

                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: 'å±±ä¸˜ä¹‹ç‹',
                    text: `ã€å±±ä¸˜ä¹‹ç‹ã€‘è§¦å‘ï¼šé›·éœ†ä¸€å‡»å†æ¬¡é‡Šæ”¾ï¼`
                });
                logs.push({
                    round,
                    actor: character.name,
                    action: `${skill.name}(å±±ä¸˜ä¹‹ç‹)`,
                    target: combatState.enemy?.name,
                    value: extraDamage,
                    type: 'damage',
                    isCrit: extraResult.isCrit
                });

                // é¢å¤–çš„é›·éœ†ä¸€å‡»ä¹Ÿèƒ½è§¦å‘æš´å‡»é‡ä¼¤
                if (extraResult.isCrit && extraResult.dotOnCrit) {
                    enemyDebuffs.push({
                        type: 'dot',
                        sourceSkillId: currentSkillId,
                        sourceSkillName: skill.name,
                        damagePerTurn: Math.floor((extraResult.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult),
                        duration: extraResult.dotOnCrit.duration
                    });

                    logs.push({
                        round,
                        actor: character.name,
                        action: `${skill.name}(å±±ä¸˜ä¹‹ç‹-é‡ä¼¤)`,
                        target: combatState.enemy?.name,
                        value: Math.floor((extraResult.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult),
                        type: 'debuff',
                        text: `ã€é‡ä¼¤ã€‘æ–½åŠ ï¼šæ¯å›åˆ ${Math.floor((extraResult.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult)} ä¼¤å®³ï¼ŒæŒç»­ ${extraResult.dotOnCrit.duration} å›åˆ`
                    });
                }
            }
        }else if (result.aoeDot) {
            // æŠŠ aoeDot å½“ä½œå•ä½“ dot æŒ‚åˆ° enemyDebuffs
            enemyDebuffs.push({
                type: 'dot',
                sourceSkillId: currentSkillId,
                sourceSkillName: result.aoeDot.name || skill.name,
                ...result.aoeDot, // school, damagePerTurn, duration, canGenerateFinger, name ç­‰
                // âœ… ç§æ—ï¼šæš—å¤œç²¾çµã€éšéã€‘â€”â€”è‹¥è¯¥æŠ€èƒ½ä½äºç¬¬1æ ¼ï¼Œåˆ™DOTä¹Ÿäº«å—ä¼¤å®³ä¹˜ç®—
                damagePerTurn: Math.floor((result.aoeDot.damagePerTurn || 0) * racialSlotDamageMult),
            });

            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: combatState.enemy?.name,
                type: 'debuff',
                text: `æ–½æ”¾ã€${result.aoeDot.name || skill.name}ã€‘ï¼šæ¯å›åˆ ${Math.floor((result.aoeDot.damagePerTurn || 0) * racialSlotDamageMult)}ï¼ŒæŒç»­ ${result.aoeDot.duration} å›åˆ`
            });
        }

        // ===== åŸæœ‰æ™®é€šä¼¤å®³é€»è¾‘ï¼ˆä¿æŒä¸å˜ï¼‰=====
        else if (result.damage) {
            let damage = result.damage;

            // ===== 10çº§å¤©èµ‹ï¼šæš—å½±å¢å¹…ï¼ˆæš—å½±ä¼¤å®³ +20%ï¼‰=====
            if (character.talents?.[10] === 'shadow_amp' && result.school === 'shadow') {
                damage *= 1.2;
            }

            // ===== 20çº§å¤©èµ‹ï¼šé˜´æš—é¢ä¹‹åŠ›ï¼ˆå¿ƒçµéœ‡çˆ†ä¼¤å®³ +80%ï¼‰=====
            if (character.talents?.[20] === 'dark_side' && currentSkillId === 'mind_blast') {
                damage *= 1.8;
            }

            // 40çº§å¤©èµ‹ï¼šæ— åšä¸æ‘§ä¹‹åŠ› - ç›¾å¢™æœŸé—´ä¼¤å®³æé«˜50%
            let buffDamageDealtMultForDamage = 1;
            buffs.forEach(b => {
                if (b.damageDealtMult) {
                    buffDamageDealtMultForDamage *= b.damageDealtMult;
                }
            });
            damage *= buffDamageDealtMultForDamage;

            // âœ… ç§æ—ï¼šæš—å¤œç²¾çµã€éšéã€‘ï¼ˆåœ°å›¾æˆ˜æ–—ç¬¬1æ ¼æŠ€èƒ½ä¼¤å®³+20%ï¼Œä¹˜ç®—ï¼‰
            damage *= racialSlotDamageMult;

            // âœ… è£…å¤‡ç‰¹æ•ˆï¼šåœ°å›¾å± æˆ®ï¼ˆåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼‰
            damage *= mapDamageDealtMult;

            // ===== 10çº§å¤©èµ‹ï¼šç¥åœ£å¢å¹…ï¼ˆæƒ©å‡»ï¼šç›®æ ‡å—æ³•æœ¯ä¼¤å®³ +10% æŒç»­2å›åˆï¼‰=====
            if (character.talents?.[10] === 'holy_vuln' && currentSkillId === 'smite') {
                enemyDebuffs.push({ type: 'spell_vuln', mult: 1.10, duration: 2 });
                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: 'ç¥åœ£å¢å¹…',
                    text: 'ã€ç¥åœ£å¢å¹…ã€‘è§¦å‘ï¼šç›®æ ‡å—åˆ°çš„æ³•æœ¯ä¼¤å®³ +10%ï¼ˆ2å›åˆï¼‰'
                });
            }

            const isSpellSchool = (result.school === 'holy' || result.school === 'shadow');
            let takenMult = 1;
            if (isSpellSchool) {
                const vuln = enemyDebuffs.find(d => d.type === 'spell_vuln');
                if (vuln) takenMult *= (vuln.mult ?? 1);
            }

            damage = Math.floor(damage * takenMult);
            const actualDamage = Math.max(1, damage - (combatState.enemy?.defense ?? 0));
            enemyHp -= actualDamage;

            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: combatState.enemy?.name,
                value: actualDamage,
                type: 'damage',
                isCrit: result.isCrit
            });

            if (character.stats.atonement) {
                const healFromAtonement = Math.floor(actualDamage * character.stats.atonement.healingRate);
                const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
                const actualHeal = Math.min(healFromAtonement, maxHp - charHp);
                charHp += actualHeal;
                logs.push({
                    round,
                    actor: character.name,
                    action: `æ•‘èµ`,
                    target: character.name,
                    value: actualHeal,
                    type: 'heal',
                    text: `å› ä¸ºæ•‘èµæ¢å¤ ${healFromAtonement} ç‚¹ç”Ÿå‘½`
                });
            }

            // ==================== æ–°å¢ï¼šé­ç¬è€…è‹è¨æ–¯ç‰¹æ•ˆ - æ™®æ”»å50%æ¦‚ç‡å†æ¬¡æ™®æ”» ====================
            if (currentSkillId === 'basic_attack') {
                const repeatChance = getBasicAttackRepeatChance(character);
                if (repeatChance > 0 && Math.random() < repeatChance) {
                    logs.push({
                        round,
                        kind: 'proc',
                        actor: character.name,
                        proc: 'é­ç¬è€…è‹è¨æ–¯',
                        text: 'ã€é­ç¬è€…è‹è¨æ–¯ã€‘è§¦å‘ï¼šå†æ¬¡å‘åŠ¨æ™®é€šæ”»å‡»ï¼'
                    });
                    // ===== å¤©èµ‹è§¦å‘ï¼ˆä¿æŒä¸å˜ï¼‰=====
                    if (currentSkillId === 'basic_attack' && character.talents?.[10] === 'plain') {
                        talentBuffs.attackFlat = (talentBuffs.attackFlat || 0) + 5;
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'è´¨æœ´',
                            value: 5,
                            text: 'ã€è´¨æœ´ã€‘è§¦å‘ï¼Œæ”»å‡»å¼ºåº¦ +5ï¼ˆæœ¬åœºæˆ˜æ–—ï¼‰'
                        });
                    }
                    enemyHp -= actualDamage;
                    logs.push({
                        round,
                        actor: character.name,
                        action: skill.name,
                        target: combatState.enemy?.name,
                        value: actualDamage,
                        type: 'damage',
                        isCrit: result.isCrit
                    });

                    // ===== 50çº§å¤©èµ‹ï¼šåœ£å‰‘ - æ™®æ”»é¢å¤–é€ æˆæ ¼æŒ¡å€¼ä¼¤å®³ =====
                    if (result.holySwordDamage && result.holySwordDamage > 0) {
                        const holySwordActualDamage = Math.max(1, Math.floor(result.holySwordDamage * racialSlotDamageMult * mapDamageDealtMult));
                        enemyHp -= holySwordActualDamage;

                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'åœ£å‰‘',
                            text: `ã€åœ£å‰‘ã€‘è§¦å‘ï¼šé¢å¤–é€ æˆ ${holySwordActualDamage} ç‚¹çœŸå®ä¼¤å®³ï¼ˆæ— è§†é˜²å¾¡ï¼‰`
                        });
                    }
                }
            }
        }
        // ===== åŸæœ‰å…¶ä»–æŠ€èƒ½é€»è¾‘ï¼ˆä¿æŒä¸å˜ï¼‰=====
        else if (result.heal) {
            const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
            const actualHeal = Math.min(result.heal, maxHp - charHp);
            charHp += actualHeal;
            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: character.name,
                value: actualHeal,
                type: 'heal'
            });
        }
        else if (result.buff) {
            buffs.push({ ...result.buff });
            let buffText = '';
            if (result.buff.damageTakenMult) {
                const damageReduction = Math.round((1 - result.buff.damageTakenMult) * 100);
                buffText = `å¼€å¯ç›¾å¢™ï¼šå—åˆ°ä¼¤å®³é™ä½${damageReduction}%`;
                if (result.buff.damageDealtMult && result.buff.damageDealtMult > 1) {
                    const damageIncrease = Math.round((result.buff.damageDealtMult - 1) * 100);
                    buffText += `ï¼Œé€ æˆä¼¤å®³æé«˜${damageIncrease}%`;
                }
            }
            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: character.name,
                value: result.buff.duration ?? 0,
                type: 'buff',
                text: buffText
            });
        }// ===== æŠ¤ç›¾æŠ€èƒ½å¤„ç† =====
        else if (result.shield) {
            // æ£€æŸ¥æ˜¯å¦å·²æœ‰åŒç±»å‹æŠ¤ç›¾ï¼Œå¦‚æœæœ‰åˆ™åˆ·æ–°
            const existingShieldIdx = buffs.findIndex(b => b.type === result.shield.type);
            if (existingShieldIdx !== -1) {
                // åˆ·æ–°æŠ¤ç›¾ï¼šå–æ–°æ—§æŠ¤ç›¾çš„è¾ƒå¤§å€¼
                const oldShield = buffs[existingShieldIdx];
                buffs[existingShieldIdx] = {
                    ...result.shield,
                    amount: Math.max(oldShield.amount, result.shield.amount)
                };
                logs.push({
                    round,
                    actor: character.name,
                    action: skill.name,
                    target: character.name,
                    type: 'shield',
                    value: result.shield.amount,
                    text: `åˆ·æ–°ã€${result.shield.name}ã€‘æŠ¤ç›¾ï¼Œå½“å‰å¸æ”¶é‡ï¼š${buffs[existingShieldIdx].amount}`
                });
            } else {
                // æ·»åŠ æ–°æŠ¤ç›¾
                buffs.push({ ...result.shield });
                logs.push({
                    round,
                    actor: character.name,
                    action: skill.name,
                    target: character.name,
                    type: 'shield',
                    value: result.shield.amount,
                    text: `è·å¾—ã€${result.shield.name}ã€‘æŠ¤ç›¾ï¼Œå¯å¸æ”¶ ${result.shield.amount} ç‚¹ä¼¤å®³ï¼ŒæŒç»­ ${result.shield.duration} å›åˆ`
                });
            }
        }
        else if (result.dot) {
            enemyDebuffs.push({
                type: 'dot',
                sourceSkillId: currentSkillId,
                sourceSkillName: skill.name,
                ...result.dot,
                // âœ… ç§æ—ï¼šæš—å¤œç²¾çµã€éšéã€‘â€”â€”è‹¥è¯¥æŠ€èƒ½ä½äºç¬¬1æ ¼ï¼Œåˆ™DOTä¹Ÿäº«å—ä¼¤å®³ä¹˜ç®—
                damagePerTurn: Math.floor((result.dot.damagePerTurn || 0) * racialSlotDamageMult),
            });

            logs.push({
                round,
                actor: character.name,
                action: `${skill.name}(æ–½åŠ )`,
                target: combatState.enemy?.name,
                value: Math.floor((result.dot.damagePerTurn || 0) * racialSlotDamageMult),
                type: 'debuff',
                text: `æ–½åŠ æŒç»­ä¼¤å®³ï¼šæ¯å›åˆ ${Math.floor((result.dot.damagePerTurn || 0) * racialSlotDamageMult)}ï¼ŒæŒç»­ ${result.dot.duration} å›åˆ`
            });
        }
        else if (result.healAll) {
            const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
            const actualHeal = Math.min(result.healAll, maxHp - charHp);
            charHp += actualHeal;
            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: character.name,
                value: actualHeal,
                type: 'heal'
            });
        }
        // ===== è‹¦ä¿®æŠ€èƒ½å¤„ç† =====
        else if (result.penanceHeal) {
            // è‹¦ä¿®æ²»ç–—è‡ªå·±ï¼ˆæ™®é€šæˆ˜æ–—ä¸­åªæœ‰ä¸€ä¸ªè§’è‰²ï¼Œæ‰€ä»¥æ²»ç–—è‡ªå·±ï¼‰
            const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
            const actualHeal = Math.min(result.penanceHeal, maxHp - charHp);
            charHp += actualHeal;

            let healText = `è‹¦ä¿®æ²»ç–— ${actualHeal}`;
            if (fortuneMisfortuneStacks > 0 && character.talents?.[40] === 'fortune_misfortune') {
                healText += `ï¼ˆç¥¸ç¦ç›¸ä¾ ${fortuneMisfortuneStacks} å±‚åŠ æˆï¼‰`;
            }

            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: character.name,
                value: actualHeal,
                type: 'heal',
                text: healText
            });

            // 40çº§å¤©èµ‹ï¼šç»ˆæè‹¦ä¿® - é€ æˆä¼¤å®³
            if (result.penanceDamage) {
                const actualDamage = Math.max(
                    1,
                    Math.floor(result.penanceDamage * racialSlotDamageMult * mapDamageDealtMult) - (combatState.enemy?.defense ?? 0)
                );
                enemyHp -= actualDamage;
                logs.push({
                    round,
                    actor: character.name,
                    action: `${skill.name}(ç»ˆæè‹¦ä¿®)`,
                    target: combatState.enemy?.name,
                    value: actualDamage,
                    type: 'damage',
                    text: 'ã€ç»ˆæè‹¦ä¿®ã€‘é€ æˆä¼¤å®³'
                });
            }

            // 40çº§å¤©èµ‹ï¼šäº‰åˆ†å¤ºç§’ - æ€¥é€Ÿbuff
            if (result.applyHasteBuff) {
                buffs.push({
                    type: 'haste',
                    hasteBonus: result.applyHasteBuff.hasteBonus,
                    duration: result.applyHasteBuff.duration
                });
                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: 'äº‰åˆ†å¤ºç§’',
                    text: `ã€äº‰åˆ†å¤ºç§’ã€‘è§¦å‘ï¼šæ€¥é€Ÿ+${result.applyHasteBuff.hasteBonus}%ï¼ŒæŒç»­${result.applyHasteBuff.duration}å›åˆ`
                });
            }

            // æ¸…ç©ºç¥¸ç¦ç›¸ä¾å±‚æ•°
            if (result.clearFortuneStacks) {
                fortuneMisfortuneStacks = 0;
            }
        }

        if (result.applyAtonement) {
            const actualHeal = 0.2;
            const atonementDuration = result.applyAtonement.duration || 2;
            character.stats.atonement = {
                healingRate: actualHeal,
                duration: atonementDuration
            };
            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: character.name,
                value: `æ•‘èµç”Ÿæ•ˆï¼ŒæŒç»­ ${atonementDuration} å›åˆï¼Œæ²»ç–—é‡ï¼š${actualHeal}å€ä¼¤å®³`,
                type: 'buff'
            });
        }

        // ===== å¹»æƒ³æ›²ï¼šç¥åœ£æ–°æ˜Ÿæ–½æ”¾åæ¸…ç©ºå±‚æ•° =====
        if (result.clearFantasiaStacks) {
            const used = Number(result.fantasiaStacksUsed) || fantasiaStacks;
            fantasiaStacks = 0;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'å¹»æƒ³æ›²',
                text: `ã€å¹»æƒ³æ›²ã€‘æ¶ˆè€—${used}å±‚ï¼Œå¼ºåŒ–æœ¬æ¬¡ç¥åœ£æ–°æ˜Ÿåæ¸…ç©ºå±‚æ•°`
            });
        }

        // ===== å¤©èµ‹è§¦å‘ï¼ˆä¿æŒä¸å˜ï¼‰=====
        if (currentSkillId === 'basic_attack' && character.talents?.[10] === 'plain') {
            talentBuffs.attackFlat = (talentBuffs.attackFlat || 0) + 5;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'è´¨æœ´',
                value: 5,
                text: 'ã€è´¨æœ´ã€‘è§¦å‘ï¼Œæ”»å‡»å¼ºåº¦ +5ï¼ˆæœ¬åœºæˆ˜æ–—ï¼‰'
            });
        }

        if (currentSkillId === 'smite' && character.talents?.[10] === 'holy_infusion') {
            talentBuffs.spellPowerFlat = (talentBuffs.spellPowerFlat || 0) + 2;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'ç¥åœ£çŒæ³¨',
                value: 2,
                text: 'ã€ç¥åœ£çŒæ³¨ã€‘è§¦å‘ï¼Œæ³•æœ¯å¼ºåº¦ +2ï¼ˆæœ¬åœºæˆ˜æ–—ï¼‰'
            });
        }

        // 40çº§å¤©èµ‹ï¼šç¥¸ç¦ç›¸ä¾ - æƒ©å‡»å’Œå¿ƒçµéœ‡çˆ†ç´¯ç§¯å±‚æ•°
        if ((currentSkillId === 'smite' || currentSkillId === 'mind_blast') && character.talents?.[40] === 'fortune_misfortune') {
            fortuneMisfortuneStacks += 1;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'ç¥¸ç¦ç›¸ä¾',
                value: fortuneMisfortuneStacks,
                text: `ã€ç¥¸ç¦ç›¸ä¾ã€‘å±‚æ•°+1ï¼Œå½“å‰${fortuneMisfortuneStacks}å±‚ï¼ˆè‹¦ä¿®æ²»ç–—é‡+${fortuneMisfortuneStacks * 25}%ï¼‰`
            });
        }

        // âœ… å†°æªæ¶ˆè€—å¯’å†°æŒ‡
        if (result.consumeFingersOfFrost) {
            fingersOfFrost = Math.max(0, fingersOfFrost - 1);
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'å¯’å†°æŒ‡',
                value: fingersOfFrost,
                text: `æ¶ˆè€— 1 å±‚å¯’å†°æŒ‡ï¼ˆå‰©ä½™ ${fingersOfFrost} å±‚ï¼‰`
            });
        }

        skillIndex++;

        if (enemyHp <= 0) break;

        // ===== DOT ç»“ç®—ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼Œé‡ä¼¤DOTä¼šè‡ªåŠ¨å‚ä¸ï¼‰=====
        const dots = enemyDebuffs.filter(d => d.type === 'dot');
        if (dots.length > 0) {
            for (const d of dots) {
                let dotDamage = d.damagePerTurn ?? 0;

                if (character.talents?.[10] === 'shadow_amp' && d.school === 'shadow') {
                    dotDamage *= 1.2;
                }

                const isSpellSchool = (d.school === 'holy' || d.school === 'shadow');
                if (isSpellSchool) {
                    const vuln = enemyDebuffs.find(x => x.type === 'spell_vuln');
                    if (vuln?.mult) dotDamage *= vuln.mult;
                }

                // æ€¥é€Ÿï¼šDOT ä¼¤å®³æé«˜ï¼ˆæ€¥é€Ÿ * 2%ï¼‰
                dotDamage *= (1 + ((character.stats.haste || 0) * 0.02));

                // âœ… è£…å¤‡ç‰¹æ•ˆï¼šåœ°å›¾å± æˆ®ï¼ˆåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼‰
                dotDamage *= mapDamageDealtMult;
                dotDamage = Math.floor(dotDamage);
                const actualDot = Math.max(1, dotDamage - (combatState.enemy?.defense ?? 0));
                enemyHp -= actualDot;

                logs.push({
                    round,
                    actor: character.name,
                    action: `${d.sourceSkillName || 'æŒç»­ä¼¤å®³'}(æŒç»­)`,
                    target: combatState.enemy?.name,
                    value: actualDot,
                    type: 'damage'
                });

                // 30çº§å¤©èµ‹ï¼šæ®‹æš´åŠ¨åŠ› - é‡ä¼¤ä¼¤å®³çš„150%æ²»ç–—è‡ªå·±
                if (character.talents?.[30] === 'brutal_momentum' && d.sourceSkillName === 'é›·éœ†ä¸€å‡»') {
                    const healAmount = Math.floor(actualDot * 1.5);
                    const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
                    const actualHeal = Math.min(healAmount, maxHp - charHp);
                    if (actualHeal > 0) {
                        charHp += actualHeal;
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'æ®‹æš´åŠ¨åŠ›',
                            value: actualHeal,
                            type: 'heal',
                            text: `ã€æ®‹æš´åŠ¨åŠ›ã€‘è§¦å‘ï¼šæ²»ç–— ${actualHeal} ç‚¹ç”Ÿå‘½`
                        });
                    }
                }

                // âœ… 30çº§å¤©èµ‹ï¼šå®ç ç²¾é€š - å¯’å†°å®ç çš„DOTæœ‰æ¦‚ç‡ç”Ÿæˆå¯’å†°æŒ‡
                if (character.talents?.[30] === 'orb_mastery' && d.canGenerateFinger) {
                    if (Math.random() < 0.25) { // æ¦‚ç‡ä½ å¯ä»¥æŒ‰Bossæˆ˜é€»è¾‘å¯¹é½ï¼›
                        fingersOfFrost += 1;
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'å®ç ç²¾é€š',
                            value: fingersOfFrost,
                            text: `ã€å®ç ç²¾é€šã€‘è§¦å‘ï¼šè·å¾— 1 å±‚å¯’å†°æŒ‡ï¼ˆå½“å‰ ${fingersOfFrost} å±‚ï¼‰`
                        });
                    }
                }


                if (enemyHp <= 0) break;
            }
        }

        // æ•‘èµæŒç»­æ—¶é—´å¤„ç†ï¼ˆä¿æŒä¸å˜ï¼‰
        if (character.stats.atonement && character.stats.atonement.duration > 0) {
            character.stats.atonement.duration -= 1;
        }
        if (character.stats.atonement && character.stats.atonement.duration <= 0) {
            delete character.stats.atonement;
            logs.push({
                round,
                actor: character.name,
                action: "æ•‘èµç»“æŸ",
                target: character.name,
                value: "æ•‘èµæ•ˆæœç»“æŸ",
                type: 'buff'
            });
        }

        // ===== æ•Œäººå›åˆ =====
        const dr = getArmorDamageReduction(character.stats.armor);
        const rawEnemyDamage = applyPhysicalMitigation(combatState.enemy?.attack ?? 0, character.stats.armor);

        // ===== 50çº§å¤©èµ‹ï¼šæ ¼æŒ¡çªç ´ - è¶…è¿‡95%çš„æ ¼æŒ¡ç‡è½¬åŒ–ä¸ºæ ¼æŒ¡å€¼åŠ æˆ =====
        let baseBlockRate = (character.stats.blockRate || 0) + getBuffBlockRate();
        let blockBreakthroughBonusValue = 0;

        if (character.talents?.[50] === 'block_breakthrough' && baseBlockRate > 95) {
            const excessBlockRate = baseBlockRate - 95;
            // è¶…å‡ºéƒ¨åˆ†è½¬åŒ–ä¸ºæ ¼æŒ¡å€¼ç™¾åˆ†æ¯”åŠ æˆ
            blockBreakthroughBonusValue = Math.floor((character.stats.blockValue || 0) * (excessBlockRate / 100));
            baseBlockRate = 95; // æ ¼æŒ¡ç‡å°é¡¶95%
        }

        const blockChance = Math.max(
            0,
            Math.min(
                0.95,
                ((character.stats.blockRate || 0) + getBuffBlockRate()) / 100
            )
        );

        let finalDamage = rawEnemyDamage;
        let blockedAmount = 0;

        if (Math.random() < blockChance) {
            // æ ¼æŒ¡å€¼ = åŸºç¡€æ ¼æŒ¡å€¼ + å¤©èµ‹åŠ æˆ + æ ¼æŒ¡çªç ´åŠ æˆ
            const blockValue = Math.floor(
                (character.stats.blockValue || 0) +
                (talentBuffs.blockValueFlat || 0) +
                blockBreakthroughBonusValue
            );
            blockedAmount = Math.min(finalDamage - 1, blockValue);
            finalDamage = Math.max(1, finalDamage - blockedAmount);
        }

        if (blockedAmount > 0 && character.talents?.[10] === 'block_master') {
            talentBuffs.blockValueFlat = (talentBuffs.blockValueFlat || 0) + 10;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'æ ¼æŒ¡å¤§å¸ˆ',
                value: 10,
                text: 'ã€æ ¼æŒ¡å¤§å¸ˆã€‘è§¦å‘ï¼Œæ ¼æŒ¡å€¼ +10ï¼ˆæœ¬åœºæˆ˜æ–—ï¼‰'
            });
        }

        // ===== æ–°å¢ï¼šbuffå‡ä¼¤ä¹˜åŒºï¼ˆç›¾å¢™ç­‰ï¼‰=====
        let buffDamageTakenMult = 1;
        let buffDamageDealtMult = 1;  // 40çº§å¤©èµ‹ï¼šæ— åšä¸æ‘§ä¹‹åŠ›
        buffs.forEach(b => {
            if (b.damageTakenMult) {
                buffDamageTakenMult *= b.damageTakenMult;
            }
            if (b.damageDealtMult) {
                buffDamageDealtMult *= b.damageDealtMult;
            }
        });

        // 30çº§å¤©èµ‹ï¼šæŒ«å¿—æ€’å¼ - æ•Œäººé€ æˆçš„ä¼¤å®³é™ä½20%
        const demoralizingShout = enemyDebuffs.find(d => d.type === 'demoralizing_shout');
        const enemyDamageMult = demoralizingShout ? demoralizingShout.damageMult : 1;

        finalDamage = Math.max(1, Math.floor(finalDamage * (character.stats.damageTakenMult || 1) * buffDamageTakenMult * enemyDamageMult * getVersatilityDamageTakenMult(character.stats.versatility)));

        // ===== æ–°å¢ï¼šæŠ¤ç›¾å¸æ”¶ä¼¤å®³ =====
        let shieldAbsorbed = 0;
        const shieldBuff = buffs.find(b => b.type && b.amount > 0 && ['ice_barrier', 'holy_barrier'].includes(b.type));

        if (shieldBuff && finalDamage > 0) {
            // è®¡ç®—æŠ¤ç›¾å¸æ”¶é‡
            shieldAbsorbed = Math.min(shieldBuff.amount, finalDamage);
            shieldBuff.amount -= shieldAbsorbed;
            finalDamage -= shieldAbsorbed;

            // æŠ¤ç›¾å—å‡»è§¦å‘æ•ˆæœ
            if (shieldBuff.onHitEffect) {
                if (shieldBuff.onHitEffect.type === 'generate_finger' && character.classId === 'frost_mage') {
                    if (Math.random() < shieldBuff.onHitEffect.chance) {
                        fingersOfFrost = (fingersOfFrost || 0) + 1;
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'å¯’å†°æŠ¤ä½“',
                            text: `ã€å¯’å†°æŠ¤ä½“ã€‘è§¦å‘ï¼šè·å¾—1å±‚å¯’å†°æŒ‡ï¼ˆå½“å‰${fingersOfFrost}å±‚ï¼‰`
                        });
                    }
                }
            }

            // æŠ¤ç›¾ç ´ç¢
            if (shieldBuff.amount <= 0) {
                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: shieldBuff.name,
                    text: `ã€${shieldBuff.name}ã€‘æŠ¤ç›¾ç ´ç¢ï¼`
                });
                // ä»buffsä¸­ç§»é™¤ï¼ˆæˆ–æ ‡è®°ä¸º0ï¼Œåœ¨tickBuffsæ—¶æ¸…ç†ï¼‰
                const shieldIdx = buffs.findIndex(b => b.type === shieldBuff.type);
                if (shieldIdx !== -1) {
                    buffs.splice(shieldIdx, 1);
                }
            }
        }

        charHp -= finalDamage;
        const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
        logs.push({
            round,
            actor: combatState.enemy?.name,
            action: `æ™®é€šæ”»å‡»(æŠ¤ç”²å‡ä¼¤ ${(dr * 100).toFixed(3)}%${blockText})`,
            target: character.name,
            value: Math.floor(finalDamage),
            type: 'damage'
        });

        // å›åˆç»“æŸï¼Œbuff/debuff duration -1ï¼ˆä¿æŒåŸæœ‰ï¼‰
        tickBuffs();
        tickEnemyDebuffs();
    }

    const finished = (charHp <= 0) || (enemyHp <= 0) || (round >= 50);

    return {
        finished,
        won: enemyHp <= 0,
        charHp,
        combatState: {
            ...combatState,
            enemyHp,
            round,
            skillIndex,
            buffs,
            enemyDebuffs,
            validSkills,
            logs,
            talentBuffs,
            fortuneMisfortuneStacks,
            fantasiaStacks,
            fingersOfFrost, // æŠŠæœ€æ–°å±‚æ•°å­˜å›å»
        }
    };
}

// ==================== è®¡ç®—åŠŸèƒ½å»ºç­‘åŠ¨æ€æˆæœ¬ ====================
function getFunctionalBuildingCost(buildingId, state) {
    const building = FUNCTIONAL_BUILDINGS[buildingId];
    if (!building) return {};

    const builtCount = state.functionalBuildings?.[buildingId] || 0;

    // æ¯å¤šå»ºé€ ä¸€åº§ï¼Œæˆæœ¬å¢åŠ 20%
    const multiplier = Math.pow(1.2, builtCount);

    const cost = {};
    Object.entries(building.cost).forEach(([res, amount]) => {
        cost[res] = Math.ceil(amount * multiplier);
    });

    return cost;
}

// ==================== GAME REDUCER ====================
function gameReducer(state, action) {
    switch (action.type) {
        case 'TOGGLE_WORLD_BOSS_AUTOKILL': {
            const { bossId } = action.payload || {};
            if (!bossId) return state;
            const cur = !!state.worldBossAutoKill?.[bossId];
            return {
                ...state,
                worldBossAutoKill: {
                    ...(state.worldBossAutoKill || {}),
                    [bossId]: !cur,
                }
            };
        }

        case 'TOGGLE_DROP_FILTER': {
            const { itemId } = action.payload;
            const current = state.dropFilters?.[itemId];

            // current === false => åˆ‡å› true
            // undefined / true => åˆ‡æˆ false
            const nextValue = current === false;

            return {
                ...state,
                dropFilters: {
                    ...(state.dropFilters || {}),
                    [itemId]: nextValue
                }
            };
        }

        case 'APPLY_OFFLINE_REWARDS': {
            const { rewards, actualSeconds } = action.payload;
            let newState = { ...state };

            newState.resources = {
                ...newState.resources,
                gold: newState.resources.gold + rewards.gold
            };

            newState.characters = newState.characters.map(char => {
                if (rewards.exp[char.id]) {
                    let exp = char.exp + rewards.exp[char.id];
                    let level = char.level;
                    let expToNext = char.expToNext;

                    while (exp >= expToNext && level < 60) {
                        exp -= expToNext;
                        level++;
                        expToNext = Math.floor(100 * Math.pow(1.2, level - 1));
                    }

                    const updatedChar = { ...char, exp, level, expToNext };
                    updatedChar.stats = calculateTotalStats(updatedChar, undefined, state);
                    return updatedChar;
                }
                return char;
            });

            // âœ… ç¦»çº¿èµ„æºè¿›ä¸»åŸ resourcesï¼ˆæŒ‰åç§°æ˜ å°„åˆ° keyï¼‰
            const mapResourceNameToKey = (name) => {
                const m = {
                    'æœ¨æ': 'wood',
                    'è‰è¯': 'herb',
                    'é“çŸ¿': 'ironOre',
                    'æ¯›çš®': 'leather',
                    'é­”æ³•ç²¾å': 'magicEssence',
                    'ç‚¼é‡‘æ²¹': 'alchemyOil',
                };
                return m[name] || null;
            };

            if (rewards.kingdomResources) {
                const res = { ...newState.resources };
                Object.entries(rewards.kingdomResources).forEach(([cnName, amount]) => {
                    const key = mapResourceNameToKey(cnName);
                    if (!key) return;
                    res[key] = (res[key] || 0) + (amount || 0);
                });
                newState.resources = res;
            }

            if (rewards.items.length > 0) {
                newState.inventory = [...newState.inventory];

                const allowDrop = (id) => state.dropFilters?.[id] !== false;
                rewards.items.forEach(item => {
                    if (item && (item.type === 'junk' || item.type === 'equipment')) {
                        if (!allowDrop(item.id)) return; // âœ… ç¦ç”¨æ‰è½ => ç›´æ¥è·³è¿‡
                    }
                    if (newState.inventory.length < newState.inventorySize) {
                        if (typeof item === 'string') {
                            newState.inventory.push({
                                id: `item_${Date.now()}_${Math.random()}`,
                                name: item,
                                type: 'resource'
                            });
                        } else {
                            newState.inventory.push(item);
                        }

                        if (item && item.type === 'equipment') {
                            newState = addEquipmentIdToCodex(newState, item.id);
                        }

                        if (item && item.type === 'junk') {
                            newState = addJunkIdToCodex(newState, item.id);
                        }
                    }
                });
            }

            if (rewards.researchProgress > 0 && newState.currentResearch) {
                newState.researchProgress = Math.min(
                    100,
                    newState.researchProgress + rewards.researchProgress
                );
            }

            // âœ… ç¦»çº¿æˆ˜æ–—ç»Ÿè®¡ï¼šè®¡å…¥æ€»æˆ˜æ–—èƒœåˆ©æ•° & å„åŒºåŸŸå‡»æ€æ•°ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä¸ä¼šè¢«é‡ç”Ÿé‡ç½®ï¼‰æš‚æ—¶ä¸è®°å½•
            /*const offlineCombats = Number(rewards.combats) || 0;
            if (offlineCombats > 0) {
                newState.stats = {
                    ...(newState.stats || {}),
                    battlesWon: (newState.stats?.battlesWon || 0) + offlineCombats,
                };
            }

            const killsByZone = (rewards.killsByZone && typeof rewards.killsByZone === 'object' && !Array.isArray(rewards.killsByZone))
                ? rewards.killsByZone
                : null;

            if (killsByZone) {
                const nextZoneKillCounts = (newState.zoneKillCounts && typeof newState.zoneKillCounts === 'object' && !Array.isArray(newState.zoneKillCounts))
                    ? { ...newState.zoneKillCounts }
                    : {};

                Object.entries(killsByZone).forEach(([zid, cnt]) => {
                    const add = Math.max(0, Math.floor(Number(cnt) || 0));
                    if (!zid || add <= 0) return;
                    nextZoneKillCounts[zid] = (nextZoneKillCounts[zid] || 0) + add;
                });

                newState.zoneKillCounts = nextZoneKillCounts;
            }*/

            newState.offlineRewards = null;
            newState.lastOnlineTime = Date.now();

            return newState;
        }

        case 'CALCULATE_OFFLINE_REWARDS': {
            const now = Date.now();
            const offlineSeconds = Math.floor((now - state.lastOnlineTime) / 1000);

            if (offlineSeconds > 60) {
                const offlineData = calculateOfflineRewards(state, offlineSeconds);
                return {
                    ...state,
                    offlineRewards: offlineData
                };
            }

            return {
                ...state,
                lastOnlineTime: now
            };
        }

        case 'DISMISS_OFFLINE_REWARDS': {
            return {
                ...state,
                offlineRewards: null,
                lastOnlineTime: Date.now()
            };
        }

        case 'TICK': {
            const deltaSeconds = action.payload?.deltaSeconds ?? 1;

            let newState = {
                ...state,
                frame: state.frame + deltaSeconds ,
                lifeFrame: (state.lifeFrame || 0) + deltaSeconds,};
// ===== æ—¶é—´æ®µåˆ‡æ¢ï¼šæš—å¤œç²¾çµã€ç²¾çµç²¾é­„ã€‘ =====
// ä»…åœ¨ 6:00 / 18:00 è¾¹ç•Œå‘ç”Ÿå˜åŒ–æ—¶é‡ç®—ä¸€æ¬¡å…¨é˜Ÿå±æ€§ï¼Œé¿å…æ¯ç§’å…¨é‡é‡ç®—ã€‚
            {
                const hour = new Date().getHours();
                const cfg = RACE_TRAITS?.['æš—å¤œç²¾çµ']?.timeBasedStatBonus || {};
                const dayStart = Number.isFinite(Number(cfg.dayStart)) ? Number(cfg.dayStart) : 6;
                const nightStart = Number.isFinite(Number(cfg.nightStart)) ? Number(cfg.nightStart) : 18;
                const isDay = dayStart < nightStart
                    ? (hour >= dayStart && hour < nightStart)
                    : (hour >= dayStart || hour < nightStart);
                const phase = isDay ? 'day' : 'night';
                if (newState.nightElfSpiritPhase !== phase) {
                    newState.nightElfSpiritPhase = phase;

                    // é˜Ÿä¼é‡Œæœ‰æš—å¤œç²¾çµæ—¶æ‰éœ€è¦é‡ç®—
                    if ((newState.characters || []).some(c => c?.race === 'æš—å¤œç²¾çµ')) {
                        newState.characters = recalcPartyStats(newState, newState.characters);
                    }
                }
            }


            // ===== è·¨ä¸–ç´¯è®¡ï¼šåœ°å›¾åŒºåŸŸå‡»æ€è®¡æ•°ï¼ˆç”¨äºæˆå°±ï¼Œå¦‚ã€Œåé‡Œå¡å‰‘åœ£ã€ï¼‰ =====
            // è¯´æ˜ï¼šè¯¥è®¡æ•°ä¸åº”å› é‡ç”Ÿ/ä»»ä½•æ“ä½œè€Œè¢«é‡ç½®ï¼Œå› æ­¤æŒ‚åœ¨ state.zoneKillCounts å¹¶éšå­˜æ¡£æŒä¹…åŒ–ã€‚
            let zoneKillCountsUpdated = false;
            let nextZoneKillCounts = (newState.zoneKillCounts && typeof newState.zoneKillCounts === 'object' && !Array.isArray(newState.zoneKillCounts))
                ? { ...newState.zoneKillCounts }
                : {};


            // ===== ä¸–ç•ŒBossé‡ç”Ÿå†·å´ï¼ˆç§’ï¼‰ =====
            if (newState.bossCooldowns && typeof newState.bossCooldowns === 'object') {
                const nextCooldowns = {};
                const readyNow = []; // æœ¬ tick å†…å†·å´å½’é›¶çš„ boss
                Object.entries(newState.bossCooldowns).forEach(([bid, sec]) => {
                    const left = Math.max(0, Math.floor((sec || 0) - deltaSeconds));
                    if (left > 0) {
                        nextCooldowns[bid] = left;
                    } else {
                        readyNow.push(bid);
                    }
                });
                newState.bossCooldowns = nextCooldowns;
                newState.__readyWorldBosses = readyNow; // ä¸´æ—¶å­—æ®µï¼ˆä»…æœ¬æ¬¡ reducer å†…ä½¿ç”¨ï¼‰
            }

            // ===== è‡ªåŠ¨å‡»æ€ä¸–ç•Œé¦–é¢† =====
            // è§„åˆ™ï¼šæ¯ä¸ª boss ç´¯è®¡å‡»æ€>=10åï¼Œå¯å¼€å¯ï¼›å½“ CD å¥½äº†ï¼ˆæˆ–æœ¬æ¥å°±æ²¡CDï¼‰å°±è‡ªåŠ¨å‡»æ€å¹¶æ‰è½
            // æ³¨æ„ï¼šä¸åœ¨ bossCombat ä¸­æ‰§è¡Œï¼Œé¿å…æ‰“æ–­æ‰‹åŠ¨æŒ‘æˆ˜
            if (!newState.bossCombat) {
                const killCounts = newState.worldBossKillCounts || {};
                const autoCfg = newState.worldBossAutoKill || {};

                const canAutoKillBoss = (bossId) => {
                    const boss = WORLD_BOSSES?.[bossId];
                    if (!boss) return false;

                    // è§£é”æ¡ä»¶ï¼šç­‰çº§/é“å…·
                    const unlockedByLevel = !boss.unlockLevel || (newState.characters || []).some(c => (c.level || 0) >= (boss.unlockLevel || 0));
                    if (!unlockedByLevel) return false;
                    if (bossId === 'prestor_lady' && !newState.worldBossProgress?.prestor_lady) return false;

                    // è‡ªåŠ¨å‡»æ€è§£é”ï¼šç´¯è®¡10æ¬¡
                    if ((killCounts[bossId] || 0) < 10) return false;

                    // å¿…é¡»å¼€å¯å¼€å…³
                    if (!autoCfg[bossId]) return false;

                    // CD å¿…é¡»ä¸º 0ï¼ˆç¼ºå¤±ä¹Ÿè§†ä¸º 0ï¼‰
                    const cd = newState.bossCooldowns?.[bossId] || 0;
                    if (cd > 0) return false;

                    return true;
                };

                const grantBossRewardsAuto = (bossId) => {
                    const bossData = BOSS_DATA[bossId] || WORLD_BOSSES[bossId];
                    if (!bossData?.rewards) return;

                    // 1) è®¾ç½®ä¸‹ä¸€æ¬¡CD
                    newState.bossCooldowns = {
                        ...(newState.bossCooldowns || {}),
                        [bossId]: 30 * 60,
                    };

                    // 2) æœ¬ä¸–å‡»æ€æ ‡è®°ï¼ˆé‡ç”ŸåŠ æˆéœ€è¦ï¼‰
                    if (!newState.defeatedBosses) newState.defeatedBosses = [];
                    if (!newState.defeatedBosses.includes(bossId)) {
                        newState.defeatedBosses = [...newState.defeatedBosses, bossId];
                    }

                    // 3) è·¨ä¸–ç´¯è®¡å‡»æ€æ¬¡æ•°
                    newState.worldBossKillCounts = {
                        ...(newState.worldBossKillCounts || {}),
                        [bossId]: (newState.worldBossKillCounts?.[bossId] || 0) + 1
                    };

                    // 4) é‡‘å¸
                    newState.resources = {
                        ...newState.resources,
                        gold: (newState.resources.gold || 0) + getEffectiveGoldGain((bossData.rewards.gold || 0), newState)
                    };

                    // 5) ç»éªŒï¼šè‡ªåŠ¨å‡»æ€ä¸å‘ç»éªŒï¼ˆåªå‘é‡‘å¸/è£…å¤‡ï¼‰ï¼Œé¿å…æŒ‚æœºåˆ·ç­‰çº§

                    // 6) æ‰è½
                    (bossData.rewards.items || []).forEach(itemTpl => {
                        const dropId = (typeof itemTpl === 'string') ? itemTpl : itemTpl?.id;
                        if (!dropId) return;

                        if (newState.dropFilters?.[dropId] === false) return;

                        const baseDropChance = itemTpl?.chance ?? 1;
                        const dropChance = getEffectiveDropChance(baseDropChance, newState);
                        if (Math.random() > dropChance) return;

                        if (FIXED_EQUIPMENTS?.[dropId]) {
                            const inst = createEquipmentInstance(dropId);
                            newState.inventory.push(inst);
                            newState = addEquipmentIdToCodex(newState, dropId);
                            return;
                        }

                        const tpl = ITEMS?.[dropId];
                        if (tpl) {
                            newState.inventory.push({
                                ...tpl,
                                instanceId: `autoBoss_${Date.now()}_${Math.random()}`,
                                id: tpl.id,
                            });
                            newState = addJunkIdToCodex(newState, dropId);
                            return;
                        }

                        newState.inventory.push({
                            instanceId: `autoBoss_${Date.now()}_${Math.random()}`,
                            id: dropId,
                            name: dropId,
                            type: 'junk',
                        });
                    });

                    // 7) è®°å½•æˆ˜æ–—æ—¥å¿—ï¼ˆç”¨äºå¯è¿½æº¯ï¼‰
                    const bossLogEntry = {
                        id: `bosslog_${Date.now()}_${Math.random()}`,
                        timestamp: Date.now(),
                        characterName: 'é˜Ÿä¼',
                        zoneName: 'ä¸–ç•Œé¦–é¢†',
                        enemyName: bossData.name || bossId,
                        result: 'victory',
                        logs: [`ã€è‡ªåŠ¨å‡»æ€ã€‘${bossData.name || bossId} å·²è¢«è‡ªåŠ¨å‡»æ€ï¼Œè·å¾—é‡‘å¸ä¸æ‰è½ã€‚`],
                        rewards: { gold: bossData.rewards.gold || 0, exp: 0 },
                    };
                    newState.combatLogs = [bossLogEntry, ...(newState.combatLogs || [])].slice(0, 50);
                };

                // å…ˆå¤„ç†â€œåˆšåˆšè½¬å¥½â€çš„ bossï¼Œå†å¤„ç†â€œæœ¬æ¥å°±æ²¡CDâ€çš„ bossï¼ˆé¿å…åŒ tick å†…é‡å¤ï¼‰
                const readyFromCd = Array.isArray(newState.__readyWorldBosses) ? newState.__readyWorldBosses : [];
                const processed = new Set();
                readyFromCd.forEach(bid => {
                    if (processed.has(bid)) return;
                    if (!canAutoKillBoss(bid)) return;
                    processed.add(bid);
                    grantBossRewardsAuto(bid);
                });

                Object.keys(WORLD_BOSSES || {}).forEach(bid => {
                    if (processed.has(bid)) return;
                    if (!canAutoKillBoss(bid)) return;
                    processed.add(bid);
                    grantBossRewardsAuto(bid);
                });
            }

            // æ¸…ç†ä¸´æ—¶å­—æ®µ
            if (newState.__readyWorldBosses) delete newState.__readyWorldBosses;

            newState.lastOnlineTime = Date.now();

            let newResources = { ...newState.resources };

            // ===== èµ„æºå»ºç­‘äº§å‡º =====
            Object.entries(newState.resourceAssignments || {}).forEach(([buildingId, workers]) => {
                if (!workers || workers.length === 0) return;

                const buildingData = RESOURCE_BUILDINGS[buildingId];
                if (!buildingData) return;

                // æ£€æŸ¥æ¶ˆè€—èµ„æºæ˜¯å¦è¶³å¤Ÿ
                if (buildingData.consumption) {
                    let canProduce = true;
                    Object.entries(buildingData.consumption).forEach(([res, amount]) => {
                        if ((newResources[res] || 0) < amount * workers.length) {
                            canProduce = false;
                        }
                    });
                    if (!canProduce) return;

                    // æ‰£é™¤æ¶ˆè€—
                    Object.entries(buildingData.consumption).forEach(([res, amount]) => {
                        newResources[res] -= amount * workers.length;
                    });
                }

                // è®¡ç®—äº§å‡º
                const production = calculateBuildingProduction(buildingId, workers, newState);
                const resourceType = buildingData.resourceType;
                newResources[resourceType] = (newResources[resourceType] || 0) + production * deltaSeconds;
            });

            // ===== åŠŸèƒ½å»ºç­‘æ•ˆæœ =====
            const fountainCount = newState.functionalBuildings?.plaza_fountain || 0;
            const trainingCount = newState.functionalBuildings?.training_dummy || 0;
            const warehouseCount = newState.functionalBuildings?.warehouse || 0;
            const glowLighthouseCount = newState.functionalBuildings?.glow_lighthouse || 0;

            // ä»“åº“å¢åŠ èƒŒåŒ…å¤§å°
            const bonusInventorySize = warehouseCount * 1;
            newState.inventorySize = 80 + bonusInventorySize + (newState.inventorySizeExtra || 0);

            newState.resources = newResources;

            // ===== è„±æˆ˜å›è¡€ï¼ˆå–·æ³‰åŠ æˆï¼‰ =====
            const BASE_REGEN_DELAY_MS = 5000;
            const REGEN_DELAY_MS = Math.max(0, BASE_REGEN_DELAY_MS - glowLighthouseCount * 1000);
            const REGEN_PER_SECOND = 10;
            const now = Date.now();

            const researchBonus = {};
            Object.entries(newState.research).forEach(([id, level]) => {
                const research = RESEARCH[id];
                if (research) {
                    researchBonus[research.effect] = (researchBonus[research.effect] || 0) + research.bonus * level;
                }
            });

            // âœ… æˆå°±ï¼šæ‰€æœ‰å»ºç­‘äº§é‡åŠ æˆï¼ˆå»ºè®¾è€…ç³»åˆ—ç­‰ï¼‰
            const achResourceBonus = getAchievementResourceBonus(newState);

            Object.entries(newState.buildings || {}).forEach(([buildingId, count]) => {
                if (count > 0) {
                    const building = BUILDINGS[buildingId];
                    Object.entries(building.production || {}).forEach(([resource, amount]) => {
                        const bonus = researchBonus[resource] || 0;
                        const production = amount * count * (1 + bonus) * (1 + achResourceBonus);
                        newResources[resource] = (newResources[resource] || 0) + production;
                    });
                    Object.entries(building.consumption || {}).forEach(([resource, amount]) => {
                        newResources[resource] = (newResources[resource] || 0) - amount * count;
                    });
                }
            });

            const maxPopBonus = researchBonus.population || 0;
            const houseCount = (newState.buildings||{}).house || 0;
            newResources.maxPopulation = Math.floor(houseCount * 2 * (1 + maxPopBonus));

            newState.resources = newResources;

            if (newState.currentResearch) {
                const research = RESEARCH[newState.currentResearch];
                const level = newState.research[newState.currentResearch] || 0;
                const cost = Math.floor(research.baseCost * Math.pow(1.2, level));

                if (newState.resources.gold >= cost) {
                    newState.researchProgress += 1;
                    if (newState.researchProgress >= 100) {
                        newState.research = {
                            ...newState.research,
                            [newState.currentResearch]: level + 1
                        };
                        newState.researchProgress = 0;
                        newState.resources.gold -= cost;
                    }
                }
            }


            // Bossæˆ˜æ–—æ¨è¿›
            if (newState.bossCombat) {
                newState = stepBossCombat(newState);
            }

            const toRecall = [];

            // åå°æˆ˜æ–—ï¼ˆæ‹†åˆ†æˆå¤š tick æ¨è¿›ï¼Œå®æ—¶æ›´æ–°è¡€é‡ï¼‰
            const COMBAT_START_INTERVAL_FRAMES = 10; // ä¸æ—§é€»è¾‘ä¿æŒèŠ‚å¥ï¼šæ¯10å¸§â€œå¼€ä¸€åœºâ€
            const COMBAT_ROUNDS_PER_TICK = 2; // æ¯ç§’æ¨è¿›2å›åˆï¼šæœ€å¤š20å›åˆ => æœ€é•¿çº¦10ç§’
            const PULL_INTERVAL_MS = 1000; // æ¯ 1 ç§’å°è¯•æ‹‰æ€ª

            Object.entries(newState.assignments).forEach(([charId, zoneId]) => {
                const zone = newState.zones[zoneId];
                const charIndex = newState.characters.findIndex(c => c.id === charId);

                console.log("ã€æ´¾é£å¾ªç¯ã€‘", {
                    charId, zoneId,
                    hasZone: !!zone,
                    enemiesLen: zone?.enemies?.length,
                    charIndex,
                    frame: newState.frame,
                    frameType: typeof newState.frame,
                });

                if (charIndex === -1) return;


                let char = { ...newState.characters[charIndex] };

                if (!zone || !zone.enemies) return;

                const now = Date.now();

                // å…³é”®ï¼šæ¯ä¸ªè§’è‰²ä¸€ä¸ªâ€œä¸Šæ¬¡æ‹‰æ€ªæ£€æŸ¥æ—¶é—´â€
                const lastPullTry = char.lastPullTry || 0;
                // âœ… ä¿®å¤ï¼šåªæœ‰"åˆ°ç‚¹"ä¸”è„±æˆ˜å›è¡€å®Œæˆï¼ˆæˆ–è¡€é‡å·²æ»¡ï¼‰æ‰ä¼šæ‹‰æ€ªå¼€å§‹æ–°æˆ˜æ–—
                if (!char.combatState && now - lastPullTry >= PULL_INTERVAL_MS) {
                    char.lastPullTry = now;
                    const lastCombatTime = char.lastCombatTime || 0;
                    const maxHp = char.stats?.maxHp ?? char.stats?.hp ?? 0;
                    const curHp = char.stats?.currentHp ?? maxHp;

                    // âœ… æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦å®Œæˆè„±æˆ˜å›è¡€æœŸï¼ˆæˆ–è¡€é‡å·²æ»¡ï¼‰
                    const isRegenPeriodOver = (now - lastCombatTime >= REGEN_DELAY_MS);
                    const isFullHp = curHp >= maxHp;

                    // âœ… æ·»åŠ è°ƒè¯•æ—¥å¿—
                    console.log('ã€æˆ˜æ–—æ£€æŸ¥ã€‘', {
                        charName: char.name,
                        now,
                        lastCombatTime,
                        timeSinceCombat: now - lastCombatTime,
                        REGEN_DELAY_MS,
                        isRegenPeriodOver,
                        curHp,
                        maxHp,
                        isFullHp,
                        willStartCombat: isRegenPeriodOver && isFullHp
                    });

                    // åªæœ‰å›è¡€æœŸç»“æŸæˆ–è¡€é‡å·²æ»¡ï¼Œæ‰å¼€å§‹æ–°æˆ˜æ–—
                    if (isRegenPeriodOver && isFullHp) {
                        const enemy = zone.enemies[Math.floor(Math.random() * zone.enemies.length)];
                        char.combatState = createCombatState(char, enemy, char.skillSlots || []);
                        char.lastCombatTime = now; // è¿›å…¥æˆ˜æ–—
                        console.log('ã€å¼€å§‹æ–°æˆ˜æ–—ã€‘', char.name);
                    }
                }

                // æ¨è¿›å½“å‰æˆ˜æ–—ï¼šæ¯tickæ›´æ–°ä¸€æ¬¡ currentHp => UI å®æ—¶å˜åŒ–
                if (char.combatState) {
                    char.lastCombatTime = now; // æˆ˜æ–—ä¸­æŒç»­åˆ·æ–°ï¼Œç¡®ä¿ä¸ä¼šè¢«è„±æˆ˜å›è¡€é€»è¾‘å½±å“

                    const step = stepCombatRounds(char, char.combatState, COMBAT_ROUNDS_PER_TICK, newState);

                    const endHp = Number.isFinite(step.charHp)
                        ? Math.max(0, Math.floor(step.charHp))
                        : (char.stats.currentHp ?? char.stats.maxHp);

                    char.stats = { ...char.stats, currentHp: endHp };
                    char.combatState = step.combatState;

                    // æˆ˜æ–—ç»“æŸï¼šå†™æ—¥å¿—ã€ç»“ç®—å¥–åŠ±ã€æ¸… combatState
                    if (step.finished) {
                        char.lastCombatTime = now; // ç»“æŸä¹Ÿåˆ·æ–°ä¸€æ¬¡ï¼šè„±æˆ˜å›è¡€ä»è¿™é‡Œå¼€å§‹è®¡æ—¶

                        const enemy = step.combatState.enemy;

                        const finalLogs = step.combatState.logs || [];

                        // âœ… ç§æ—ï¼šå®¾è‡³å¦‚å½’ï¼ˆäººç±»ï¼‰- åœ°å›¾æˆ˜æ–—ç»“æŸåå›å¤æœ€å¤§ç”Ÿå‘½å€¼çš„ 10%
                        const raceTrait = RACE_TRAITS?.[char.race];
                        const hospitalityPct = Number(raceTrait?.mapCombatEndHealPct) || 0;
                        if (hospitalityPct > 0) {
                            const maxHp = Number(char.stats?.maxHp ?? char.stats?.hp) || 0;
                            const curHp = Number(char.stats?.currentHp ?? maxHp) || 0;

                            // æ­»äº¡ï¼ˆ<=0ï¼‰ä¸è§¦å‘ï¼Œé¿å…â€œå¤æ´»â€ï¼›æ»¡è¡€ä¸è§¦å‘
                            if (maxHp > 0 && curHp > 0 && curHp < maxHp) {
                                const heal = Math.floor(maxHp * hospitalityPct);
                                if (heal > 0) {
                                    const nextHp = Math.min(maxHp, curHp + heal);
                                    if (nextHp !== curHp) {
                                        char.stats = { ...char.stats, currentHp: nextHp };

                                        // å†™å…¥æˆ˜æ–—æ—¥å¿—ï¼ˆæ©™è‰²ï¼šè¢«åŠ¨è§¦å‘ï¼‰
                                        finalLogs.push({
                                            kind: 'proc',
                                            proc: 'å®¾è‡³å¦‚å½’',
                                            text: `ã€å®¾è‡³å¦‚å½’ã€‘è§¦å‘ï¼šå›å¤ ${nextHp - curHp} ç‚¹ç”Ÿå‘½`
                                        });
                                    }
                                }
                            }
                        }


                        newState.combatLogs = [
                            {
                                id: `log_${Date.now()}_${Math.random()}`,
                                timestamp: Date.now(),
                                characterName: char.name,
                                zoneName: zone.name,
                                enemyName: enemy.name,
                                result: step.won ? 'victory' : 'defeat',
                                logs: finalLogs,
                                rewards: step.won ? { gold: enemy.gold, exp: enemy.exp } : { gold: 0, exp: 0 }
                            },
                            ...newState.combatLogs
                        ].slice(0, 50);

                        // æ¸…ç†æˆ˜æ–—çŠ¶æ€
                        char.combatState = null;

                        // å¤±è´¥ï¼šå¦‚æœæ­»äº¡åˆ™å¬å›
                        if (!step.won) {
                            if (endHp <= 0) {
                                toRecall.push(charId);
                            }
                        } else {
                            // èƒœåˆ©ç»“ç®—
                            newState.resources.gold += getEffectiveGoldGain(enemy.gold, newState);

                            let expGained = (1 + (char.stats.expBonus || 0));
                            char.exp += enemy.exp * expGained;

                            while (char.exp >= char.expToNext && char.level < 200) {
                                char.exp -= char.expToNext;
                                char.level++;
                                char.expToNext = Math.floor(100 * Math.pow(1.2, char.level - 1));
                                char.skills = learnNewSkills(char);
                                char.stats = calculateTotalStats(char, undefined, state);
                            }

                            newState.stats.battlesWon++;

                            // âœ… è·¨ä¸–ç´¯è®¡ï¼šåœ°å›¾åŒºåŸŸå‡»æ€è®¡æ•°ï¼ˆç”¨äºæˆå°±è¿›åº¦ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿä¸é‡ç½®ï¼‰
                            if (zoneId) {
                                nextZoneKillCounts[zoneId] = (nextZoneKillCounts[zoneId] || 0) + 1;
                                zoneKillCountsUpdated = true;
                            }

                            const mapResourceNameToKey = (name) => {
                                const m = {
                                    'æœ¨æ': 'wood',
                                    'è‰è¯': 'herb',
                                    'é“çŸ¿': 'ironOre',
                                    'æ¯›çš®': 'leather',
                                    'é­”æ³•ç²¾å': 'magicEssence',
                                    'ç‚¼é‡‘æ²¹': 'alchemyOil',
                                };
                                return m[name] || null;
                            };

                            if (Math.random() < 0.1 && zone.resources) {
                                const resourceName = zone.resources[Math.floor(Math.random() * zone.resources.length)];
                                const key = mapResourceNameToKey(resourceName);
                                if (key) {
                                    newState.resources = { ...newState.resources, [key]: (newState.resources[key] || 0) + 1 };
                                }
                            }

                            // âœ… æ–°å¢ï¼šè®°å½•æ‰è½ç‰©å“
                            const droppedItems = [];

                            // âœ… è£…å¤‡æ‰è½ï¼ˆä¿®æ”¹ç‰ˆï¼šè®°å½•æ‰è½ä¿¡æ¯ï¼‰
                            const dropTable = DROP_TABLES[zone.id];
                            if (dropTable?.equipment && newState.inventory.length < newState.inventorySize) {
                                const allowDrop = (id) => state.dropFilters?.[id] !== false;

                                dropTable.equipment.filter(drop => allowDrop(drop.id)).forEach(drop => {
                                    if (newState.inventory.length >= newState.inventorySize) return;

                                    const baseChance = drop.chance ?? 0;
                                    const effectiveChance = getEffectiveDropChance(baseChance, newState);

                                    if (Math.random() < effectiveChance) {
                                        const instance = createEquipmentInstance(drop.id);
                                        if (instance) {
                                            newState.inventory.push(instance);
                                            newState = addEquipmentIdToCodex(newState, drop.id);

                                            // âœ… è®°å½•æ‰è½ä¿¡æ¯
                                            droppedItems.push({
                                                name: instance.name,
                                                rarity: instance.rarity,
                                                chance: effectiveChance * 100, // è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼ˆåŠ æˆåï¼‰
                                                baseChance: baseChance * 100   // è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼ˆåŸºç¡€ï¼‰
                                            });
                                        }
                                    }
                                });
                            }

                            // âœ… ç‰©å“æ‰è½ï¼ˆå¦‚æœä½ ä¹Ÿæƒ³ç”¨æ‰è½è¡¨çš„ itemsï¼‰
                            if (dropTable?.items && newState.inventory.length < newState.inventorySize) {

                                const allowDrop = (id) => state.dropFilters?.[id] !== false; // é»˜è®¤å…è®¸

                                dropTable.items.filter(drop => allowDrop(drop.id)).forEach(drop => {
                                    if (newState.inventory.length >= newState.inventorySize) return;

                                    const baseChance = drop.chance ?? 0;
                                    const effectiveChance = getEffectiveDropChance(baseChance, newState);
                                    if (Math.random() < effectiveChance) {
                                        const tpl = ITEMS[drop.id];
                                        if (tpl) {
                                            newState.inventory.push({
                                                ...tpl,
                                                instanceId: `inv_${Date.now()}_${Math.random()}`,
                                                id: tpl.id,            // ä¿æŒæ¨¡æ¿ id: IT_001
                                            });
                                            newState = addJunkIdToCodex(newState, drop.id);

                                            // âœ… è®°å½•æ‰è½ä¿¡æ¯
                                            droppedItems.push({
                                                name: tpl.name,
                                                rarity: tpl.rarity || 'white',
                                                chance: effectiveChance * 100, // è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼ˆåŠ æˆåï¼‰
                                                baseChance: baseChance * 100   // è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼ˆåŸºç¡€ï¼‰
                                            });
                                        }
                                    }
                                });
                            }

                            // âœ… å°†æ‰è½ä¿¡æ¯æ·»åŠ åˆ°æˆ˜æ–—æ—¥å¿—
                            if (droppedItems.length > 0) {
                                const fmtPct = (pct) => (pct < 1 ? pct.toFixed(2) : pct.toFixed(1));
                                droppedItems.forEach(item => {
                                    const basePct = Number.isFinite(item.baseChance) ? item.baseChance : item.chance;
                                    const effPct = item.chance;
                                    const showArrow = Number.isFinite(item.baseChance) && Math.abs(basePct - effPct) > 1e-9;
                                    finalLogs.push({
                                        round: 'ç»“ç®—',
                                        kind: 'drop',
                                        itemName: item.name,
                                        rarity: item.rarity,
                                        chance: item.chance,
                                        text: `ğŸ æ‰è½ã€${item.name}ã€‘ï¼Œæ¦‚ç‡ï¼š${fmtPct(basePct)}%${showArrow ? ` â†’ ${fmtPct(effPct)}%` : ''}`
                                    });
                                });
                            }

                        }
                    }

                    // å†™å›è§’è‰²
                    newState.characters = [...newState.characters];
                    newState.characters[charIndex] = char;
                }
            });
            if (toRecall.length > 0) {
                const newAssignments = { ...newState.assignments };
                toRecall.forEach(id => delete newAssignments[id]);
                newState.assignments = newAssignments;
            }

            // å†™å›è·¨ä¸–ç´¯è®¡å‡»æ€è®¡æ•°ï¼ˆç”¨äºæˆå°±è¿›åº¦ï¼‰
            if (zoneKillCountsUpdated) {
                newState.zoneKillCounts = nextZoneKillCounts;
            }

            // âœ… æˆå°±è§£é”æ£€æµ‹ï¼ˆè‹¥æˆå°±ä¼šå½±å“å±æ€§ï¼Œå¦‚ hpPctï¼Œéœ€è¦é‡ç®—å…¨é˜Ÿé¢æ¿ï¼‰
            let achievementUnlockedThisTick = false;
            Object.entries(ACHIEVEMENTS).forEach(([id, achievement]) => {
                if (!newState.achievements[id] && achievement.condition(newState)) {
                    newState.achievements = { ...newState.achievements, [id]: true };
                    achievementUnlockedThisTick = true;
                }
            });

            if (achievementUnlockedThisTick) {
                // æˆå°±å¯èƒ½æ”¹å˜è§’è‰²æ€»è¡€é‡ç­‰æ°¸ä¹…å±æ€§ï¼Œéœ€è¦ç«‹å³é‡ç®—ï¼Œå¦åˆ™éœ€è¦ç­‰åˆ°ä¸‹æ¬¡å‡çº§/é‡ç®—æ‰ç”Ÿæ•ˆ
                newState.characters = recalcPartyStats(newState, newState.characters);
            }

            const maxCharLevel = Math.max(...newState.characters.map(c => c.level), 0);
            Object.values(newState.zones).forEach(zone => {
                if (!zone.unlocked && zone.unlockLevel && maxCharLevel >= zone.unlockLevel) {
                    zone.unlocked = true;
                }
            });


            newState.characters = newState.characters.map(char => {
                const maxHp = char.stats?.maxHp ?? char.stats?.hp ?? 0;
                const curHp = char.stats?.currentHp ?? maxHp;

                // æˆ˜æ–—ä¸­ä¸å›è¡€
                if (char.combatState) return char;

                if (curHp >= maxHp) return char;

                const lastCombatTime = char.lastCombatTime || 0;
                if (now - lastCombatTime < REGEN_DELAY_MS) return char;

                return {
                    ...char,
                    stats: {
                        ...char.stats,
                        currentHp: Math.min(maxHp, curHp + REGEN_PER_SECOND+fountainCount*2)
                    }
                };
            });

            // ==================== æ–°å¢ï¼šæœºæ¢°è‡‚è‡ªåŠ¨åˆæˆå‰Næ ¼è£…å¤‡ ====================
            const mechanicalArmCount = newState.functionalBuildings?.mechanical_arm ?? 0;
            const autoMergeSlots = Math.min(10, mechanicalArmCount);

            // è®¡æ—¶å™¨ï¼ˆæ¯30ç§’æ‰§è¡Œä¸€æ¬¡ï¼‰
            let timer = (newState.autoMergeTimer || 0) + deltaSeconds;
            let executions = 0;
            while (timer >= 30) {
                timer -= 30;
                executions++;
            }
            newState.autoMergeTimer = timer;

            if (executions > 0 && autoMergeSlots > 0 && newState.inventory?.length > 0) {
                let newInventory = [...newState.inventory];

                for (let exec = 0; exec < executions; exec++) {
                    let changed = false;

                    // ä»å‰åˆ°åå¤„ç†å‰ N æ ¼ç›®æ ‡
                    for (let slot = 0; slot < autoMergeSlots && slot < newInventory.length; slot++) {
                        let target = newInventory[slot];

                        if (!target || target.type !== 'equipment' || (target.currentLevel ?? 1) >= 100) {
                            continue;
                        }

                        const oldLevel = target.currentLevel ?? 1;

                        // é“¾å¼åƒåŒæ¬¾ï¼ˆåªåƒåé¢çš„ï¼‰
                        while (true) {
                            let sourceIndex = -1;
                            for (let j = slot + 1; j < newInventory.length; j++) {
                                const source = newInventory[j];
                                if (source &&
                                    source.type === 'equipment' &&
                                    source.id === target.id &&
                                    source.instanceId !== target.instanceId) {
                                    sourceIndex = j;
                                    break;
                                }
                            }

                            if (sourceIndex === -1) break; // æ²¡åŒæ¬¾äº†

                            const source = newInventory[sourceIndex];

                            // æ–°è§„åˆ™ï¼šç­‰çº§ = ç›®æ ‡å½“å‰ç­‰çº§ + æ¥æºç­‰çº§ + 1
                            target.currentLevel = Math.min(100,
                                (target.currentLevel ?? 1) + (source.currentLevel ?? 1) + 1
                            );

                            // æ›´æ–°å±æ€§
                            target.stats = scaleStats(
                                target.baseStats,
                                target.growth,
                                target.currentLevel
                            );

                            // ç§»é™¤è¢«åƒçš„è£…å¤‡
                            newInventory.splice(sourceIndex, 1);

                            changed = true;

                            // æ»¡çº§ååœæ­¢åƒï¼ˆé¿å…æ— æ„ä¹‰ç»§ç»­æ‰¾ï¼‰
                            if (target.currentLevel >= 100) break;
                        }

                        // å†™å›
                        newInventory[slot] = target;

                        // Lv100 å›¾é‰´è§£é”
                        if (oldLevel < 100 && target.currentLevel >= 100) {
                            newState.lv100Codex = {
                                ...(newState.lv100Codex || {}),
                                [target.id]: true
                            };
                            newState.combatLogs = [
                                ...(newState.combatLogs || []),
                                `æœºæ¢°è‡‚è‡ªåŠ¨åˆæˆï¼š${target.name} è¾¾åˆ° Lv100ï¼Œå›¾é‰´è§£é”ï¼`
                            ];
                        }
                    }

                    if (!changed) break; // æœ¬æ¬¡æ‰§è¡Œæ²¡åˆæˆä»»ä½•ä¸œè¥¿ï¼Œæå‰ç»“æŸ
                }

                newState.inventory = newInventory;
            }
            // ==================== æœºæ¢°è‡‚é€»è¾‘ç»“æŸ ====================

            // å¸§æ•°ç´¯è®¡
            newState.frame = (newState.frame || 0) + deltaSeconds;
            newState.lifeFrame = (newState.lifeFrame || 0) + deltaSeconds;

            return newState;
        }

        case 'CREATE_CHARACTER': {
            const { name, race, classId } = action.payload;
            console.log(race);
            if (state.characters.length >= state.characterSlots) return state;

            const classData = CLASSES[classId];
            const baseSkillSlots = Array(8).fill('basic_attack');
            const baseSkills = classData.skills.filter(s => s.level <= 1).map(s => s.skillId);
            const raceExtraSkills = RACE_TRAITS?.[race]?.extraSkills || [];
            console.log(RACE_TRAITS?.[race]?.extraSkills.length);
            const newChar = {
                id: `char_${Date.now()}`,
                name,
                race,
                classId,
                level: 1,
                exp: 0,
                expToNext: 100,
                equipment: {},
                talents: {},
                // å½“å‰æ¿€æ´»çš„æŠ€èƒ½æ§½ä½ï¼ˆç”¨äºæˆ˜æ–—è¯»å–ï¼‰
                skillSlots: [...baseSkillSlots],
                // ä¸‰å¥—æŠ€èƒ½é…ç½®ï¼š1/2/3
                skillSets: [
                    [...baseSkillSlots],
                    [...baseSkillSlots],
                    [...baseSkillSlots]
                ],
                activeSkillSet: 0,
                skills: Array.from(new Set([...(baseSkills || []), ...(raceExtraSkills || [])])),
                buffs: [],
                lastCombatTime: 0,
                combatState: null,
            };

            newChar.stats = calculateTotalStats(newChar, undefined, state);

            return {
                ...state,
                characters: [...state.characters, newChar]
            };
        }

        case 'UPDATE_SKILL_SETS': {
            const { characterId, skillSets, activeSkillSet } = action.payload || {};
            const charIndex = state.characters.findIndex(c => c.id === characterId);
            if (charIndex === -1) return state;

            const make8 = (arr, fallback) => Array.from({ length: 8 }, (_, i) => (arr?.[i] ?? fallback?.[i] ?? ''));

            const newChars = [...state.characters];
            const target = newChars[charIndex];

            const base = make8(target.skillSlots || [], Array(8).fill('basic_attack'));

            let setsRaw = Array.isArray(skillSets) ? skillSets : null;
            if (!setsRaw || setsRaw.length === 0) {
                setsRaw = [base, [...base], [...base]];
            }

            const s0 = make8(setsRaw[0], base);
            const s1 = make8(setsRaw[1], s0);
            const s2 = make8(setsRaw[2], s0);
            const normalizedSets = [s0, s1, s2];

            let active = Number.isFinite(Number(activeSkillSet))
                ? Math.floor(Number(activeSkillSet))
                : (Number.isFinite(Number(target.activeSkillSet)) ? Math.floor(Number(target.activeSkillSet)) : 0);
            active = Math.max(0, Math.min(2, active));

            const activeSlots = normalizedSets[active] || s0;

            newChars[charIndex] = {
                ...target,
                skillSets: normalizedSets,
                activeSkillSet: active,
                // åŒæ­¥ï¼šæˆ˜æ–—è¯»å– skillSlotsï¼ˆæ¿€æ´»çš„é‚£å¥—ï¼‰
                skillSlots: [...activeSlots],
            };

            return {
                ...state,
                characters: newChars
            };
        }

        // legacyï¼šåªæ›´æ–°â€œå½“å‰æ¿€æ´»é…ç½®â€çš„ skillSlotsï¼Œå¹¶å†™å›åˆ° skillSets[active]
        case 'UPDATE_SKILL_SLOTS': {
            const { characterId, skillSlots } = action.payload || {};
            const charIndex = state.characters.findIndex(c => c.id === characterId);
            if (charIndex === -1) return state;

            const make8 = (arr, fallback) => Array.from({ length: 8 }, (_, i) => (arr?.[i] ?? fallback?.[i] ?? ''));

            const newChars = [...state.characters];
            const target = newChars[charIndex];

            let active = Number.isFinite(Number(target.activeSkillSet)) ? Math.floor(Number(target.activeSkillSet)) : 0;
            active = Math.max(0, Math.min(2, active));

            const slots8 = make8(skillSlots, target.skillSlots || Array(8).fill(''));
            const base = make8(target.skillSlots || [], Array(8).fill('basic_attack'));

            // ensure existing sets
            const raw = Array.isArray(target.skillSets) ? target.skillSets : null;
            const s0 = make8(raw?.[0], base);
            const s1 = make8(raw?.[1], s0);
            const s2 = make8(raw?.[2], s0);
            const normalizedSets = [s0, s1, s2];
            normalizedSets[active] = [...slots8];

            newChars[charIndex] = {
                ...target,
                skillSlots: [...slots8],
                skillSets: normalizedSets,
                activeSkillSet: active
            };

            return {
                ...state,
                characters: newChars
            };
        }

        case 'SYNC_CHARACTER_SKILLS': {
            const { characterId } = action.payload;
            const charIndex = state.characters.findIndex(c => c.id === characterId);
            if (charIndex === -1) return state;

            const target = state.characters[charIndex];
            const curSkills = target.skills || [];
            const nextSkills = learnNewSkills(target);

            // æ²¡æœ‰æ–°æŠ€èƒ½åˆ™ä¸æ›´æ–°
            const isSame =
                nextSkills.length === curSkills.length &&
                nextSkills.every(s => curSkills.includes(s));

            if (isSame) return state;

            const newChars = [...state.characters];
            newChars[charIndex] = { ...target, skills: nextSkills };

            // ä¿é™©ï¼šé‡ç®—å…¨é˜Ÿå±æ€§ï¼ˆå…‰ç¯ç­‰ï¼‰
            const updatedParty = recalcPartyStats(state, newChars);

            return {
                ...state,
                characters: updatedParty
            };
        }


        case 'EQUIP_ITEM': {
            const { characterId, itemInstanceId } = action.payload;

            // 1) æ‰¾åˆ°èƒŒåŒ…é‡Œçš„è¿™ä»¶è£…å¤‡
            const invIdx = state.inventory.findIndex(i =>
                (i.instanceId && i.instanceId === itemInstanceId) ||
                (!i.instanceId && i.id === itemInstanceId) // å…¼å®¹è€å­˜æ¡£
            );
            if (invIdx === -1) return state;

            const item = state.inventory[invIdx];
            if (!item || item.type !== 'equipment') return state;

            const slot = item.slot;
            if (!slot) return state;

            // 2) æ›´æ–°è§’è‰²ï¼šæŠŠè£…å¤‡æ”¾è¿›å¯¹åº” slot
            const newChars = state.characters.map(c => {
                if (c.id !== characterId) return c;

                const prevEquipped = c.equipment?.[slot] || null;

                const nextChar = {
                    ...c,
                    equipment: {
                        ...(c.equipment || {}),
                        [slot]: item,
                    },
                };

                // 3) é‡ç®—å±æ€§ï¼ˆä½ å·²ç»æœ‰ calculateTotalStatsï¼‰
                nextChar.stats = calculateTotalStats(nextChar, undefined, state);

                // æŠŠä¹‹å‰ç©¿ç€çš„åŒæ§½è£…å¤‡ï¼ˆå¦‚æœæœ‰ï¼‰ä¸´æ—¶æŒ‚åˆ° nextChar ä¸Šï¼Œæ–¹ä¾¿åé¢å¡å›èƒŒåŒ…
                nextChar.__prevEquipped = prevEquipped;
                return nextChar;
            });

            // 4) èƒŒåŒ…ç§»é™¤å·²è£…å¤‡ç‰©å“ï¼Œå¹¶æŠŠè¢«æ›¿æ¢ä¸‹æ¥çš„è£…å¤‡å¡å›èƒŒåŒ…ï¼ˆæœ‰ç©ºé—´æ‰å¡ï¼‰
            const newInventory = [...state.inventory];
            newInventory.splice(invIdx, 1);

            const equippedChar = newChars.find(c => c.id === characterId);
            const prevEquipped = equippedChar?.__prevEquipped;
            if (prevEquipped) {
                if (newInventory.length < state.inventorySize) {
                    newInventory.push(prevEquipped);
                }
            }

            // æ¸…ç†ä¸´æ—¶å­—æ®µ
            const cleanedChars = newChars.map(c => {
                if (c.__prevEquipped === undefined) return c;
                const { __prevEquipped, ...rest } = c;
                return rest;
            });

            const finalChars = recalcPartyStats(state,cleanedChars);

            return {
                ...state,
                characters: finalChars,
                inventory: newInventory,
            };
        }

        case 'UNEQUIP_ITEM': {
            const { characterId, slot } = action.payload;

            // Ensure the character exists
            const char = state.characters.find(c => c.id === characterId);
            if (!char) return state;

            // Get the item to unequip
            const equipped = char.equipment?.[slot];
            if (!equipped) return state;

            // Ensure the inventory has space
            if (state.inventory.length >= state.inventorySize) return state;

            // Map over characters and update their stats after unequipping the item
            const newChars = state.characters.map(c => {
                if (c.id !== characterId) return c;

                // Clone the character's equipment to avoid mutation
                const newEquipment = { ...c.equipment };
                delete newEquipment[slot];  // Remove the equipment from the slot

                // Recalculate stats after unequipping the item
                const updatedChar = { ...c, equipment: newEquipment };
                updatedChar.stats = calculateTotalStats(updatedChar, undefined, state);

                return updatedChar;
            });

            // Add the unequipped item back to the inventory
            const newInventory = [...state.inventory, equipped];

            const finalChars = recalcPartyStats(state,newChars);
            return {
                ...state,
                characters: finalChars,
                inventory: newInventory,
            };
        }



        case 'MERGE_EQUIPMENT': {
            const { instanceIdA, instanceIdB } = action.payload;

            const idxA = state.inventory.findIndex(i => i.instanceId === instanceIdA);
            const idxB = state.inventory.findIndex(i => i.instanceId === instanceIdB);
            if (idxA === -1 || idxB === -1 || idxA === idxB) return state;

            const eqA = state.inventory[idxA];
            const eqB = state.inventory[idxB];
            if (eqA.type !== 'equipment' || eqB.type !== 'equipment') return state;

            const merged = mergeEquipments(eqA, eqB);
            if (!merged) return state;

            const newInventory = [...state.inventory];
            newInventory.splice(Math.max(idxA, idxB), 1);
            newInventory.splice(Math.min(idxA, idxB), 1);
            newInventory.push(merged);

            let nextState = {
                ...addEquipmentIdToCodex(state, merged.id),
                inventory: newInventory
            };

            if ((merged.currentLevel ?? merged.level ?? 0) >= 100) {
                nextState = addEquipmentIdToLv100Codex(nextState, merged.id);
            }

            return nextState;
        }



        case 'MERGE_EQUIPMENT_CHAIN': {
            const { targetInstanceId } = action.payload || {};
            if (!targetInstanceId) return state;

            let inv = [...state.inventory];

            const getLevel = (eq) => (eq?.currentLevel ?? eq?.level ?? 0);

            let targetIdx = inv.findIndex(i => i?.type === 'equipment' && i.instanceId === targetInstanceId);
            if (targetIdx === -1) return state;

            let target = inv[targetIdx];
            if (target?.type !== 'equipment') return state;

            while (getLevel(target) < 100) {
                const otherIdx = inv.findIndex(i =>
                    i?.type === 'equipment' &&
                    i.instanceId !== target.instanceId &&
                    i.id === target.id
                );

                if (otherIdx === -1) break;

                const other = inv[otherIdx];
                const merged = mergeEquipments(target, other);
                if (!merged) break;

                // ç§»é™¤è¢«åˆæˆçš„ä¸¤ä»¶è£…å¤‡ï¼ˆå…ˆåˆ è¾ƒå¤§ç´¢å¼•ï¼‰
                const idxA = inv.findIndex(i => i?.instanceId === target.instanceId);
                const idxB = inv.findIndex(i => i?.instanceId === other.instanceId);
                if (idxA === -1 || idxB === -1) break;

                inv.splice(Math.max(idxA, idxB), 1);
                inv.splice(Math.min(idxA, idxB), 1);

                inv.push(merged);
                target = merged;
            }

            let nextState = {
                ...addEquipmentIdToCodex(state, target.id),
                inventory: inv
            };

            if (getLevel(target) >= 100) {
                nextState = addEquipmentIdToLv100Codex(nextState, target.id);
            }

            return nextState;
        }

        case 'ASSIGN_ZONE': {
            const { characterId, zoneId } = action.payload;

            // æ£€æŸ¥è§’è‰²æ˜¯å¦åœ¨ä¸»åŸèµ„æºå»ºç­‘å·¥ä½œ
            const isInResourceBuilding = Object.values(state.resourceAssignments || {})
                .flat()
                .includes(characterId);

            if (isInResourceBuilding) {
                // è§’è‰²æ­£åœ¨ä¸»åŸé‡‡é›†ï¼Œä¸èƒ½æ´¾é£å»åœ°å›¾
                console.warn(`è§’è‰² ${characterId} æ­£åœ¨ä¸»åŸé‡‡é›†ï¼Œæ— æ³•æ´¾é£åˆ°åœ°å›¾`);
                return state;
            }

            return {
                ...state,
                assignments: {
                    ...state.assignments,
                    [characterId]: zoneId
                }
            };
        }

        case 'UNASSIGN_CHARACTER': {
            const { characterId } = action.payload;
            const newAssignments = { ...state.assignments };
            delete newAssignments[characterId];

            // å¬å›æ—¶è§†ä¸ºè„±æˆ˜ï¼šæ¸…ç†æˆ˜æ–—çŠ¶æ€ï¼Œå¹¶åˆ·æ–° lastCombatTimeï¼ˆ5ç§’åå¼€å§‹å›è¡€ï¼‰
            const newChars = state.characters.map(c => {
                if (c.id !== characterId) return c;
                return {
                    ...c,
                    combatState: null,
                    lastCombatTime: Date.now()
                };
            });

            return {
                ...state,
                assignments: newAssignments,
                characters: newChars
            };
        }

        case 'BUILD': {
            const { buildingId } = action.payload;
            const building = BUILDINGS[buildingId];

            // å·²å»ºæ•°é‡ï¼ˆå»ºç¬¬1åº§æ—¶ builtCount=0 â†’ 100% æˆæœ¬ï¼‰
            const builtCount = state.buildings[buildingId] || 0;

            // æ¯å¤šä¸€åº§ +10%
            const multiplier = 1 + builtCount * 0.1;

            // è®¡ç®—åŠ¨æ€æˆæœ¬ï¼ˆå‘ä¸Šå–æ•´é¿å…å‡ºç°å°æ•°ï¼‰
            const dynamicCost = {};
            Object.entries(building.cost).forEach(([resource, amount]) => {
                dynamicCost[resource] = Math.ceil(amount * multiplier);
            });

            // æ ¡éªŒèµ„æºå¤Ÿä¸å¤Ÿ
            let canBuild = true;
            Object.entries(dynamicCost).forEach(([resource, amount]) => {
                if ((state.resources[resource] || 0) < amount) canBuild = false;
            });
            if (!canBuild) return state;

            // æ‰£èµ„æº
            const newResources = { ...state.resources };
            Object.entries(dynamicCost).forEach(([resource, amount]) => {
                newResources[resource] -= amount;
            });

            return {
                ...state,
                resources: newResources,
                buildings: {
                    ...state.buildings,
                    [buildingId]: builtCount + 1
                }
            };
        }


        case 'START_RESEARCH': {
            const { researchId } = action.payload;
            const research = RESEARCH?.[researchId];

            // å®‰å…¨æ ¡éªŒï¼šä¸å­˜åœ¨/æœªè§£é”åˆ™æ‹’ç»å¼€å§‹ç ”ç©¶
            if (!research) return state;
            if (research.unlockBoss && !(state.defeatedBosses || []).includes(research.unlockBoss)) {
                alert(`æœªè§£é”ï¼šéœ€è¦å‡»è´¥ ${WORLD_BOSSES?.[research.unlockBoss]?.name || research.unlockBoss}`);
                return state;
            }

            if (state.currentResearch) return state;
            return {
                ...state,
                currentResearch: researchId,
                researchProgress: 0
            };
        }

        case 'CANCEL_RESEARCH': {
            return {
                ...state,
                currentResearch: null,
                researchProgress: 0
            };
        }

        case 'USE_ITEM': {
            const { itemInstanceId } = action.payload;

            const idx = state.inventory.findIndex(i =>
                (i.instanceId && i.instanceId === itemInstanceId) ||
                (!i.instanceId && i.id === itemInstanceId) // å…¼å®¹è€æ•°æ®
            );
            if (idx === -1) return state;

            const item = state.inventory[idx];
            // âœ… é‚€è¯·å‡½é€»è¾‘
            if (item.id === 'REBIRTH_INVITATION') {
                const newInventory = [...state.inventory];
                newInventory.splice(idx, 1);

                const alreadyRebirthed = (state.rebirthCount || 0) > 0;

                return {
                    ...state,
                    inventory: newInventory,
                    rebirthUnlocked: true,
                    showRebirthConfirm: !alreadyRebirthed // åªæœ‰æ²¡é‡ç”Ÿè¿‡æ‰å¼¹ç¡®è®¤
                };
            }

            // âœ… ä¿®å¤ï¼šé»‘é¾™åŒ–èº«çš„è¯æ˜ - éœ€è¦æ­£ç¡®è¿”å›æ–°state
            if (item.id === 'IT_BLACK_DRAGON_PROOF') {
                const newInventory = [...state.inventory];
                newInventory.splice(idx, 1);

                return {
                    ...state,
                    inventory: newInventory,
                    worldBossProgress: {
                        ...state.worldBossProgress,
                        prestor_lady: true
                    }
                };
            }


// âœ… å¾½ç« ç±»é“å…·ï¼ˆå¤ç”¨â€œè¡€è‰²åå­—å†›å¾½ç« â€æ¨¡å¼ï¼‰ï¼šæ‰“å¼€â€œé€‰æ‹©ç›®æ ‡è£…å¤‡â€æ¨¡æ€æ¡†ï¼Œä¸ç«‹åˆ»æ¶ˆè€—
            if (BADGE_UPGRADE_RULES?.[item.id]) {
                return {
                    ...state,
                    showScarletBadgeModal: true,
                    pendingScarletBadgeInstanceId: item.instanceId || item.id,
                    pendingBadgeItemId: item.id
                };
            }

            const newInventory = [...state.inventory];
            newInventory.splice(idx, 1);

            return { ...state, inventory: newInventory };
        }

        case 'CLOSE_SCARLET_BADGE_MODAL': {
            return {
                ...state,
                showScarletBadgeModal: false,
                pendingScarletBadgeInstanceId: null,
                pendingBadgeItemId: null
            };
        }

        case 'APPLY_SCARLET_BADGE': {
            const { targetInstanceId } = action.payload || {};
            const badgeInstanceId = state.pendingScarletBadgeInstanceId;
            const badgeItemId = state.pendingBadgeItemId || 'IT_SCARLET_CRUSADER_BADGE';
            const rule = BADGE_UPGRADE_RULES?.[badgeItemId] || BADGE_UPGRADE_RULES.IT_SCARLET_CRUSADER_BADGE;
            if (!targetInstanceId || !badgeInstanceId) return state;

            // 1) æ ¡éªŒå¾½ç« ä»åœ¨èƒŒåŒ…
            const badgeIdx = state.inventory.findIndex(i =>
                (i.instanceId && i.instanceId === badgeInstanceId) ||
                (!i.instanceId && i.id === badgeInstanceId)
            );
            if (badgeIdx === -1) {
                return {
                    ...state,
                    showScarletBadgeModal: false,
                    pendingScarletBadgeInstanceId: null,
                    pendingBadgeItemId: null
                };
            }

            // 2) æ‰¾åˆ°ç›®æ ‡è£…å¤‡ï¼ˆå¯èƒ½åœ¨èƒŒåŒ…ï¼Œä¹Ÿå¯èƒ½å·²è£…å¤‡ï¼‰
            const invTargetIdx = state.inventory.findIndex(i => i?.type === 'equipment' && i.instanceId === targetInstanceId);
            let targetEq = invTargetIdx >= 0 ? state.inventory[invTargetIdx] : null;

            // å¦‚æœä¸åœ¨èƒŒåŒ…ï¼Œå°è¯•åœ¨è§’è‰²å·²è£…å¤‡ä¸­æŸ¥æ‰¾
            if (!targetEq) {
                for (const c of (state.characters || [])) {
                    for (const eq of Object.values(c.equipment || {})) {
                        if (eq?.type === 'equipment' && eq.instanceId === targetInstanceId) {
                            targetEq = eq;
                            break;
                        }
                    }
                    if (targetEq) break;
                }
            }

            if (!targetEq || !rule.isEligible(targetEq)) {
                return state; // éæ³•ç›®æ ‡ç›´æ¥å¿½ç•¥ï¼ˆUIé‡Œä¸€èˆ¬ä¸ä¼šå‡ºç°ï¼‰
            }


// 3) å‡çº§ç›®æ ‡è£…å¤‡ï¼ˆrule.incçº§ï¼Œå°é¡¶rule.capï¼‰
            const tpl = FIXED_EQUIPMENTS?.[targetEq.id];
            const hardCap = rule.cap ?? 100;
            const maxLv = Math.min(hardCap, (targetEq.maxLevel ?? tpl?.maxLevel ?? hardCap));
            const curLv = (targetEq.currentLevel ?? targetEq.level ?? 0);
            const nextLv = Math.min(maxLv, curLv + (rule.inc ?? 2));

            const baseStats = targetEq.baseStats || tpl?.baseStats || {};
            const growth = targetEq.growth || tpl?.growth || {};

            const upgradedEq = {
                ...targetEq,
                currentLevel: nextLv,
                stats: scaleStats(baseStats, growth, nextLv)
            };

            // 4) æ›´æ–°èƒŒåŒ…/è§’è‰²ä¸­çš„é‚£ä»¶è£…å¤‡
            let newInventory = [...state.inventory];
            if (invTargetIdx >= 0) {
                newInventory[invTargetIdx] = upgradedEq;
            }

            const newChars = (state.characters || []).map(c => {
                let changed = false;
                const nextEquip = { ...(c.equipment || {}) };
                for (const [slot, eq] of Object.entries(nextEquip)) {
                    if (eq?.type === 'equipment' && eq.instanceId === targetInstanceId) {
                        nextEquip[slot] = upgradedEq;
                        changed = true;
                    }
                }
                if (!changed) return c;
                const nextChar = { ...c, equipment: nextEquip };
                nextChar.stats = calculateTotalStats(nextChar, undefined, state);
                return nextChar;
            });

            // 5) æ¶ˆè€—å¾½ç« 
            newInventory.splice(badgeIdx, 1);

            // 6) äº®æ¡† Lv100 å›¾é‰´ï¼ˆå¦‚æœåˆ°è¾¾100ï¼‰
            let nextState = {
                ...state,
                inventory: newInventory,
                characters: recalcPartyStats(state, newChars),
                showScarletBadgeModal: false,
                pendingScarletBadgeInstanceId: null
            };
            if ((upgradedEq.currentLevel ?? 0) >= 100) {
                nextState = addEquipmentIdToLv100Codex(nextState, upgradedEq.id);
            }
            return nextState;
        }

        case 'SELL_ITEM': {
            const { itemInstanceId } = action.payload;

            const idx = state.inventory.findIndex(i =>
                (i.instanceId && i.instanceId === itemInstanceId) ||
                (!i.instanceId && i.id === itemInstanceId) // å…¼å®¹è€æ•°æ®
            );
            if (idx === -1) return state;

            const item = state.inventory[idx];
            if (!item.sellPrice) return state;

            const newInventory = [...state.inventory];
            newInventory.splice(idx, 1);

            return {
                ...state,
                inventory: newInventory,
                resources: {
                    ...state.resources,
                    gold: state.resources.gold + getEffectiveGoldGain(item.sellPrice, state)
                }
            };
        }

        case 'SELL_ALL_JUNK': {
            // è®¤å®šï¼štype === 'junk' ä¸”æœ‰ sellPrice çš„éƒ½ç®—â€œåƒåœ¾å¯å‡ºå”®â€
            const junkItems = state.inventory.filter(i => i?.type === 'junk' && (i.sellPrice || 0) > 0);
            if (junkItems.length === 0) return state;

            const totalGold = junkItems.reduce((sum, it) => sum + (it.sellPrice || 0), 0);

            const newInventory = state.inventory.filter(i => !(i?.type === 'junk' && (i.sellPrice || 0) > 0));

            return {
                ...state,
                inventory: newInventory,
                resources: {
                    ...state.resources,
                    gold: state.resources.gold + getEffectiveGoldGain(totalGold, state)
                }
            };
        }

        // ==================== å®ä¼Ÿå®åº“ï¼šé¢†å–å¥–åŠ± ====================
        // payload: { templateId }
        // é¢†å–æ—¶è£…å¤‡ç­‰çº§å›ºå®šä¸º 5 çº§
        case 'CLAIM_GRAND_VAULT_REWARD': {
            const { templateId } = action.payload || {};
            if (!templateId) return state;

            const nowTs = Date.now();
            const snap = computeGrandVaultSnapshot(state, nowTs);
            const dayKey = snap.dayKey;
            const gv = snap.grandVault || {};
            const rows = snap.rows || [];

            // å½“æ—¥å·²é¢†å–ï¼šé˜»æ­¢å†æ¬¡é¢†å–
            if (gv.claimedDayKey === dayKey) {
                alert('å®ä¼Ÿå®åº“ï¼šå½“æ—¥å·²ç»é¢†å–ã€‚');
                return state;
            }

            // åªå…è®¸é¢†å–å½“å‰å®åº“å€™é€‰ä¸­çš„è£…å¤‡ï¼ˆé˜²æ­¢ç»•è¿‡ UI/è¿‡æœŸé¢†å–ï¼‰
            const isInVault = Array.isArray(rows) && rows.some(r => (r?.equipTemplateIds || []).includes(templateId));
            if (!isInVault) {
                alert('å®ä¼Ÿå®åº“ï¼šè¯¥å¥–åŠ±ä¸å±äºå½“å‰å®åº“ï¼ˆå¯èƒ½å·²åˆ·æ–°ï¼‰ã€‚');
                return { ...state, grandVault: gv };
            }

            // èƒŒåŒ…æ»¡åˆ™ä¸é¢†å–
            if ((state.inventory?.length || 0) >= (state.inventorySize || 0)) {
                return { ...state, grandVault: gv };
            }

            const inst0 = createEquipmentInstance(templateId);
            if (!inst0) return { ...state, grandVault: gv };

            const lv = GRAND_VAULT_EQUIP_LEVEL;
            const baseStats = inst0.baseStats || FIXED_EQUIPMENTS?.[templateId]?.baseStats || {};
            const growth = inst0.growth || FIXED_EQUIPMENTS?.[templateId]?.growth || {};

            const inst = {
                ...inst0,
                currentLevel: lv,
                stats: scaleStats(baseStats, growth, lv)
            };

            let newState = {
                ...state,
                stats: {
                    ...(state.stats || {}),
                    grandVaultPicks: (state.stats?.grandVaultPicks || 0) + 1
                },
                grandVault: {
                    ...gv,
                    claimedDayKey: dayKey,
                    claimedAt: nowTs,
                },
                inventory: [...(state.inventory || []), inst]
            };

            newState = addEquipmentIdToCodex(newState, templateId);
            return newState;
        }

        case 'SET_GRAND_VAULT': {
            const gv = action.payload?.grandVault;
            if (!gv || typeof gv !== 'object' || Array.isArray(gv)) return state;

            return {
                ...state,
                grandVault: gv
            };
        }

        case 'SET_TALENT': {
            const { characterId, tier, talentId } = action.payload || {};
            if (!characterId || !tier) return state;

            const updatedChars = state.characters.map(c => {
                if (c.id !== characterId) return c;

                const talents = { ...(c.talents || {}) };
                talents[tier] = talentId;

                return { ...c, talents };
            });

            // å…³é”®ï¼šå…‰ç¯ä¼šå½±å“å…¨é˜Ÿï¼Œæ‰€ä»¥è¦å…¨é˜Ÿä¸€èµ·é‡ç®—
            const newChars = recalcPartyStats(state,updatedChars);

            return { ...state, characters: newChars };
        }


        case 'SET_MENU': {
            return {
                ...state,
                currentMenu: action.payload
            };
        }

        case 'EXPORT_SAVE': {
            return state;
        }

        case 'IMPORT_SAVE': {
            try {
                const decoded = JSON.parse(decodeBase64(action.payload));

                // ===== 1ï¸âƒ£ è¡¥è€å­˜æ¡£å­—æ®µï¼ˆé˜²å¾¡æ€§ï¼‰=====
                decoded.rebirthBonuses ??= {};
                decoded.rebirthBonuses.exp ??= 0;
                decoded.rebirthBonuses.gold ??= 0;
                decoded.rebirthBonds ??= [];
                decoded.codexEquipLv100 ??= [];
                decoded.bossCooldowns ??= {};
                decoded.worldBossKillCounts ??= {};
                decoded.worldBossAutoKill ??= {};

                // ===== å®ä¼Ÿå®åº“ï¼ˆæ¯æ—¥æ—©ä¸Š9ç‚¹åˆ·æ–°ï¼‰å…¼å®¹æ—§æ¡£ =====
                decoded.grandVault ??= {};
                if (typeof decoded.grandVault !== 'object' || Array.isArray(decoded.grandVault)) {
                    decoded.grandVault = {};
                }
                decoded.grandVault.dayKey ??= '';
                decoded.grandVault.rows ??= null;
                decoded.grandVault.badgePicks ??= {};
                if (typeof decoded.grandVault.badgePicks !== 'object' || Array.isArray(decoded.grandVault.badgePicks)) {
                    decoded.grandVault.badgePicks = {};
                }
                decoded.grandVault.claimedDayKey ??= '';
                decoded.grandVault.lastRefreshAt ??= 0;
                decoded.grandVault.claimedAt ??= 0;

                decoded.zoneKillCounts ??= {};
                if (typeof decoded.zoneKillCounts !== 'object' || Array.isArray(decoded.zoneKillCounts)) {
                    decoded.zoneKillCounts = {};
                }

                // statsï¼ˆç”¨äºæˆå°±/ç»Ÿè®¡ï¼‰
                decoded.stats ??= {};
                decoded.stats.battlesWon ??= 0;
                decoded.stats.totalDamage ??= 0;
                decoded.stats.totalHealing ??= 0;
                decoded.stats.bossLateRoundDefeats ??= 0;
                decoded.stats.grandVaultPicks ??= 0;

// ===== 2ï¸âƒ£ è§’è‰²æŠ€èƒ½æ ï¼šä¸‰å¥—æŠ€èƒ½é…ç½®å…¼å®¹æ—§æ¡£ =====
                if (Array.isArray(decoded.characters)) {
                    decoded.characters = decoded.characters.map(c => {
                        const make8 = (arr, fallback) => Array.from({ length: 8 }, (_, i) => (arr?.[i] ?? fallback?.[i] ?? ''));
                        const baseSlots = make8(c.skillSlots || [], Array(8).fill('basic_attack'));

                        let sets = Array.isArray(c.skillSets) ? c.skillSets : null;
                        if (!sets || sets.length === 0) {
                            sets = [baseSlots, [...baseSlots], [...baseSlots]];
                        } else {
                            const s0 = make8(sets[0], baseSlots);
                            const s1 = make8(sets[1], s0);
                            const s2 = make8(sets[2], s0);
                            sets = [s0, s1, s2];
                        }

                        let active = Number.isFinite(Number(c.activeSkillSet)) ? Math.floor(Number(c.activeSkillSet)) : 0;
                        active = Math.max(0, Math.min(2, active));

                        const activeSlots = sets[active] || baseSlots;

                        // âœ… ç§æ—é¢å¤–æŠ€èƒ½ï¼šç¡®ä¿æ—§å­˜æ¡£çš„äººç±»ä¹Ÿèƒ½æ‹¿åˆ°
                        let learnedSkills = Array.isArray(c.skills) ? c.skills : [];
                        try {
                            learnedSkills = learnNewSkills({ ...c, skills: learnedSkills });
                        } catch (e) {
                            // ignore
                        }
                        const raceExtraSkills = RACE_TRAITS?.[c.race]?.extraSkills || [];
                        const mergedSkills = Array.from(new Set([...(learnedSkills || []), ...(raceExtraSkills || [])]));

                        return {
                            ...c,
                            skills: mergedSkills,
                            skillSets: sets,
                            activeSkillSet: active,
                            // åŒæ­¥ï¼šæˆ˜æ–—è¯»å– skillSlotsï¼ˆæ¿€æ´»çš„é‚£å¥—ï¼‰
                            skillSlots: make8(activeSlots, baseSlots),
                        };
                    });
                }

// ===== 3ï¸âƒ£ å…³é”®ï¼šé‡ç®—å…¨é˜Ÿå±æ€§ =====
                const fixedCharacters = recalcPartyStats(
                    decoded,
                    decoded.characters
                );

                return {
                    ...decoded,
                    characters: fixedCharacters,
                    lastOnlineTime: Date.now(),
                    offlineRewards: null
                };
            } catch (e) {
                console.error('IMPORT_SAVE failed', e);
                return state;
            }
        }

        case 'EXPAND_CHARACTER_SLOTS': {
            if (state.characterSlots >= state.maxCharacterSlots) return state;
            const cost = 1000 * Math.pow(2, state.characterSlots);
            if (state.resources.gold < cost) return state;

            return {
                ...state,
                resources: {
                    ...state.resources,
                    gold: state.resources.gold - cost
                },
                characterSlots: state.characterSlots + 1
            };
        }

        case 'CLEAR_COMBAT_LOGS': {
            return {
                ...state,
                combatLogs: []
            };
        }

        case 'OPEN_BOSS_PREPARE': {
            const bossId = action.payload;
            const cd = state.bossCooldowns?.[bossId] || 0;
            if (cd > 0) {
                const mm = String(Math.floor(cd / 60)).padStart(2, '0');
                const ss = String(cd % 60).padStart(2, '0');
                alert(`ã€${BOSS_DATA[bossId]?.name || bossId}ã€‘æ­£åœ¨é‡ç”Ÿä¸­ï¼Œå‰©ä½™ ${mm}:${ss}`);
                return state;
            }
            return {
                ...state,
                prepareBoss: bossId,
                bossTeam: [null, null, null],
                bossStrategy: { priorityBoss: true, stance: 'dispersed' }
            };
        }

        case 'CLOSE_BOSS_PREPARE': {
            return { ...state, prepareBoss: null, bossTeam: [null, null, null] };
        }

        case 'SET_BOSS_TEAM_SLOT': {
            const { slot, charId } = action.payload;
            const newTeam = [...state.bossTeam];
            // å¦‚æœåŒä¸€ä¸ªè§’è‰²å·²å­˜åœ¨ï¼Œç§»é™¤æ—§ä½ç½®
            const oldSlot = newTeam.indexOf(charId);
            if (oldSlot !== -1 && oldSlot !== slot) newTeam[oldSlot] = null;
            newTeam[slot] = charId ?? null;
            return { ...state, bossTeam: newTeam };
        }

        case 'SET_BOSS_STRATEGY': {
            const { key, value } = action.payload;
            return {
                ...state,
                bossStrategy: { ...state.bossStrategy, [key]: value }
            };
        }

        case 'START_BOSS_COMBAT': {
            const bossId = state.prepareBoss;
            if (!bossId) return state;
            const boss = BOSS_DATA[bossId];
            if (!boss) return state;

            const teamIds = state.bossTeam.filter(Boolean);
            if (teamIds.length === 0) return state;

            const teamChars = teamIds.map(id => state.characters.find(c => c.id === id)).filter(Boolean);
            // é‡æ–°è®¡ç®—é˜Ÿä¼å…‰ç¯
            const recalcedTeam = recalcPartyStats(state,teamChars.map(c => ({ ...c })));
            // âœ… æˆå°±ï¼šä»…BOSSæˆ˜æ–—ç”Ÿå‘½åŠ æˆï¼ˆå¦‚ã€é“å¿ƒæ¾„æ¾ˆâ… /â…¡ã€‘ï¼‰
            const bossHpPctBonus = getAchievementBossHpPctBonus(state);
            const recalcedTeamForBoss = (Number.isFinite(bossHpPctBonus) && bossHpPctBonus > 0)
                ? recalcedTeam.map(char => {
                    const baseMaxHp = Number(char.stats?.maxHp) || 0;
                    const nextMaxHp = Math.floor(baseMaxHp * (1 + bossHpPctBonus));
                    const baseHp = Number(char.stats?.hp) || baseMaxHp;
                    const nextHp = Math.floor(baseHp * (1 + bossHpPctBonus));
                    return {
                        ...char,
                        stats: {
                            ...char.stats,
                            hp: nextHp,
                            maxHp: nextMaxHp,
                            currentHp: nextMaxHp,
                        }
                    };
                })
                : recalcedTeam;


            const playerStates = recalcedTeamForBoss.map(char => ({
                char,
                currentHp: char.stats.maxHp,
                currentMp: char.stats.maxMp,
                skillIndex: 0,
                buffs: [],
                talentBuffs: { attackFlat: 0, blockValueFlat: 0, spellPowerFlat: 0 },
                fortuneMisfortuneStacks: 0, // ç¥¸ç¦ç›¸ä¾å±‚æ•°
                fantasiaStacks: 0,          // å¹»æƒ³æ›²å±‚æ•°ï¼ˆæˆ’å¾‹ç‰§å¸ˆ50çº§å¤©èµ‹ï¼Œä»…æœ¬åœºæˆ˜æ–—ï¼‰
                fingersOfFrost: 0, // å¯’å†°æŒ‡å±‚æ•°ï¼ˆå†°éœœæ³•å¸ˆï¼‰
                // âœ… ç§æ—æˆ˜æ–—å†…è§¦å‘çŠ¶æ€ï¼ˆæ¯åœºæˆ˜æ–—é‡ç½®ï¼‰
                racialFlags: {
                    stoneformCurseUsed: false,
                    stoneformPoisonUsed: false,
                },
                validSkills: Array.from({ length: 8 }, (_, i) => {
                    const sid = char.skillSlots?.[i] || '';
                    return sid && SKILLS[sid] ? sid : 'rest';
                }).map(sid => SKILLS[sid] ? sid : 'basic_attack')
            }));

            return {
                ...state,
                bossCombat: {
                    bossId,
                    strategy: { ...state.bossStrategy },
                    playerStates,
                    bossHp: boss.maxHp,
                    minions: [],
                    minionDebuffs: [],
                    bossDebuffs: [],
                    round: 0,
                    logs: []
                },
                prepareBoss: null
            };
        }
        case 'CLOSE_HOGGER_PLOT': return { ...state, showHoggerPlot: false };
        case 'OPEN_REBIRTH_CONFIRM': return { ...state, showRebirthConfirm: true };
        case 'CLOSE_REBIRTH_CONFIRM': return { ...state, showRebirthConfirm: false };
        case 'PERFORM_REBIRTH': {
            const equippedCount = state.characters.reduce((sum, char) =>
                sum + Object.values(char.equipment || {}).filter(Boolean).length, 0);
            if (state.inventory.length + equippedCount > state.inventorySize) {
                alert('é“å…·æ ç©ºé—´ä¸è¶³ï¼Œè¯·æ¸…ç†æˆ–æ‰©å®¹èƒŒåŒ…ä»¥å­˜æ”¾æ‰€æœ‰è£…å¤‡ï¼');
                return state;
            }

            let newState = { ...state, showRebirthConfirm: false };

            // å¸ä¸‹æ‰€æœ‰è£…å¤‡
            const extraItems = [];
            newState.characters = newState.characters.map(char => {
                Object.values(char.equipment || {}).forEach(eq => { if (eq) extraItems.push(eq); });
                return { ...char, equipment: {} };
            });
            newState.inventory = [...newState.inventory, ...extraItems];

            // ==================== æ–°çš„é‡ç”ŸåŠ æˆè®¡ç®—å…¬å¼ ====================
            // å¸§æ•°åŠ æˆï¼šå¯¹æ•°å‡½æ•°ï¼Œ3600å¸§â†’10%, 36000å¸§â†’20%, 86400å¸§â†’30%
            // å…¬å¼ï¼šframeBonus = 0.1 * log10(frame / 360)ï¼Œæœ€å°0
            const frame = state.lifeFrame || 0;
            const frameBonus = frame >= 360 ? 0.1 * Math.log10(frame / 360) : 0;

            // ç­‰çº§åŠ æˆï¼šæ¯çº§0.2%ï¼Œæœ€é«˜ç­‰çº§
            const maxLevel = state.characters.reduce((m, c) => Math.max(m, c.level || 0), 0);
            const levelBonus = maxLevel * 0.002;

            // BossåŠ æˆï¼šæ ¹æ®å‡»æ€çš„Bossç»™äºˆåŠ æˆ
            const bossBonus = {
                hogger: 0.05,      // éœæ ¼+5%
                vancleef: 0.10,   // èŒƒå…‹é‡Œå¤«+10%ï¼ˆé¢„ç•™ï¼‰
                prestor_lady: 0.15,//æ™®ç‘æ–¯æ‰˜å¥³å£«+15%
                thalnos: 0.2, //è¨å°”è¯ºæ–¯+20%
                dagran_thaurissan: 0.2, // è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸ +20%
                darkmaster_gandling: 0.1, // é»‘æš—é™¢é•¿åŠ ä¸ +10%
                baron_rivendare: 0.1, // ç‘æ–‡æˆ´å°”ç”·çˆµ +10%
                rend_blackhand: 0.1,//é›·å¾·é»‘æ‰‹ +10%
            };
            const defeatedBosses = state.defeatedBosses || [];
            const totalBossBonus = defeatedBosses.reduce((sum, bossId) => sum + (bossBonus[bossId] || 0), 0);

            // æ€»åŠ æˆï¼ˆç»éªŒ/é‡‘å¸ç›¸åŒï¼Œæ‰è½å’Œç ”ç©¶æœ‰ç³»æ•°ï¼‰
            // ä¸‰é¡¹ä¹˜åŒºï¼šå¸§æ•° / æœ€é«˜ç­‰çº§ / Bosså‡»æ€ â€”â€” ä¹˜ç®—ï¼Œä¸åŠ ç®—
            const newExp = (1 + frameBonus) * (1 + levelBonus) * (1 + totalBossBonus) - 1;
            const newGold = newExp;
            const newDrop = newExp * 0.6;
            const newResearch = newExp * 0.5;

            // âš ï¸ é‡è¦ï¼šæ¸…ç©ºä¸Šä¸€ä¸–åŠ æˆï¼Œä½¿ç”¨æ–°çš„åŠ æˆå€¼ï¼ˆä¸å åŠ ï¼‰
            newState.rebirthBonuses = {
                exp: newExp,
                gold: newGold,
                drop: newDrop,
                researchSpeed: newResearch
            };

            // éšæœºç¾ç»Šï¼ˆç¾ç»Šä»ç„¶å åŠ ä¿ç•™ï¼‰
            const possibleBonds = ['baoernai', 'jianyue'];
            const newBond = possibleBonds[Math.floor(Math.random() * possibleBonds.length)];
            newState.rebirthBonds = [...newState.rebirthBonds, newBond];

            // æ¶ˆè€—é‚€è¯·å‡½
            const tokenIdx = newState.inventory.findIndex(i => i.id === 'REBIRTH_INVITATION');
            if (tokenIdx >= 0) newState.inventory.splice(tokenIdx, 1);

            newState.rebirthCount += 1;

            // é‡ç”Ÿå‰§æƒ…æ•°æ®
            newState.showRebirthPlot = {
                frame: frame,
                maxLevel: maxLevel,
                defeatedBosses: defeatedBosses,
                newExp: (newExp * 100).toFixed(1),
                newGold: (newGold * 100).toFixed(1),
                newDrop: (newDrop * 100).toFixed(1),
                newResearch: (newResearch * 100).toFixed(1),
                newBond: BOND_NAMES[newBond],
                rebirthCount: newState.rebirthCount
            };

            // ==================== é‡ç”Ÿä¿ç•™ï¼šåŠŸèƒ½å»ºç­‘ï¼ˆå…¨éƒ¨ä¿ç•™ï¼Œä¸ä¼šæ¶ˆå¤±ï¼‰ ====================
            // éœ€æ±‚ï¼šé‡ç”Ÿåã€æ‰€æœ‰ã€‘åŠŸèƒ½å»ºç­‘æ•°é‡éƒ½ä¿ç•™ï¼ˆåŒ…å«ï¼šå–·æ³‰/ä»“åº“/è®­ç»ƒå‡äºº/æœºæ¢°è‡‚/å¯»é¾™ä¼šç­‰ï¼‰ã€‚
            // å…¼å®¹æ—§æ¡£ï¼šfunctionalBuildings å¯èƒ½ä¸ºç©º/éå¯¹è±¡
            const keptFunctionalBuildings = (newState.functionalBuildings && typeof newState.functionalBuildings === 'object' && !Array.isArray(newState.functionalBuildings))
                ? { ...newState.functionalBuildings }
                : {};

            const keptWarehouseCount = Math.max(0, Math.floor(Number(keptFunctionalBuildings.warehouse) || 0));
            const keptInventorySizeExtra = newState.inventorySizeExtra || 0;

            // é‡ç½®æ¸¸æˆè¿›åº¦
            newState.characters = [];
            newState.resources = { ...initialState.resources, gold: 500 };
            newState.buildings = {};
            // âœ… ä¿ç•™æ‰€æœ‰åŠŸèƒ½å»ºç­‘
            newState.functionalBuildings = keptFunctionalBuildings;
            // ç«‹åˆ»åŒæ­¥èƒŒåŒ…ä¸Šé™ï¼ˆé¿å…UI/æ‰è½é€»è¾‘ä½¿ç”¨æ—§å€¼ï¼‰
            newState.inventorySizeExtra = keptInventorySizeExtra;
            newState.inventorySize = 80 + keptWarehouseCount * 1 + keptInventorySizeExtra;
            // æ–°ä¸€ä¸–ä»0å¼€å§‹è®¡ï¼ˆæœºæ¢°è‡‚ä¾ç„¶ä¿ç•™ï¼Œä½†è®¡æ—¶å™¨é‡ç½®æ›´ç›´è§‚ï¼‰
            newState.autoMergeTimer = 0;
            newState.research = {};
            newState.currentResearch = null;
            newState.researchProgress = 0;
            newState.assignments = {};
            newState.zones = JSON.parse(JSON.stringify(ZONES));
            newState.achievements = {};
            newState.prepareBoss = null;
            newState.bossTeam = [null, null, null];
            newState.bossCombat = null;
            newState.currentMenu = 'map';
            newState.lifeFrame = 0; // æ–°ä¸€ä¸–ä»0å¼€å§‹è®¡
            newState.defeatedBosses = []; // æ¸…ç©ºæœ¬ä¸–å‡»æ€çš„Boss
            newState.bossCooldowns = {}; // é‡ç”Ÿåä¸–ç•ŒBosså†·å´é‡ç½®
            newState.questProgress = {};  // é‡ç½®æ‰€æœ‰ä»»åŠ¡è¿›åº¦
            newState.questItems = [];     // æ¸…ç©ºä»»åŠ¡ç‰©å“
            return newState;
        }
        case 'CHEAT_ADD_GOLD': {
            return {
                ...state,
                resources: {
                    ...state.resources,
                    gold: state.resources.gold + action.payload
                }
            };
        }

        case 'CHEAT_ADD_EQUIPMENT': {
            const newInventory = [...state.inventory, action.payload];

            // è‡ªåŠ¨ç‚¹äº®å›¾é‰´
            let newCodex = state.codex.slice();
            if (!newCodex.includes(action.payload.id)) {
                newCodex.push(action.payload.id);
            }

            // å¦‚æœè¾¾åˆ° Lv.100ï¼Œç‚¹äº® Lv100 å›¾é‰´
            let newCodexLv100 = state.codexEquipLv100.slice();
            if (action.payload.currentLevel >= 100 && !newCodexLv100.includes(action.payload.id)) {
                newCodexLv100.push(action.payload.id);
            }

            return {
                ...state,
                inventory: newInventory,
                codex: newCodex,
                codexEquipLv100: newCodexLv100
            };
        }
        case 'CHEAT_ADD_LV100_CODEX': {
            const id = action.payload;
            let newCodexLv100 = state.codexEquipLv100.slice();
            if (!newCodexLv100.includes(id)) {
                newCodexLv100.push(id);
            }
            return {
                ...state,
                codexEquipLv100: newCodexLv100
            };
        }
        case 'CHEAT_ADD_BAGSLOT': {
            const amount = Math.max(0, parseInt(action.payload) || 0);
            const warehouseCount = state.functionalBuildings?.warehouse || 0;
            const nextExtra = (state.inventorySizeExtra || 0) + amount;
            return {
                ...state,
                inventorySizeExtra: nextExtra,
                inventorySize: 80 + warehouseCount * 1 + nextExtra,
            };
        }
        case 'CHEAT_ADD_EXP': {
            const { amount, charIndex } = action.payload;
            if (charIndex < 0 || charIndex >= state.characters.length) {
                return state; // å®‰å…¨æ£€æŸ¥
            }

            const newCharacters = [...state.characters];
            let char = { ...newCharacters[charIndex] };

            // åŠ ç»éªŒ
            char.exp = (char.exp || 0) + amount;

            // å‡çº§å¾ªç¯
            while (char.exp >= char.expToNext && char.level < 200) {
                char.level += 1;
                char.exp -= char.expToNext;
                char.expToNext = Math.floor(100 * Math.pow(1.2, char.level - 1));
                char.skills = learnNewSkills(char); // å­¦ä¼šæ–°æŠ€èƒ½
            }

            // é‡ç®—æ€»å±æ€§ï¼ˆä½¿ç”¨å…¨é˜Ÿå…‰ç¯ï¼‰
            const updatedParty = recalcPartyStats(state, newCharacters.map(c => c.id === char.id ? char : c));
            const updatedChar = updatedParty.find(c => c.id === char.id);

            newCharacters[charIndex] = updatedChar || char;

            return {
                ...state,
                characters: newCharacters
            };
        }
        case 'CLOSE_REBIRTH_PLOT':
            return { ...state, showRebirthPlot: null };
        case "DELETE_CHARACTER": {
            const { characterId } = action.payload || {};
            if (!characterId) return state;

            // æ‰¾åˆ°è¦åˆ çš„è§’è‰²ï¼ˆä¸ºäº†æŠŠè£…å¤‡é€€å›èƒŒåŒ…ï¼‰
            const target = (state.characters || []).find(c => c.id === characterId);
            if (!target) return state;

            // 1) è£…å¤‡é€€å›èƒŒåŒ…ï¼šæŠŠ target.equipment é‡Œæ‰€æœ‰å·²ç©¿æˆ´è£…å¤‡æå‡ºæ¥
            const equippedItems = Object.values(target.equipment || {}).filter(Boolean);

            // æ³¨æ„ï¼šä½ çš„ç³»ç»Ÿå¯¹æ‰è½/å¥–åŠ±å…¥åŒ…ä¼šæ£€æŸ¥ inventorySizeï¼ˆé¿å…è¶…ä¸Šé™ï¼‰
            // è¿™é‡Œåˆ é™¤è§’è‰²å±äºâ€œé€€å›å·²æœ‰ç‰©å“â€ï¼Œå»ºè®®ä¹Ÿéµå®ˆä¸Šé™ï¼šèƒ½æ”¾å¤šå°‘æ”¾å¤šå°‘ï¼Œå‰©ä½™ä¸¢å¼ƒï¼ˆé¿å…èƒŒåŒ…æ— é™è†¨èƒ€ï¼‰
            const freeSlots = Math.max(0, (state.inventorySize ?? 0) - (state.inventory?.length ?? 0));
            const canReturn = equippedItems.slice(0, freeSlots);
            const newInventory = [...(state.inventory || []), ...canReturn];

            // 2) ä»è§’è‰²åˆ—è¡¨ç§»é™¤ï¼ˆè§’è‰²æœ¬ä½“ä¸Šå°±åŒ…å« exp/talents/skillSlots/combatState ç­‰ï¼‰
            // è§’è‰²å¯¹è±¡åŒ…å« expã€equipmentã€talentsã€skillSlotsã€combatState ç­‰å­—æ®µï¼Œåˆ æ‰å¯¹è±¡å³å¯æ¸…ç† :contentReference[oaicite:2]{index=2}
            const newCharacters = (state.characters || []).filter(c => c.id !== characterId);

            // 3) æ¸…ç† assignmentsï¼ˆé˜²æ­¢ç¦»çº¿å¥–åŠ±/æ´¾é£é€»è¾‘ä»ç„¶å¼•ç”¨å·²åˆ é™¤è§’è‰²ï¼‰
            const newAssignments = { ...(state.assignments || {}) };
            delete newAssignments[characterId];

            // 4) æ¸…ç† bossTeamï¼šæŠŠé˜µå®¹é‡Œå¼•ç”¨çš„ charId ç½®ç©º
            // bossTeam åœ¨ state é‡Œæ˜¯ [null, null, null] å­˜ charId :contentReference[oaicite:3]{index=3}
            const newBossTeam = (state.bossTeam || []).map(id => (id === characterId ? null : id));

            // 5) æ¸…ç† bossCombatï¼ˆå¦‚æœè¯¥è§’è‰²æ­£åœ¨ä¸–ç•Œé¦–é¢†æˆ˜é‡Œï¼‰
            let newBossCombat = state.bossCombat;
            if (newBossCombat?.playerStates?.some(ps => ps?.char?.id === characterId)) {
                newBossCombat = null; // æœ€ç¨³å¦¥ï¼šç›´æ¥ä¸­æ­¢è¿™åœº boss æˆ˜ï¼Œé¿å…æ®‹ç•™ playerStates å¼•ç”¨å·²åˆ è§’è‰²
            }

            // 6) ä½ é¡¹ç›®é‡Œå¤šå¤„ä¼šé‡ç®—å…¨é˜Ÿ/å…‰ç¯ç­‰ï¼Œè¿™é‡Œä¿æŒä¸€è‡´
            const finalChars = recalcPartyStats(state, newCharacters);

            return {
                ...state,
                characters: finalChars,
                inventory: newInventory,
                assignments: newAssignments,
                bossTeam: newBossTeam,
                bossCombat: newBossCombat,
            };
        }
        case 'SYNTHESIZE_EQ_044': {
            const getLevel = (eq) => (eq?.currentLevel ?? eq?.level ?? 0);

            const idxA = state.inventory.findIndex(i => i?.type === 'equipment' && i.id === 'EQ_041' && getLevel(i) >= 100);
            const idxB = state.inventory.findIndex(i => i?.type === 'equipment' && i.id === 'EQ_042' && getLevel(i) >= 100);
            if (idxA === -1 || idxB === -1) return state;

            // èƒŒåŒ…ç©ºé—´ï¼šç§»é™¤2ä»¶å†åŠ 1ä»¶ï¼Œä¸€å®šæœ‰ç©ºé—´ï¼Œä¸ç”¨é¢å¤–åˆ¤æ–­
            const tpl = FIXED_EQUIPMENTS['EQ_044'];
            if (!tpl) return state;

            const instance = {
                ...tpl,
                instanceId: `syn_${Date.now()}_${Math.random().toString(36)}`,
                qualityColor: getRarityColor(tpl.rarity),
                currentLevel: 0,
                stats: scaleStats(tpl.baseStats, tpl.growth, 0)
            };

            const newInventory = [...state.inventory];
            newInventory.splice(Math.max(idxA, idxB), 1);
            newInventory.splice(Math.min(idxA, idxB), 1);
            newInventory.push(instance);

            let nextState = {
                ...state,
                inventory: newInventory
            };

            // è®°å½•å›¾é‰´ï¼ˆè·Ÿä½ åˆæˆè£…å¤‡åè®°å›¾é‰´çš„é€»è¾‘ä¸€è‡´ï¼‰:contentReference[oaicite:5]{index=5}
            nextState = addEquipmentIdToCodex(nextState, instance.id);

            return nextState;
        }

        // ===== èµ„æºå»ºç­‘æ´¾é£ =====
        case 'ASSIGN_RESOURCE_BUILDING': {
            const { characterId, buildingId } = action.payload;

            if (!characterId || !buildingId) {
                console.warn('ASSIGN_RESOURCE_BUILDING: ç¼ºå°‘ characterId æˆ– buildingId');
                return state;
            }

            const building = RESOURCE_BUILDINGS[buildingId];
            if (!building) {
                console.warn(`ASSIGN_RESOURCE_BUILDING: æ‰¾ä¸åˆ°å»ºç­‘ ${buildingId}`);
                return state;
            }

            // æ£€æŸ¥è§’è‰²æ˜¯å¦å­˜åœ¨
            const charExists = state.characters.some(c => c.id === characterId);
            if (!charExists) {
                console.warn(`ASSIGN_RESOURCE_BUILDING: æ‰¾ä¸åˆ°è§’è‰² ${characterId}`);
                return state;
            }

            // æ£€æŸ¥è§’è‰²æ˜¯å¦åœ¨åœ°å›¾æ‰“æ€ª
            if (state.assignments?.[characterId]) {
                console.warn(`è§’è‰² ${characterId} æ­£åœ¨åœ°å›¾æ‰“æ€ªï¼Œæ— æ³•æ´¾é£åˆ°ä¸»åŸé‡‡é›†`);
                return state;
            }

            // âœ… ç¡®ä¿ resourceAssignments æ˜¯å¯¹è±¡
            const currentResourceAssignments = state.resourceAssignments || {};

            // âœ… å…³é”®ä¿®å¤ï¼šè¿‡æ»¤æ‰ä¸å­˜åœ¨çš„è§’è‰²ID
            const existingCharIds = new Set(state.characters.map(c => c.id));
            const currentWorkers = (currentResourceAssignments[buildingId] || [])
                .filter(id => existingCharIds.has(id));

            // æ£€æŸ¥æ˜¯å¦å·²è¾¾ä¸Šé™
            if (currentWorkers.length >= building.maxWorkers) {
                console.warn(`å»ºç­‘ ${buildingId} å·²è¾¾æœ€å¤§å·¥äººæ•° ${building.maxWorkers}`);
                return state;
            }

            // âœ… æ¸…ç†æ‰€æœ‰å»ºç­‘ä¸­ä¸å­˜åœ¨çš„è§’è‰²ï¼Œå¹¶ç§»é™¤å½“å‰è§’è‰²çš„æ—§åˆ†é…
            let newAssignments = {};
            Object.keys(currentResourceAssignments).forEach(bid => {
                newAssignments[bid] = (currentResourceAssignments[bid] || [])
                    .filter(id => existingCharIds.has(id) && id !== characterId);
            });

            // æ·»åŠ åˆ°æ–°å»ºç­‘
            newAssignments[buildingId] = [...(newAssignments[buildingId] || []), characterId];

            console.log(`âœ“ æˆåŠŸæ´¾é£è§’è‰² ${characterId} åˆ° ${buildingId}`);

            return {
                ...state,
                resourceAssignments: newAssignments
            };
        }

        case 'UNASSIGN_RESOURCE_BUILDING': {
            const { characterId, buildingId } = action.payload;
            const currentWorkers = state.resourceAssignments?.[buildingId] || [];

            return {
                ...state,
                resourceAssignments: {
                    ...state.resourceAssignments,
                    [buildingId]: currentWorkers.filter(id => id !== characterId)
                }
            };
        }

        // ===== åŠŸèƒ½å»ºç­‘å»ºé€  =====
        case 'BUILD_FUNCTIONAL': {
            const { buildingId } = action.payload;
            const building = FUNCTIONAL_BUILDINGS[buildingId];
            if (!building) return state;

            const currentCount = state.functionalBuildings?.[buildingId] || 0;

            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ä¸Šé™
            if (currentCount >= building.maxCount) return state;

            // âœ… ä½¿ç”¨åŠ¨æ€æˆæœ¬
            const dynamicCost = getFunctionalBuildingCost(buildingId, state);

            // æ£€æŸ¥èµ„æº
            let canBuild = true;
            Object.entries(dynamicCost).forEach(([res, amount]) => {
                if ((state.resources[res] || 0) < amount) canBuild = false;
            });
            if (!canBuild) return state;

            // æ‰£é™¤èµ„æº
            const newResources = { ...state.resources };
            Object.entries(dynamicCost).forEach(([res, amount]) => {
                newResources[res] -= amount;
            });

            return {
                ...state,
                resources: newResources,
                functionalBuildings: {
                    ...state.functionalBuildings,
                    [buildingId]: currentCount + 1
                }
            };
        }
        case 'SORT_INVENTORY': {
            const sortedInventory = [...state.inventory].sort((a, b) => {
                // 1. è£…å¤‡ä¼˜å…ˆäºéè£…å¤‡
                const aIsEquip = a.type === 'equipment' ? 1 : 0;
                const bIsEquip = b.type === 'equipment' ? 1 : 0;
                if (aIsEquip !== bIsEquip) return bIsEquip - aIsEquip; // è£…å¤‡åœ¨å‰

                // 2. å¯¹äºè£…å¤‡ï¼ŒæŒ‰ ID æ’åºï¼ˆEQ_001, EQ_002...ï¼‰
                if (a.type === 'equipment' && b.type === 'equipment') {
                    // æå–æ•°å­—éƒ¨åˆ†è¿›è¡Œæ¯”è¾ƒï¼ˆEQ_001 -> 1, EQ_002 -> 2ï¼‰
                    const aIdNum = parseInt((a.id || '').replace(/\D/g, '')) || 0;
                    const bIdNum = parseInt((b.id || '').replace(/\D/g, '')) || 0;

                    if (aIdNum !== bIdNum) {
                        return bIdNum - aIdNum; // ID ä»å¤§åˆ°å°
                    }

                    // 3. åŒIDè£…å¤‡æŒ‰ç­‰çº§æ’åºï¼ˆä»å¤§åˆ°å°ï¼‰
                    const aLevel = a.currentLevel ?? a.level ?? 0;
                    const bLevel = b.currentLevel ?? b.level ?? 0;
                    return bLevel - aLevel; // ç­‰çº§ä»å¤§åˆ°å°
                }

                // 4. éè£…å¤‡ç‰©å“æŒ‰IDå­—æ¯æ’åº
                return (a.id || '').localeCompare(b.id || '');
            });

            return {
                ...state,
                inventory: sortedInventory
            };
        }
        case 'CHEAT_SET_REBIRTH_BONUS': {
            const { exp, gold, drop, researchSpeed } = action.payload || {};

            const nextState = {
                ...state,
                rebirthBonuses: {
                    ...(state.rebirthBonuses || {}),
                    exp: Number(exp) || 0,
                    gold: Number(gold) || 0,
                    drop: Number(drop) || 0,
                    researchSpeed: Number(researchSpeed) || 0,
                },
            };

            return {
                ...nextState,
                characters: recalcPartyStats(nextState, nextState.characters),
            };
        }
        case 'MOVE_INVENTORY_ITEM': {
            const { fromIndex, toIndex } = action.payload;

            if (fromIndex === toIndex) return state;
            if (fromIndex < 0 || fromIndex >= state.inventory.length) return state;
            if (toIndex < 0 || toIndex >= state.inventorySize) return state;

            const newInventory = [...state.inventory];
            const [movedItem] = newInventory.splice(fromIndex, 1);

            // å¦‚æœç›®æ ‡ä½ç½®è¶…å‡ºå½“å‰æ•°ç»„é•¿åº¦ï¼Œç›´æ¥pushåˆ°æœ«å°¾
            // å¦åˆ™æ’å…¥åˆ°æŒ‡å®šä½ç½®
            if (toIndex >= newInventory.length) {
                newInventory.push(movedItem);
            } else {
                newInventory.splice(toIndex, 0, movedItem);
            }

            return {
                ...state,
                inventory: newInventory
            };
        }
        case 'START_QUEST': {
            const { questId } = action.payload;
            const quest = QUEST_CHAINS[questId];
            if (!quest) return state;

            // æ£€æŸ¥è§£é”æ¡ä»¶
            if (quest.unlockCondition) {
                if (quest.unlockCondition.type === 'boss_defeated') {
                    if (!state.defeatedBosses?.includes(quest.unlockCondition.bossId)) {
                        return state;
                    }
                }
            }

            // æ£€æŸ¥æ˜¯å¦å·²å®Œæˆï¼ˆæœ¬ä¸–ï¼‰
            if (state.questProgress[questId]?.status === 'completed') {
                return state;
            }

            return {
                ...state,
                questProgress: {
                    ...state.questProgress,
                    [questId]: {
                        status: QUEST_STATUS.IN_PROGRESS,
                        currentStep: Object.keys(quest.steps)[0],  // ç¬¬ä¸€æ­¥
                        flags: [],
                        completedSteps: [],
                        completedBranch: null
                    }
                }
            };
        }

        case 'QUEST_CHOICE': {
            const { questId, choiceId } = action.payload;
            const quest = QUEST_CHAINS[questId];
            const progress = state.questProgress[questId];
            if (!quest || !progress) return state;

            const currentStep = quest.steps[progress.currentStep];
            if (!currentStep) return state;

            const choice = currentStep.choices.find(c => c.id === choiceId);
            if (!choice) return state;

            // æ£€æŸ¥æ˜¯å¦æ»¡è¶³æ¡ä»¶
            if (choice.requireFlag && !choice.requireFlag.every(f => progress.flags.includes(f))) {
                return state;
            }

            let newState = { ...state };
            let newProgress = { ...progress };

            // æ ‡è®°å½“å‰æ­¥éª¤å®Œæˆ
            newProgress.completedSteps = [...newProgress.completedSteps, progress.currentStep];

            // è®¾ç½®æ ‡è®°
            if (choice.flagSet) {
                newProgress.flags = [...new Set([...newProgress.flags, ...choice.flagSet])];
            }

            // å‘æ”¾å¥–åŠ±
            if (choice.rewards) {
                if (choice.rewards.gold) {
                    newState.resources = {
                        ...newState.resources,
                        gold: newState.resources.gold + getEffectiveGoldGain(choice.rewards.gold, newState)
                    };
                }
                if (choice.rewards.exp) {
                    // ç»™æ‰€æœ‰è§’è‰²åŠ ç»éªŒ
                    newState.characters = newState.characters.map(char => {
                        let gained = choice.rewards.exp * (1 + (char.stats?.expBonus || 0));
                        let newExp = char.exp + gained;
                        let level = char.level;
                        let expToNext = char.expToNext;
                        while (newExp >= expToNext && level < 200) {
                            newExp -= expToNext;
                            level++;
                            expToNext = Math.floor(100 * Math.pow(1.2, level - 1));
                        }
                        return { ...char, exp: newExp, level, expToNext };
                    });
                }
            }

            // å¤„ç†ç»“æŸä»»åŠ¡
            if (choice.endQuest) {
                newProgress.status = QUEST_STATUS.FAILED;
                newProgress.currentStep = null;
            } else if (choice.nextStep) {
                const nextStepData = quest.steps[choice.nextStep];

                // æ£€æŸ¥æ˜¯å¦æ˜¯ç»“å±€
                if (nextStepData?.isEnding) {
                    newProgress.currentStep = choice.nextStep;
                    // ç»“å±€å¥–åŠ±éœ€è¦é¢å¤–æ¡ä»¶ï¼ˆå¦‚å‡»è´¥Bossï¼‰æ‰èƒ½é¢†å–
                } else {
                    newProgress.currentStep = choice.nextStep;
                }
            }

            newState.questProgress = {
                ...newState.questProgress,
                [questId]: newProgress
            };

            return newState;
        }

        case 'COMPLETE_QUEST_ENDING': {
            const { questId } = action.payload;
            const quest = QUEST_CHAINS[questId];
            const progress = state.questProgress[questId];
            if (!quest || !progress) return state;

            const endingStep = quest.steps[progress.currentStep];
            if (!endingStep?.isEnding) return state;

            // æ£€æŸ¥ç»“å±€æ¡ä»¶
            if (endingStep.requirement) {
                if (endingStep.requirement.type === 'boss_defeated') {
                    if (!state.defeatedBosses?.includes(endingStep.requirement.bossId)) {
                        return state;  // æ¡ä»¶ä¸æ»¡è¶³
                    }
                }
            }

            let newState = { ...state };

            // å‘æ”¾ç»“å±€å¥–åŠ±
            const rewards = endingStep.rewards;
            if (rewards) {
                if (rewards.gold) {
                    newState.resources = {
                        ...newState.resources,
                        gold: newState.resources.gold + getEffectiveGoldGain(rewards.gold, newState)
                    };
                }
                if (rewards.exp) {
                    newState.characters = newState.characters.map(char => {
                        // ... åŠ ç»éªŒé€»è¾‘
                        return char;
                    });
                }
                if (rewards.items) {
                    rewards.items.forEach(itemDef => {
                        if (itemDef.guaranteed || Math.random() < (itemDef.chance || 1)) {
                            const tpl = QUEST_REWARD_EQUIPMENTS[itemDef.id] || FIXED_EQUIPMENTS[itemDef.id];
                            if (tpl) {
                                const instance = createEquipmentInstance(itemDef.id);
                                if (instance) {
                                    newState.inventory = [...newState.inventory, instance];
                                    newState = addEquipmentIdToCodex(newState, itemDef.id);
                                }
                            }
                        }
                    });
                }
                if (rewards.title) {
                    newState.questTitles = [...(newState.questTitles || []), rewards.title];
                }
            }

            // æ ‡è®°ä»»åŠ¡å®Œæˆ
            newState.questProgress = {
                ...newState.questProgress,
                [questId]: {
                    ...progress,
                    status: QUEST_STATUS.COMPLETED,
                    completedBranch: endingStep.branch
                }
            };

            // è®°å½•å®Œæˆçš„åˆ†æ”¯
            newState.completedQuestBranches = [
                ...(newState.completedQuestBranches || []),
                { questId, branch: endingStep.branch, ending: endingStep.id }
            ];

            return newState;
        }

        default:
            return state;
    }
}

// ==================== UI COMPONENTS ====================
const Panel = ({ title, children, actions, style }) => (
    <div style={{
        background: 'linear-gradient(135deg, rgba(30,25,20,0.95) 0%, rgba(20,15,12,0.98) 100%)',
        border: '2px solid #4a3c2a',
        borderRadius: 8,
        padding: 20,
        marginBottom: 16,
        boxShadow: '0 4px 16px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.05)',
        ...style
    }}>
        <div style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: title ? 16 : 0,
            paddingBottom: title ? 12 : 0,
            borderBottom: title ? '1px solid rgba(201,162,39,0.2)' : 'none'
        }}>
            {title && (
                <h3 style={{
                    margin: 0,
                    fontSize: 18,
                    color: '#c9a227',
                    textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
                    fontWeight: 600
                }}>
                    {title}
                </h3>
            )}
            {actions && <div style={{ display: 'flex', gap: 8 }}>{actions}</div>}
        </div>
        {children}
    </div>
);

const Button = ({ children, onClick, variant = 'primary', disabled, style }) => {
    const variants = {
        primary: {
            background: disabled
                ? 'rgba(60,60,60,0.5)'
                : 'linear-gradient(180deg, rgba(201,162,39,0.9), rgba(139,115,25,0.9))',
            color: disabled ? '#666' : '#fff',
            border: `2px solid ${disabled ? '#444' : '#c9a227'}`,
        },
        secondary: {
            background: 'rgba(40,35,30,0.8)',
            color: '#c9a227',
            border: '2px solid #5a4c3a',
        },
        danger: {
            background: 'linear-gradient(180deg, rgba(180,50,50,0.9), rgba(120,30,30,0.9))',
            color: '#fff',
            border: '2px solid #a03030',
        }
    };

    return (
        <button
            onClick={onClick}
            disabled={disabled}
            style={{
                padding: '8px 16px',
                ...variants[variant],
                borderRadius: 4,
                cursor: disabled ? 'not-allowed' : 'pointer',
                fontFamily: 'inherit',
                fontSize: 13,
                fontWeight: 600,
                transition: 'all 0.2s',
                boxShadow: disabled ? 'none' : '0 2px 6px rgba(0,0,0,0.4)',
                textShadow: disabled ? 'none' : '1px 1px 2px rgba(0,0,0,0.6)',
                ...style
            }}
        >
            {children}
        </button>
    );
};

const StatBar = ({ label, current, max, color = '#4CAF50' }) => (
    <div style={{ marginBottom: 8 }}>
        <div style={{
            display: 'flex',
            justifyContent: 'space-between',
            fontSize: 11,
            color: '#aaa',
            marginBottom: 4
        }}>
            <span>{label}</span>
            <span>{Math.floor(current)} / {Math.floor(max)}</span>
        </div>
        <div style={{
            height: 8,
            background: 'rgba(0,0,0,0.5)',
            borderRadius: 4,
            overflow: 'hidden',
            border: '1px solid rgba(255,255,255,0.1)'
        }}>
            <div style={{
                height: '100%',
                width: `${Math.min(100, (current / max) * 100)}%`,
                background: `linear-gradient(90deg, ${color}, ${color}dd)`,
                transition: 'width 0.3s',
                boxShadow: `0 0 8px ${color}88`
            }} />
        </div>
    </div>
);

// ==================== MODALS ====================

// æŠ€èƒ½ç¼–è¾‘æ¨¡æ€æ¡†
const SkillEditorModal = ({ character, onClose, onSave, state }) => {
    // ===== ä¸‰å¥—æŠ€èƒ½é…ç½®ï¼ˆå…¼å®¹æ—§å­˜æ¡£ï¼šåªæœ‰ skillSlotsï¼‰=====
    const initSkillSets = () => {
        const base = Array.from({ length: 8 }, (_, i) => (character.skillSlots?.[i] ?? ''));
        const setsRaw = Array.isArray(character.skillSets) ? character.skillSets : null;

        const make8 = (arr, fallback) => Array.from({ length: 8 }, (_, i) => (arr?.[i] ?? fallback?.[i] ?? ''));

        if (!setsRaw || setsRaw.length === 0) {
            // æ—§æ¡£ï¼šåªæœ‰ skillSlotsï¼Œä¸‰å¥—å…ˆå¤åˆ¶ä¸€ä»½
            const s0 = make8(base, base);
            return [s0, [...s0], [...s0]];
        }

        const s0 = make8(setsRaw[0], base);
        const s1 = make8(setsRaw[1], s0);
        const s2 = make8(setsRaw[2], s0);

        return [s0, s1, s2];
    };

    const initActiveSet = () => {
        const v = Number(character.activeSkillSet);
        if (!Number.isFinite(v)) return 0;
        return Math.max(0, Math.min(2, Math.floor(v)));
    };

    const [activeSet, setActiveSet] = useState(initActiveSet);
    const [skillSets, setSkillSets] = useState(initSkillSets);

    const skillSlots = skillSets?.[activeSet] || Array(8).fill('');

    // è·å–æŠ€èƒ½çš„å®é™…é™åˆ¶ï¼ˆè€ƒè™‘å¤©èµ‹æ•ˆæœï¼‰
    const getSkillLimit = (skillId) => {
        const skill = SKILLS[skillId];
        let limit = skill?.limit ?? Infinity;

        // 40çº§å¤©èµ‹ï¼šæŠ¤å«ç¥ç›¾ - ç›¾å¢™å¯é…ç½®2æ¬¡
        if (skillId === 'shield_wall' && character.talents?.[40] === 'guardian_shield') {
            limit = 2;
        }

        // å†°éœœæ³•å¸ˆ40çº§å¤©èµ‹ï¼šåŒå½—æ˜Ÿ - å½—æ˜Ÿé£æš´å¯é…ç½®2æ¬¡
        if (skillId === 'comet_storm' && character.talents?.[40] === 'double_comet') {
            limit = 2;
        }

        // æˆ’å¾‹ç‰§å¸ˆ20çº§å¤©èµ‹ï¼šåœ£å…‰çš„è®¸è¯º - çœŸè¨€æœ¯ï¼šè€€å¯å¤šé…ç½®1æ¬¡
        if (skillId === 'power_word_radiance' && character.talents?.[20] === 'radiance_plus') {
            limit = (skill?.limit || 2) + 1;
        }

        return limit;
    };

    const handleSlotChange = (index, skillId) => {
        const newSlots = [...skillSlots];
        newSlots[index] = skillId;

        // ç»Ÿè®¡æ¯ä¸ªæŠ€èƒ½åœ¨æŠ€èƒ½æ ä¸­çš„å‡ºç°æ¬¡æ•°
        const countMap = {};
        newSlots.forEach(sid => {
            if (!sid) return;
            countMap[sid] = (countMap[sid] || 0) + 1;
        });

        // æ ¡éªŒæ¯ä¸ªæŠ€èƒ½çš„ limitï¼ˆè€ƒè™‘å¤©èµ‹ï¼‰
        for (const [sid, count] of Object.entries(countMap)) {
            const skill = SKILLS[sid];
            const limit = getSkillLimit(sid);

            if (count > limit) {
                alert(`${skill.name} åœ¨æŠ€èƒ½æ ä¸­æœ€å¤šåªèƒ½æ”¾ ${limit} æ¬¡`);
                return; // âŒ é˜»æ­¢è¿™æ¬¡ä¿®æ”¹
            }
        }

        const nextSets = [...(skillSets || [Array(8).fill(''), Array(8).fill(''), Array(8).fill('')])];
        nextSets[activeSet] = newSlots;
        setSkillSets(nextSets);
    };

    const SwitchButton = ({ idx }) => {
        const isActive = activeSet === idx;
        return (
            <button
                onClick={() => setActiveSet(idx)}
                style={{
                    width: 38,
                    height: 38,
                    borderRadius: 8,
                    cursor: 'pointer',
                    fontWeight: 800,
                    fontSize: 14,
                    color: isActive ? '#1a1510' : '#c9a227',
                    background: isActive
                        ? 'linear-gradient(180deg, rgba(255,215,0,0.95), rgba(201,162,39,0.95))'
                        : 'rgba(0,0,0,0.35)',
                    border: isActive ? '2px solid #ffd700' : '2px solid #5a4c3a',
                    boxShadow: isActive ? '0 0 14px rgba(255,215,0,0.35)' : 'none',
                }}
                title={`æŠ€èƒ½é…ç½® ${idx + 1}ï¼ˆé€‰ä¸­åå°†ç”¨äºåœ°å›¾æˆ˜æ–— / BOSSæˆ˜æ–—ï¼‰`}
            >
                {idx + 1}
            </button>
        );
    };

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20
        }} >
            <div style={{
                background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                border: '3px solid #c9a227',
                borderRadius: 12,
                padding: 24,
                maxWidth: 650,
                width: '100%',
                boxShadow: '0 8px 32px rgba(201,162,39,0.3)',
            }} onClick={(e) => e.stopPropagation()}>
                <div style={{ marginBottom: 18 }}>
                    <h2 style={{ margin: '0 0 8px 0', fontSize: 20, color: '#ffd700' }}>
                        ç¼–è¾‘æŠ€èƒ½æ  - {character.name}
                    </h2>
                    <div style={{ fontSize: 12, color: '#888', lineHeight: 1.6 }}>
                        <div>æˆ˜æ–—æ—¶ä¼šå¾ªç¯ä½¿ç”¨è¿™ 8 ä¸ªæŠ€èƒ½ã€‚</div>
                    </div>

                    <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: 10,
                        marginTop: 12
                    }}>
                        <div style={{ fontSize: 12, color: '#aaa' }}>æŠ€èƒ½é…ç½®ï¼š</div>
                        <div style={{ display: 'flex', gap: 8 }}>
                            <SwitchButton idx={0} />
                            <SwitchButton idx={1} />
                            <SwitchButton idx={2} />
                        </div>
                        <div style={{
                            marginLeft: 'auto',
                            fontSize: 12,
                            color: '#c9a227',
                            background: 'rgba(0,0,0,0.25)',
                            border: '1px solid rgba(201,162,39,0.35)',
                            padding: '6px 10px',
                            borderRadius: 999
                        }}>
                            å½“å‰ï¼šé…ç½® {activeSet + 1}
                        </div>
                    </div>
                </div>

                <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(4, 1fr)',
                    gap: 12,
                    marginBottom: 20
                }}>
                    {skillSlots.map((skillId, index) => (
                        <div key={index} style={{
                            background: 'rgba(0,0,0,0.3)',
                            border: '2px solid #4a3c2a',
                            borderRadius: 6,
                            padding: 12,
                            textAlign: 'center'
                        }}>
                            <div style={{ fontSize: 10, color: '#888', marginBottom: 8 }}>
                                æ§½ä½ {index + 1}
                            </div>
                            <select
                                value={skillId}
                                onChange={(e) => handleSlotChange(index, e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '6px',
                                    background: 'rgba(0,0,0,0.4)',
                                    border: '1px solid #4a3c2a',
                                    borderRadius: 4,
                                    color: '#fff',
                                    fontSize: 11,
                                    cursor: 'pointer'
                                }}
                            >
                                <option value="">ç©º</option>
                                {character.skills // è¢«åŠ¨æŠ€èƒ½ä»…ç”¨äºå±•ç¤ºï¼Œä¸å…è®¸å¡è¿›å¾ªç¯æŠ€èƒ½æ 
                                    .filter((sid) => sid && SKILLS[sid] && SKILLS[sid].type !== 'passive').map(sid => {
                                        const skill = SKILLS[sid];
                                        return (
                                            <option key={sid} value={sid}>
                                                {skill.icon} {skill.name}
                                            </option>
                                        );
                                    })}
                            </select>
                            {skillId && SKILLS[skillId] && (
                                <div style={{
                                    fontSize: 24,
                                    marginTop: 8
                                }}>
                                    {
                                        SKILLS[skillId].iconUrl ? (
                                            <img
                                                src={SKILLS[skillId].iconUrl}
                                                alt={SKILLS[skillId].name}
                                                style={{
                                                    width: 24,
                                                    height: 24,
                                                    objectFit: "contain",
                                                    imageRendering: "pixelated",
                                                    background: "#000",
                                                    border: "1px solid #444",
                                                    borderRadius: 4,
                                                }}
                                            />
                                        ) : (
                                            SKILLS[skillId].icon
                                        )
                                    }
                                </div>
                            )}
                        </div>
                    ))}
                </div>

                <div style={{ display: 'flex', gap: 12 }}>
                    <Button onClick={() => {
                        // âœ… ä¿å­˜ä¸‰å¥—é…ç½® + å½“å‰æ¿€æ´»é…ç½®
                        onSave(character.id, skillSets, activeSet);
                        onClose();
                    }} style={{ flex: 1 }}>
                        âœ“ ä¿å­˜
                    </Button>
                    <Button onClick={onClose} variant="secondary" style={{ flex: 1 }}>
                        å–æ¶ˆ
                    </Button>
                </div>
            </div>
        </div>
    );
};



// æŸ¥çœ‹å¯ç”¨æŠ€èƒ½ï¼ˆæ’é™¤â€œä¼‘æ¯/æ™®é€šæ”»å‡»â€ï¼‰
const SkillViewerModal = ({ character, onClose }) => {
    const availableSkillIds = (character.skills || []).filter(
        (sid) => sid && sid !== 'rest' && sid !== 'basic_attack' && SKILLS[sid]
    );

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20
        }} onClick={onClose}>
            <div style={{
                background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                border: '3px solid #c9a227',
                borderRadius: 12,
                padding: 24,
                maxWidth: 700,
                width: '100%',
                maxHeight: '80vh',
                overflowY: 'auto',
                boxShadow: '0 8px 32px rgba(201,162,39,0.3)',
            }} onClick={(e) => e.stopPropagation()}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 16 }}>
                    <div>
                        <h2 style={{ margin: 0, fontSize: 20, color: '#ffd700' }}>
                            æŸ¥çœ‹æŠ€èƒ½ - {character.name}
                        </h2>
                        <div style={{ fontSize: 12, color: '#888', marginTop: 4 }}>
                            ä»…å±•ç¤ºå¯ç”¨æŠ€èƒ½
                        </div>
                    </div>
                    <Button onClick={onClose} variant="secondary">âœ• å…³é—­</Button>
                </div>

                {availableSkillIds.length === 0 ? (
                    <div style={{ textAlign: 'center', padding: 40, color: '#666' }}>
                        æš‚æ— å¯ç”¨æŠ€èƒ½
                    </div>
                ) : (
                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(2, 1fr)',
                        gap: 12
                    }}>
                        {availableSkillIds.map((sid) => {
                            const skill = SKILLS[sid];
                            // è·å–æŠ€èƒ½çš„å®é™…é™åˆ¶ï¼ˆè€ƒè™‘å¤©èµ‹æ•ˆæœï¼‰
                            let limit = skill.limit;
                            if (sid === 'shield_wall' && character.talents?.[40] === 'guardian_shield') {
                                limit = 2;
                            }
                            // å†°éœœæ³•å¸ˆ40çº§å¤©èµ‹ï¼šåŒå½—æ˜Ÿ
                            if (sid === 'comet_storm' && character.talents?.[40] === 'double_comet') {
                                limit = 2;
                            }
                            // æˆ’å¾‹ç‰§å¸ˆ20çº§å¤©èµ‹ï¼šåœ£å…‰çš„è®¸è¯º
                            if (sid === 'power_word_radiance' && character.talents?.[20] === 'radiance_plus') {
                                limit = (skill?.limit || 2) + 1;
                            }
                            return (
                                <div key={sid} style={{
                                    background: 'rgba(0,0,0,0.3)',
                                    border: '1px solid #4a3c2a',
                                    borderRadius: 10,
                                    padding: 14
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 10, marginBottom: 8 }}>
                                        <div style={{ fontSize: 26 }}>
                                            {
                                                skill.iconUrl ? (
                                                    <img
                                                        src={skill.iconUrl}
                                                        alt={skill.name}
                                                        style={{
                                                            width: 26,
                                                            height: 26,
                                                            objectFit: "contain",
                                                            imageRendering: "pixelated",
                                                            background: "#000",
                                                            border: "1px solid #444",
                                                            borderRadius: 4,
                                                        }}
                                                    />
                                                ) : (
                                                    skill.icon
                                                )
                                            }
                                        </div>
                                        <div style={{ flex: 1 }}>
                                            <div style={{ color: '#ffd700', fontWeight: 700, fontSize: 13 }}>
                                                {skill.name}
                                            </div>
                                            <div style={{ color: '#888', fontSize: 11 }}>
                                                ç±»å‹ï¼š{skill.type}{typeof limit === 'number' ? ` Â· æ§½ä½ä¸Šé™ï¼š${limit}` : ''}
                                            </div>
                                        </div>
                                    </div>

                                    <div style={{ fontSize: 12, color: '#ccc', lineHeight: 1.5 }}>
                                        {skill.description}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                )}
            </div>
        </div>
    );
};

// ==================== COMBAT LOGS (MODULE) ====================
// ç»Ÿä¸€æˆ˜æ–—æ—¥å¿—è§„èŒƒï¼š
// - ä¸»åŠ¨æŠ€èƒ½ï¼šæ˜¾ç¤ºâ€œä½¿ç”¨â€
// - è¢«åŠ¨è§¦å‘ï¼ˆå¤©èµ‹/è¢«åŠ¨ï¼‰ï¼šæ˜¾ç¤ºâ€œã€xxxã€‘è§¦å‘ï¼š...â€ï¼Œä¸ç®—ä¸€æ¬¡è¡ŒåŠ¨
// - ç³»ç»Ÿäº‹ä»¶ï¼šæ˜¾ç¤ºçº¯æ–‡æœ¬
function normalizeCombatLogEntry(entry) {
    if (!entry || typeof entry !== 'object') {
        return { kind: 'system', text: String(entry ?? '') };
    }
    if (entry.kind) return entry;

    // å…¼å®¹æ—§å­—æ®µï¼štype
    if (entry.type === 'talent') {
        return { ...entry, kind: 'proc', proc: entry.action || entry.proc || 'è¢«åŠ¨' };
    }
    if (entry.type === 'damage' || entry.type === 'heal' || entry.type === 'buff' || entry.type === 'block') {
        return { ...entry, kind: 'skill' };
    }
    return { ...entry, kind: 'system', text: entry.text || entry.action || '' };
}

function renderCombatLogLine(entry) {
    const e = normalizeCombatLogEntry(entry);

    // ç³»ç»Ÿæ—¥å¿—
    if (e.kind === 'system') {
        return (
            <>
                <span style={{ color: '#aaa' }}>{e.text || ''}</span>
            </>
        );
    }

    // âœ… æ–°å¢ï¼šæ‰è½æ—¥å¿—
    if (e.kind === 'drop') {
        const rarityColors = {
            white: '#d9d9d9',
            green: '#1eff00',
            blue: '#0070dd',
            purple: '#a335ee',
            orange: '#ff8000'
        };
        const color = rarityColors[e.rarity] || '#ffd700';

        return (
            <>
                <span style={{ color: '#ffd700' }}>ğŸ æ‰è½</span>
                {' '}
                <span style={{
                    color: color,
                    fontWeight: 600,
                    textShadow: `0 0 6px ${color}66`
                }}>
                    ã€{e.itemName}ã€‘
                </span>
                <span style={{ color: '#888', marginLeft: 8, fontSize: '0.9em' }}>
                    æ¦‚ç‡ï¼š{e.chance < 1 ? e.chance.toFixed(2) : e.chance.toFixed(1)}%
                </span>
            </>
        );
    }

    // è¢«åŠ¨è§¦å‘ï¼šä¸æ˜¾ç¤ºâ€œä½¿ç”¨â€ï¼Œä¹Ÿä¸é‡å¤æ˜¾ç¤ºæ–½æ”¾è€…ï¼ˆç»Ÿä¸€ç”±æ–‡æœ¬è‡ªèº«è¡¨è¾¾ï¼‰
    if (e.kind === 'proc') {
        return (
            <>
                <span style={{ color: '#ff9800' }}>
                    {e.text || `ã€${e.proc || e.action || 'è¢«åŠ¨'}ã€‘è§¦å‘`}
                </span>
            </>
        );
    }

// ä¸»åŠ¨æŠ€èƒ½ï¼šä¿ç•™åŸæ¥çš„â€œä½¿ç”¨â€è¯­ä¹‰
    return (
        <>
            <span style={{ color: '#ffd700' }}>{e.actor}</span>
            {' '}ä½¿ç”¨{' '}
            <span style={{ color: '#4CAF50' }}>{e.action}</span>

            {e.type === 'damage' && (
                <>
                    {' '}å¯¹{' '}
                    <span style={{ color: '#ff6b6b' }}>{e.target}</span>
                    {' '}é€ æˆ{' '}
                    <span style={{ color: '#f44336', fontWeight: 600 }}>
                        {e.value}
                    </span>
                    {' '}ç‚¹ä¼¤å®³
                    {e.isCrit && (
                        <span style={{ color: '#ff9800', marginLeft: 4 }}>
                            [æš´å‡»!]
                        </span>
                    )}
                </>
            )}

            {e.type === 'heal' && (
                <>
                    {' '}æ¢å¤{' '}
                    <span style={{ color: '#4CAF50', fontWeight: 600 }}>
                        {e.value}
                    </span>
                    {' '}ç‚¹ç”Ÿå‘½
                </>
            )}

            {e.type === 'block' && (
                <>
                    {' '}æ ¼æŒ¡äº†{' '}
                    <span style={{ color: '#4CAF50', fontWeight: 600 }}>
                        {e.value}
                    </span>
                    {' '}ç‚¹ä¼¤å®³
                </>
            )}

            {e.type === 'buff' && (
                <>
                    {' '}è·å¾—æ•ˆæœï¼ˆæŒç»­{' '}
                    <span style={{ color: '#4CAF50', fontWeight: 700 }}>{e.value}</span>
                    {' '}å›åˆï¼‰
                </>
            )}
        </>
    );
}

// æˆ˜æ–—æ—¥å¿—æ¨¡æ€æ¡†
const CombatLogsModal = ({ logs, onClose, onClear }) => {

    const safe = Array.isArray(logs) ? logs : [];

    const normalized = safe
        .filter(Boolean)
        .map((x) => {
            if (typeof x === "string") {
                return {
                    id: `legacy_${Date.now()}_${Math.random()}`,
                    timestamp: Date.now(),
                    characterName: "ç³»ç»Ÿ",
                    zoneName: "",
                    enemyName: "",
                    result: "victory",
                    logs: [x],
                    rewards: { gold: 0, exp: 0 },
                    drops: [],

                };
            }
            return {
                ...x,
                logs: Array.isArray(x.logs) ? x.logs : [],
                drops: Array.isArray(x.drops) ? x.drops : [] // âœ… æ–°å¢
            };
        });

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20
        }} onClick={onClose}>
            <div style={{
                background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                border: '3px solid #c9a227',
                borderRadius: 12,
                padding: 24,
                maxWidth: 800,
                width: '100%',
                maxHeight: '80vh',
                display: 'flex',
                flexDirection: 'column',
                boxShadow: '0 8px 32px rgba(201,162,39,0.3)',
            }} onClick={(e) => e.stopPropagation()}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 16 }}>
                    <h2 style={{ margin: 0, fontSize: 20, color: '#ffd700' }}>
                        æˆ˜æ–—æ—¥å¿—
                    </h2>
                    <div style={{ display: 'flex', gap: 8 }}>
                        <Button onClick={onClear} variant="danger">æ¸…ç©ºæ—¥å¿—</Button>
                        <Button onClick={onClose} variant="secondary">âœ• å…³é—­</Button>
                    </div>
                </div>

                <div style={{
                    flex: 1,
                    overflowY: 'auto',
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 6,
                    padding: 12
                }}>
                    {logs.length === 0 ? (
                        <div style={{ textAlign: 'center', color: '#666', padding: 40 }}>
                            æš‚æ— æˆ˜æ–—è®°å½•
                        </div>
                    ) : (
                        normalized.map(log => (
                            <div key={log.id} style={{
                                background: log.result === 'victory' ? 'rgba(76,175,80,0.1)' : 'rgba(244,67,54,0.1)',
                                border: `1px solid ${log.result === 'victory' ? '#4CAF50' : '#f44336'}`,
                                borderRadius: 6,
                                padding: 12,
                                marginBottom: 12
                            }}>
                                <div style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    marginBottom: 8,
                                    paddingBottom: 8,
                                    borderBottom: '1px solid rgba(255,255,255,0.1)'
                                }}>
                                    <div>
                                        <span style={{ color: '#ffd700', fontWeight: 600 }}>
                                            {log.characterName}
                                        </span>
                                        <span style={{ color: '#888', margin: '0 8px' }}>VS</span>
                                        <span style={{ color: '#ff6b6b', fontWeight: 600 }}>
                                            {log.enemyName}
                                        </span>
                                        <span style={{ color: '#888', marginLeft: 8 }}>
                                            @ {log.zoneName}
                                        </span>
                                    </div>
                                    <div style={{
                                        fontSize: 11,
                                        color: log.result === 'victory' ? '#4CAF50' : '#f44336',
                                        fontWeight: 600
                                    }}>
                                        {log.result === 'victory' ? 'âœ“ èƒœåˆ©' : 'âœ— å¤±è´¥'}
                                    </div>
                                </div>

                                <div style={{
                                    maxHeight: 200,
                                    overflowY: 'auto',
                                    fontSize: 11,
                                    color: '#ccc'
                                }}>
                                    {(log.logs || []).map((entry, i) => (
                                        <div key={i} style={{
                                            padding: '4px 0',
                                            borderBottom: i < log.logs.length - 1 ? '1px solid rgba(255,255,255,0.05)' : 'none'
                                        }}>
                                            <span style={{ color: '#888' }}>å›åˆ{entry.round}:</span>{' '}
                                            {renderCombatLogLine(entry)}
                                        </div>
                                    ))}
                                </div>

                                {/* åœ¨å¥–åŠ±æ˜¾ç¤ºåæ·»åŠ æ‰è½æ‘˜è¦ */}
                                {log.drops && log.drops.length > 0 && (
                                    <div style={{
                                        marginTop: 8,
                                        paddingTop: 8,
                                        borderTop: '1px solid rgba(255,255,255,0.1)',
                                        fontSize: 12
                                    }}>
                                        <span style={{ color: '#ffd700', marginRight: 8 }}>ğŸ æ‰è½ï¼š</span>
                                        {log.drops.map((drop, idx) => {
                                            const rarityColors = {
                                                white: '#d9d9d9',
                                                green: '#1eff00',
                                                blue: '#0070dd',
                                                purple: '#a335ee',
                                                orange: '#ff8000'
                                            };
                                            const color = rarityColors[drop.rarity] || '#ffd700';
                                            return (
                                                <span key={idx} style={{ marginRight: 12 }}>
                                                <span style={{ color: color, fontWeight: 600 }}>{drop.name}</span>
                                                <span style={{ color: '#666', fontSize: 10, marginLeft: 4 }}>
                                                    ({drop.chance < 1 ? drop.chance.toFixed(2) : drop.chance.toFixed(1)}%)
                                                </span>
                                                </span>
                                            );
                                        })}
                                    </div>
                                )}

                                {log.rewards && (
                                    <div style={{
                                        marginTop: 8,
                                        paddingTop: 8,
                                        borderTop: '1px solid rgba(255,255,255,0.1)',
                                        fontSize: 11,
                                        color: '#ffd700'
                                    }}>
                                        å¥–åŠ±: ğŸª™{log.rewards.gold} | â­{log.rewards.exp}
                                    </div>
                                )}
                            </div>
                        ))
                    )}
                </div>
            </div>
        </div>
    );
};

// è§’è‰²è¯¦æƒ…æ¨¡æ€æ¡†
const CharacterDetailsModal = ({ characterId, state, onClose, onUnequip, onEditSkills, onViewSkills, onSyncSkills }) => {
    const character = state.characters.find(c => c.id === characterId);

    // è§’è‰²è¢«åˆ é™¤/ä¸å­˜åœ¨æ—¶ï¼Œç›´æ¥ä¸æ¸²æŸ“ï¼ˆæˆ–ä½ ä¹Ÿå¯ä»¥ onClose()ï¼‰
    if (!character) return null;

    const [syncTip, setSyncTip] = useState(null);
    const syncTipTimerRef = useRef(null);

    const showSyncTip = (msg) => {
        setSyncTip(msg);
        if (syncTipTimerRef.current) clearTimeout(syncTipTimerRef.current);
        syncTipTimerRef.current = setTimeout(() => setSyncTip(null), 1500);
    };

    useEffect(() => {
        return () => {
            if (syncTipTimerRef.current) clearTimeout(syncTipTimerRef.current);
        };
    }, []);

    const currentSkills = character.skills || [];
    const levelSkills = learnNewSkills(character);
    const missingSkills = levelSkills.filter(s => !currentSkills.includes(s));
    const canSyncSkills = missingSkills.length > 0;

    const statNames = {
        hp: 'ç”Ÿå‘½å€¼',
        mp: 'æ³•åŠ›å€¼',
        attack: 'æ”»å‡»å¼ºåº¦',
        spellPower: 'æ³•æœ¯å¼ºåº¦',
        armor: 'æŠ¤ç”²',
        magicResist: 'é­”æ³•æŠ—æ€§',
        haste: 'æ€¥é€Ÿ',
        critRate: 'æš´å‡»ç‡',
        critDamage: 'æš´å‡»ä¼¤å®³',
        mastery: 'ç²¾é€š',
        versatility: 'å…¨èƒ½',
        blockRate: 'æ ¼æŒ¡ç‡',
        blockValue: 'æ ¼æŒ¡å€¼',
        // æ–°å¢é‡‡é›†å±æ€§
        proficiency: 'ç†Ÿç»ƒ',
        precision: 'ç²¾ç»†',
        perception: 'æ„ŸçŸ¥',
    };

    const setBonuses = getSetBonusesForCharacter(character);

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20,
            overflowY: 'auto'
        }} onClick={onClose}>
            <div style={{
                background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                border: '3px solid #c9a227',
                borderRadius: 12,
                padding: 24,
                maxWidth: 900,
                width: '100%',
                maxHeight: '90vh',
                overflowY: 'auto',
                boxShadow: '0 8px 32px rgba(201,162,39,0.3)',
            }} onClick={(e) => e.stopPropagation()}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: 20 }}>
                    <div>
                        <h2 style={{ margin: '0 0 8px 0', fontSize: 24, color: '#ffd700' }}>
                            {character.name}
                        </h2>
                        <div style={{ fontSize: 14, color: '#888' }}>
                            Lv.{character.level} {character.race} {CLASSES[character.classId].name}
                        </div>
                    </div>
                    <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
                        <Button onClick={onViewSkills} variant="secondary">ğŸ‘ æŸ¥çœ‹æŠ€èƒ½</Button>
                        <Button onClick={onEditSkills} variant="secondary">âœï¸ ç¼–è¾‘æŠ€èƒ½</Button>
                        <Button
                            onClick={() => {
                                if (!onSyncSkills) return;
                                onSyncSkills();
                                // ç®€å•æç¤ºï¼šå­¦ä¼šæœ¬ç­‰çº§åº”å­¦ä¼šçš„æŠ€èƒ½ï¼ˆç”¨äºæ—§è§’è‰²è¡¥é½æ–°æŠ€èƒ½ï¼‰
                                showSyncTip(`åŒæ­¥æˆåŠŸï¼šå­¦ä¼š ${missingSkills.length} ä¸ªæŠ€èƒ½`);
                            }}
                            variant="secondary"
                            disabled={!canSyncSkills}
                            title={canSyncSkills ? 'å­¦ä¼šå½“å‰ç­‰çº§åº”å­¦ä¼šçš„æŠ€èƒ½ï¼ˆè¡¥é½æ–°æŠ€èƒ½ï¼‰' : 'å½“å‰å·²å­¦ä¼šæœ¬ç­‰çº§åº”å­¦ä¼šçš„æŠ€èƒ½'}
                        >
                            ğŸ“š å­¦ä¼šæœ¬çº§æŠ€èƒ½
                        </Button>
                        <Button onClick={onClose} variant="secondary">âœ• å…³é—­</Button>
                    </div>
                </div>

                {syncTip && (
                    <div style={{
                        marginTop: 10,
                        background: 'rgba(0,0,0,0.35)',
                        border: '1px solid rgba(201,162,39,0.35)',
                        color: '#f3e6b3',
                        padding: '8px 12px',
                        borderRadius: 8,
                        fontSize: 13,
                    }}>
                        âœ… {syncTip}
                    </div>
                )}

                <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: 20 }}>
                    {/* å·¦ä¾§ï¼šå±æ€§ */}
                    <div>
                        <h3 style={{ fontSize: 16, color: '#c9a227', marginBottom: 12 }}>è§’è‰²å±æ€§</h3>
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: 6,
                            padding: 12,
                            border: '1px solid #4a3c2a'
                        }}>
                            {Object.entries(statNames).map(([stat, name]) => (
                                <div key={stat} style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    padding: '6px 0',
                                    borderBottom: '1px solid rgba(255,255,255,0.05)',
                                    fontSize: 12
                                }}>
                                    <span style={{ color: '#aaa' }}>{name}</span>
                                    <span style={{ color: '#ffd700', fontWeight: 600 }}>
                                        {stat === 'critRate' || stat === 'blockRate'
                                            ? `${(character.stats[stat] || 0).toFixed(1)}%`
                                            : stat === 'critDamage'
                                                ? `${Math.round((character.stats[stat] || 0) * 100)}%`
                                                : Math.floor(character.stats[stat] || 0)
                                        }
                                    </span>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* å³ä¾§ï¼šè£…å¤‡ */}
                    <div>
                        <h3 style={{ fontSize: 16, color: '#c9a227', marginBottom: 12 }}>è£…å¤‡</h3>
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 8 }}>
                            {Object.entries(EQUIPMENT_SLOTS).map(([slot, slotInfo]) => {
                                const equipped = character.equipment[slot];
                                return (
                                    <div
                                        key={slot}
                                        style={{
                                            background: equipped ? 'rgba(201,162,39,0.15)' : 'rgba(0,0,0,0.3)',
                                            border: `2px solid ${equipped ? '#c9a227' : '#4a3c2a'}`,
                                            borderRadius: 6,
                                            padding: 12,
                                            minHeight: 80,
                                            position: 'relative'
                                        }}
                                    >
                                        <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                                            {equipped ? (
                                                <ItemIcon item={equipped} size={18} />
                                            ) : (
                                                <span>{slotInfo.icon}</span>
                                            )}
                                            <span>{slotInfo.name}</span>
                                        </div>


                                        {equipped ? (
                                            <>
                                                <div style={{
                                                    fontSize: 12,
                                                    color: equipped.qualityColor,
                                                    fontWeight: 600,
                                                    marginBottom: 6
                                                }}>
                                                    {equipped.name}
                                                </div>

                                                <div style={{ fontSize: 10, color: '#aaa', marginBottom: 8 }}>
                                                    {Object.entries(equipped.stats).map(([stat, value]) => (
                                                        <div key={stat}>
                                                            {statNames[stat] || stat}: +{formatItemStatValue(stat, value)}
                                                        </div>
                                                    ))}
                                                </div>

                                                <Button
                                                    onClick={() => onUnequip(character.id, slot)}
                                                    variant="danger"
                                                    style={{ padding: '4px 8px', fontSize: 10, width: '100%' }}
                                                >
                                                    å¸ä¸‹
                                                </Button>
                                            </>
                                        ) : (
                                            <div style={{
                                                fontSize: 24,
                                                color: '#333',
                                                textAlign: 'center',
                                                paddingTop: 8
                                            }}>
                                                âˆ…
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>

                        {/* å¥—è£…æ•ˆæœ */}
                        {setBonuses.length > 0 && (
                            <div style={{
                                marginTop: 14,
                                padding: 12,
                                borderRadius: 8,
                                background: 'rgba(0,0,0,0.25)',
                                border: '1px solid rgba(201,162,39,0.25)'
                            }}>
                                <div style={{ fontSize: 14, fontWeight: 800, color: '#ffd700', marginBottom: 8 }}>
                                    å¥—è£…æ•ˆæœ
                                </div>

                                <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                                    {setBonuses.map(set => (
                                        <div key={set.setId} style={{
                                            padding: 10,
                                            borderRadius: 8,
                                            background: 'rgba(0,0,0,0.25)',
                                            border: '1px solid rgba(201,162,39,0.18)'
                                        }}>
                                            <div style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'baseline',
                                                marginBottom: 6
                                            }}>
                                                <div style={{ fontSize: 13, fontWeight: 800, color: '#c9a227' }}>
                                                    {set.name}
                                                </div>
                                                <div style={{ fontSize: 11, color: '#aaa' }}>
                                                    å·²è£…å¤‡ {set.count} ä»¶
                                                </div>
                                            </div>

                                            <div style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                                                {set.activated.map((t, idx) => (
                                                    <div key={idx} style={{ fontSize: 12, color: '#ddd' }}>
                                                        âœ… {t.count} ä»¶ï¼š{formatBonusText(t.bonus)}
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};





// ç‰©å“è¯¦æƒ…æ¨¡æ€æ¡†
const ItemDetailsModal = ({ item, onClose, onEquip, characters, state , dispatch }) => {
    const [selectedCharId, setSelectedCharId] = useState('');

    const statNames = {
        hp: 'ç”Ÿå‘½å€¼',
        mp: 'æ³•åŠ›å€¼',
        attack: 'æ”»å‡»å¼ºåº¦',
        spellPower: 'æ³•æœ¯å¼ºåº¦',
        armor: 'æŠ¤ç”²',
        magicResist: 'é­”æ³•æŠ—æ€§',
        haste: 'æ€¥é€Ÿ',
        critRate: 'æš´å‡»ç‡',
        critDamage: 'æš´å‡»ä¼¤å®³',
        mastery: 'ç²¾é€š',
        versatility: 'å…¨èƒ½',
        blockRate: 'æ ¼æŒ¡ç‡',
        blockValue: 'æ ¼æŒ¡å€¼',
        expBonus: 'ç»éªŒå€¼å¢å¹…',
        proficiency: 'ç†Ÿç»ƒ',
        precision: 'ç²¾ç»†',
        perception: 'æ„ŸçŸ¥',
    };

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20
        }} onClick={onClose}>
            <div style={{
                background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                border: `3px solid ${item.qualityColor || '#4a3c2a'}`,
                borderRadius: 12,
                padding: 24,
                maxWidth: 400,
                width: '100%',
                boxShadow: `0 8px 32px ${item.qualityColor}44`,
            }} onClick={(e) => e.stopPropagation()}>
                <div style={{ textAlign: 'center', marginBottom: 20 }}>
                    <div style={{ fontSize: 48, marginBottom: 12 }}>
                        <ItemIcon item={item} size={32} />
                    </div>
                    <h2 style={{
                        margin: '0 0 8px 0',
                        fontSize: 20,
                        color: item.qualityColor,
                        textShadow: '2px 2px 4px rgba(0,0,0,0.8)'
                    }}>
                        {item.name}
                    </h2>
                    <div style={{ fontSize: 12, color: '#888' }}>
                        {EQUIPMENT_SLOTS[item.slot]?.name} Â· ç­‰çº§ {item.currentLevel ?? item.level ?? 0} Â· {item.quality}
                    </div>
                </div>

                <div style={{
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 8,
                    padding: 16,
                    marginBottom: 20
                }}>
                    <h3 style={{ fontSize: 14, color: '#c9a227', marginBottom: 12 }}>å±æ€§</h3>
                    {Object.entries(item.stats).map(([stat, value]) => (
                        <div
                            key={stat}
                            style={{
                                display: 'flex',
                                justifyContent: 'space-between',
                                padding: '6px 0',
                                borderBottom: '1px solid rgba(255,255,255,0.05)',
                                fontSize: 12
                            }}
                        >
                            <span style={{ color: '#aaa' }}>{statNames[stat] || stat}</span>
                            <span style={{ color: '#4CAF50', fontWeight: 600 }}>
                                +{formatItemStatValue(stat, value)}
                            </span>
                        </div>
                    ))}
                </div>

                {/* ç‰¹æ®Šæ•ˆæœæ˜¾ç¤º */}
                {item.specialEffect && (
                    <div style={{
                        background: 'rgba(255, 152, 0, 0.1)',
                        border: '1px solid rgba(255, 152, 0, 0.3)',
                        borderRadius: 8,
                        padding: 16,
                        marginBottom: 20
                    }}>
                        <h3 style={{ fontSize: 14, color: '#ff9800', marginBottom: 12 }}>âš¡ ç‰¹æ®Šæ•ˆæœ</h3>
                        {/* skill_slot_buff ç±»å‹ */}
                        {item.specialEffect.type === 'skill_slot_buff' && (
                            <div style={{ fontSize: 12, color: '#ffb74d', lineHeight: 1.6 }}>
                                åœ¨ç¬¬ <span style={{ color: '#ffd700', fontWeight: 600 }}>
                    {item.specialEffect.slots.map(s => s + 1).join('ã€')}
                </span> æŠ€èƒ½æ ¼é‡Šæ”¾æŠ€èƒ½æ—¶ï¼š
                                {item.specialEffect.attackBonus && (
                                    <div style={{ marginTop: 8, color: '#fff' }}>
                                        â€¢ æ”»å‡»å¼ºåº¦ <span style={{ color: '#4CAF50', fontWeight: 600 }}>+{item.specialEffect.attackBonus}</span>
                                    </div>
                                )}
                                {item.specialEffect.spellPowerBonus && (
                                    <div style={{ marginTop: 8, color: '#fff' }}>
                                        â€¢ æ³•æœ¯å¼ºåº¦ <span style={{ color: '#4CAF50', fontWeight: 600 }}>+{item.specialEffect.spellPowerBonus}</span>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* basic_attack_repeat ç±»å‹ */}
                        {item.specialEffect.type === 'basic_attack_repeat' && (
                            <div style={{ fontSize: 12, color: '#ffb74d', lineHeight: 1.6 }}>
                                <div style={{ marginBottom: 8, color: '#fff' }}>
                                    ä½¿ç”¨æ™®é€šæ”»å‡»åï¼Œæœ‰ <span style={{ color: '#ffd700', fontWeight: 600 }}>
                        {(item.specialEffect.chance * 100).toFixed(0)}%
                    </span> æ¦‚ç‡å†æ¬¡å‘åŠ¨ä¸€æ¬¡æ™®é€šæ”»å‡»
                                </div>
                                <div style={{
                                    marginTop: 12,
                                    padding: '8px 12px',
                                    background: 'rgba(255,215,0,0.1)',
                                    borderRadius: 6,
                                    border: '1px dashed rgba(255,215,0,0.3)',
                                    fontSize: 11,
                                    color: '#c9a227'
                                }}>
                                    ğŸ’¡ æç¤ºï¼šè¿å‡»ä¼¤å®³ä¸æ™®é€šæ”»å‡»ç›¸åŒï¼Œå¯è§¦å‘"è´¨æœ´"ç­‰æ™®æ”»ç›¸å…³å¤©èµ‹
                                </div>
                            </div>
                        )}

                        {/* proc_stat Â· turn_start ç±»å‹ï¼ˆæ¯å›åˆæ¦‚ç‡è§¦å‘å±æ€§å¢ç›Šï¼‰ */}
                        {item.specialEffect.type === 'proc_stat' && item.specialEffect.trigger === 'turn_start' && (
                            <div style={{ fontSize: 12, color: '#ffb74d', lineHeight: 1.6 }}>
                                <div style={{ marginBottom: 8, color: '#fff' }}>
                                    æ¯å›åˆæœ‰ <span style={{ color: '#ffd700', fontWeight: 600 }}>
                                        {(item.specialEffect.chance * 100).toFixed(0)}%
                                    </span> æ¦‚ç‡è·å¾—ä»¥ä¸‹å¢ç›Šï¼ˆä»…æœ¬å›åˆï¼‰ï¼š
                                </div>

                                {(Object.entries(item.specialEffect.stats || {})).map(([stat, value]) => (
                                    <div key={stat} style={{ marginTop: 8, color: '#fff' }}>
                                        â€¢ {statNames[stat] || stat}{' '}
                                        <span style={{ color: '#4CAF50', fontWeight: 600 }}>
                                            +{formatItemStatValue(stat, value)}
                                        </span>
                                    </div>
                                ))}

                                {item.specialEffect.scaleWithLevel && (
                                    <div style={{
                                        marginTop: 12,
                                        padding: '8px 12px',
                                        background: 'rgba(255,215,0,0.1)',
                                        borderRadius: 6,
                                        border: '1px dashed rgba(255,215,0,0.3)',
                                        fontSize: 11,
                                        color: '#c9a227'
                                    }}>
                                        ğŸ’¡ æç¤ºï¼šè¯¥ç‰¹æ•ˆä¼šéšè£…å¤‡ç­‰çº§æå‡è€Œå¢å¼ºï¼ˆlv0=1x, lv100=2xï¼‰
                                    </div>
                                )}
                            </div>
                        )}

                        {/* map_slayer ç±»å‹ï¼ˆåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼‰ */}
                        {item.specialEffect.type === 'map_slayer' && (
                            <div style={{ fontSize: 12, color: '#ffb74d', lineHeight: 1.6 }}>
                                <div style={{ marginBottom: 8, color: '#fff' }}>
                                    åœ°å›¾æˆ˜æ–—ä¸­é€ æˆçš„ä¼¤å®³æé«˜{' '}
                                    <span style={{ color: '#ffd700', fontWeight: 600 }}>
                                        {((item.specialEffect.bonusDamageVsMap || 0) * 100).toFixed(0)}%
                                    </span>
                                </div>
                                <div style={{
                                    marginTop: 12,
                                    padding: '8px 12px',
                                    background: 'rgba(255,215,0,0.1)',
                                    borderRadius: 6,
                                    border: '1px dashed rgba(255,215,0,0.3)',
                                    fontSize: 11,
                                    color: '#c9a227'
                                }}>
                                    ğŸ’¡ æç¤ºï¼šä»…å¯¹åœ°å›¾æˆ˜æ–—ç”Ÿæ•ˆï¼Œä¸å½±å“ Boss æˆ˜
                                </div>
                            </div>
                        )}
                    </div>
                )}

                <div style={{ marginBottom: 16 }}>
                    <label style={{ display: 'block', fontSize: 12, color: '#c9a227', marginBottom: 8 }}>
                        è£…å¤‡ç»™è§’è‰²
                    </label>
                    <select
                        value={selectedCharId}
                        onChange={(e) => setSelectedCharId(e.target.value)}
                        style={{
                            width: '100%',
                            padding: '8px 12px',
                            background: 'rgba(0,0,0,0.4)',
                            border: '1px solid #4a3c2a',
                            borderRadius: 4,
                            color: '#fff',
                            fontSize: 13,
                            cursor: 'pointer'
                        }}
                    >
                        <option value="">é€‰æ‹©è§’è‰²...</option>
                        {characters.map(char => (
                            <option key={char.id} value={char.id}>
                                {char.name} (Lv.{char.level})
                            </option>
                        ))}
                    </select>
                </div>

                <div style={{ display: 'flex', gap: 12 }}>
                    {item.id === 'REBIRTH_INVITATION' && (
                        <Button
                            variant="danger"
                            onClick={() => {
                                dispatch({ type: 'USE_ITEM', payload: { itemInstanceId: item.instanceId || item.id } });
                                onClose();
                            }}
                            style={{ flex: 1 }}
                        >
                            ğŸŒ€ ä½¿ç”¨é‚€è¯·å‡½
                        </Button>
                    )}
                    <Button
                        onClick={() => {
                            if (selectedCharId) {
                                onEquip(selectedCharId, item.instanceId || item.id);
                                onClose();
                            }
                        }}
                        disabled={!selectedCharId}
                        style={{ flex: 1 }}
                    >
                        è£…å¤‡
                    </Button>
                    {(() => {
                        const getLevel = (eq) => (eq?.currentLevel ?? eq?.level ?? 0);
                        const isMatA = item.id === 'EQ_041' && getLevel(item) >= 100;
                        const isMatB = item.id === 'EQ_042' && getLevel(item) >= 100;

                        const hasOther =
                            isMatA
                                ? state.inventory.some(i => i?.type === 'equipment' && i.id === 'EQ_042' && getLevel(i) >= 100)
                                : isMatB
                                ? state.inventory.some(i => i?.type === 'equipment' && i.id === 'EQ_041' && getLevel(i) >= 100)
                                : false;

                        if (!(hasOther && (isMatA || isMatB))) return null;

                        return (
                            <Button
                                onClick={() => {
                                    if (window.confirm('æ¶ˆè€—ã€åå‡»è€…æ¡‘è¨æ–¯ Lv100ã€‘ä¸ã€ä¿æŠ¤è€…åŠ è¨æ–¯ Lv100ã€‘åˆæˆã€é­ç¬è€…è‹è¨æ–¯ Lv0ã€‘ï¼Ÿ')) {
                                        dispatch({ type: 'SYNTHESIZE_EQ_044' });
                                        onClose();
                                    }
                                }}
                                style={{ flex: 1 }}
                            >
                                âš—ï¸ è‹è¨æ–¯
                            </Button>
                        );
                    })()}
                    <Button
                        variant="danger"
                        onClick={() => {
                            if (window.confirm(`ç¡®å®šè¦ä¸¢å¼ƒ ${item.name} å—ï¼Ÿ`)) {
                                dispatch({ type: 'USE_ITEM', payload: { itemInstanceId: item.instanceId || item.id } });
                                onClose();
                            }
                        }}
                    >
                        ğŸ—‘ï¸ ä¸¢å¼ƒ
                    </Button>
                    <Button onClick={onClose} variant="secondary" style={{ flex: 1 }}>
                        å…³é—­
                    </Button>
                </div>
            </div>
        </div>
    );
};

// ç¦»çº¿å¥–åŠ±æ¨¡æ€æ¡†
const OfflineRewardsModal = ({ rewards, actualSeconds, maxSeconds, onClaim, onDismiss }) => {
    const formatTime = (seconds) => {
        const days = Math.floor(seconds / 86400);
        const hours = Math.floor((seconds % 86400) / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);

        if (days > 0) return `${days}å¤© ${hours}å°æ—¶`;
        if (hours > 0) return `${hours}å°æ—¶ ${minutes}åˆ†é’Ÿ`;
        return `${minutes}åˆ†é’Ÿ`;
    };

    const totalExp = Object.values(rewards.exp).reduce((a, b) => a + b, 0);

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20
        }}>
            <div style={{
                background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                border: '3px solid #c9a227',
                borderRadius: 12,
                padding: 32,
                maxWidth: 500,
                width: '100%',
                boxShadow: '0 8px 32px rgba(201,162,39,0.3), inset 0 1px 0 rgba(255,255,255,0.1)',
            }}>
                <div style={{ textAlign: 'center', marginBottom: 24 }}>
                    <div style={{ fontSize: 48, marginBottom: 12 }}>ğŸ’°</div>
                    <h2 style={{
                        margin: '0 0 8px 0',
                        fontSize: 24,
                        color: '#ffd700',
                        textShadow: '2px 2px 4px rgba(0,0,0,0.8)'
                    }}>
                        æ¬¢è¿å›æ¥!
                    </h2>
                    <p style={{ margin: 0, color: '#aaa', fontSize: 14 }}>
                        ä½ å·²ç¦»çº¿ {formatTime(actualSeconds)}
                        {actualSeconds >= maxSeconds && ` (è¾¾åˆ°ä¸Šé™: ${formatTime(maxSeconds)})`}
                    </p>
                </div>

                <div style={{
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 8,
                    padding: 20,
                    marginBottom: 20
                }}>
                    <h3 style={{
                        margin: '0 0 16px 0',
                        fontSize: 16,
                        color: '#c9a227',
                        textAlign: 'center'
                    }}>
                        æŒ‚æœºæ”¶ç›Š
                    </h3>

                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 12 }}>
                        <div style={{
                            background: 'rgba(201,162,39,0.1)',
                            padding: 12,
                            borderRadius: 6,
                            border: '1px solid rgba(201,162,39,0.3)'
                        }}>
                            <div style={{ fontSize: 11, color: '#888', marginBottom: 4 }}>æˆ˜æ–—æ¬¡æ•°</div>
                            <div style={{ fontSize: 20, color: '#ffd700', fontWeight: 600 }}>
                                {rewards.combats}
                            </div>
                        </div>

                        <div style={{
                            background: 'rgba(201,162,39,0.1)',
                            padding: 12,
                            borderRadius: 6,
                            border: '1px solid rgba(201,162,39,0.3)'
                        }}>
                            <div style={{ fontSize: 11, color: '#888', marginBottom: 4 }}>é‡‘å¸</div>
                            <div style={{ fontSize: 20, color: '#ffd700', fontWeight: 600 }}>
                                +{Math.floor(rewards.gold)}
                            </div>
                        </div>

                        <div style={{
                            background: 'rgba(201,162,39,0.1)',
                            padding: 12,
                            borderRadius: 6,
                            border: '1px solid rgba(201,162,39,0.3)'
                        }}>
                            <div style={{ fontSize: 11, color: '#888', marginBottom: 4 }}>ç»éªŒå€¼</div>
                            <div style={{ fontSize: 20, color: '#4CAF50', fontWeight: 600 }}>
                                +{Math.floor(totalExp)}
                            </div>
                        </div>

                        <div style={{
                            background: 'rgba(201,162,39,0.1)',
                            padding: 12,
                            borderRadius: 6,
                            border: '1px solid rgba(201,162,39,0.3)'
                        }}>
                            <div style={{ fontSize: 11, color: '#888', marginBottom: 4 }}>ç‰©å“</div>
                            <div style={{ fontSize: 20, color: '#9C27B0', fontWeight: 600 }}>
                                +{rewards.items.length}
                            </div>
                        </div>
                    </div>

                    {rewards.researchProgress > 0 && (
                        <div style={{
                            marginTop: 12,
                            background: 'rgba(201,162,39,0.1)',
                            padding: 12,
                            borderRadius: 6,
                            border: '1px solid rgba(201,162,39,0.3)',
                            textAlign: 'center'
                        }}>
                            <div style={{ fontSize: 11, color: '#888', marginBottom: 4 }}>ç ”ç©¶è¿›åº¦</div>
                            <div style={{ fontSize: 20, color: '#2196F3', fontWeight: 600 }}>
                                +{Math.floor(rewards.researchProgress)}%
                            </div>
                        </div>
                    )}
                </div>

                <div style={{ display: 'flex', gap: 12 }}>
                    <Button onClick={onClaim} style={{ flex: 1 }}>
                        âœ“ é¢†å–å¥–åŠ±
                    </Button>
                    <Button onClick={onDismiss} variant="secondary" style={{ flex: 1 }}>
                        ç¨åé¢†å–
                    </Button>
                </div>
            </div>
        </div>
    );
};

// ==================== PAGE: MAP (with Drag & Drop) ====================
const TalentPage = ({ state, dispatch }) => {
    const characters = state.characters || [];
    const [selectedId, setSelectedId] = useState(characters[0]?.id || '');

    useEffect(() => {
        if (!selectedId && characters[0]?.id) setSelectedId(characters[0].id);
        if (selectedId && !characters.some(c => c.id === selectedId)) {
            setSelectedId(characters[0]?.id || '');
        }
    }, [characters, selectedId]);

    const character = characters.find(c => c.id === selectedId);

    if (!character) {
        return (
            <Panel title="å¤©èµ‹">
                <div style={{ color: '#888', textAlign: 'center', padding: 20 }}>
                    è¿˜æ²¡æœ‰è§’è‰²ï¼Œå…ˆå»â€œè§’è‰²â€é¡µé¢åˆ›å»ºä¸€ä¸ªå§ã€‚
                </div>
            </Panel>
        );
    }

    const tiers = TALENTS[character.classId] || [];
    const talents = character.talents || {};

    const isTierUnlocked = (tier) => (character.level || 1) >= tier;

    const chooseTalent = (tier, talentId) => {
        if (!isTierUnlocked(tier)) return;
        dispatch({ type: 'SET_TALENT', payload: { characterId: character.id, tier, talentId } });
    };

    const cardStyle = (tier, optionId) => {
        const picked = talents?.[tier] === optionId;
        const hasPick = Boolean(talents?.[tier]);
        const locked = !isTierUnlocked(tier);

        const dim = hasPick && !picked;
        return {
            background: picked
                ? 'linear-gradient(135deg, rgba(201,162,39,0.20) 0%, rgba(120,90,20,0.15) 100%)'
                : 'rgba(0,0,0,0.25)',
            border: picked ? '2px solid #c9a227' : '2px solid rgba(74,60,42,0.9)',
            borderRadius: 10,
            padding: 14,
            cursor: (locked || dim) ? 'not-allowed' : 'pointer',
            opacity: locked ? 0.45 : (dim ? 0.25 : 1),
            transition: 'all 0.15s',
            boxShadow: picked ? '0 0 14px rgba(201,162,39,0.25)' : 'none',
            userSelect: 'none',
        };
    };

    return (
        <div>
            <Panel
                title="å¤©èµ‹"
                actions={
                    <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                        <div style={{ fontSize: 12, color: '#aaa' }}>é€‰æ‹©è§’è‰²ï¼š</div>
                        <select
                            value={selectedId}
                            onChange={(e) => setSelectedId(e.target.value)}
                            style={{
                                padding: '6px 10px',
                                background: 'rgba(0,0,0,0.4)',
                                border: '1px solid #4a3c2a',
                                borderRadius: 6,
                                color: '#fff',
                                fontSize: 12,
                                cursor: 'pointer'
                            }}
                        >
                            {characters.map(c => (
                                <option key={c.id} value={c.id}>
                                    {c.name}ï¼ˆLv{c.level}ï¼‰
                                </option>
                            ))}
                        </select>
                    </div>
                }
            >
                <div style={{ color: '#888', fontSize: 12, marginBottom: 10 }}>
                    æ¯10çº§è§£é”ä¸€è¡Œï¼Œæ¯è¡Œ3é€‰1ã€‚
                </div>

                {tiers.map(tierDef => {
                    const tier = tierDef.tier;
                    const locked = !isTierUnlocked(tier);
                    const picked = talents?.[tier];

                    return (
                        <div key={tier} style={{
                            marginBottom: 14,
                            padding: 14,
                            background: 'rgba(0,0,0,0.18)',
                            border: '1px solid rgba(201,162,39,0.12)',
                            borderRadius: 10,
                        }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', marginBottom: 10 }}>
                                <div style={{ color: '#ffd700', fontWeight: 700 }}>
                                    Lv{tier} å¤©èµ‹
                                </div>
                                <div style={{ fontSize: 12, color: locked ? '#a66' : '#7f7' }}>
                                    {locked ? `æœªè§£é”ï¼ˆéœ€è¦ Lv${tier}ï¼‰` : (picked ? `å·²é€‰æ‹©ï¼š${tierDef.options.find(o => o.id === picked)?.name || picked}` : 'æœªé€‰æ‹©')}
                                </div>
                            </div>

                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 12 }}>
                                {tierDef.options.map(opt => (
                                    <div
                                        key={opt.id}
                                        style={cardStyle(tier, opt.id)}
                                        onClick={() => {
                                            if (locked) return;
                                            // å¦‚æœå·²é€‰è¿™ä¸€é¡¹ï¼Œåˆ™ä¸åšåˆ‡æ¢ï¼ˆé¿å…è¯¯è§¦ï¼‰
                                            if (talents?.[tier] === opt.id) return;
                                            // å¦‚æœæ˜¯å ä½ï¼ˆé¢„ç•™ï¼‰è¡Œï¼Œå…ˆä¸å…è®¸é€‰æ‹©ï¼ˆé¿å…è¯¯å¯¼ï¼‰
                                            if (tier >= 80) return;
                                            chooseTalent(tier, opt.id);
                                        }}
                                        title={locked ? 'æœªè§£é”' : (tier >= 50 ? 'é¢„ç•™å¤©èµ‹ï¼Œå¾…å®ç°' : 'ç‚¹å‡»é€‰æ‹©')}
                                    >
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 8 }}>
                                            <div style={{ fontWeight: 700, color: '#fff' }}>{opt.name}</div>
                                            {talents?.[tier] === opt.id && (
                                                <div style={{ color: '#c9a227', fontSize: 12, fontWeight: 800 }}>âœ“ å·²ç‚¹äº®</div>
                                            )}
                                        </div>
                                        <div style={{ fontSize: 12, color: '#bbb', lineHeight: 1.45 }}>
                                            {opt.description}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    );
                })}
            </Panel>
        </div>
    );
};

const MapPage = ({ state, dispatch }) => {
    const [draggedChar, setDraggedChar] = useState(null);

    const handleDragStart = (e, charId) => {
        setDraggedChar(charId);
        // âœ… Edge/éƒ¨åˆ†æµè§ˆå™¨éœ€è¦ setData æ‰ä¼šè®¤ä¸ºè¿™æ˜¯â€œæœ‰æ•ˆæ‹–æ‹½â€
        e.dataTransfer.setData('text/plain', charId);
        e.dataTransfer.effectAllowed = 'move';
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    };

    const handleDrop = (e, zoneId) => {
        e.preventDefault();
        if (draggedChar) {
            dispatch({
                type: 'ASSIGN_ZONE',
                payload: { characterId: draggedChar, zoneId }
            });
            setDraggedChar(null);
        }
    };

    // è·å–æ‰€æœ‰åœ¨ä¸»åŸèµ„æºå»ºç­‘å·¥ä½œçš„è§’è‰²ID
    const resourceAssignedIds = new Set(
        Object.values(state.resourceAssignments || {}).flat()
    );

    // è¿‡æ»¤ï¼šæ—¢ä¸åœ¨åœ°å›¾æ‰“æ€ªï¼Œä¹Ÿä¸åœ¨ä¸»åŸé‡‡é›†
    const unassignedChars = state.characters.filter(c =>
        !state.assignments[c.id] && !resourceAssignedIds.has(c.id)
    );

    return (
        <div>
            {/* æœªåˆ†é…çš„è§’è‰²åˆ—è¡¨ */}
            {unassignedChars.length > 0 && (
                <div
                    style={{
                        position: 'sticky',
                        top: 12,
                        zIndex: 50,
                        // å¯é€‰ï¼šå¦‚æœè§’è‰²å¾ˆå¤šï¼Œå›ºå®šæ è‡ªå·±æ»šåŠ¨
                        maxHeight: '40vh',
                        overflowY: 'auto',
                    }}
                >
                    <Panel title="å¯æ´¾é£è§’è‰²" style={{ marginBottom: 16 }}>
                        <div style={{
                            display: 'flex',
                            gap: 12,
                            flexWrap: 'wrap'
                        }}>
                            {unassignedChars.map(char => (
                                <div
                                    key={char.id}
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, char.id)}
                                    style={{
                                        padding: '12px 16px',
                                        background: 'linear-gradient(135deg, rgba(201,162,39,0.2), rgba(139,115,25,0.1))',
                                        border: '2px solid #c9a227',
                                        borderRadius: 6,
                                        cursor: 'grab',
                                        transition: 'all 0.2s',
                                        userSelect: 'none'
                                    }}
                                    onMouseEnter={(e) => {
                                        e.currentTarget.style.transform = 'translateY(-4px)';
                                        e.currentTarget.style.boxShadow = '0 4px 12px rgba(201,162,39,0.4)';
                                    }}
                                    onMouseLeave={(e) => {
                                        e.currentTarget.style.transform = 'translateY(0)';
                                        e.currentTarget.style.boxShadow = 'none';
                                    }}
                                >
                                    <div style={{ fontSize: 14, color: '#ffd700', fontWeight: 600 }}>
                                        {char.name}
                                    </div>
                                    <div style={{ fontSize: 11, color: '#888', marginTop: 4 }}>
                                        Lv.{char.level} {CLASSES[char.classId].name}
                                    </div>
                                </div>
                            ))}
                        </div>
                        <div style={{
                            marginTop: 12,
                            fontSize: 12,
                            color: '#888',
                            fontStyle: 'italic'
                        }}>
                            ğŸ’¡ æ‹–æ‹½è§’è‰²åˆ°åŒºåŸŸè¿›è¡Œåˆ†é…
                        </div>
                    </Panel>
                </div>
            )}

            {/* åŒºåŸŸåˆ—è¡¨ */}
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: 16 }}>
                {Object.values(state.zones).map(zone => {
                    const assignedChars = Object.entries(state.assignments)
                        .filter(([_, zId]) => zId === zone.id)
                        .map(([cId, _]) => state.characters.find(c => c.id === cId))
                        .filter(Boolean);

                    return (
                        <div
                            key={zone.id}
                            onDragOver={zone.unlocked ? handleDragOver : undefined}
                            onDrop={zone.unlocked ? (e) => handleDrop(e, zone.id) : undefined}
                            style={{
                                opacity: zone.unlocked ? 1 : 0.6,
                                transition: 'all 0.2s'
                            }}
                        >
                            <Panel title={zone.name}>
                                <div style={{ fontSize: 13, color: '#aaa', marginBottom: 12 }}>
                                    ç­‰çº§: {zone.level} | {zone.unlocked ? 'âœ“ å·²è§£é”' : `ğŸ”’ éœ€è¦ç­‰çº§ ${zone.unlockLevel}`}
                                </div>

                                {zone.unlocked && (
                                    <>
                                        <div style={{ marginBottom: 12 }}>
                                            <div style={{ fontSize: 12, color: '#888', marginBottom: 8 }}>æ€ªç‰©:</div>
                                            {zone.enemies?.map((enemy, i) => (
                                                <div key={i} style={{
                                                    fontSize: 11,
                                                    padding: 6,
                                                    background: 'rgba(0,0,0,0.3)',
                                                    borderRadius: 4,
                                                    marginBottom: 4
                                                }}>
                                                    {enemy.name} (HP: {enemy.hp}, æ”»å‡»: {enemy.attack})
                                                </div>
                                            ))}
                                        </div>

                                        <div style={{
                                            minHeight: 60,
                                            padding: 12,
                                            background: 'rgba(201,162,39,0.05)',
                                            border: '2px dashed #4a3c2a',
                                            borderRadius: 6,
                                            marginBottom: 12
                                        }}>
                                            <div style={{ fontSize: 12, color: '#888', marginBottom: 8 }}>
                                                å·²åˆ†é…è§’è‰²:
                                            </div>
                                            {assignedChars.length > 0 ? (
                                                assignedChars.map(char => (
                                                    <div key={char.id} style={{
                                                        display: 'flex',
                                                        justifyContent: 'space-between',
                                                        alignItems: 'center',
                                                        padding: 6,
                                                        background: 'rgba(201,162,39,0.1)',
                                                        borderRadius: 4,
                                                        marginBottom: 4
                                                    }}>
                                                        <span style={{ fontSize: 11 }}>{char.name} (Lv.{char.level})</span>
                                                        <Button
                                                            onClick={() => dispatch({
                                                                type: 'UNASSIGN_CHARACTER',
                                                                payload: { characterId: char.id }
                                                            })}
                                                            variant="danger"
                                                            style={{ padding: '4px 8px', fontSize: 10 }}
                                                        >
                                                            å¬å›
                                                        </Button>
                                                    </div>
                                                ))
                                            ) : (
                                                <div style={{ fontSize: 11, color: '#666', fontStyle: 'italic', textAlign: 'center' }}>
                                                    æ‹–æ‹½è§’è‰²åˆ°æ­¤å¤„
                                                </div>
                                            )}
                                        </div>
                                    </>
                                )}
                            </Panel>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

// ==================== PAGE: CHARACTER ====================
const CharacterPage = ({ state, dispatch }) => {
    const [showCreate, setShowCreate] = useState(false);
    const [newChar, setNewChar] = useState({ name: '', race: RACES[0], classId: 'protection_warrior' });
    const [selectedCharId, setSelectedCharId] = useState(null);
    const [showSkillEditor, setShowSkillEditor] = useState(null);
    const [showSkillViewer, setShowSkillViewer] = useState(null);
    const [showCombatLogs, setShowCombatLogs] = useState(false);

    const createCharacter = () => {
        if (newChar.name.trim()) {
            dispatch({ type: 'CREATE_CHARACTER', payload: newChar });
            setNewChar({ name: '', race: RACES[0], classId: 'protection_warrior' });
            setShowCreate(false);
        }
    };

    const expandCost = 1000 * Math.pow(2, state.characterSlots);
    const hasAvailableSlots = state.characters.length < state.characterSlots;

    return (
        <div>
            {showCombatLogs && (
                <CombatLogsModal
                    logs={state.combatLogs}
                    onClose={() => setShowCombatLogs(false)}
                    onClear={() => {
                        dispatch({ type: 'CLEAR_COMBAT_LOGS' });
                        setShowCombatLogs(false);
                    }}
                />
            )}

            {showSkillEditor && (
                <SkillEditorModal
                    character={showSkillEditor}
                    onClose={() => setShowSkillEditor(null)}
                    onSave={(charId, skillSets, activeSkillSet) => {
                        dispatch({ type: 'UPDATE_SKILL_SETS', payload: { characterId: charId, skillSets, activeSkillSet } });
                    }}
                    state={state}
                />
            )}

            {showSkillViewer && (
                <SkillViewerModal
                    character={showSkillViewer}
                    onClose={() => setShowSkillViewer(null)}
                />
            )}

            {selectedCharId && (
                <CharacterDetailsModal
                    characterId={selectedCharId}
                    state={state}
                    onClose={() => setSelectedCharId(null)}
                    onUnequip={(charId, slot) => {
                        dispatch({ type: 'UNEQUIP_ITEM', payload: { characterId: charId, slot } });
                    }}
                    onEditSkills={() => {
                        const latest = state.characters.find(c => c.id === selectedCharId);
                        if (latest) setShowSkillEditor(latest);
                        setSelectedCharId(null);
                    }}
                    onViewSkills={() => {
                        const latest = state.characters.find(c => c.id === selectedCharId);
                        if (latest) setShowSkillViewer(latest);
                        setSelectedCharId(null);
                    }}
                    onSyncSkills={() => dispatch({ type: 'SYNC_CHARACTER_SKILLS', payload: { characterId: selectedCharId } })}
                />
            )}

            <Panel
                title="è§’è‰²ç®¡ç†"
                actions={
                    <div style={{ display: 'flex', gap: 8 }}>
                        <Button
                            onClick={() => setShowCombatLogs(true)}
                            variant="secondary"
                        >
                            ğŸ“œ æˆ˜æ–—æ—¥å¿— ({state.combatLogs.length})
                        </Button>
                        <Button
                            onClick={() => setShowCreate(!showCreate)}
                            disabled={!hasAvailableSlots}
                        >
                            {showCreate ? 'âœ— å–æ¶ˆ' : '+ åˆ›å»ºè§’è‰²'}
                        </Button>
                        <Button
                            onClick={() => dispatch({ type: 'EXPAND_CHARACTER_SLOTS' })}
                            variant="secondary"
                            disabled={state.characterSlots >= state.maxCharacterSlots || state.resources.gold < expandCost}
                        >
                            æ‰©å±•æ§½ä½ ({state.characterSlots}/{state.maxCharacterSlots}) - ğŸª™{expandCost}
                        </Button>
                    </div>
                }
            >
                <div style={{ fontSize: 13, color: '#aaa', marginBottom: 16 }}>
                    è§’è‰²æ§½ä½: {state.characters.length} / {state.characterSlots}
                </div>

                {showCreate && (
                    <div style={{
                        padding: 16,
                        background: 'rgba(0,0,0,0.3)',
                        borderRadius: 6,
                        marginBottom: 16,
                        border: '1px solid #4a3c2a'
                    }}>
                        <div style={{ marginBottom: 12 }}>
                            <label style={{ display: 'block', fontSize: 12, color: '#c9a227', marginBottom: 4 }}>
                                è§’è‰²å
                            </label>
                            <input
                                type="text"
                                value={newChar.name}
                                onChange={(e) => setNewChar({ ...newChar, name: e.target.value })}
                                placeholder="è¾“å…¥è§’è‰²å..."
                                style={{
                                    width: '100%',
                                    padding: '8px 12px',
                                    background: 'rgba(0,0,0,0.4)',
                                    border: '1px solid #4a3c2a',
                                    borderRadius: 4,
                                    color: '#fff',
                                    fontSize: 13
                                }}
                            />
                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 12, marginBottom: 12 }}>
                            <div>
                                <label style={{ display: 'block', fontSize: 12, color: '#c9a227', marginBottom: 4 }}>
                                    ç§æ—
                                </label>
                                <select
                                    value={newChar.race}
                                    onChange={(e) => setNewChar({ ...newChar, race: e.target.value })}
                                    style={{
                                        width: '100%',
                                        padding: '8px 12px',
                                        background: 'rgba(0,0,0,0.4)',
                                        border: '1px solid #4a3c2a',
                                        borderRadius: 4,
                                        color: '#fff',
                                        fontSize: 13,
                                        cursor: 'pointer'
                                    }}
                                >
                                    {RACES.map(race => (
                                        <option key={race} value={race}>{race}</option>
                                    ))}
                                </select>
                            </div>

                            <div>
                                <label style={{ display: 'block', fontSize: 12, color: '#c9a227', marginBottom: 4 }}>
                                    èŒä¸š
                                </label>
                                <select
                                    value={newChar.classId}
                                    onChange={(e) => setNewChar({ ...newChar, classId: e.target.value })}
                                    style={{
                                        width: '100%',
                                        padding: '8px 12px',
                                        background: 'rgba(0,0,0,0.4)',
                                        border: '1px solid #4a3c2a',
                                        borderRadius: 4,
                                        color: '#fff',
                                        fontSize: 13,
                                        cursor: 'pointer'
                                    }}
                                >
                                    {Object.values(CLASSES).map(cls => (
                                        <option key={cls.id} value={cls.id}>{cls.name}</option>
                                    ))}
                                </select>
                            </div>
                        </div>

                        <Button onClick={createCharacter} disabled={!newChar.name.trim()}>
                            âœ“ åˆ›å»º
                        </Button>
                    </div>
                )}

                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))', gap: 12 }}>
                    {state.characters.map(char => {
                        const assignment = state.assignments[char.id];
                        const zone = assignment ? state.zones[assignment] : null;
                        const equippedCount = Object.keys(char.equipment || {}).length;

                        // è„±æˆ˜æ—¶é—´ï¼ˆå¯è¢«åŠŸèƒ½å»ºç­‘ï¼šè¾‰å…‰ç¯å¡” ç¼©çŸ­ï¼‰
                        const glowLighthouseCount = state.functionalBuildings?.glow_lighthouse || 0;
                        const regenDelayMs = Math.max(0, 5000 - glowLighthouseCount * 1000);
                        const timeSinceCombat = Date.now() - (char.lastCombatTime || 0);
                        const regenSecondsLeft = Math.max(0, Math.ceil((regenDelayMs - timeSinceCombat) / 1000));

                        return (
                            <div
                                key={char.id}
                                onClick={() => setSelectedCharId(char.id)}
                                style={{
                                    cursor: 'pointer',
                                    padding: 12,
                                    borderRadius: 10,
                                    border: '1px solid #333',
                                    background: 'rgba(0,0,0,0.35)',
                                    transition: 'transform 0.06s ease',
                                }}
                                onMouseDown={(e) => {
                                    // å°å°æŒ‰å‹åé¦ˆï¼ˆå¯åˆ ï¼‰
                                    e.currentTarget.style.transform = 'scale(0.995)';
                                }}
                                onMouseMove={(e) => {
                                    e.currentTarget.style.transform = 'scale(1)';
                                }}
                                onMouseUp={(e) => {
                                    e.currentTarget.style.transform = 'scale(1)';
                                }}
                            >
                                {/* ===== é¡¶éƒ¨ä¿¡æ¯ ===== */}
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                    <div>
                                        {/* âœ… åå­—ä¸éœ€è¦å†å•ç‹¬ç»‘å®š onClickï¼Œå› ä¸ºæ•´ä¸ªå¡ç‰‡éƒ½èƒ½ç‚¹ */}
                                        <div style={{ fontSize: 14, fontWeight: 700, color: '#ffd700' }}>
                                            {char.name}
                                        </div>
                                        <div style={{ fontSize: 11, color: '#aaa', marginTop: 4 }}>
                                            Lv.{char.level} Â· {char.race} Â· {CLASSES[char.classId]?.name}
                                        </div>
                                    </div>

                                    <div style={{ textAlign: 'right' }}>
                                        {zone && (
                                            <div style={{
                                                padding: '4px 8px',
                                                background: 'rgba(201,162,39,0.2)',
                                                borderRadius: 4,
                                                fontSize: 10,
                                                color: '#c9a227',
                                                marginBottom: 4
                                            }}>
                                                ğŸ“ {zone.name}
                                            </div>
                                        )}
                                        <div style={{ fontSize: 10, color: '#888' }}>
                                            è£…å¤‡: {equippedCount}/{Object.keys(EQUIPMENT_SLOTS).length}
                                        </div>
                                    </div>
                                </div>

                                <StatBar
                                    label="ç”Ÿå‘½"
                                    current={char.stats.currentHp}
                                    max={char.stats.maxHp}
                                    color="#f44336"
                                />
                                <StatBar
                                    label="ç»éªŒ"
                                    current={char.exp}
                                    max={char.expToNext}
                                    color="#4CAF50"
                                />

                                <div style={{ fontSize: 11, color: '#888', marginTop: 6 }}>
                                    {char.combatState
                                        ? 'âš”ï¸ æˆ˜æ–—ä¸­'
                                        : (timeSinceCombat < regenDelayMs
                                                ? `ğŸ•’ è„±æˆ˜å›è¡€ ${regenSecondsLeft} ç§’åå¼€å§‹`
                                                : `ğŸ’š è„±æˆ˜å›è¡€ä¸­ï¼šæ¯ç§’ +${10 + (state.functionalBuildings?.plaza_fountain || 0) * 2}`
                                        )
                                    }
                                </div>

                                <div style={{
                                    display: 'grid',
                                    gridTemplateColumns: '1fr 1fr',
                                    gap: 8,
                                    fontSize: 11,
                                    color: '#aaa',
                                    marginTop: 12,
                                    marginBottom: 12
                                }}>
                                    <div>ç”Ÿå‘½: {Math.floor(char.stats.currentHp)} / {Math.floor(char.stats.maxHp)}</div>
                                    <div>æ³•åŠ›: {Math.floor(char.stats.currentMp)} / {Math.floor(char.stats.maxMp)}</div>
                                    <div>æ”»å‡»: {formatStatForDisplay('attack', char.stats.attack)}</div>
                                    <div>æŠ¤ç”²: {Math.floor(char.stats.armor)}</div>
                                </div>

                                {/* âœ… è§’è‰²å¡ç‰‡ï¼šæŸ¥çœ‹æŠ€èƒ½ï¼ˆæ’é™¤â€œä¼‘æ¯/æ™®é€šæ”»å‡»â€ï¼‰ + ç¼–è¾‘æŠ€èƒ½ */}
                                <div style={{ display: 'flex', gap: 8 }}>
                                    <Button
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            setShowSkillViewer(char);
                                        }}
                                        variant="secondary"
                                        style={{ flex: 1, fontSize: 11, padding: '6px 8px' }}
                                    >
                                        æŸ¥çœ‹æŠ€èƒ½
                                    </Button>
                                    <Button
                                        onClick={(e) => {
                                            e.stopPropagation();     // âœ… é˜²æ­¢è§¦å‘å¡ç‰‡ç‚¹å‡»æ‰“å¼€è¯¦æƒ…
                                            setShowSkillEditor(char);
                                        }}
                                        variant="secondary"
                                        style={{ flex: 1, fontSize: 11, padding: '6px 8px' }}
                                    >
                                        ç¼–è¾‘æŠ€èƒ½
                                    </Button>
                                    <Button
                                        variant="danger"
                                        onClick={() => {
                                            if (window.confirm("ç¡®å®šè¦åˆ é™¤è¯¥è§’è‰²å—ï¼Ÿ")) {
                                                dispatch({ type: "DELETE_CHARACTER", payload: { characterId: char.id } });
                                            }
                                        }}
                                    >
                                        ğŸ—‘ åˆ é™¤
                                    </Button>
                                </div>
                            </div>
                        );

                    })}
                </div>
            </Panel>
        </div>
    );
};

// ==================== PAGE: INVENTORY ====================
const InventoryPage = ({ state, dispatch }) => {
    const [selectedItem, setSelectedItem] = useState(null);
    const [draggedItemId, setDraggedItemId] = useState(null);
    const [draggedIndex, setDraggedIndex] = useState(null);

    const mechanicalArmCount = state.functionalBuildings?.mechanical_arm ?? 0;
    const autoMergeSlots = Math.min(10, mechanicalArmCount);

    const handleDropToEmpty = (e, targetIndex) => {
        e.preventDefault();

        if (draggedIndex !== null && draggedIndex !== targetIndex) {
            dispatch({
                type: 'MOVE_INVENTORY_ITEM',
                payload: { fromIndex: draggedIndex, toIndex: targetIndex }
            });
        }

        setDraggedItemId(null);
        setDraggedIndex(null);
    };

    return (
        <div>
            {/* âœ… è£…å¤‡è¯¦æƒ…æ¨¡æ€æ¡† - ç¡®ä¿è¿™éƒ¨åˆ†å­˜åœ¨ */}
            {selectedItem && selectedItem.type === 'equipment' && (
                <ItemDetailsModal
                    item={selectedItem}
                    onClose={() => setSelectedItem(null)}
                    onEquip={(charId, itemInstanceId) => {
                        dispatch({ type: 'EQUIP_ITEM', payload: { characterId: charId, itemInstanceId } });
                    }}
                    characters={state.characters}
                    state={state}
                    dispatch={dispatch}
                />
            )}

            <Panel
                title={`é“å…·æ  (${state.inventory.length}/${state.inventorySize})`}
                actions={
                    <div style={{ display: 'flex', gap: 8 }}>
                        <Button
                            variant="secondary"
                            onClick={() => dispatch({ type: 'SORT_INVENTORY' })}
                        >
                            ğŸ“¦ æ•´ç†èƒŒåŒ…
                        </Button>
                        <Button
                            variant="secondary"
                            onClick={() => {
                                const junkItems = state.inventory.filter(i => i?.type === 'junk' && (i.sellPrice || 0) > 0);
                                const totalGold = junkItems.reduce((sum, it) => sum + (it.sellPrice || 0), 0);

                                if (junkItems.length === 0) {
                                    alert('æ²¡æœ‰å¯å‡ºå”®çš„åƒåœ¾ã€‚');
                                    return;
                                }

                                if (window.confirm(`ä¸€é”®å‡ºå”® ${junkItems.length} ä»¶åƒåœ¾ï¼Œè·å¾— ğŸª™${totalGold} é‡‘å¸ï¼Ÿ`)) {
                                    dispatch({ type: 'SELL_ALL_JUNK' });
                                }
                            }}
                        >
                            ğŸ”˜ ä¸€é”®å–åƒåœ¾
                        </Button>
                    </div>
                }
            >
                <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fill, minmax(120px, 1fr))',
                    gap: 8
                }}>
                    {state.inventory.map((item, index) => (
                        <div
                            key={item.instanceId || item.id}
                            draggable={item.type === 'equipment'}
                            onDragStart={(e) => {
                                if (item.type !== 'equipment') return;
                                if (!item.instanceId) return;
                                setDraggedItemId(item.instanceId);
                                setDraggedIndex(index);
                                e.dataTransfer.effectAllowed = 'move';
                            }}
                            onDragOver={(e) => {
                                e.preventDefault();
                                e.dataTransfer.dropEffect = 'move';
                            }}
                            onDrop={(e) => {
                                e.preventDefault();

                                const fromInstanceId = draggedItemId;
                                const toInstanceId = item.instanceId;

                                if (!fromInstanceId || fromInstanceId === toInstanceId) {
                                    setDraggedItemId(null);
                                    setDraggedIndex(null);
                                    return;
                                }

                                const fromItem = state.inventory.find(i => i.instanceId === fromInstanceId);
                                const toItem = item;

                                if (!toItem || toItem.type !== 'equipment') {
                                    if (draggedIndex !== null) {
                                        dispatch({
                                            type: 'MOVE_INVENTORY_ITEM',
                                            payload: { fromIndex: draggedIndex, toIndex: index }
                                        });
                                    }
                                    setDraggedItemId(null);
                                    setDraggedIndex(null);
                                    return;
                                }

                                if (fromItem && fromItem.type === 'equipment' && fromItem.id === toItem.id) {
                                    dispatch({
                                        type: 'MERGE_EQUIPMENT',
                                        payload: { instanceIdA: fromInstanceId, instanceIdB: toInstanceId }
                                    });
                                } else if (draggedIndex !== null) {
                                    dispatch({
                                        type: 'MOVE_INVENTORY_ITEM',
                                        payload: { fromIndex: draggedIndex, toIndex: index }
                                    });
                                }

                                setDraggedItemId(null);
                                setDraggedIndex(null);
                            }}
                            onDragEnd={() => {
                                setDraggedItemId(null);
                                setDraggedIndex(null);
                            }}
                            onClick={(e) => {
                                // âœ… æ¶ˆè€—å“ä½¿ç”¨
                                if (item.type === 'consumable' && item.canUse) {
                                    dispatch({ type: 'USE_ITEM', payload: { itemInstanceId: item.instanceId || item.id } });
                                    return;
                                }

                                // âœ… éè£…å¤‡ä¸å¤„ç†
                                if (item.type !== 'equipment') return;

                                // âœ… Shift+ç‚¹å‡»ï¼šé“¾å¼åˆæˆ
                                if (e.shiftKey && item.instanceId) {
                                    e.preventDefault();
                                    dispatch({ type: 'MERGE_EQUIPMENT_CHAIN', payload: { targetInstanceId: item.instanceId } });
                                    return;
                                }

                                // âœ… æ™®é€šç‚¹å‡»ï¼šæ‰“å¼€è¯¦æƒ…æ¨¡æ€æ¡†
                                setSelectedItem(item);
                            }}
                            onContextMenu={(e) => {
                                e.preventDefault();

                                if (item.sellPrice) {
                                    if (window.confirm(`å‡ºå”® ${item.name}ï¼Œè·å¾— ğŸª™${item.sellPrice} é‡‘å¸ï¼Ÿ`)) {
                                        dispatch({ type: 'SELL_ITEM', payload: { itemInstanceId: item.instanceId || item.id } });
                                    }
                                } else {
                                    if (window.confirm(`ç¡®å®šè¦ä¸¢å¼ƒ ${item.name} å—ï¼Ÿ`)) {
                                        dispatch({ type: 'USE_ITEM', payload: { itemInstanceId: item.instanceId || item.id } });
                                    }
                                }
                            }}
                            style={{
                                position: 'relative',
                                padding: 12,
                                background: item.type === 'equipment'
                                    ? `linear-gradient(135deg, ${(item.qualityColor || getRarityColor(item.rarity))}22, rgba(0,0,0,0.3))`
                                    : 'rgba(0,0,0,0.3)',
                                border: `2px solid ${item.type === 'equipment' ? (item.qualityColor || getRarityColor(item.rarity)) : '#4a3c2a'}`,
                                outline: (draggedItemId && item.type === 'equipment' && draggedItemId === item.instanceId)
                                    ? '2px solid #ffd700'
                                    : 'none',
                                borderRadius: 6,
                                textAlign: 'center',
                                cursor: item.type === 'equipment' ? 'grab' : 'default',
                                transition: 'all 0.2s'
                            }}
                            onMouseEnter={(e) => {
                                if (item.type === 'equipment') {
                                    e.currentTarget.style.transform = 'translateY(-4px)';
                                    e.currentTarget.style.boxShadow = `0 4px 12px ${item.qualityColor}66`;
                                }
                            }}
                            onMouseLeave={(e) => {
                                if (item.type === 'equipment') {
                                    e.currentTarget.style.transform = 'translateY(0)';
                                    e.currentTarget.style.boxShadow = 'none';
                                }
                            }}
                        >
                            <div style={{ fontSize: 28, marginBottom: 8 }}>
                                <ItemIcon item={item} size={32} />
                            </div>
                            <div style={{
                                fontSize: 11,
                                color: item.type === 'equipment' ? item.qualityColor : '#ffd700',
                                fontWeight: item.type === 'equipment' ? 600 : 'normal'
                            }}>
                                {item.name}
                            </div>
                            {item.type === 'equipment' && (
                                <div style={{ fontSize: 9, color: '#888', marginTop: 4 }}>
                                    Lv.{item.currentLevel ?? item.level ?? 0}
                                </div>
                            )}
                            {item.specialEffect && (
                                <div style={{
                                    fontSize: 9,
                                    color: '#ff9800',
                                    marginTop: 4,
                                    padding: '2px 4px',
                                    background: 'rgba(255, 152, 0, 0.15)',
                                    borderRadius: 3
                                }}>
                                    {item.specialEffect.type === 'skill_slot_buff' && (
                                        <>
                                            âš¡ {item.specialEffect.slots.map(s => s + 1).join('/')}æ ¼
                                            {item.specialEffect.attackBonus ? ` æ”»+${item.specialEffect.attackBonus}` : ''}
                                            {item.specialEffect.spellPowerBonus ? ` æ³•+${item.specialEffect.spellPowerBonus}` : ''}
                                        </>
                                    )}
                                    {item.specialEffect.type === 'basic_attack_repeat' && (
                                        <>
                                            âš”ï¸ æ™®æ”» {(item.specialEffect.chance * 100).toFixed(0)}% è¿å‡»
                                        </>
                                    )}

                                    {item.specialEffect.type === 'proc_stat' && item.specialEffect.trigger === 'turn_start' && (
                                        <>
                                            ğŸ² æ¯å›åˆ {(item.specialEffect.chance * 100).toFixed(0)}%{' '}
                                            {(() => {
                                                const entries = Object.entries(item.specialEffect.stats || {});
                                                const brief = entries.slice(0, 2).map(([stat, val]) =>
                                                    `${(STAT_LABELS[stat] || stat).replace('å¼ºåº¦', '')}+${formatItemStatValue(stat, val)}`
                                                );
                                                return `${brief.join(' ')}${entries.length > 2 ? 'â€¦' : ''}`;
                                            })()}
                                        </>
                                    )}

                                    {item.specialEffect.type === 'map_slayer' && (
                                        <>
                                            ğŸ—ºï¸ åœ°å›¾ä¼¤å®³ +{((item.specialEffect.bonusDamageVsMap || 0) * 100).toFixed(0)}%
                                        </>
                                    )}
                                </div>
                            )}
                            {index < autoMergeSlots && item?.type === 'equipment' && (
                                <div style={{
                                    position: 'absolute',
                                    top: 4,
                                    right: 4,
                                    background: 'rgba(76,175,80,0.85)',
                                    color: '#fff',
                                    fontSize: 10,
                                    padding: '3px 7px',
                                    borderRadius: 4,
                                    pointerEvents: 'none',
                                    zIndex: 10,
                                    border: '1px solid rgba(255,255,255,0.3)',
                                    boxShadow: '0 0 8px rgba(76,175,80,0.6)',
                                    fontWeight: 600
                                }}>
                                    ğŸ¦¾
                                </div>
                            )}
                        </div>
                    ))}

                    {/* ç©ºæ ä½ - æ”¯æŒæ‹–æ”¾ */}
                    {Array.from({ length: Math.max(0, state.inventorySize - state.inventory.length) }).map((_, i) => {
                        const targetIndex = state.inventory.length + i;
                        return (
                            <div
                                key={`empty_${i}`}
                                onDragOver={(e) => {
                                    e.preventDefault();
                                    e.dataTransfer.dropEffect = 'move';
                                }}
                                onDrop={(e) => handleDropToEmpty(e, targetIndex)}
                                style={{
                                    padding: 12,
                                    background: draggedItemId ? 'rgba(201,162,39,0.1)' : 'rgba(0,0,0,0.2)',
                                    border: draggedItemId ? '2px dashed #c9a227' : '1px dashed #333',
                                    borderRadius: 6,
                                    textAlign: 'center',
                                    opacity: draggedItemId ? 0.8 : 0.3,
                                    transition: 'all 0.2s',
                                    minHeight: 80,
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }}
                            >
                                <div style={{ fontSize: 28, color: draggedItemId ? '#c9a227' : '#333' }}>
                                    {draggedItemId ? 'ğŸ“¥' : 'âˆ…'}
                                </div>
                            </div>
                        );
                    })}
                </div>
            </Panel>
        </div>
    );
};

// ==================== PAGE: CITY (é‡æ–°è®¾è®¡) ====================
const CityPage = ({ state, dispatch }) => {
    const [draggedChar, setDraggedChar] = useState(null);
    const [activeTab, setActiveTab] = useState('resources'); // 'resources' | 'functional'

    // è·å–æœªè¢«æ´¾é£çš„è§’è‰²ï¼ˆä¸åœ¨åœ°å›¾ä¹Ÿä¸åœ¨èµ„æºå»ºç­‘ï¼‰
    const getAvailableChars = () => {
        const mapAssigned = new Set(Object.keys(state.assignments || {}));
        const resourceAssigned = new Set(
            Object.values(state.resourceAssignments || {}).flat()
        );

        return state.characters.filter(c =>
            !mapAssigned.has(c.id) && !resourceAssigned.has(c.id)
        );
    };

    const availableChars = getAvailableChars();

    // è·å–æŸå»ºç­‘çš„å·¥äººï¼ˆè¿‡æ»¤æ‰ä¸å­˜åœ¨çš„è§’è‰²ï¼‰
    const getWorkers = (buildingId) => {
        return (state.resourceAssignments?.[buildingId] || [])
            .map(id => state.characters.find(c => c.id === id))
            .filter(Boolean);  // âœ… è¿™è¡Œå·²ç»èƒ½è¿‡æ»¤æ‰æ‰¾ä¸åˆ°çš„è§’è‰²
    };

    const handleDragStart = (e, charId) => {
        setDraggedChar(charId);

        // âœ… Edge/éƒ¨åˆ†æµè§ˆå™¨éœ€è¦ setData æ‰ä¼šè®¤ä¸ºè¿™æ˜¯â€œæœ‰æ•ˆæ‹–æ‹½â€
        e.dataTransfer.setData('text/plain', charId);

        e.dataTransfer.effectAllowed = 'move';
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    };

    const handleDrop = (e, buildingId) => {
        e.preventDefault();

        // âœ… ç›´æ¥ä» dataTransfer è·å–æ•°æ®
        const charId = e.dataTransfer.getData('text/plain');

        console.log('handleDrop è§¦å‘:', { charId, buildingId }); // è°ƒè¯•æ—¥å¿—

        if (charId) {
            dispatch({
                type: 'ASSIGN_RESOURCE_BUILDING',
                payload: { characterId: charId, buildingId }
            });
        } else {
            console.warn('handleDrop: æ²¡æœ‰è·å–åˆ° charId');
        }
        setDraggedChar(null);
    };

    // âœ… èµ„æºæ˜¾ç¤ºé…ç½®ï¼ˆè¿‡æ»¤æ‰ population å’Œ maxPopulationï¼‰
    const resourceConfig = {
        gold: { icon: 'ğŸŸ¡', name: 'é‡‘å¸' },
        wood: { icon: 'ğŸªµ', name: 'æœ¨æ' },
        ironOre: { icon: 'ğŸª™', name: 'é“çŸ¿' },
        ironIngot: { icon: 'ğŸ”©', name: 'é“é”­' },
        herb: { icon: 'ğŸŒ¿', name: 'è‰è¯' },
        leather: { icon: 'ğŸ¦Œ', name: 'æ¯›çš®' },
        magicEssence: { icon: 'ğŸ’', name: 'é­”æ³•ç²¾å' },
        alchemyOil: { icon: 'âš—ï¸', name: 'ç‚¼é‡‘æ²¹' }
    };

    // âœ… åªæ˜¾ç¤ºé…ç½®ä¸­å®šä¹‰çš„èµ„æº
    const displayedResources = Object.entries(state.resources)
        .filter(([key]) => resourceConfig[key]);

    return (
        <div>
            {/* èµ„æºæ€»è§ˆ */}
            <Panel title="ğŸ“¦ èµ„æºæ€»è§ˆ">
                <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fill, minmax(120px, 1fr))',
                    gap: 10
                }}>
                    {displayedResources.map(([key, value]) => {
                        const config = resourceConfig[key];
                        return (
                            <div key={key} style={{
                                padding: 12,
                                background: 'rgba(0,0,0,0.3)',
                                border: '1px solid #4a3c2a',
                                borderRadius: 8,
                                textAlign: 'center'
                            }}>
                                <div style={{ fontSize: 24, marginBottom: 4 }}>{config.icon}</div>
                                <div style={{ fontSize: 11, color: '#888', marginBottom: 2 }}>{config.name}</div>
                                <div style={{ fontSize: 16, color: '#ffd700', fontWeight: 600 }}>
                                    {Math.floor(value)}
                                </div>
                            </div>
                        );
                    })}
                </div>
            </Panel>

            {/* å¯æ´¾é£è§’è‰² */}
            {availableChars.length > 0 && (
                <Panel title="ğŸ‘¥ å¯æ´¾é£è§’è‰²" style={{ marginBottom: 16 }}>
                    <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }}>
                        {availableChars.map(char => {
                            const gatherStats = calculateGatherStats(char);
                            return (
                                <div
                                    key={char.id}
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, char.id)}
                                    style={{
                                        padding: 12,
                                        background: 'linear-gradient(135deg, rgba(201,162,39,0.2), rgba(139,115,25,0.1))',
                                        border: '2px solid #c9a227',
                                        borderRadius: 8,
                                        cursor: 'grab',
                                        transition: 'all 0.2s',
                                        minWidth: 140
                                    }}
                                >
                                    <div style={{ fontSize: 14, color: '#ffd700', fontWeight: 600, marginBottom: 4 }}>
                                        {char.name}
                                    </div>
                                    <div style={{ fontSize: 11, color: '#888', marginBottom: 8 }}>
                                        Lv.{char.level} {CLASSES[char.classId].name}
                                    </div>
                                    <div style={{ fontSize: 10, color: '#aaa', display: 'flex', gap: 8 }}>
                                        <span title="ç†Ÿç»ƒ">ğŸ”§{gatherStats.proficiency}</span>
                                        <span title="ç²¾ç»†">ğŸ¯{gatherStats.precision}</span>
                                        <span title="æ„ŸçŸ¥">ğŸ‘ï¸{gatherStats.perception}</span>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                    <div style={{ marginTop: 12, fontSize: 12, color: '#888', fontStyle: 'italic' }}>
                        ğŸ’¡ æ‹–æ‹½è§’è‰²åˆ°ä¸‹æ–¹å»ºç­‘è¿›è¡Œæ´¾é£é‡‡é›†
                    </div>
                </Panel>
            )}

            {/* Tab åˆ‡æ¢ */}
            <div style={{
                display: 'flex',
                gap: 4,
                marginBottom: 16,
                padding: 4,
                background: 'rgba(0,0,0,0.3)',
                borderRadius: 8,
                border: '1px solid #3a3a3a'
            }}>
                <button
                    onClick={() => setActiveTab('resources')}
                    style={{
                        flex: 1,
                        padding: '10px 16px',
                        background: activeTab === 'resources'
                            ? 'linear-gradient(180deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))'
                            : 'transparent',
                        border: activeTab === 'resources' ? '1px solid #c9a227' : '1px solid transparent',
                        borderRadius: 6,
                        color: activeTab === 'resources' ? '#ffd700' : '#888',
                        cursor: 'pointer',
                        fontFamily: 'inherit',
                        fontSize: 14,
                        fontWeight: 600
                    }}
                >
                    â›ï¸ èµ„æºå»ºç­‘
                </button>
                <button
                    onClick={() => setActiveTab('functional')}
                    style={{
                        flex: 1,
                        padding: '10px 16px',
                        background: activeTab === 'functional'
                            ? 'linear-gradient(180deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))'
                            : 'transparent',
                        border: activeTab === 'functional' ? '1px solid #c9a227' : '1px solid transparent',
                        borderRadius: 6,
                        color: activeTab === 'functional' ? '#ffd700' : '#888',
                        cursor: 'pointer',
                        fontFamily: 'inherit',
                        fontSize: 14,
                        fontWeight: 600
                    }}
                >
                    ğŸ›ï¸ åŠŸèƒ½å»ºç­‘
                </button>
            </div>

            {/* èµ„æºå»ºç­‘åŒºåŸŸ */}
            {activeTab === 'resources' && (
                <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fill, minmax(320px, 1fr))',
                    gap: 16
                }}>
                    {Object.values(RESOURCE_BUILDINGS).map(building => {
                        const workers = getWorkers(building.id);
                        const currentProduction = workers.length > 0
                            ? calculateBuildingProduction(building.id, workers.map(w => w.id), state)
                            : 0;

                        return (
                            <div
                                key={building.id}
                                onDragOver={handleDragOver}
                                onDrop={(e) => handleDrop(e, building.id)}
                                style={{
                                    background: 'linear-gradient(135deg, rgba(40,35,30,0.9), rgba(25,20,15,0.95))',
                                    border: workers.length > 0 ? '2px solid #c9a227' : '2px solid #4a3c2a',
                                    borderRadius: 12,
                                    overflow: 'hidden',
                                    transition: 'all 0.2s'
                                }}
                            >
                                {/* å»ºç­‘å¤´éƒ¨ */}
                                <div style={{
                                    padding: 16,
                                    background: workers.length > 0
                                        ? 'linear-gradient(180deg, rgba(201,162,39,0.15), transparent)'
                                        : 'linear-gradient(180deg, rgba(60,50,40,0.3), transparent)',
                                    borderBottom: '1px solid rgba(201,162,39,0.2)'
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                                        <div style={{
                                            width: 50,
                                            height: 50,
                                            background: 'rgba(0,0,0,0.4)',
                                            borderRadius: 8,
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            fontSize: 28,
                                            border: '1px solid rgba(201,162,39,0.3)'
                                        }}>
                                            {building.icon}
                                        </div>
                                        <div style={{ flex: 1 }}>
                                            <div style={{ fontSize: 16, color: '#ffd700', fontWeight: 600 }}>
                                                {building.name}
                                            </div>
                                            <div style={{ fontSize: 11, color: '#888', marginTop: 2 }}>
                                                {building.description}
                                            </div>
                                        </div>
                                        <div style={{ textAlign: 'right' }}>
                                            <div style={{ fontSize: 11, color: '#888' }}>å·¥äºº</div>
                                            <div style={{
                                                fontSize: 14,
                                                color: workers.length >= building.maxWorkers ? '#f44336' : '#4CAF50',
                                                fontWeight: 600
                                            }}>
                                                {workers.length}/{building.maxWorkers}
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* äº§å‡ºä¿¡æ¯ */}
                                <div style={{
                                    padding: '12px 16px',
                                    background: 'rgba(0,0,0,0.2)',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center'
                                }}>
                                    <div>
                                        <span style={{ fontSize: 11, color: '#888' }}>å½“å‰äº§å‡ºï¼š</span>
                                        <span style={{
                                            fontSize: 14,
                                            color: currentProduction > 0 ? '#4CAF50' : '#666',
                                            fontWeight: 600,
                                            marginLeft: 4
                                        }}>
                                            +{currentProduction.toFixed(1)}/ç§’
                                        </span>
                                    </div>
                                    {building.consumption && (
                                        <div style={{ fontSize: 11, color: '#f44336' }}>
                                            æ¶ˆè€—: {Object.entries(building.consumption).map(([r, a]) =>
                                            `${r}Ã—${a}`
                                        ).join(', ')}/äºº
                                        </div>
                                    )}
                                </div>

                                {/* å·¥äººåŒºåŸŸ */}
                                <div style={{
                                    padding: 16,
                                    minHeight: 80,
                                    background: 'rgba(201,162,39,0.03)',
                                    borderTop: '1px dashed rgba(201,162,39,0.2)'
                                }}>
                                    {workers.length > 0 ? (
                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8 }}>
                                            {workers.map(char => {
                                                const gatherStats = calculateGatherStats(char);
                                                return (
                                                    <div key={char.id} style={{
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: 8,
                                                        padding: '8px 12px',
                                                        background: 'rgba(201,162,39,0.1)',
                                                        border: '1px solid rgba(201,162,39,0.3)',
                                                        borderRadius: 6
                                                    }}>
                                                        <div>
                                                            <div style={{ fontSize: 12, color: '#ffd700' }}>
                                                                {char.name}
                                                            </div>
                                                            <div style={{ fontSize: 10, color: '#888' }}>
                                                                ğŸ”§{gatherStats.proficiency} ğŸ¯{gatherStats.precision} ğŸ‘ï¸{gatherStats.perception}
                                                            </div>
                                                        </div>
                                                        <button
                                                            onClick={() => dispatch({
                                                                type: 'UNASSIGN_RESOURCE_BUILDING',
                                                                payload: { characterId: char.id, buildingId: building.id }
                                                            })}
                                                            style={{
                                                                background: 'rgba(244,67,54,0.2)',
                                                                border: '1px solid rgba(244,67,54,0.5)',
                                                                borderRadius: 4,
                                                                color: '#f44336',
                                                                padding: '4px 8px',
                                                                fontSize: 10,
                                                                cursor: 'pointer'
                                                            }}
                                                        >
                                                            å¬å›
                                                        </button>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ) : (
                                        <div style={{
                                            height: '100%',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            color: '#555',
                                            fontSize: 12,
                                            fontStyle: 'italic'
                                        }}>
                                            æ‹–æ‹½è§’è‰²åˆ°æ­¤å¤„å¼€å§‹é‡‡é›†
                                        </div>
                                    )}
                                </div>
                            </div>
                        );
                    })}
                </div>
            )}

            {/* åŠŸèƒ½å»ºç­‘åŒºåŸŸ */}
            {activeTab === 'functional' && (
                <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))',
                    gap: 16
                }}>
                    {Object.values(FUNCTIONAL_BUILDINGS).map(building => {
                        const currentCount = state.functionalBuildings?.[building.id] || 0;
                        const isMaxed = currentCount >= building.maxCount;

                        // âœ… è·å–åŠ¨æ€æˆæœ¬
                        const dynamicCost = getFunctionalBuildingCost(building.id, state);

                        // æ£€æŸ¥èµ„æºæ˜¯å¦è¶³å¤Ÿ
                        let canBuild = true;
                        Object.entries(dynamicCost).forEach(([res, amount]) => {
                            if ((state.resources[res] || 0) < amount) canBuild = false;
                        });

                        return (
                            <div key={building.id} style={{
                                padding: 20,
                                background: currentCount > 0
                                    ? 'linear-gradient(135deg, rgba(76,175,80,0.1), rgba(40,35,30,0.9))'
                                    : 'rgba(0,0,0,0.3)',
                                border: currentCount > 0 ? '2px solid #4CAF50' : '2px solid #4a3c2a',
                                borderRadius: 12
                            }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: 12, marginBottom: 12 }}>
                                    <div style={{
                                        width: 48,
                                        height: 48,
                                        background: 'rgba(0,0,0,0.4)',
                                        borderRadius: 8,
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        fontSize: 26
                                    }}>
                                        {building.icon}
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <div style={{ fontSize: 16, color: '#ffd700', fontWeight: 600 }}>
                                            {building.name}
                                        </div>
                                        <div style={{
                                            fontSize: 12,
                                            color: currentCount > 0 ? '#4CAF50' : '#888'
                                        }}>
                                            å·²å»ºé€ : {currentCount}/{building.maxCount}
                                        </div>
                                    </div>
                                </div>

                                <div style={{
                                    fontSize: 12,
                                    color: '#aaa',
                                    marginBottom: 12,
                                    padding: 10,
                                    background: 'rgba(0,0,0,0.2)',
                                    borderRadius: 6
                                }}>
                                    {building.description}
                                </div>

                                {/* âœ… æ˜¾ç¤ºåŠ¨æ€æˆæœ¬ */}
                                <div style={{
                                    fontSize: 11,
                                    color: '#888',
                                    marginBottom: 12,
                                    padding: 10,
                                    background: 'rgba(0,0,0,0.15)',
                                    borderRadius: 6
                                }}>
                                    <div style={{ marginBottom: 4, color: '#aaa' }}>
                                        å»ºé€ æˆæœ¬ {currentCount > 0 && (
                                        <span style={{ color: '#ff9800', fontSize: 10 }}>
                                                (+{((Math.pow(1.2, currentCount) - 1) * 100).toFixed(0)}%)
                                            </span>
                                    )}ï¼š
                                    </div>
                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8 }}>
                                        {Object.entries(dynamicCost).map(([res, amount]) => {
                                            const names = {
                                                gold: 'ğŸŸ¡ é‡‘å¸',
                                                wood: 'ğŸªµ æœ¨æ',
                                                ironOre: 'ğŸª™ é“çŸ¿',
                                                ironIngot: 'ğŸ”© é“é”­',
                                                herb: 'ğŸŒ¿ è‰è¯',
                                                leather: 'ğŸ¦Œ æ¯›çš®',
                                                magicEssence: 'ğŸ’ é­”æ³•ç²¾å',
                                                alchemyOil: 'âš—ï¸ ç‚¼é‡‘æ²¹'
                                            };
                                            const hasEnough = (state.resources[res] || 0) >= amount;
                                            return (
                                                <span key={res} style={{
                                                    color: hasEnough ? '#4CAF50' : '#f44336',
                                                    padding: '2px 6px',
                                                    background: hasEnough ? 'rgba(76,175,80,0.1)' : 'rgba(244,67,54,0.1)',
                                                    borderRadius: 4,
                                                    border: `1px solid ${hasEnough ? 'rgba(76,175,80,0.3)' : 'rgba(244,67,54,0.3)'}`
                                                }}>
                                                    {names[res] || res}: {amount.toLocaleString()}
                                                </span>
                                            );
                                        })}
                                    </div>
                                </div>

                                <Button
                                    onClick={() => dispatch({
                                        type: 'BUILD_FUNCTIONAL',
                                        payload: { buildingId: building.id }
                                    })}
                                    disabled={!canBuild || isMaxed}
                                    style={{ width: '100%' }}
                                >
                                    {isMaxed ? 'å·²è¾¾ä¸Šé™' : 'å»ºé€ '}
                                </Button>
                            </div>
                        );
                    })}
                </div>
            )}
        </div>
    );
};

// ==================== PAGE: RESEARCH ====================
const ResearchPage = ({ state, dispatch }) => {
    return (
        <Panel title="ç ”ç©¶">
            {state.currentResearch && (
                <div style={{
                    padding: 16,
                    background: 'rgba(201,162,39,0.1)',
                    border: '2px solid #c9a227',
                    borderRadius: 6,
                    marginBottom: 16
                }}>
                    <div style={{
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        marginBottom: 8
                    }}>
                        <span style={{ fontSize: 14, color: '#ffd700' }}>
                            æ­£åœ¨ç ”ç©¶: {RESEARCH[state.currentResearch].name}
                        </span>
                        <Button
                            onClick={() => dispatch({ type: 'CANCEL_RESEARCH' })}
                            variant="danger"
                            style={{ padding: '4px 12px', fontSize: 11 }}
                        >
                            å–æ¶ˆ
                        </Button>
                    </div>
                    <StatBar
                        label="è¿›åº¦"
                        current={state.researchProgress}
                        max={100}
                        color="#2196F3"
                    />
                </div>
            )}

            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: 12 }}>
                {Object.values(RESEARCH).map(research => {
                    const level = state.research[research.id] || 0;

                    // è§£é”æ¡ä»¶ï¼šå‡»è´¥æŒ‡å®šä¸–ç•Œé¦–é¢†
                    const unlocked = !research.unlockBoss || (state.defeatedBosses || []).includes(research.unlockBoss);

                    const cost = Math.floor(research.baseCost * Math.pow(1.2, level));
                    const canResearch = unlocked && !state.currentResearch && state.resources.gold >= cost;

                    return (
                        <div
                            key={research.id}
                            style={{
                                padding: 16,
                                background: 'rgba(0,0,0,0.3)',
                                border: '2px solid #4a3c2a',
                                borderRadius: 6,
                            }}
                        >
                            <h4 style={{ margin: '0 0 8px 0', fontSize: 14, color: '#ffd700' }}>
                                {research.name} (Lv.{level})
                            </h4>
                            <div style={{ fontSize: 11, color: '#aaa', marginBottom: 12 }}>
                                {research.description}
                            </div>
                            <div style={{ fontSize: 11, color: '#4CAF50', marginBottom: 12 }}>
                                æ•ˆæœ: +{(research.bonus * 100).toFixed(0)}% {research.effect}
                            </div>

                            {!unlocked && (
                                <div style={{ fontSize: 11, color: '#f44336', marginBottom: 12 }}>
                                    æœªè§£é”ï¼šéœ€è¦å‡»è´¥ {WORLD_BOSSES?.[research.unlockBoss]?.name || research.unlockBoss}
                                </div>
                            )}
                            <div style={{ fontSize: 11, color: '#888', marginBottom: 12 }}>
                                æˆæœ¬: ğŸª™{cost}
                            </div>
                            <Button
                                onClick={() => dispatch({ type: 'START_RESEARCH', payload: { researchId: research.id } })}
                                disabled={!canResearch}
                                style={{ width: '100%' }}
                            >
                                {unlocked ? 'ç ”ç©¶' : 'æœªè§£é”'}
                            </Button>
                        </div>
                    );
                })}
            </div>
        </Panel>
    );
};

// ==================== å®ä¼Ÿå®åº“ï¼ˆä¸–ç•Œé¦–é¢†é¡µå…¥å£ï¼‰ ====================
// è¯´æ˜ï¼š
// - 3 è¡Œ 3 åˆ—ï¼Œå…± 9 ä¸ªè£…å¤‡æ§½ä½
// - æ¯è¡Œæ¥è‡ªä¸€ç§å¾½ç« å¯å‡çº§è£…å¤‡æ± ï¼ˆé€šè¿‡ isXXXEquipment åˆ¤å®šï¼‰
// - æ¯ç§å¾½ç« éšæœº 3 ä»¶ï¼Œä½œä¸ºå®ä¼Ÿå®åº“å€™é€‰
// - é€‰æ‹© 1 ä»¶åç‚¹å‡»â€œé€‰æ‹©å¥–åŠ±â€è·å¾—ï¼ˆå¥–åŠ±è£…å¤‡ç­‰çº§å›ºå®šä¸º 5 çº§ï¼‰

const GRAND_VAULT_EQUIP_LEVEL = 5;

const GRAND_VAULT_RESET_HOUR = 9;

// ä»¥â€œæ—©ä¸Š 9 ç‚¹â€ä¸ºåˆ†ç•Œï¼Œå¾—åˆ°å½“å‰å®åº“çš„â€œæ—¥å‘¨æœŸâ€keyï¼ˆYYYY-MM-DDï¼‰
// - 08:59 å±äºâ€œæ˜¨å¤©â€çš„å®åº“å‘¨æœŸ
// - 09:00 èµ·å±äºâ€œä»Šå¤©â€çš„å®åº“å‘¨æœŸ
function getGrandVaultDayKey(now = new Date(), resetHour = GRAND_VAULT_RESET_HOUR) {
    const d = new Date(now);
    const h = d.getHours();
    if (h < resetHour) {
        d.setDate(d.getDate() - 1);
    }
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${y}-${m}-${day}`;
}

function getGrandVaultDayKeyByTs(ts = Date.now(), resetHour = GRAND_VAULT_RESET_HOUR) {
    return getGrandVaultDayKey(new Date(ts), resetHour);
}

// ä»ä¸–ç•Œé¦–é¢†å¥–åŠ±è¡¨ä¸­æ¨å¯¼ï¼šbossId -> badgeIdï¼ˆåªå– BADGE_UPGRADE_RULES ä¸­å­˜åœ¨çš„å¾½ç« ï¼‰
const GRAND_VAULT_BOSS_TO_BADGE = (() => {
    const map = {};
    Object.entries(BOSS_DATA || {}).forEach(([bossId, boss]) => {
        const items = boss?.rewards?.items || [];
        items.forEach(it => {
            const id = (typeof it === 'string') ? it : it?.id;
            if (!id) return;
            if (!BADGE_UPGRADE_RULES?.[id]) return;
            map[bossId] = id;
        });
    });
    return map;
})();

function getBossStrengthSnapshot(bossId) {
    const b = BOSS_DATA?.[bossId] || WORLD_BOSSES?.[bossId] || {};
    return {
        unlockLevel: Number(b.unlockLevel || 0),
        hp: Number(b.maxHp || b.hp || 0),
        attack: Number(b.attack || 0),
        defense: Number(b.defense || 0),
    };
}

function compareBossByStrengthDesc(aBossId, bBossId) {
    const a = getBossStrengthSnapshot(aBossId);
    const b = getBossStrengthSnapshot(bBossId);

    if (a.unlockLevel !== b.unlockLevel) return b.unlockLevel - a.unlockLevel;
    if (a.hp !== b.hp) return b.hp - a.hp;
    if (a.attack !== b.attack) return b.attack - a.attack;
    return b.defense - a.defense;
}

// å–â€œå·²å‡»æ€è¿‡â€çš„ä¸–ç•Œé¦–é¢†ï¼ˆä¼˜å…ˆç”¨è·¨ä¸–ç´¯è®¡ worldBossKillCountsï¼›å…¼å®¹æœ¬ä¸– defeatedBossesï¼‰
function getKilledWorldBossIdsForVault(state) {
    const killed = new Set();

    const counts = state?.worldBossKillCounts || {};
    if (counts && typeof counts === 'object' && !Array.isArray(counts)) {
        Object.entries(counts).forEach(([bossId, n]) => {
            if ((Number(n) || 0) > 0) killed.add(bossId);
        });
    }

    (state?.defeatedBosses || []).forEach(bossId => {
        if (bossId) killed.add(bossId);
    });

    return Array.from(killed);
}

// æ ¹æ®â€œæ˜¯å¦å‡»æ€è¿‡è¯¥BOSSâ€å†³å®šå®åº“å±•ç¤ºçš„ 3 ä¸ªå¾½ç« ï¼šå–æœ€å¼ºçš„ä¸‰ä¸ª
function pickTopGrandVaultRowDefs(state, maxRows = 3) {
    const killedBosses = getKilledWorldBossIdsForVault(state)
        .filter(bossId => !!GRAND_VAULT_BOSS_TO_BADGE?.[bossId]);

    // å…ˆæŠŠ boss -> badge -> è§„åˆ™æ•´ç†å‡ºæ¥ï¼Œå†æŒ‰â€œå¾½ç« å¼ºåº¦â€æ’åºï¼ˆcap è¶Šé«˜è¶Šå¼ºï¼‰
    const enriched = killedBosses.map(bossId => {
        const badgeId = GRAND_VAULT_BOSS_TO_BADGE[bossId];
        const rule = BADGE_UPGRADE_RULES?.[badgeId];
        const cap = Number(rule?.cap || 0);
        const inc = Number(rule?.inc || 0);
        return { bossId, badgeId, rule, cap, inc };
    }).filter(x => x?.badgeId && x?.rule && typeof x.rule.isEligible === 'function');

    enriched.sort((a, b) => {
        // âœ… å–æœ€å¼ºçš„å¾½ç« ï¼šå…ˆæ¯” capï¼ˆä¸Šé™ï¼‰ï¼Œå†æ¯” incï¼ˆå•æ¬¡æå‡ï¼‰
        if (a.cap !== b.cap) return b.cap - a.cap;
        if (a.inc !== b.inc) return b.inc - a.inc;

        // åŒæ¡£ä½å…œåº•ï¼šå†æŒ‰ Boss æœ¬ä½“å¼ºåº¦æ’åºï¼Œä¿è¯ç¨³å®š
        return compareBossByStrengthDesc(a.bossId, b.bossId);
    });

    const chosen = enriched.slice(0, Math.max(0, Number(maxRows) || 0));

    return chosen.map(({ bossId, badgeId, rule }) => ({
        badgeId,
        zoneLabel: rule?.zoneLabel || 'æœªçŸ¥åœ°åŒº',
        bossLabel: BOSS_DATA?.[bossId]?.name || WORLD_BOSSES?.[bossId]?.name || bossId,
        isEligible: rule?.isEligible,
    }));
}


function pickRandomUniqueIds(ids = [], count = 3) {
    const arr = Array.isArray(ids) ? [...ids] : [];
    // Fisherâ€“Yates shuffle
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr.slice(0, Math.min(count, arr.length));
}

// ç”Ÿæˆ/åŒæ­¥å½“æ—¥å®ä¼Ÿå®åº“å†…å®¹ï¼š
// - ä»¥â€œæ—©ä¸Š9ç‚¹â€ä¸ºæ—¥åˆ·æ–°åˆ†ç•Œï¼ˆdayKeyï¼‰
// - å®åº“å±•ç¤ºçš„ 3 ä¸ªå¾½ç« ï¼šæ ¹æ®æ˜¯å¦å‡»æ€è¿‡ BOSSï¼Œå–æœ€å¼ºçš„ä¸‰ä¸ª
// - åŒä¸€æ—¥å‘¨æœŸå†…ï¼Œæ¯ä¸ªå¾½ç« çš„ 3 ä¸ªå€™é€‰è£…å¤‡å›ºå®šï¼ˆå­˜äº grandVault.badgePicksï¼‰ï¼Œé¿å…åå¤æ‰“å¼€åˆ·å‡ºä¸åŒç»“æœ
function computeGrandVaultSnapshot(state, nowTs = Date.now()) {
    const dayKey = getGrandVaultDayKeyByTs(nowTs);

    const gv0 = (state?.grandVault && typeof state.grandVault === 'object' && !Array.isArray(state.grandVault))
        ? state.grandVault
        : {};

    let gv = { ...gv0 };

    // å…¼å®¹æ—§æ¡£/å¼‚å¸¸å­—æ®µ
    if (typeof gv.dayKey !== 'string') gv.dayKey = '';
    if (typeof gv.claimedDayKey !== 'string') gv.claimedDayKey = '';
    if (typeof gv.lastRefreshAt !== 'number') gv.lastRefreshAt = 0;
    if (typeof gv.claimedAt !== 'number') gv.claimedAt = 0;
    if (typeof gv.badgePicks !== 'object' || gv.badgePicks == null || Array.isArray(gv.badgePicks)) gv.badgePicks = {};

    let changed = false;

    // ===== æ¯æ—¥æ—©ä¸Š9ç‚¹åˆ·æ–°ï¼šè¿›å…¥æ–° dayKey åæ¸…ç©ºå½“æ—¥ç¼“å­˜ =====
    if (gv.dayKey !== dayKey) {
        gv.dayKey = dayKey;
        gv.badgePicks = {};
        gv.rows = null;
        gv.lastRefreshAt = nowTs;
        changed = true;
    }

    // å–æœ€å¼ºçš„ä¸‰ä¸ªå¾½ç« ï¼ˆéšå‡»æ€è§£é”è€Œå˜åŒ–ï¼‰
    const rowDefs = pickTopGrandVaultRowDefs(state, 3);

    const nextBadgePicks = { ...(gv.badgePicks || {}) };
    let picksChanged = false;

    const rows = rowDefs.map(def => {
        const pool = Object.values(FIXED_EQUIPMENTS || {})
            .filter(tpl => tpl?.type === 'equipment' && def.isEligible?.(tpl))
            .map(tpl => tpl.id)
            .filter(Boolean);

        // è¯»å–/æ ¡éªŒæ—§çš„ picks
        let picks = nextBadgePicks[def.badgeId];
        if (Array.isArray(picks)) {
            const used = new Set();
            picks = picks
                .filter(id => pool.includes(id))
                .filter(id => (used.has(id) ? false : (used.add(id), true)));
        } else {
            picks = [];
        }

        // ä¸è¶³ 3 ä¸ªåˆ™è¡¥é½ï¼ˆä»å‰©ä½™æ± éšæœºå–ï¼‰
        if (picks.length < 3) {
            const remain = pool.filter(id => !picks.includes(id));
            const fill = pickRandomUniqueIds(remain, 3 - picks.length);
            if (fill.length > 0) picksChanged = true;
            picks = [...picks, ...fill];
        }

        // å¦‚æœæ± å­ä¸è¶³ 3 ä¸ªï¼Œå°±æŒ‰æ± å­é•¿åº¦æˆªæ–­
        picks = picks.slice(0, Math.min(3, pool.length));

        const prev = nextBadgePicks[def.badgeId];
        const prevKey = Array.isArray(prev) ? prev.join('|') : '';
        const nowKey = picks.join('|');
        if (prevKey !== nowKey) picksChanged = true;

        nextBadgePicks[def.badgeId] = picks;

        return {
            ...def,
            equipTemplateIds: picks
        };
    });

    // rows å˜åŒ–ï¼ˆä¾‹å¦‚å‡»æ€äº†æ›´å¼º Bossï¼ŒTop3 å¾½ç« å˜åŒ–ï¼‰
    const prevRows = Array.isArray(gv.rows) ? gv.rows : null;
    const sameRows = (() => {
        if (!prevRows) return false;
        if (prevRows.length !== rows.length) return false;
        for (let i = 0; i < rows.length; i++) {
            const a = prevRows[i];
            const b = rows[i];
            if (a?.badgeId !== b?.badgeId) return false;
            const ae = Array.isArray(a?.equipTemplateIds) ? a.equipTemplateIds : [];
            const be = Array.isArray(b?.equipTemplateIds) ? b.equipTemplateIds : [];
            if (ae.length !== be.length) return false;
            for (let j = 0; j < ae.length; j++) {
                if (ae[j] !== be[j]) return false;
            }
        }
        return true;
    })();

    if (!sameRows) {
        gv.rows = rows;
        changed = true;
    }

    if (picksChanged) {
        gv.badgePicks = nextBadgePicks;
        changed = true;
    }

    return { dayKey, rows, grandVault: gv, changed };
}

// æ—§è°ƒç”¨ç‚¹å…¼å®¹ï¼šç›´æ¥è¿”å› rows
function buildGrandVaultRows(state) {
    return computeGrandVaultSnapshot(state).rows;
}

function getEquipmentPreviewAtLevel(templateId, level = GRAND_VAULT_EQUIP_LEVEL) {
    const tpl = getEquipmentTemplate(templateId);
    if (!tpl) return null;
    const lv = clamp(Number(level) || 0, 0, tpl.maxLevel ?? 100);
    return {
        ...tpl,
        qualityColor: getRarityColor(tpl.rarity),
        currentLevel: lv,
        stats: scaleStats(tpl.baseStats || {}, tpl.growth || {}, lv)
    };
}

function describeEquipmentSpecialEffect(eq) {
    const effects = getEquipmentSpecialEffectList(eq);
    if (!effects || effects.length === 0) return [];

    return effects.map(se => {
        if (!se) return '';

        if (se.type === 'skill_slot_buff') {
            const slots = (se.slots || []).map(s => (Number(s) + 1)).filter(n => Number.isFinite(n));
            const parts = [];
            if (se.attackBonus) parts.push(`æ”»+${formatItemStatValue('attack', se.attackBonus)}`);
            if (se.spellPowerBonus) parts.push(`æ³•+${formatItemStatValue('spellPower', se.spellPowerBonus)}`);
            return `âš¡ æŠ€èƒ½æ ¼ ${slots.join('/') || '?'}ï¼š${parts.join(' ') || 'å¼ºåŒ–'}`;
        }

        if (se.type === 'basic_attack_repeat') {
            return `âš”ï¸ æ™®æ”» ${(Number(se.chance || 0) * 100).toFixed(0)}% è¿å‡»`;
        }

        if (se.type === 'proc_stat' && se.trigger === 'turn_start') {
            const chance = (Number(se.chance || 0) * 100).toFixed(0);
            const bonusText = formatProcStatBonusText(se.stats || {});
            return `ğŸ² æ¯å›åˆ ${chance}%ï¼š${bonusText || 'è§¦å‘å¢ç›Š'}`;
        }

        if (se.type === 'map_slayer') {
            return `ğŸ—ºï¸ åœ°å›¾ä¼¤å®³ +${((Number(se.bonusDamageVsMap || 0)) * 100).toFixed(0)}%`;
        }

        return `âš¡ ç‰¹æ•ˆï¼š${se.type}`;
    }).filter(Boolean);
}

const GrandVaultModal = ({ rows, inventoryFull, onClose, onClaim }) => {
    const [selectedId, setSelectedId] = React.useState('');
    const [hover, setHover] = React.useState(null); // { id, x, y }

    const selectedPreview = selectedId ? getEquipmentPreviewAtLevel(selectedId, GRAND_VAULT_EQUIP_LEVEL) : null;

    if (!rows || rows.length === 0) return null;

    const tooltipPreview = hover?.id ? getEquipmentPreviewAtLevel(hover.id, GRAND_VAULT_EQUIP_LEVEL) : null;
    const tooltipEffects = tooltipPreview ? describeEquipmentSpecialEffect(tooltipPreview) : [];

    const tooltipX = (() => {
        const x = Number(hover?.x) || 0;
        const w = 300;
        const pad = 14;
        if (typeof window === 'undefined') return x + 16;
        return Math.max(pad, Math.min(x + 16, window.innerWidth - w - pad));
    })();
    const tooltipY = (() => {
        const y = Number(hover?.y) || 0;
        const h = 240;
        const pad = 14;
        if (typeof window === 'undefined') return y + 16;
        return Math.max(pad, Math.min(y + 16, window.innerHeight - h - pad));
    })();

    const canClaim = !!selectedId && !inventoryFull;

    return (
        <div
            style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: 'rgba(0,0,0,0.88)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 2400,
                padding: 18,
            }}
            onClick={onClose}
        >
            <div
                style={{
                    width: 980,
                    maxWidth: '96vw',
                    maxHeight: '92vh',
                    overflow: 'auto',
                    background: 'linear-gradient(135deg, rgba(35,28,22,0.98) 0%, rgba(18,14,11,0.98) 100%)',
                    border: '3px solid rgba(201,162,39,0.85)',
                    borderRadius: 14,
                    boxShadow: '0 12px 44px rgba(0,0,0,0.65), inset 0 1px 0 rgba(255,255,255,0.06)',
                    position: 'relative',
                    padding: 22,
                }}
                onClick={(e) => e.stopPropagation()}
            >
                {/* é¡¶éƒ¨æ ‡é¢˜ */}
                <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    position: 'relative',
                    paddingBottom: 12,
                    marginBottom: 14,
                    borderBottom: '1px solid rgba(201,162,39,0.20)'
                }}>
                    <div style={{
                        fontSize: 22,
                        fontWeight: 800,
                        color: '#ffd700',
                        textShadow: '2px 2px 6px rgba(0,0,0,0.8)',
                        letterSpacing: 1
                    }}>
                        ğŸ›ï¸ å®ä¼Ÿå®åº“
                    </div>

                    <button
                        onClick={onClose}
                        style={{
                            position: 'absolute',
                            right: 0,
                            top: 0,
                            width: 34,
                            height: 34,
                            borderRadius: 8,
                            border: '1px solid rgba(255,255,255,0.15)',
                            background: 'rgba(0,0,0,0.35)',
                            color: '#ffd700',
                            fontWeight: 900,
                            cursor: 'pointer'
                        }}
                        title="å…³é—­"
                    >
                        âœ•
                    </button>
                </div>

                <div style={{
                    textAlign: 'center',
                    color: '#c9a227',
                    fontSize: 13,
                    marginBottom: 18,
                    opacity: 0.95
                }}>
                    ä½ åªèƒ½ä»å®ä¼Ÿå®åº“ä¸­é€‰æ‹© <b style={{ color: '#ffd700' }}>ä¸€ä»¶</b> å¥–åŠ±ã€‚
                </div>

                {/* 3 è¡Œ 3 åˆ— */}
                <div style={{ display: 'flex', flexDirection: 'column', gap: 14 }}>
                    {rows.map((row) => {
                        const badge = ITEMS?.[row.badgeId];
                        return (
                            <div
                                key={row.badgeId}
                                style={{
                                    display: 'grid',
                                    gridTemplateColumns: '180px 1fr',
                                    gap: 14,
                                    alignItems: 'stretch',
                                    padding: 14,
                                    background: 'rgba(0,0,0,0.22)',
                                    border: '1px solid rgba(255,255,255,0.08)',
                                    borderRadius: 12,
                                }}
                            >
                                {/* å·¦ä¾§æ ‡ç­¾ */}
                                <div style={{
                                    display: 'flex',
                                    flexDirection: 'column',
                                    justifyContent: 'center',
                                    padding: 12,
                                    borderRadius: 10,
                                    background: 'linear-gradient(135deg, rgba(201,162,39,0.16) 0%, rgba(60,45,18,0.10) 100%)',
                                    border: '1px solid rgba(201,162,39,0.25)'
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                                        <div style={{
                                            width: 34,
                                            height: 34,
                                            borderRadius: 8,
                                            background: 'rgba(0,0,0,0.35)',
                                            border: '1px solid rgba(255,255,255,0.10)',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center'
                                        }}>
                                            <ItemIcon item={badge} size={28} />
                                        </div>
                                        <div style={{ lineHeight: 1.2 }}>
                                            <div style={{ fontSize: 16, fontWeight: 900, color: '#ffd700' }}>
                                                {row.zoneLabel}
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', marginTop: 2 }}>
                                                {badge?.name || row.badgeId}
                                            </div>
                                        </div>
                                    </div>

                                    <div style={{ marginTop: 10, fontSize: 11, color: '#aaa', lineHeight: 1.45 }}>
                                        æ¥æºï¼š<span style={{ color: '#e8dcc4' }}>{row.bossLabel}</span>
                                        <div style={{ color: '#888', marginTop: 4 }}>
                                            éšæœº 3 ä»¶å¯å‡çº§è£…å¤‡
                                        </div>
                                    </div>
                                </div>

                                {/* å³ä¾§ 3 ä¸ªè£…å¤‡æ§½ */}
                                <div
                                    style={{
                                        display: 'grid',
                                        gridTemplateColumns: 'repeat(3, 1fr)',
                                        gap: 12,
                                    }}
                                >
                                    {(row.equipTemplateIds || []).map((templateId) => {
                                        const preview = getEquipmentPreviewAtLevel(templateId, GRAND_VAULT_EQUIP_LEVEL);
                                        if (!preview) return null;
                                        const picked = selectedId === templateId;

                                        return (
                                            <div
                                                key={templateId}
                                                onClick={() => setSelectedId(templateId)}
                                                onMouseEnter={(e) => setHover({ id: templateId, x: e.clientX, y: e.clientY })}
                                                onMouseMove={(e) => {
                                                    setHover((h) => (h && h.id === templateId)
                                                        ? { ...h, x: e.clientX, y: e.clientY }
                                                        : h
                                                    );
                                                }}
                                                onMouseLeave={() => setHover(null)}
                                                style={{
                                                    userSelect: 'none',
                                                    cursor: 'pointer',
                                                    padding: 14,
                                                    borderRadius: 12,
                                                    background: picked
                                                        ? 'linear-gradient(135deg, rgba(201,162,39,0.18) 0%, rgba(90,70,18,0.12) 100%)'
                                                        : 'rgba(0,0,0,0.25)',
                                                    border: picked
                                                        ? '2px solid #ffd700'
                                                        : `2px solid ${preview.qualityColor}55`,
                                                    boxShadow: picked
                                                        ? '0 0 16px rgba(255,215,0,0.20)'
                                                        : 'none',
                                                    position: 'relative',
                                                    minHeight: 92,
                                                    transition: 'all 0.12s',
                                                    opacity: inventoryFull ? 0.95 : 1
                                                }}
                                                title="ç‚¹å‡»é€‰æ‹©ï¼ˆæ‚¬åœæŸ¥çœ‹å±æ€§ï¼‰"
                                            >
                                                {picked && (
                                                    <div style={{
                                                        position: 'absolute',
                                                        top: 10,
                                                        right: 10,
                                                        fontSize: 12,
                                                        fontWeight: 900,
                                                        color: '#0b0b0b',
                                                        background: 'linear-gradient(180deg, #ffd700, #c9a227)',
                                                        borderRadius: 999,
                                                        padding: '4px 10px',
                                                        border: '1px solid rgba(0,0,0,0.25)',
                                                        boxShadow: '0 2px 10px rgba(0,0,0,0.35)'
                                                    }}>
                                                        âœ“ å·²é€‰
                                                    </div>
                                                )}

                                                <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                                                    <div style={{
                                                        width: 46,
                                                        height: 46,
                                                        borderRadius: 10,
                                                        background: 'rgba(0,0,0,0.35)',
                                                        border: '1px solid rgba(255,255,255,0.10)',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexShrink: 0
                                                    }}>
                                                        <ItemIcon item={preview} size={38} />
                                                    </div>

                                                    <div style={{ minWidth: 0 }}>
                                                        <div style={{
                                                            fontSize: 13,
                                                            fontWeight: 800,
                                                            color: preview.qualityColor,
                                                            whiteSpace: 'nowrap',
                                                            overflow: 'hidden',
                                                            textOverflow: 'ellipsis'
                                                        }}>
                                                            {preview.name}
                                                        </div>
                                                        <div style={{ fontSize: 11, color: '#aaa', marginTop: 4 }}>
                                                            {EQUIPMENT_SLOTS?.[preview.slot]?.name || preview.slot} Â· Lv.{GRAND_VAULT_EQUIP_LEVEL}
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        );
                    })}
                </div>

                {/* åº•éƒ¨ï¼šé€‰æ‹©å¥–åŠ± */}
                <div style={{
                    marginTop: 18,
                    paddingTop: 16,
                    borderTop: '1px solid rgba(201,162,39,0.18)',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    gap: 10
                }}>
                    {selectedPreview ? (
                        <div style={{
                            fontSize: 12,
                            color: '#aaa',
                            textAlign: 'center'
                        }}>
                            å·²é€‰æ‹©ï¼š<span style={{ color: selectedPreview.qualityColor, fontWeight: 800 }}>{selectedPreview.name}</span>
                            <span style={{ color: '#888' }}>ï¼ˆLv.{GRAND_VAULT_EQUIP_LEVEL}ï¼‰</span>
                        </div>
                    ) : (
                        <div style={{ fontSize: 12, color: '#888', textAlign: 'center' }}>
                            è¯·é€‰æ‹©ä¸€ä»¶è£…å¤‡ä½œä¸ºå¥–åŠ±ã€‚
                        </div>
                    )}

                    {inventoryFull && (
                        <div style={{
                            fontSize: 12,
                            color: '#ff6b6b',
                            textAlign: 'center'
                        }}>
                            âš ï¸ èƒŒåŒ…å·²æ»¡ï¼Œæ— æ³•é¢†å–å¥–åŠ±ã€‚
                        </div>
                    )}

                    <Button
                        onClick={() => {
                            if (!canClaim) return;
                            onClaim?.(selectedId);
                        }}
                        disabled={!canClaim}
                        style={{
                            padding: '12px 40px',
                            fontSize: 14,
                            borderRadius: 8
                        }}
                    >
                        é€‰æ‹©å¥–åŠ±
                    </Button>
                </div>

                {/* æ‚¬åœå±æ€§ Tooltip */}
                {tooltipPreview && (
                    <div
                        style={{
                            position: 'fixed',
                            left: tooltipX,
                            top: tooltipY,
                            width: 300,
                            padding: 12,
                            background: 'rgba(10,10,10,0.92)',
                            border: `2px solid ${tooltipPreview.qualityColor}`,
                            borderRadius: 10,
                            boxShadow: '0 10px 30px rgba(0,0,0,0.6)',
                            zIndex: 2600,
                            pointerEvents: 'none'
                        }}
                    >
                        <div style={{
                            fontWeight: 900,
                            color: tooltipPreview.qualityColor,
                            fontSize: 14,
                            marginBottom: 4
                        }}>
                            {tooltipPreview.name}
                        </div>
                        <div style={{ fontSize: 11, color: '#bbb', marginBottom: 10 }}>
                            {EQUIPMENT_SLOTS?.[tooltipPreview.slot]?.name || tooltipPreview.slot} Â· Lv.{GRAND_VAULT_EQUIP_LEVEL}
                        </div>

                        <div style={{
                            borderTop: '1px solid rgba(255,255,255,0.10)',
                            paddingTop: 8,
                            display: 'flex',
                            flexDirection: 'column',
                            gap: 4
                        }}>
                            {Object.entries(tooltipPreview.stats || {}).length === 0 ? (
                                <div style={{ fontSize: 11, color: '#888' }}>ï¼ˆæ— å±æ€§ï¼‰</div>
                            ) : (
                                Object.entries(tooltipPreview.stats || {}).map(([stat, value]) => (
                                    <div key={stat} style={{ display: 'flex', justifyContent: 'space-between', fontSize: 11 }}>
                                        <span style={{ color: '#aaa' }}>{STAT_LABELS?.[stat] || stat}</span>
                                        <span style={{ color: '#4CAF50', fontWeight: 800 }}>+{formatItemStatValue(stat, value)}</span>
                                    </div>
                                ))
                            )}
                        </div>

                        {tooltipEffects.length > 0 && (
                            <div style={{
                                marginTop: 10,
                                paddingTop: 8,
                                borderTop: '1px solid rgba(255,255,255,0.10)',
                                display: 'flex',
                                flexDirection: 'column',
                                gap: 4
                            }}>
                                {tooltipEffects.map((line, idx) => (
                                    <div key={idx} style={{ fontSize: 11, color: '#ffb74d', lineHeight: 1.35 }}>
                                        {line}
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
};

// ==================== WorldBossPage ä¿®æ”¹ ====================
const WorldBossPage = ({ state, dispatch }) => {
    const [showVault, setShowVault] = useState(false);
    const [vaultRows, setVaultRows] = useState(null);

    const openVault = () => {
        const nowTs = Date.now();
        const snap = computeGrandVaultSnapshot(state, nowTs);
        const dayKey = snap.dayKey;
        const gv = snap.grandVault || {};

        // âœ… å½“æ—¥å·²é¢†å–ï¼šç‚¹å‡»æç¤º
        if (gv.claimedDayKey === dayKey) {
            alert('å®ä¼Ÿå®åº“ï¼šå½“æ—¥å·²ç»é¢†å–ã€‚');
            return;
        }

        const rows = Array.isArray(snap.rows) ? snap.rows : [];
        if (!rows || rows.length === 0) {
            alert('å®ä¼Ÿå®åº“ï¼šä½ å°šæœªå‡»æ€è¿‡å¯è®¡å…¥å®åº“çš„ä¸–ç•Œé¦–é¢†ï¼Œæš‚æ— å¯ç”¨å¥–åŠ±ã€‚');
            return;
        }

        // âœ… åŒæ­¥åˆ°å­˜æ¡£ï¼šä¿è¯åŒä¸€æ—¥å‘¨æœŸå†…ä¸ä¼šåå¤æ‰“å¼€åˆ·æ–°å‡ºä¸åŒç»“æœ
        if (snap.changed) {
            dispatch({ type: 'SET_GRAND_VAULT', payload: { grandVault: gv } });
        }

        setVaultRows(rows);
        setShowVault(true);
    };

    const VaultButton = ({ onClick }) => (
        <button
            onClick={onClick}
            style={{
                padding: '8px 14px',
                borderRadius: 8,
                border: '2px solid rgba(201,162,39,0.9)',
                background: 'linear-gradient(180deg, rgba(201,162,39,0.25), rgba(139,115,25,0.18))',
                color: '#ffd700',
                fontWeight: 900,
                fontSize: 12,
                cursor: 'pointer',
                boxShadow: '0 2px 10px rgba(0,0,0,0.35)',
                textShadow: '1px 1px 2px rgba(0,0,0,0.7)',
                letterSpacing: 0.5
            }}
            title="æ‰“å¼€å®ä¼Ÿå®åº“"
        >
            ğŸ›ï¸ å®ä¼Ÿå®åº“
        </button>
    );

    return (
        <Panel
            title="ä¸–ç•Œé¦–é¢†"
            actions={
                <>
                    <VaultButton onClick={openVault} />
                </>
            }
        >
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: 16 }}>
                {Object.values(WORLD_BOSSES).map(boss => {
                    const bossData = BOSS_DATA[boss.id] || boss;
                    const unlocked = !boss.unlockLevel || state.characters.some(c => c.level >= (boss.unlockLevel || 0));
                    const cdSeconds = state.bossCooldowns?.[boss.id] || 0;
                    const cdText = cdSeconds > 0 ? `${String(Math.floor(cdSeconds / 60)).padStart(2, '0')}:${String(cdSeconds % 60).padStart(2, '0')}` : '';

                    // ===== è‡ªåŠ¨å‡»æ€ï¼ˆè·¨ä¸–ç´¯è®¡10æ¬¡è§£é”ï¼‰ =====
                    const totalKills = state.worldBossKillCounts?.[boss.id] || 0;
                    const autoEnabled = !!state.worldBossAutoKill?.[boss.id];
                    const autoUnlocked = totalKills >= 10;

                    // æ™®ç‘æ–¯æ‰˜å¥³å£«ç‰¹æ®Šè§£é”æ¡ä»¶
                    if (boss.id === 'prestor_lady' && !state.worldBossProgress?.prestor_lady) {
                        return null;
                    }

                    return (
                        <div key={boss.id} style={{
                            padding: 20,
                            background: unlocked
                                ? 'linear-gradient(135deg, rgba(180,50,50,0.2) 0%, rgba(80,20,20,0.3) 100%)'
                                : 'rgba(0,0,0,0.3)',
                            border: `2px solid ${unlocked ? '#a03030' : '#333'}`,
                            borderRadius: 12,
                            opacity: unlocked ? 1 : 0.5,
                            boxShadow: unlocked ? '0 4px 20px rgba(160,48,48,0.3)' : 'none'
                        }}>
                            {/* BOSSå›¾ç‰‡åŒºåŸŸ */}
                            <div style={{
                                width: '100%',
                                height: 180,
                                background: 'linear-gradient(135deg, rgba(60,20,20,0.5) 0%, rgba(30,10,10,0.6) 100%)',
                                border: '2px solid rgba(180,50,50,0.4)',
                                borderRadius: 10,
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                marginBottom: 16,
                                overflow: 'hidden',
                                position: 'relative',
                                boxShadow: 'inset 0 0 30px rgba(0,0,0,0.5)'
                            }}>
                                {boss.icon ? (
                                    <img
                                        src={boss.icon}
                                        alt={boss.name}
                                        style={{
                                            width: '100%',
                                            height: '100%',
                                            objectFit: 'cover',
                                            filter: unlocked ? 'none' : 'grayscale(100%)'
                                        }}
                                    />
                                ) : (
                                    <div style={{
                                        fontSize: 64,
                                        opacity: 0.6,
                                        filter: unlocked
                                            ? 'drop-shadow(0 0 15px rgba(255,100,100,0.5))'
                                            : 'grayscale(100%)'
                                    }}>
                                        {unlocked ? 'ğŸ²' : 'ğŸ”’'}
                                    </div>
                                )}

                                {/* é”å®šé®ç½© */}
                                {!unlocked && (
                                    <div style={{
                                        position: 'absolute',
                                        top: 0,
                                        left: 0,
                                        right: 0,
                                        bottom: 0,
                                        background: 'rgba(0,0,0,0.6)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center'
                                    }}>
                                        <span style={{ fontSize: 48 }}>ğŸ”’</span>
                                    </div>
                                )}

                                {/* åº•éƒ¨æ¸å˜ */}
                                <div style={{
                                    position: 'absolute',
                                    bottom: 0,
                                    left: 0,
                                    right: 0,
                                    height: '40%',
                                    background: 'linear-gradient(0deg, rgba(0,0,0,0.8) 0%, transparent 100%)',
                                    pointerEvents: 'none'
                                }} />
                            </div>

                            {/* BOSSåç§° */}
                            <h3 style={{
                                textAlign: 'center',
                                color: unlocked ? '#ff6b6b' : '#666',
                                margin: '0 0 12px 0',
                                fontSize: 20,
                                textShadow: unlocked ? '0 0 10px rgba(255,107,107,0.5)' : 'none'
                            }}>
                                {boss.name}
                            </h3>

                            {/* BOSSå±æ€§é¢„è§ˆ */}
                            {unlocked && (
                                <div style={{
                                    display: 'grid',
                                    gridTemplateColumns: 'repeat(3, 1fr)',
                                    gap: 8,
                                    marginBottom: 16,
                                    padding: 10,
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: 6
                                }}>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>ç”Ÿå‘½</div>
                                        <div style={{ fontSize: 12, color: '#f44336', fontWeight: 600 }}>
                                            {(bossData.maxHp || boss.hp)?.toLocaleString()}
                                        </div>
                                    </div>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>æ”»å‡»</div>
                                        <div style={{ fontSize: 12, color: '#ff9800', fontWeight: 600 }}>
                                            {bossData.attack || boss.attack}
                                        </div>
                                    </div>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>é˜²å¾¡</div>
                                        <div style={{ fontSize: 12, color: '#4CAF50', fontWeight: 600 }}>
                                            {bossData.defense || boss.defense}
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* æŒ‘æˆ˜æŒ‰é’® / è§£é”æ¡ä»¶ */}
                            {unlocked ? (
                                <div>
                                    {/* è‡ªåŠ¨å‡»æ€å¼€å…³ */}
                                    <div style={{
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'space-between',
                                        gap: 10,
                                        padding: '8px 10px',
                                        marginBottom: 10,
                                        background: 'rgba(0,0,0,0.22)',
                                        border: '1px solid rgba(255,255,255,0.08)',
                                        borderRadius: 6
                                    }}>
                                        <div style={{ lineHeight: 1.2 }}>
                                            <div style={{ fontSize: 12, color: '#ffd700', fontWeight: 700 }}>
                                                ğŸ¤– è‡ªåŠ¨å‡»æ€
                                            </div>
                                            <div style={{ fontSize: 10, color: '#aaa' }}>
                                                {autoUnlocked
                                                    ? 'CDç»“æŸåè‡ªåŠ¨å‡»æ€å¹¶æ‰è½'
                                                    : `è§£é”ï¼šç´¯è®¡å‡»æ€ ${totalKills}/10`}
                                            </div>
                                        </div>
                                        <button
                                            onClick={() => dispatch({ type: 'TOGGLE_WORLD_BOSS_AUTOKILL', payload: { bossId: boss.id } })}
                                            disabled={!autoUnlocked}
                                            style={{
                                                border: '1px solid rgba(255,255,255,0.12)',
                                                background: autoEnabled ? 'rgba(76,175,80,0.18)' : 'rgba(255,255,255,0.06)',
                                                color: autoUnlocked ? (autoEnabled ? '#7CFF7C' : '#ddd') : '#666',
                                                padding: '6px 10px',
                                                borderRadius: 999,
                                                fontSize: 11,
                                                fontWeight: 800,
                                                cursor: autoUnlocked ? 'pointer' : 'not-allowed',
                                                opacity: autoUnlocked ? 1 : 0.7
                                            }}
                                        >
                                            {autoEnabled ? 'å¼€å¯' : 'å…³é—­'}
                                        </button>
                                    </div>

                                    {cdSeconds > 0 && (
                                        <div style={{
                                            textAlign: 'center',
                                            marginBottom: 10,
                                            padding: '8px 10px',
                                            background: 'rgba(0,0,0,0.25)',
                                            border: '1px solid rgba(255,255,255,0.08)',
                                            borderRadius: 6,
                                            color: '#ffd700',
                                            fontSize: 12
                                        }}>
                                            â³ é‡ç”Ÿå†·å´ä¸­ï¼š<b>{cdText}</b>
                                        </div>
                                    )}
                                    <Button
                                        variant="danger"
                                        style={{
                                            width: '100%',
                                            padding: '10px 16px',
                                            fontSize: 14,
                                            fontWeight: 600,
                                            opacity: cdSeconds > 0 ? 0.6 : 1
                                        }}
                                        disabled={cdSeconds > 0}
                                        onClick={() => dispatch({ type: 'OPEN_BOSS_PREPARE', payload: boss.id })}
                                    >
                                        {cdSeconds > 0 ? `â³ é‡ç”Ÿä¸­ (${cdText})` : 'âš”ï¸ æŒ‘æˆ˜'}
                                    </Button>
                                </div>
                            ) : (
                                <div style={{
                                    textAlign: 'center',
                                    color: '#666',
                                    padding: '10px',
                                    background: 'rgba(0,0,0,0.2)',
                                    borderRadius: 6,
                                    fontSize: 12
                                }}>
                                    ğŸ”’ éœ€è¦ç­‰çº§ {boss.unlockLevel || 0}
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>

            {showVault && (
                <GrandVaultModal
                    rows={vaultRows}
                    inventoryFull={(state.inventory?.length || 0) >= (state.inventorySize || 0)}
                    onClose={() => setShowVault(false)}
                    onClaim={(templateId) => {
                        if (!templateId) return;
                        dispatch({ type: 'CLAIM_GRAND_VAULT_REWARD', payload: { templateId } });
                        setShowVault(false);
                    }}
                />
            )}
        </Panel>
    );
};

// ==================== PAGE: ACHIEVEMENT ====================
const AchievementPage = ({ state }) => {
    return (
        <Panel title="æˆå°±">
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: 12 }}>
                {Object.values(ACHIEVEMENTS).map(achievement => {
                    const unlocked = state.achievements[achievement.id];
                    const bonusText = formatBonusText(achievement.reward);

                    return (
                        <div
                            key={achievement.id}
                            style={{
                                padding: 16,
                                background: unlocked ? 'rgba(201,162,39,0.2)' : 'rgba(0,0,0,0.3)',
                                border: `2px solid ${unlocked ? '#c9a227' : '#4a3c2a'}`,
                                borderRadius: 6,
                                opacity: unlocked ? 1 : 0.6
                            }}
                        >
                            <div style={{ fontSize: 32, textAlign: 'center', marginBottom: 8 }}>
                                {achievement.icon}
                            </div>

                            <h4 style={{
                                margin: '0 0 8px 0',
                                fontSize: 14,
                                color: unlocked ? '#ffd700' : '#888',
                                textAlign: 'center'
                            }}>
                                {achievement.name}
                            </h4>

                            <div style={{
                                fontSize: 11,
                                color: '#aaa',
                                textAlign: 'center',
                                marginBottom: 8
                            }}>
                                {achievement.description}
                            </div>

                            {/* âœ… BONUS å±•ç¤ºï¼ˆå·²è§£é”æ˜¾ç¤ºâ€œå·²è·å¾—â€ï¼Œæœªè§£é”æ˜¾ç¤ºâ€œå¥–åŠ±é¢„è§ˆâ€ä¹Ÿè¡Œï¼‰ */}
                            {!!bonusText && (
                                <div style={{
                                    fontSize: 11,
                                    color: unlocked ? '#4CAF50' : '#9aa0a6',
                                    textAlign: 'center',
                                    padding: '6px 8px',
                                    background: unlocked ? 'rgba(76,175,80,0.10)' : 'rgba(255,255,255,0.04)',
                                    borderRadius: 6,
                                    border: unlocked ? '1px solid rgba(76,175,80,0.25)' : '1px solid rgba(255,255,255,0.08)',
                                    marginBottom: 8
                                }}>
                                    {unlocked ? `å¥–åŠ±ï¼š${bonusText}` : `å¥–åŠ±ï¼š${bonusText}`}
                                </div>
                            )}

                            {unlocked && (
                                <div style={{
                                    fontSize: 10,
                                    color: '#4CAF50',
                                    textAlign: 'center',
                                    padding: '4px 8px',
                                    background: 'rgba(76,175,80,0.1)',
                                    borderRadius: 4
                                }}>
                                    âœ“ å·²è§£é”
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        </Panel>
    );
};


// ==================== PAGE: CODEX ====================
const CodexPage = ({ state, dispatch }) => {
    const [tab, setTab] = React.useState('equipment'); // 'equipment' | 'junk' | 'effects'

    const allowDrop = (id) => state.dropFilters?.[id] !== false;

    // ===== è£…å¤‡å›¾é‰´ =====
    const allEquipTemplates = [
        ...Object.values(FIXED_EQUIPMENTS),
        ...Object.values(QUEST_REWARD_EQUIPMENTS),
    ];
    const equipCodexSet = new Set(state.codex || []);
    const lv100CodexSet = new Set(state.codexEquipLv100 || []);

    const hasLevel100 = (equipmentId) => {
        return lv100CodexSet.has(equipmentId);
    };

    // ===== åƒåœ¾å›¾é‰´ =====
    const allJunkTemplates = Object.values(ITEMS).filter(it => it?.type === 'junk');
    const junkCodexSet = new Set(state.codexJunk || []);

    const TabButton = ({ id, children }) => (
        <button
            onClick={() => setTab(id)}
            style={{
                padding: '8px 14px',
                borderRadius: 6,
                cursor: 'pointer',
                fontFamily: 'inherit',
                fontSize: 12,
                fontWeight: 700,
                border: tab === id ? '2px solid #c9a227' : '2px solid #4a3c2a',
                color: tab === id ? '#ffd700' : '#888',
                background: tab === id
                    ? 'linear-gradient(180deg, rgba(201,162,39,0.25), rgba(139,115,25,0.18))'
                    : 'rgba(0,0,0,0.25)',
                boxShadow: tab === id ? '0 0 12px rgba(255,215,0,0.15)' : 'none',
                transition: 'all 0.15s',
            }}
        >
            {children}
        </button>
    );

    const toggleDrop = (itemId) => {
        dispatch({
            type: 'TOGGLE_DROP_FILTER',
            payload: { itemId }
        });
    };

    const DropTag = ({ enabled }) => (
        <div style={{
            marginTop: 8,
            fontSize: 9,
            fontWeight: 800,
            display: 'inline-block',
            padding: '2px 6px',
            borderRadius: 999,
            border: enabled ? '1px solid rgba(120,220,120,0.5)' : '1px solid rgba(255,80,80,0.55)',
            color: enabled ? 'rgba(120,220,120,0.9)' : 'rgba(255,80,80,0.9)',
            background: enabled ? 'rgba(120,220,120,0.08)' : 'rgba(255,80,80,0.08)',
        }}>
            {enabled ? 'æ‰è½ï¼šå¼€å¯' : 'æ‰è½ï¼šå…³é—­'}
        </div>
    );

    const CardShell = ({ children, onClick, disabledDrop }) => (
        <div
            onClick={onClick}
            style={{
                cursor: 'pointer',
                userSelect: 'none',
                position: 'relative',
                padding: 12,
                borderRadius: 8,
                textAlign: 'center',
                transition: 'all 0.15s',
                outline: 'none',
                opacity: disabledDrop ? 0.55 : 1,
                filter: disabledDrop ? 'grayscale(35%)' : 'none'
            }}
        >
            {children}
            {disabledDrop && (
                <div style={{
                    position: 'absolute',
                    top: 6,
                    right: 6,
                    fontSize: 10,
                    fontWeight: 900,
                    color: 'rgba(255,80,80,0.95)',
                    background: 'rgba(0,0,0,0.45)',
                    padding: '2px 6px',
                    borderRadius: 999,
                    border: '1px solid rgba(255,80,80,0.5)'
                }}>
                    ğŸš«
                </div>
            )}
        </div>
    );

    // ===== å›¾é‰´é›†é½æ•ˆæœæ¸²æŸ“ =====
    const renderEffectsTab = () => {
        return (
            <div>
                <div style={{ fontSize: 12, color: '#888', marginBottom: 16 }}>
                    é›†é½æŒ‡å®šåŒºåŸŸçš„æ‰€æœ‰è£…å¤‡ Lv.100 å›¾é‰´åï¼Œå…¨é˜Ÿæ°¸ä¹…è·å¾—å¯¹åº”åŠ æˆ
                </div>

                <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
                    {CODEX_SET_EFFECTS.map(effect => {
                        const collected = effect.equipIds.filter(id => lv100CodexSet.has(id)).length;
                        const total = effect.equipIds.length;
                        const isComplete = collected === total;
                        const progress = collected / total;

                        return (
                            <div
                                key={effect.id}
                                style={{
                                    padding: 16,
                                    background: isComplete
                                        ? `linear-gradient(135deg, ${effect.color}22, ${effect.color}11)`
                                        : 'rgba(0,0,0,0.3)',
                                    border: isComplete
                                        ? `2px solid ${effect.color}`
                                        : '1px solid #4a3c2a',
                                    borderRadius: 10,
                                    boxShadow: isComplete ? `0 0 20px ${effect.color}33` : 'none',
                                    transition: 'all 0.3s'
                                }}
                            >
                                <div style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    marginBottom: 10
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                                        <span style={{
                                            fontSize: 20,
                                            filter: isComplete ? 'none' : 'grayscale(100%)',
                                            opacity: isComplete ? 1 : 0.5
                                        }}>
                                            {isComplete ? 'âœ…' : 'ğŸ”’'}
                                        </span>
                                        <span style={{
                                            fontSize: 16,
                                            fontWeight: 700,
                                            color: isComplete ? effect.color : '#888'
                                        }}>
                                            {effect.name}
                                        </span>
                                    </div>

                                    <span style={{
                                        fontSize: 13,
                                        fontWeight: 600,
                                        color: isComplete ? '#4CAF50' : '#888',
                                        padding: '4px 10px',
                                        background: isComplete ? 'rgba(76,175,80,0.15)' : 'rgba(0,0,0,0.2)',
                                        borderRadius: 6,
                                        border: isComplete ? '1px solid rgba(76,175,80,0.3)' : '1px solid #333'
                                    }}>
                                        {collected}/{total}
                                    </span>
                                </div>

                                {/* è¿›åº¦æ¡ */}
                                <div style={{
                                    height: 6,
                                    background: 'rgba(0,0,0,0.4)',
                                    borderRadius: 3,
                                    overflow: 'hidden',
                                    marginBottom: 10
                                }}>
                                    <div style={{
                                        height: '100%',
                                        width: `${progress * 100}%`,
                                        background: isComplete
                                            ? `linear-gradient(90deg, ${effect.color}, ${effect.color}cc)`
                                            : 'linear-gradient(90deg, #666, #888)',
                                        borderRadius: 3,
                                        transition: 'width 0.3s'
                                    }} />
                                </div>

                                {/* æ•ˆæœæè¿° */}
                                <div style={{
                                    fontSize: 13,
                                    color: isComplete ? '#fff' : '#666',
                                    padding: '8px 12px',
                                    background: isComplete ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.15)',
                                    borderRadius: 6,
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: 8
                                }}>
                                    <span style={{ color: effect.color, fontWeight: 700 }}>æ•ˆæœï¼š</span>
                                    <span style={{
                                        color: isComplete ? '#ffd700' : '#666',
                                        fontWeight: isComplete ? 600 : 400
                                    }}>
                                        {effect.effect}
                                    </span>
                                    {isComplete && (
                                        <span style={{
                                            marginLeft: 'auto',
                                            fontSize: 11,
                                            color: '#4CAF50',
                                            fontWeight: 700
                                        }}>
                                            ç”Ÿæ•ˆä¸­
                                        </span>
                                    )}
                                </div>

                                {/* è£…å¤‡åˆ—è¡¨ï¼ˆæŠ˜å æ˜¾ç¤ºï¼‰ */}
                                <details style={{ marginTop: 10 }}>
                                    <summary style={{
                                        cursor: 'pointer',
                                        fontSize: 11,
                                        color: '#888',
                                        outline: 'none'
                                    }}>
                                        æŸ¥çœ‹è£…å¤‡åˆ—è¡¨
                                    </summary>
                                    <div style={{
                                        marginTop: 8,
                                        display: 'flex',
                                        flexWrap: 'wrap',
                                        gap: 6
                                    }}>
                                        {effect.equipIds.map(id => {
                                            const tpl = FIXED_EQUIPMENTS[id];
                                            const has100 = lv100CodexSet.has(id);
                                            return (
                                                <span
                                                    key={id}
                                                    style={{
                                                        fontSize: 10,
                                                        padding: '3px 8px',
                                                        borderRadius: 4,
                                                        background: has100 ? 'rgba(76,175,80,0.2)' : 'rgba(0,0,0,0.3)',
                                                        border: has100 ? '1px solid rgba(76,175,80,0.5)' : '1px solid #333',
                                                        color: has100 ? '#4CAF50' : '#666'
                                                    }}
                                                >
                                                    {has100 ? 'âœ“' : 'â—‹'} {tpl?.name || id}
                                                </span>
                                            );
                                        })}
                                    </div>
                                </details>
                            </div>
                        );
                    })}
                </div>

                {/* ç»Ÿè®¡æ€»è§ˆ */}
                <div style={{
                    marginTop: 20,
                    padding: 16,
                    background: 'rgba(201,162,39,0.1)',
                    border: '1px solid rgba(201,162,39,0.3)',
                    borderRadius: 10
                }}>
                    <div style={{ fontSize: 14, color: '#c9a227', fontWeight: 700, marginBottom: 10 }}>
                        ğŸ“Š é›†é½è¿›åº¦æ€»è§ˆ
                    </div>
                    <div style={{ display: 'flex', gap: 16, flexWrap: 'wrap' }}>
                        {CODEX_SET_EFFECTS.map(effect => {
                            const collected = effect.equipIds.filter(id => lv100CodexSet.has(id)).length;
                            const total = effect.equipIds.length;
                            const isComplete = collected === total;
                            return (
                                <div key={effect.id} style={{
                                    fontSize: 12,
                                    color: isComplete ? effect.color : '#666'
                                }}>
                                    {isComplete ? 'âœ…' : 'â¬œ'} {effect.name}
                                </div>
                            );
                        })}
                    </div>
                </div>
            </div>
        );
    };

    return (
        <Panel
            title="å›¾é‰´"
            actions={
                <div style={{ display: 'flex', gap: 8 }}>
                    <TabButton id="effects">âš¡ é›†é½æ•ˆæœ</TabButton>
                    <TabButton id="equipment">ğŸ›¡ï¸ è£…å¤‡</TabButton>
                    <TabButton id="junk">ğŸ§º åƒåœ¾</TabButton>
                </div>
            }
        >
            {/* ===== é›†é½æ•ˆæœ ===== */}
            {tab === 'effects' && renderEffectsTab()}

            {/* ===== è£…å¤‡å›¾é‰´ ===== */}
            {tab === 'equipment' && (
                <>
                    <div style={{ fontSize: 12, color: '#888', marginBottom: 12 }}>
                        âœ… ç‚¹äº®ï¼šå·²è·å¾—è¿‡ã€€|ã€€âœ¨ é‡‘è¾¹ï¼šå·²è¾¾ Lv.100ã€€|ã€€ç‚¹å‡»åˆ‡æ¢æ‰è½å¼€å…³
                    </div>

                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(auto-fill, minmax(90px, 1fr))',
                        gap: 10
                    }}>
                        {allEquipTemplates.map((tpl) => {
                            const unlocked = equipCodexSet.has(tpl.id);
                            const lv100 = hasLevel100(tpl.id);

                            const dropEnabled = allowDrop(tpl.id);
                            const disabledDrop = !dropEnabled;

                            return (
                                <div
                                    key={tpl.id}
                                    title={`${tpl.name}ï¼ˆç‚¹å‡»å¼€å…³æ‰è½ï¼‰`}
                                    style={{
                                        background: unlocked ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.18)',
                                        borderRadius: 8,
                                        border: lv100
                                            ? '2px solid rgba(255, 215, 0, 0.95)'
                                            : `1px solid ${unlocked ? '#4a3c2a' : '#333'}`,
                                        boxShadow: lv100 ? '0 0 10px rgba(255,215,0,0.35)' : 'none',
                                    }}
                                >
                                    <CardShell
                                        onClick={() => toggleDrop(tpl.id)}
                                        disabledDrop={disabledDrop}
                                    >
                                        <div style={{ fontSize: 26, marginBottom: 6 }}>
                                            <ItemIcon item={tpl} size={28} />
                                        </div>

                                        <div style={{
                                            fontSize: 10,
                                            color: unlocked ? '#ffd700' : '#555',
                                            lineHeight: 1.2,
                                            minHeight: 26,
                                            opacity: unlocked ? 1 : 0.7
                                        }}>
                                            {tpl.name}
                                        </div>

                                        <div style={{
                                            marginTop: 6,
                                            fontSize: 9,
                                            color: unlocked ? '#aaa' : '#444'
                                        }}>
                                            {unlocked ? 'å·²è·å–' : 'æœªè·å–'}
                                        </div>

                                        {lv100 && (
                                            <div style={{
                                                marginTop: 6,
                                                fontSize: 9,
                                                color: '#ffd700',
                                                fontWeight: 900
                                            }}>
                                                Lv.100 âœ¨
                                            </div>
                                        )}

                                        <DropTag enabled={dropEnabled} />
                                    </CardShell>
                                </div>
                            );
                        })}
                    </div>
                </>
            )}

            {/* ===== åƒåœ¾å›¾é‰´ ===== */}
            {tab === 'junk' && (
                <>
                    <div style={{ fontSize: 12, color: '#888', marginBottom: 12 }}>
                        âœ… ç‚¹äº®ï¼šå·²è·å¾—è¿‡è¯¥åƒåœ¾ã€€|ã€€ç‚¹å‡»åˆ‡æ¢æ‰è½å¼€å…³
                    </div>

                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(auto-fill, minmax(90px, 1fr))',
                        gap: 10
                    }}>
                        {allJunkTemplates.map((tpl) => {
                            const unlocked = junkCodexSet.has(tpl.id);

                            const dropEnabled = allowDrop(tpl.id);
                            const disabledDrop = !dropEnabled;

                            return (
                                <div
                                    key={tpl.id}
                                    title={`${tpl.name}ï¼ˆç‚¹å‡»å¼€å…³æ‰è½ï¼‰`}
                                    style={{
                                        background: unlocked ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.18)',
                                        borderRadius: 8,
                                        border: `1px solid ${unlocked ? '#4a3c2a' : '#333'}`,
                                    }}
                                >
                                    <CardShell
                                        onClick={() => toggleDrop(tpl.id)}
                                        disabledDrop={disabledDrop}
                                    >
                                        <div style={{ fontSize: 26, marginBottom: 6 }}>
                                            <ItemIcon item={tpl} size={26} />
                                        </div>

                                        <div style={{
                                            fontSize: 10,
                                            color: unlocked ? '#ffd700' : '#555',
                                            lineHeight: 1.2,
                                            minHeight: 26,
                                            opacity: unlocked ? 1 : 0.7
                                        }}>
                                            {tpl.name}
                                        </div>

                                        <div style={{
                                            marginTop: 6,
                                            fontSize: 9,
                                            color: unlocked ? '#aaa' : '#444'
                                        }}>
                                            {unlocked ? 'å·²è·å–' : 'æœªè·å–'}
                                        </div>

                                        <div style={{
                                            marginTop: 4,
                                            fontSize: 9,
                                            color: unlocked ? '#888' : '#444'
                                        }}>
                                            ğŸª™ {tpl.sellPrice || 0}
                                        </div>

                                        <DropTag enabled={dropEnabled} />
                                    </CardShell>
                                </div>
                            );
                        })}

                        {allJunkTemplates.length === 0 && (
                            <div style={{ color: '#666', fontSize: 12 }}>
                                å½“å‰æ²¡æœ‰å®šä¹‰åƒåœ¾ç‰©å“
                            </div>
                        )}
                    </div>
                </>
            )}
        </Panel>
    );
};

// ==================== ä»»åŠ¡ç³»ç»Ÿæ•°æ®ç»“æ„ ====================

// ä»»åŠ¡çŠ¶æ€å¸¸é‡
const QUEST_STATUS = {
    NOT_STARTED: 'not_started',
    IN_PROGRESS: 'in_progress',
    COMPLETED: 'completed',
    FAILED: 'failed'
};

// èŒƒå…‹é‡Œå¤«é€šç¼‰ä»¤ä»»åŠ¡çº¿
const QUEST_CHAINS = {
    vancleef_wanted: {
        id: 'vancleef_wanted',
        name: 'èŒƒå…‹é‡Œå¤«é€šç¼‰ä»¤',
        description: 'æš´é£åŸå‘å¸ƒäº†å¯¹èŒƒå…‹é‡Œå¤«çš„é€šç¼‰ä»¤ï¼Œä½†äº‹æƒ…ä¼¼ä¹å¹¶ä¸ç®€å•...',
        icon: 'ğŸ“œ',
        unlockCondition: {
            type: 'boss_defeated',
            bossId: 'hogger'  // éœ€è¦å…ˆå‡»è´¥éœæ ¼
        },
        resetsOnRebirth: true,  // è½®å›é‡ç½®

        // ä»»åŠ¡æ­¥éª¤
        steps: {
            // ==================== ç¬¬ä¸€æ­¥ï¼šæ¥å—ä»»åŠ¡ ====================
            step_1_accept: {
                id: 'step_1_accept',
                title: 'ç¥ç§˜çš„é€šç¼‰ä»¤',
                description: 'ä½ åœ¨æš´é£åŸå…¬å‘Šæ¿ä¸Šå‘ç°äº†ä¸€å¼ é€šç¼‰ä»¤ï¼Œä¸Šé¢å†™ç€"è¿ªè²äºšå…„å¼Ÿä¼šé¦–é¢† è‰¾å¾·æ¸©Â·èŒƒå…‹é‡Œå¤«"ã€‚ä¸€ä½ç¥ç§˜çš„è´µæ—å¥³å£«æ­£åœ¨ä¸€æ—è§‚å¯Ÿç€...',
                dialogues: [
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'å•Šï¼Œå†’é™©è€…ï¼Œä½ å¯¹è¿™å¼ é€šç¼‰ä»¤æ„Ÿå…´è¶£å—ï¼ŸèŒƒå…‹é‡Œå¤«æ›¾æ˜¯æš´é£åŸçš„å·¥åŒ å¤§å¸ˆï¼Œå¦‚ä»Šå´æ²¦ä¸ºé€šç¼‰çŠ¯...'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'ä»–å¸¦é¢†è¿ªè²äºšå…„å¼Ÿä¼šåœ¨è¥¿éƒ¨è’é‡è‚†è™ï¼Œå¿…é¡»æœ‰äººé˜»æ­¢ä»–ã€‚ä½ æ„¿æ„æ¥å—è¿™ä¸ªä»»åŠ¡å—ï¼Ÿ'
                    }
                ],
                choices: [
                    {
                        id: 'accept_quest',
                        text: 'æ¥å—ä»»åŠ¡ï¼Œè¿½æŸ¥èŒƒå…‹é‡Œå¤«',
                        nextStep: 'step_2_investigate',
                        rewards: { gold: 500 }
                    },
                    {
                        id: 'ask_more',
                        text: 'æˆ‘æƒ³å…ˆäº†è§£æ›´å¤šå…³äºèŒƒå…‹é‡Œå¤«çš„äº‹æƒ…',
                        nextStep: 'step_1b_background',
                        rewards: null
                    },
                    {
                        id: 'refuse',
                        text: 'è¿™ä¸å…³æˆ‘çš„äº‹ï¼ˆç»“æŸä»»åŠ¡çº¿ï¼‰',
                        nextStep: null,
                        endQuest: true,
                        rewards: null
                    }
                ]
            },

            // ==================== ç¬¬ä¸€æ­¥åˆ†æ”¯ï¼šäº†è§£èƒŒæ™¯ ====================
            step_1b_background: {
                id: 'step_1b_background',
                title: 'èŒƒå…‹é‡Œå¤«çš„è¿‡å»',
                description: 'ä½ è¯¢é—®æ™®ç‘æ–¯æ‰˜å¥³å£«å…³äºèŒƒå…‹é‡Œå¤«çš„æ›´å¤šä¿¡æ¯...',
                dialogues: [
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'èŒƒå…‹é‡Œå¤«...ä»–æ›¾æ˜¯æš´é£åŸé‡å»ºå·¥ç¨‹çš„é¦–å¸­å·¥åŒ ã€‚åœ¨å…½äººæˆ˜äº‰åï¼Œä»–å¸¦é¢†å·¥åŒ ä»¬é‡å»ºäº†è¿™åº§åŸå¸‚ã€‚'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'ä½†åæ¥...è´µæ—ä»¬æ‹’ç»æ”¯ä»˜å·¥åŒ ä»¬åº”å¾—çš„æŠ¥é…¬ã€‚èŒƒå…‹é‡Œå¤«æ„¤æ€’åœ°ç¦»å¼€ï¼Œåˆ›å»ºäº†è¿ªè²äºšå…„å¼Ÿä¼šã€‚'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆå¥¹è¯´è¯æ—¶çœ¼ç¥é—ªçƒï¼Œä¼¼ä¹æœ‰æ‰€éšç’...ï¼‰'
                    }
                ],
                choices: [
                    {
                        id: 'accept_after_info',
                        text: 'æˆ‘æ˜ç™½äº†ï¼Œæˆ‘ä¼šè¿½æŸ¥èŒƒå…‹é‡Œå¤«',
                        nextStep: 'step_2_investigate',
                        rewards: { gold: 500 },
                        flagSet: ['knows_background']  // è®¾ç½®æ ‡è®°
                    },
                    {
                        id: 'suspicious',
                        text: 'ä¸ºä»€ä¹ˆè´µæ—ä¸ä»˜é’±ï¼Ÿæ˜¯è°åšçš„å†³å®šï¼Ÿ',
                        nextStep: 'step_1c_suspicion',
                        rewards: null,
                        flagSet: ['suspicious_of_nobles']
                    }
                ]
            },

            // ==================== ç¬¬ä¸€æ­¥åˆ†æ”¯ï¼šäº§ç”Ÿæ€€ç–‘ ====================
            step_1c_suspicion: {
                id: 'step_1c_suspicion',
                title: 'è´µæ—çš„ç§˜å¯†',
                description: 'ä½ çš„é—®é¢˜ä¼¼ä¹è§¦åŠ¨äº†æ™®ç‘æ–¯æ‰˜å¥³å£«çš„ç¥ç»...',
                dialogues: [
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: '...è¿™æ˜¯å¾ˆä¹…ä»¥å‰çš„äº‹äº†ã€‚å½“æ—¶çš„è´µæ—è®®ä¼šåšå‡ºäº†å†³å®šï¼Œæˆ‘ä¹Ÿæ— èƒ½ä¸ºåŠ›ã€‚'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆå¥¹çš„è¯­æ°”å˜å¾—å†·æ·¡ã€‚ä¹Ÿè®¸æˆ‘åº”è¯¥å¦å¤–è°ƒæŸ¥ä¸€ä¸‹...ï¼‰'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'æ— è®ºå¦‚ä½•ï¼ŒèŒƒå…‹é‡Œå¤«ç°åœ¨æ˜¯é€šç¼‰çŠ¯ã€‚ä½ æ˜¯è¦å¸®åŠ©æš´é£åŸï¼Œè¿˜æ˜¯è¦è¢–æ‰‹æ—è§‚ï¼Ÿ'
                    }
                ],
                choices: [
                    {
                        id: 'accept_suspicious',
                        text: 'æˆ‘ä¼šå»è°ƒæŸ¥çš„ï¼ˆä½†æˆ‘ä¼šä¿æŒè­¦æƒ•ï¼‰',
                        nextStep: 'step_2_investigate',
                        rewards: { gold: 500 },
                        flagSet: ['deeply_suspicious']
                    },
                    {
                        id: 'investigate_nobles',
                        text: 'æˆ‘æƒ³å…ˆè°ƒæŸ¥ä¸€ä¸‹è´µæ—è®®ä¼šçš„è®°å½•',
                        nextStep: 'step_2_alt_investigate_nobles',
                        rewards: null,
                        flagSet: ['investigating_nobles']
                    }
                ]
            },

            // ==================== ç¬¬äºŒæ­¥ï¼šè°ƒæŸ¥èŒƒå…‹é‡Œå¤« ====================
            step_2_investigate: {
                id: 'step_2_investigate',
                title: 'è¥¿éƒ¨è’é‡çš„è°ƒæŸ¥',
                description: 'ä½ å‰å¾€è¥¿éƒ¨è’é‡è°ƒæŸ¥è¿ªè²äºšå…„å¼Ÿä¼šçš„æ´»åŠ¨...',
                requirement: {
                    type: 'zone_battles',
                    zoneId: 'westfall',
                    count: 10
                },
                dialogues: [
                    {
                        speaker: 'å†œå¤«',
                        portrait: 'ğŸ‘¨â€ğŸŒ¾',
                        text: 'è¿ªè²äºšï¼Ÿä»–ä»¬ç¡®å®åœ¨è¿™é‡Œæ´»åŠ¨...ä½†ä½ çŸ¥é“å—ï¼Œä»–ä»¬ä»ä¸ä¼¤å®³æˆ‘ä»¬è¿™äº›å¹³æ°‘ã€‚'
                    },
                    {
                        speaker: 'å†œå¤«',
                        portrait: 'ğŸ‘¨â€ğŸŒ¾',
                        text: 'ä»–ä»¬åªæ”»å‡»é‚£äº›ä¸ºè´µæ—å·¥ä½œçš„å•†é˜Ÿã€‚æœ‰äººè¯´ï¼ŒèŒƒå…‹é‡Œå¤«æ˜¯è¢«å†¤æ‰çš„...'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆåœ¨æˆ˜æ–—ä¸­ï¼Œä½ å‘ç°äº†ä¸€äº›å¥‡æ€ªçš„æ–‡ä»¶...ï¼‰'
                    }
                ],
                onComplete: {
                    giveItem: 'IT_DEFIAS_DOCUMENT'  // ç»™äºˆè¿ªè²äºšæ–‡ä»¶
                },
                choices: [
                    {
                        id: 'continue_hunt',
                        text: 'ç»§ç»­è¿½æ•èŒƒå…‹é‡Œå¤«',
                        nextStep: 'step_3_deadmines',
                        rewards: { gold: 1000, exp: 2000 }
                    },
                    {
                        id: 'read_documents',
                        text: 'ä»”ç»†ç ”ç©¶è¿™äº›æ–‡ä»¶',
                        nextStep: 'step_2b_read_documents',
                        rewards: { exp: 1000 },
                        requireFlag: null  // æ‰€æœ‰äººéƒ½èƒ½é€‰
                    }
                ]
            },

            // ==================== ç¬¬äºŒæ­¥æ›¿ä»£ï¼šè°ƒæŸ¥è´µæ— ====================
            step_2_alt_investigate_nobles: {
                id: 'step_2_alt_investigate_nobles',
                title: 'æš´é£åŸæ¡£æ¡ˆé¦†',
                description: 'ä½ æ½œå…¥æš´é£åŸæ¡£æ¡ˆé¦†ï¼Œå¯»æ‰¾å½“å¹´å·¥ç¨‹æ¬¾çš„è®°å½•...',
                requirement: {
                    type: 'have_gold',
                    amount: 2000  // éœ€è¦è´¿èµ‚å®ˆå«
                },
                dialogues: [
                    {
                        speaker: 'æ¡£æ¡ˆç®¡ç†å‘˜',
                        portrait: 'ğŸ“š',
                        text: 'ï¼ˆåœ¨æ”¶ä¸‹ä½ çš„"ææ¬¾"åï¼‰å¥½å§...è¿™æ˜¯å½“å¹´çš„è´¢åŠ¡è®°å½•ã€‚'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆè®°å½•æ˜¾ç¤ºï¼Œå·¥ç¨‹æ¬¾è¢«ä¸€ä½"Kå¥³å£«"æ‰¹å‡†è½¬ç§»åˆ°äº†å…¶ä»–ç”¨é€”...Kï¼Ÿæ™®ç‘æ–¯æ‰˜ï¼Ÿï¼‰'
                    }
                ],
                onComplete: {
                    giveItem: 'IT_FINANCIAL_RECORD',
                    flagSet: ['found_financial_proof']
                },
                choices: [
                    {
                        id: 'confront_prestor',
                        text: 'ç›´æ¥è´¨é—®æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        nextStep: 'step_3_alt_confront',
                        rewards: { exp: 3000 }
                    },
                    {
                        id: 'gather_more_evidence',
                        text: 'ç»§ç»­æ”¶é›†æ›´å¤šè¯æ®',
                        nextStep: 'step_3_alt_more_evidence',
                        rewards: { exp: 2000 }
                    }
                ]
            },

            // ==================== ç¬¬äºŒæ­¥åˆ†æ”¯ï¼šé˜…è¯»æ–‡ä»¶ ====================
            step_2b_read_documents: {
                id: 'step_2b_read_documents',
                title: 'è¿ªè²äºšçš„çœŸç›¸',
                description: 'ä½ ä»”ç»†é˜…è¯»äº†ä»è¿ªè²äºšæˆå‘˜èº«ä¸Šæœåˆ°çš„æ–‡ä»¶...',
                dialogues: [
                    {
                        speaker: 'ï¼ˆæ–‡ä»¶å†…å®¹ï¼‰',
                        portrait: 'ğŸ“„',
                        text: '"...æš´é£åŸè´µæ—èƒŒå›äº†æˆ‘ä»¬ã€‚æˆ‘ä»¬å»ºé€ äº†è¿™åº§åŸå¸‚ï¼Œå´è¢«åƒç‹—ä¸€æ ·èµ¶èµ°..."'
                    },
                    {
                        speaker: 'ï¼ˆæ–‡ä»¶å†…å®¹ï¼‰',
                        portrait: 'ğŸ“„',
                        text: '"...é‚£ä¸ªå¥³äººï¼Œå¥¹æ“æ§äº†ä¸€åˆ‡ã€‚å¥¹ä¸æ˜¯äººç±»ï¼Œå¥¹æ˜¯...é¾™..."'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜®',
                        text: 'ï¼ˆé¾™ï¼Ÿè¿™å¬èµ·æ¥å¤ªç–¯ç‹‚äº†...ä½†å¦‚æœæ˜¯çœŸçš„å‘¢ï¼Ÿï¼‰'
                    }
                ],
                onComplete: {
                    flagSet: ['knows_dragon_secret']
                },
                choices: [
                    {
                        id: 'dismiss_as_crazy',
                        text: 'è¿™æ˜¯ç–¯è¯ï¼Œç»§ç»­è¿½æ•èŒƒå…‹é‡Œå¤«',
                        nextStep: 'step_3_deadmines',
                        rewards: { gold: 1000, exp: 2000 }
                    },
                    {
                        id: 'investigate_dragon',
                        text: 'è°ƒæŸ¥è¿™ä¸ª"é¾™"çš„è¯´æ³•',
                        nextStep: 'step_3_dragon_investigation',
                        rewards: { exp: 3000 },
                        flagSet: ['pursuing_dragon_truth']
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥ï¼šè¿›æ”»æ­»äº¡çŸ¿äº• ====================
            step_3_deadmines: {
                id: 'step_3_deadmines',
                title: 'æ­»äº¡çŸ¿äº•',
                description: 'ä½ è¿½è¸ªèŒƒå…‹é‡Œå¤«åˆ°äº†ä»–çš„è€å·¢â€”â€”æ­»äº¡çŸ¿äº•...',
                requirement: {
                    type: 'character_level',
                    level: 25
                },
                dialogues: [
                    {
                        speaker: 'è¿ªè²äºšå®ˆå«',
                        portrait: 'âš”ï¸',
                        text: 'å…¥ä¾µè€…ï¼ä¿æŠ¤é˜Ÿé•¿ï¼'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆæ·±å…¥çŸ¿äº•ï¼Œä½ å‘ç°è¿™é‡Œæ­£åœ¨å»ºé€ ä¸€è‰˜å·¨å¤§çš„æˆ˜èˆ¹...èŒƒå…‹é‡Œå¤«åœ¨è®¡åˆ’ä»€ä¹ˆï¼Ÿï¼‰'
                    }
                ],
                choices: [
                    {
                        id: 'fight_vancleef',
                        text: 'ç›´æ¥ä¸èŒƒå…‹é‡Œå¤«æˆ˜æ–—',
                        nextStep: 'step_4_final_battle_vancleef',
                        rewards: { gold: 2000 }
                    },
                    {
                        id: 'talk_to_vancleef',
                        text: 'å°è¯•ä¸èŒƒå…‹é‡Œå¤«å¯¹è¯',
                        nextStep: 'step_3b_talk_vancleef',
                        rewards: null,
                        requireFlag: ['knows_background']  // éœ€è¦äº†è§£èƒŒæ™¯
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥åˆ†æ”¯ï¼šä¸èŒƒå…‹é‡Œå¤«å¯¹è¯ ====================
            step_3b_talk_vancleef: {
                id: 'step_3b_talk_vancleef',
                title: 'å·¥åŒ å¤§å¸ˆçš„æ‚²æ­Œ',
                description: 'ä½ é€‰æ‹©ä¸èŒƒå…‹é‡Œå¤«å¯¹è¯ï¼Œè€Œä¸æ˜¯ç«‹å³æˆ˜æ–—...',
                dialogues: [
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: '...ä½ å±…ç„¶æ„¿æ„å¬æˆ‘è¯´è¯ï¼Ÿå¤§å¤šæ•°"è‹±é›„"æ—©å°±æŒ¥å‰‘ç è¿‡æ¥äº†ã€‚'
                    },
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'æˆ‘ä»¬å»ºé€ äº†æš´é£åŸï¼Œç –ä¸€ç –ï¼ŒçŸ³ä¸€çŸ³ã€‚æˆ˜äº‰ç»“æŸåï¼Œè´µæ—ä»¬è¯´å›½åº“ç©ºè™šï¼Œæ— æ³•æ”¯ä»˜å·¥é’±ã€‚'
                    },
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'ä½†æˆ‘çŸ¥é“çœŸç›¸ã€‚æ˜¯é‚£ä¸ªå¥³äºº...æ™®ç‘æ–¯æ‰˜...å¥¹æŠŠé’±è½¬èµ°äº†ã€‚å¥¹ä¸æ˜¯äººç±»ï¼'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ä½ è¯´å¥¹ä¸æ˜¯äººç±»ï¼Ÿä½ æœ‰è¯æ®å—ï¼Ÿ'
                    },
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'æˆ‘è§è¿‡å¥¹å˜èº«...åœ¨å°˜æ³¥æ²¼æ³½çš„æ·±å¤„ï¼Œå¥¹æœ‰ä¸€ä¸ªå·¢ç©´ã€‚å»é‚£é‡Œæ‰¾è¯æ®å§ã€‚'
                    }
                ],
                onComplete: {
                    flagSet: ['allied_with_vancleef']
                },
                choices: [
                    {
                        id: 'believe_vancleef',
                        text: 'æˆ‘ç›¸ä¿¡ä½ ã€‚æˆ‘ä¼šå»è°ƒæŸ¥æ™®ç‘æ–¯æ‰˜',
                        nextStep: 'step_4_dragon_hunt',
                        rewards: { exp: 5000 },
                        flagSet: ['full_alliance']
                    },
                    {
                        id: 'still_arrest',
                        text: 'ä¸ç®¡æ€æ ·ï¼Œä½ ä»ç„¶æ˜¯é€šç¼‰çŠ¯',
                        nextStep: 'step_4_final_battle_vancleef',
                        rewards: { gold: 2000 }
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥æ›¿ä»£ï¼šè°ƒæŸ¥é¾™ ====================
            step_3_dragon_investigation: {
                id: 'step_3_dragon_investigation',
                title: 'è¿½å¯»é»‘é¾™çš„è¸ªè¿¹',
                description: 'ä½ å¼€å§‹è°ƒæŸ¥æ–‡ä»¶ä¸­æåˆ°çš„"é¾™"...',
                requirement: {
                    type: 'zone_battles',
                    zoneId: 'dustwallow_marsh',
                    count: 15
                },
                dialogues: [
                    {
                        speaker: 'å¡æ‹‰æ‘©æ³•å¸ˆ',
                        portrait: 'ğŸ§™',
                        text: 'é»‘é¾™ï¼Ÿåœ¨è¿™ç‰‡æ²¼æ³½ç¡®å®æœ‰é¾™çš„æ´»åŠ¨ç—•è¿¹...å¥¥å¦®å…‹å¸Œäºšçš„å·¢ç©´å°±åœ¨é™„è¿‘ã€‚'
                    },
                    {
                        speaker: 'å¡æ‹‰æ‘©æ³•å¸ˆ',
                        portrait: 'ğŸ§™',
                        text: 'æœ‰ä¼ è¨€è¯´ï¼Œé»‘é¾™å…¬ä¸»ä¼šåŒ–èº«ä¸ºäººç±»ï¼Œæ½œä¼åœ¨å„å›½çš„æƒåŠ›ä¸­å¿ƒ...'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜®',
                        text: 'ï¼ˆè¿™ä¸è¿ªè²äºšæ–‡ä»¶ä¸­çš„æè¿°å»åˆ...æ™®ç‘æ–¯æ‰˜å¥³å£«...ï¼‰'
                    }
                ],
                onComplete: {
                    giveItem: 'IT_DRAGON_SCALE_SAMPLE'
                },
                choices: [
                    {
                        id: 'find_more_proof',
                        text: 'å¯»æ‰¾æ›´å¤šè¯æ®è¯æ˜æ™®ç‘æ–¯æ‰˜çš„èº«ä»½',
                        nextStep: 'step_4_dragon_hunt',
                        rewards: { exp: 5000 }
                    },
                    {
                        id: 'report_to_king',
                        text: 'ç›´æ¥å‘å›½ç‹æŠ¥å‘Š',
                        nextStep: 'step_3c_report_king',
                        rewards: { gold: 3000 }
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥æ›¿ä»£ï¼šå‘å›½ç‹æŠ¥å‘Š ====================
            step_3c_report_king: {
                id: 'step_3c_report_king',
                title: 'å›½ç‹çš„æ€’ç«',
                description: 'ä½ è¯•å›¾å‘ç“¦é‡Œå®‰Â·ä¹Œç‘æ©å›½ç‹æŠ¥å‘Šæ™®ç‘æ–¯æ‰˜çš„çœŸå®èº«ä»½...',
                dialogues: [
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'ï¼ˆå¥¹æ°å¥½åœ¨åœºï¼‰é™›ä¸‹ï¼Œè¿™ä¸ªå†’é™©è€…åœ¨æ•£å¸ƒå…³äºæˆ‘çš„è°£è¨€...'
                    },
                    {
                        speaker: 'å›½ç‹',
                        portrait: 'ğŸ‘‘',
                        text: 'æ™®ç‘æ–¯æ‰˜å¥³å£«æ˜¯ç‹å›½æœ€å¿ è¯šçš„é¡¾é—®ï¼ä½ æœ‰è¯æ®å—ï¼Ÿ'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜°',
                        text: 'ï¼ˆæ²¡æœ‰ç¡®å‡¿è¯æ®ï¼Œä½ çš„è¯æ¯«æ— è¯´æœåŠ›...ä½ éœ€è¦æ‰¾åˆ°é“è¯ï¼ï¼‰'
                    }
                ],
                onComplete: {
                    flagSet: ['exposed_to_prestor']
                },
                choices: [
                    {
                        id: 'retreat_find_proof',
                        text: 'é€€ä¸‹ï¼Œå»å¯»æ‰¾ç¡®å‡¿è¯æ®',
                        nextStep: 'step_4_dragon_hunt',
                        rewards: null
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥æ›¿ä»£ï¼šç›´æ¥è´¨é—® ====================
            step_3_alt_confront: {
                id: 'step_3_alt_confront',
                title: 'å±é™©çš„å¯¹è´¨',
                description: 'ä½ å¸¦ç€è´¢åŠ¡è®°å½•ç›´æ¥é¢å¯¹æ™®ç‘æ–¯æ‰˜å¥³å£«...',
                dialogues: [
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜ ',
                        text: 'æ™®ç‘æ–¯æ‰˜å¥³å£«ï¼Œæˆ‘æœ‰è¯æ®è¡¨æ˜æ˜¯ä½ è½¬ç§»äº†å·¥åŒ ä»¬çš„å·¥é’±ï¼'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'ï¼ˆå¥¹çš„çœ¼ç›é—ªè¿‡ä¸€ä¸å±é™©çš„å…‰èŠ’ï¼‰ä½ åœ¨ç©ç«ï¼Œå‡¡äºº...'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‰',
                        text: 'ï¼ˆå¥¹å‘¨å›´çš„ç©ºæ°”å¼€å§‹æ‰­æ›²ï¼Œä½ æ„Ÿå—åˆ°äº†ä¸€è‚¡å¼ºå¤§çš„å¨å‹ï¼‰æ—¢ç„¶ä½ çŸ¥é“äº†å¤ªå¤š...'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜¨',
                        text: 'ï¼ˆå¥¹...å¥¹çœŸçš„ä¸æ˜¯äººç±»ï¼ä½ å¿…é¡»é€ƒè·‘å¹¶å¯»æ‰¾å¸®åŠ©ï¼ï¼‰'
                    }
                ],
                onComplete: {
                    flagSet: ['witnessed_transformation', 'prestor_hostile']
                },
                choices: [
                    {
                        id: 'escape_gather_allies',
                        text: 'é€ƒç¦»å¹¶å¬é›†ç›Ÿå‹',
                        nextStep: 'step_4_gather_allies',
                        rewards: { exp: 5000 }
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥æ›¿ä»£ï¼šæ”¶é›†æ›´å¤šè¯æ® ====================
            step_3_alt_more_evidence: {
                id: 'step_3_alt_more_evidence',
                title: 'æ·±å…¥è°ƒæŸ¥',
                description: 'ä½ ç»§ç»­ç§˜å¯†æ”¶é›†å…³äºæ™®ç‘æ–¯æ‰˜å¥³å£«çš„è¯æ®...',
                requirement: {
                    type: 'have_item',
                    itemId: 'IT_BLACK_DRAGON_PROOF'  // éœ€è¦ä»å°˜æ³¥æ²¼æ³½è·å¾—
                },
                dialogues: [
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆä½ æ‰¾åˆ°äº†é»‘é¾™åŒ–èº«çš„è¯æ˜...ç°åœ¨è¯æ®ç¡®å‡¿äº†ï¼ï¼‰'
                    }
                ],
                choices: [
                    {
                        id: 'prepare_battle',
                        text: 'å‡†å¤‡ä¸é»‘é¾™æˆ˜æ–—',
                        nextStep: 'step_4_dragon_hunt',
                        rewards: { exp: 5000 }
                    }
                ]
            },

            // ==================== ç¬¬å››æ­¥ï¼šçŒæ€é»‘é¾™ ====================
            step_4_dragon_hunt: {
                id: 'step_4_dragon_hunt',
                title: 'æ­éœ²çœŸç›¸',
                description: 'ä½ æ”¶é›†äº†è¶³å¤Ÿçš„è¯æ®ï¼Œæ˜¯æ—¶å€™æ­éœ²æ™®ç‘æ–¯æ‰˜å¥³å£«çš„çœŸå®èº«ä»½äº†...',
                requirement: {
                    type: 'character_level',
                    level: 40
                },
                dialogues: [
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'ï¼ˆå¦‚æœä½ ä¸ä»–ç»“ç›Ÿï¼‰æˆ‘çš„å…„å¼Ÿä¼šä¼šæ”¯æ´ä½ ã€‚è®©é‚£æ¡é»‘é¾™ä»˜å‡ºä»£ä»·ï¼'
                    },
                    {
                        speaker: 'é›·å…‹è¨',
                        portrait: 'ğŸ»',
                        text: 'ï¼ˆå¦‚æœä½ æ›¾å¸®åŠ©è¿‡ä»–ï¼‰æˆ‘ä¹Ÿä¼šåŠ©ä½ ä¸€è‡‚ä¹‹åŠ›ï¼Œæœ‹å‹ã€‚'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'âš”ï¸',
                        text: 'æ™®ç‘æ–¯æ‰˜å¥³å£«...ä¸ï¼Œå¥¥å¦®å…‹å¸Œäºšï¼ä½ çš„é˜´è°‹åˆ°æ­¤ä¸ºæ­¢ï¼'
                    }
                ],
                choices: [
                    {
                        id: 'final_battle_dragon',
                        text: 'å‘èµ·æœ€ç»ˆæˆ˜æ–—ï¼',
                        nextStep: 'ending_dragon_slayer',
                        rewards: null  // å¥–åŠ±åœ¨ç»“å±€ä¸­ç»™
                    }
                ]
            },

            // ==================== ç¬¬å››æ­¥æ›¿ä»£ï¼šå¬é›†ç›Ÿå‹ ====================
            step_4_gather_allies: {
                id: 'step_4_gather_allies',
                title: 'å¬é›†ç›Ÿå‹',
                description: 'ä½ éœ€è¦å¼ºå¤§çš„ç›Ÿå‹æ¥å¯¹æŠ—é»‘é¾™...',
                requirement: {
                    type: 'boss_defeated',
                    bossId: 'vancleef'  // éœ€è¦å…ˆå’ŒèŒƒå…‹é‡Œå¤«å’Œè§£æˆ–å‡»è´¥ä»–
                },
                dialogues: [
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'æ‰€ä»¥ä½ ç»ˆäºç›¸ä¿¡æˆ‘äº†...å¥½ï¼Œè¿ªè²äºšå…„å¼Ÿä¼šå°†ä¸ä½ å¹¶è‚©ä½œæˆ˜ï¼'
                    }
                ],
                choices: [
                    {
                        id: 'attack_dragon',
                        text: 'è”åˆè¿›æ”»é»‘é¾™ï¼',
                        nextStep: 'ending_dragon_slayer',
                        rewards: null
                    }
                ]
            },

            // ==================== ç¬¬å››æ­¥ï¼šæœ€ç»ˆæˆ˜æ–—ï¼ˆèŒƒå…‹é‡Œå¤«çº¿ï¼‰ ====================
            step_4_final_battle_vancleef: {
                id: 'step_4_final_battle_vancleef',
                title: 'æ­»äº¡çŸ¿äº•å†³æˆ˜',
                description: 'ä½ ä¸èŒƒå…‹é‡Œå¤«å±•å¼€æœ€ç»ˆå†³æˆ˜...',
                requirement: {
                    type: 'boss_defeated',
                    bossId: 'vancleef'
                },
                dialogues: [
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'è±æ©å›½ç‹å¿æ¸…äº†æ¬ æˆ‘ä»¬çš„å€º...ä½ çš„ä¹Ÿåˆ°æœŸäº†ï¼'
                    },
                    {
                        speaker: 'ï¼ˆæˆ˜æ–—åï¼‰',
                        portrait: 'âš”ï¸',
                        text: 'ï¼ˆèŒƒå…‹é‡Œå¤«å€’ä¸‹äº†...ä»–çš„çœ¼ä¸­æ»¡æ˜¯ä¸ç”˜ï¼‰'
                    },
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'ï¼ˆä¸´ç»ˆå‰ï¼‰é‚£ä¸ªå¥³äºº...å¥¹æ‰æ˜¯...çœŸæ­£çš„æ•Œäºº...'
                    }
                ],
                choices: [
                    {
                        id: 'ignore_words',
                        text: 'æ— è§†ä»–çš„é—è¨€ï¼Œè¿”å›æš´é£åŸé¢†èµ',
                        nextStep: 'ending_bounty_hunter',
                        rewards: null
                    },
                    {
                        id: 'heed_warning',
                        text: 'ä»–çš„è¯è®©æˆ‘åœ¨æ„...è°ƒæŸ¥æ™®ç‘æ–¯æ‰˜',
                        nextStep: 'step_5_post_vancleef_investigation',
                        rewards: null,
                        flagSet: ['posthumous_warning']
                    }
                ]
            },

            // ==================== ç¬¬äº”æ­¥ï¼šå‡»æ€èŒƒå…‹é‡Œå¤«åçš„è°ƒæŸ¥ ====================
            step_5_post_vancleef_investigation: {
                id: 'step_5_post_vancleef_investigation',
                title: 'æ­»è€…çš„è­¦å‘Š',
                description: 'èŒƒå…‹é‡Œå¤«çš„é—è¨€è®©ä½ æ— æ³•å®‰å¿ƒã€‚ä½ å†³å®šè°ƒæŸ¥æ™®ç‘æ–¯æ‰˜å¥³å£«...',
                requirement: {
                    type: 'zone_battles',
                    zoneId: 'dustwallow_marsh',
                    count: 20
                },
                dialogues: [
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆåœ¨å°˜æ³¥æ²¼æ³½æ·±å¤„ï¼Œä½ å‘ç°äº†é»‘é¾™çš„ç—•è¿¹...èŒƒå…‹é‡Œå¤«è¯´çš„æ˜¯çœŸçš„ï¼ï¼‰'
                    }
                ],
                onComplete: {
                    giveItem: 'IT_BLACK_DRAGON_PROOF'
                },
                choices: [
                    {
                        id: 'hunt_dragon',
                        text: 'ä¸ºèŒƒå…‹é‡Œå¤«å¤ä»‡ï¼ŒçŒæ€é»‘é¾™ï¼',
                        nextStep: 'ending_redemption',
                        rewards: null
                    }
                ]
            },

            // ==================== ç»“å±€ï¼šèµé‡‘çŒäºº ====================
            ending_bounty_hunter: {
                id: 'ending_bounty_hunter',
                title: 'ç»“å±€ï¼šèµé‡‘çŒäºº',
                isEnding: true,
                branch: 'suppress_vancleef',
                description: 'ä½ æˆåŠŸå‡»æ€äº†èŒƒå…‹é‡Œå¤«ï¼Œå®Œæˆäº†æš´é£åŸçš„é€šç¼‰ä»»åŠ¡ã€‚',
                dialogues: [
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'å¹²å¾—å¥½ï¼Œå†’é™©è€…ã€‚èŒƒå…‹é‡Œå¤«ç»ˆäºè¢«ç»³ä¹‹ä»¥æ³•äº†ã€‚è¿™æ˜¯ä½ åº”å¾—çš„å¥–åŠ±ã€‚'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'ï¼ˆå¥¹çš„ç¬‘å®¹è®©ä½ æ„Ÿåˆ°ä¸€ä¸å¯’æ„...ä½†ä½ é€‰æ‹©äº†å¿½è§†å®ƒï¼‰'
                    },
                    {
                        speaker: 'ï¼ˆæ—ç™½ï¼‰',
                        portrait: 'ğŸ“œ',
                        text: 'ä½ å®Œæˆäº†é€šç¼‰ä»»åŠ¡ï¼Œè·å¾—äº†ä¸°åšçš„æŠ¥é…¬ã€‚ä½†çœŸç›¸...æˆ–è®¸æ°¸è¿œè¢«åŸ‹è—åœ¨æ­»äº¡çŸ¿äº•çš„æ·±å¤„ã€‚'
                    }
                ],
                rewards: {
                    gold: 50000,
                    exp: 30000,
                    items: [
                        { id: 'EQ_QUEST_BOUNTY_CLOAK', guaranteed: true }  // èµé‡‘çŒäººæŠ«é£
                    ],
                    title: 'æš´é£åŸèµé‡‘çŒäºº'
                }
            },

            // ==================== ç»“å±€ï¼šå± é¾™è€… ====================
            ending_dragon_slayer: {
                id: 'ending_dragon_slayer',
                title: 'ç»“å±€ï¼šå± é¾™è€…',
                isEnding: true,
                branch: 'slay_prestor',
                description: 'ä½ æ­éœ²äº†æ™®ç‘æ–¯æ‰˜å¥³å£«çš„çœŸå®èº«ä»½ï¼Œå¹¶ä¸é»‘é¾™å…¬ä¸»å±•å¼€æœ€ç»ˆå†³æˆ˜ï¼',
                requirement: {
                    type: 'boss_defeated',
                    bossId: 'prestor_lady'
                },
                dialogues: [
                    {
                        speaker: 'å¥¥å¦®å…‹å¸Œäºš',
                        portrait: 'ğŸ‰',
                        text: 'æ„šè ¢çš„å‡¡äººï¼ä½ ä»¥ä¸ºä½ èƒ½æˆ˜èƒœæˆ‘ï¼Ÿæˆ‘æ˜¯æ­»äº¡ä¹‹ç¿¼çš„å¥³å„¿ï¼'
                    },
                    {
                        speaker: 'ï¼ˆæˆ˜æ–—åï¼‰',
                        portrait: 'âš”ï¸',
                        text: 'ï¼ˆé»‘é¾™å…¬ä¸»å€’ä¸‹äº†ï¼Œå¥¹çš„ä¼ªè£…å½»åº•ç“¦è§£ï¼‰'
                    },
                    {
                        speaker: 'å›½ç‹',
                        portrait: 'ğŸ‘‘',
                        text: '...æˆ‘ç«Ÿç„¶è¢«å¥¹è’™è”½äº†è¿™ä¹ˆä¹…ã€‚å‹‡å£«ï¼Œä½ æ‹¯æ•‘äº†æ•´ä¸ªç‹å›½ï¼'
                    },
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'ï¼ˆå¦‚æœå­˜æ´»ï¼‰æ­£ä¹‰...ç»ˆäºå¾—åˆ°äº†ä¼¸å¼ ã€‚ä¹Ÿè®¸ï¼Œæ˜¯æ—¶å€™è®©è¿ªè²äºšå…„å¼Ÿä¼šè§£æ•£äº†ã€‚'
                    }
                ],
                rewards: {
                    gold: 100000,
                    exp: 80000,
                    items: [
                        { id: 'EQ_QUEST_DRAGON_SLAYER_RING', guaranteed: true },  // å± é¾™è€…ä¹‹æˆ’
                        { id: 'EQ_QUEST_ONYXIA_SCALE_CLOAK', guaranteed: true }   // å¥¥å¦®å…‹å¸Œäºšé³ç‰‡æŠ«é£
                    ],
                    title: 'é»‘é¾™ç»ˆç»“è€…',
                    unlockBoss: 'prestor_lady_heroic'  // è§£é”è‹±é›„éš¾åº¦
                }
            },

            // ==================== ç»“å±€ï¼šæ•‘èµ ====================
            ending_redemption: {
                id: 'ending_redemption',
                title: 'ç»“å±€ï¼šè¿Ÿæ¥çš„æ•‘èµ',
                isEnding: true,
                branch: 'slay_prestor',
                description: 'è™½ç„¶èŒƒå…‹é‡Œå¤«å·²ç»æ­»å»ï¼Œä½†ä½ ä¸ºä»–æ­éœ²äº†çœŸç›¸ï¼Œå¹¶å‡»è´¥äº†çœŸæ­£çš„å¹•åé»‘æ‰‹ã€‚',
                requirement: {
                    type: 'boss_defeated',
                    bossId: 'prestor_lady'
                },
                dialogues: [
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜”',
                        text: 'èŒƒå…‹é‡Œå¤«...æˆ‘ä¸ºä½ æŠ¥ä»‡äº†ã€‚ä½ çš„å†¤å±ˆï¼Œç»ˆäºå¾—åˆ°äº†æ´—æ¸…ã€‚'
                    },
                    {
                        speaker: 'è¿ªè²äºšæ®‹å…š',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: '...è°¢è°¢ä½ ï¼Œå†’é™©è€…ã€‚è™½ç„¶é˜Ÿé•¿å·²ç»ä¸åœ¨äº†ï¼Œä½†çœŸç›¸ç»ˆäºå¤§ç™½äºå¤©ä¸‹ã€‚'
                    },
                    {
                        speaker: 'å›½ç‹',
                        portrait: 'ğŸ‘‘',
                        text: 'æˆ‘ä¼šé‡æ–°è¯„ä¼°å¯¹è¿ªè²äºšå…„å¼Ÿä¼šçš„åˆ¤å†³ã€‚èŒƒå…‹é‡Œå¤«å’Œå·¥åŒ ä»¬...ä»–ä»¬å€¼å¾—æ›´å¥½çš„å¯¹å¾…ã€‚'
                    }
                ],
                rewards: {
                    gold: 80000,
                    exp: 60000,
                    items: [
                        { id: 'EQ_QUEST_REDEMPTION_BLADE', guaranteed: true }  // æ•‘èµä¹‹åˆƒ
                    ],
                    title: 'çœŸç›¸è¿½å¯»è€…'
                }
            }
        }
    }
};

// ä»»åŠ¡ç‰©å“
const QUEST_ITEMS = {
    IT_DEFIAS_DOCUMENT: {
        id: 'IT_DEFIAS_DOCUMENT',
        name: 'è¿ªè²äºšå¯†ä¿¡',
        icon: 'ğŸ“„',
        type: 'quest',
        rarity: 'blue',
        description: 'ä»è¿ªè²äºšæˆå‘˜èº«ä¸Šæœåˆ°çš„å¯†ä¿¡ï¼Œä¸Šé¢æåˆ°äº†ä¸€äº›ä»¤äººä¸å®‰çš„å†…å®¹...'
    },
    IT_FINANCIAL_RECORD: {
        id: 'IT_FINANCIAL_RECORD',
        name: 'æš´é£åŸè´¢åŠ¡è®°å½•',
        icon: 'ğŸ“Š',
        type: 'quest',
        rarity: 'blue',
        description: 'æ˜¾ç¤ºå·¥ç¨‹æ¬¾è¢«ç¥ç§˜è½¬ç§»çš„è´¢åŠ¡è®°å½•'
    },
    IT_DRAGON_SCALE_SAMPLE: {
        id: 'IT_DRAGON_SCALE_SAMPLE',
        name: 'é»‘é¾™é³ç‰‡æ ·æœ¬',
        icon: 'ğŸ‰',
        type: 'quest',
        rarity: 'purple',
        description: 'åœ¨å°˜æ³¥æ²¼æ³½å‘ç°çš„é»‘é¾™é³ç‰‡ï¼Œè¯æ˜è¿™é‡Œæœ‰é¾™çš„æ´»åŠ¨'
    }
};

// ä»»åŠ¡å¥–åŠ±è£…å¤‡
const QUEST_REWARD_EQUIPMENTS = {
    EQ_QUEST_BOUNTY_CLOAK: {
        id: 'EQ_QUEST_BOUNTY_CLOAK',
        name: 'èµé‡‘çŒäººçš„æŠ«é£',
        icon: 'icons/wow/vanilla/armor/INV_Misc_Cape_18.png',
        type: 'equipment',
        slot: 'cloak',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            attack: 100,
            critRate: 5,
            gold_bonus: 10  // ç‰¹æ®Šï¼šé‡‘å¸è·å–+10%
        },
        growth: { hp: 2, attack: 2, critRate: 2 },
        description: 'å®Œæˆæš´é£åŸé€šç¼‰ä»»åŠ¡çš„å¥–åŠ±'
    },
    EQ_QUEST_DRAGON_SLAYER_RING: {
        id: 'EQ_QUEST_DRAGON_SLAYER_RING',
        name: 'å± é¾™è€…ä¹‹æˆ’',
        icon: 'icons/wow/vanilla/armor/INV_Jewelry_Ring_15.png',
        type: 'equipment',
        slot: 'ring1',
        rarity: 'orange',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 800,
            attack: 200,
            spellPower: 200,
            critRate: 10,
            critDamage: 0.3
        },
        growth: { hp: 2, attack: 2, spellPower: 2, critRate: 2, critDamage: 2 },
        description: 'å‡»è´¥é»‘é¾™å…¬ä¸»çš„è¯æ˜'
    },
    EQ_QUEST_ONYXIA_SCALE_CLOAK: {
        id: 'EQ_QUEST_ONYXIA_SCALE_CLOAK',
        name: 'å¥¥å¦®å…‹å¸Œäºšé³ç‰‡æŠ«é£',
        icon: 'icons/wow/vanilla/armor/INV_Misc_Cape_20.png',
        type: 'equipment',
        slot: 'cloak',
        rarity: 'orange',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1000,
            armor: 150,
            magicResist: 50,
            versatility: 15
        },
        growth: { hp: 2, armor: 2, magicResist: 2, versatility: 2 },
        specialEffect: {
            type: 'map_slayer',
            bonusDamageVsMap: 0.25  // åœ°å›¾æˆ˜æ–—+25%ä¼¤å®³
        },
        description: 'ç”¨å¥¥å¦®å…‹å¸Œäºšçš„é³ç‰‡åˆ¶æˆï¼Œæ•£å‘ç€é¾™ç„°çš„ä½™æ¸©'
    },
    EQ_QUEST_REDEMPTION_BLADE: {
        id: 'EQ_QUEST_REDEMPTION_BLADE',
        name: 'æ•‘èµä¹‹åˆƒ',
        icon: 'icons/wow/vanilla/weapons/INV_Sword_48.png',
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1000,
            versatility: 20,
            hp: 2000
        },
        growth: { attack: 2, versatility: 2, hp: 2 },
        description: 'ä¸ºé€è€…ä¼¸å¼ æ­£ä¹‰ï¼Œä¸ºç”Ÿè€…å¸¦æ¥æ•‘èµ'
    }
};

// ==================== ä»»åŠ¡é¡µé¢UIç»„ä»¶ ====================
const QuestPage = ({ state, dispatch }) => {
    const [selectedQuest, setSelectedQuest] = useState(null);
    const [showDialogue, setShowDialogue] = useState(false);
    const [dialogueIndex, setDialogueIndex] = useState(0);

    // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦è§£é”
    const isQuestUnlocked = (quest) => {
        if (!quest.unlockCondition) return true;

        if (quest.unlockCondition.type === 'boss_defeated') {
            return state.defeatedBosses?.includes(quest.unlockCondition.bossId);
        }
        return false;
    };

    // æ£€æŸ¥æ­¥éª¤æ¡ä»¶æ˜¯å¦æ»¡è¶³
    const isStepRequirementMet = (step) => {
        if (!step.requirement) return true;

        switch (step.requirement.type) {
            case 'zone_battles':
                // ç®€åŒ–ï¼šæ£€æŸ¥æ˜¯å¦æœ‰è§’è‰²åœ¨è¯¥åŒºåŸŸæˆ˜æ–—è¿‡è¶³å¤Ÿæ¬¡æ•°
                return true;  // å®é™…å®ç°éœ€è¦è¿½è¸ªæˆ˜æ–—æ¬¡æ•°
            case 'character_level':
                return state.characters.some(c => c.level >= step.requirement.level);
            case 'boss_defeated':
                return state.defeatedBosses?.includes(step.requirement.bossId);
            case 'have_gold':
                return state.resources.gold >= step.requirement.amount;
            case 'have_item':
                return state.inventory.some(i => i.id === step.requirement.itemId) ||
                    state.questItems?.some(i => i.id === step.requirement.itemId);
            default:
                return true;
        }
    };

    // è·å–å½“å‰å¯ç”¨ä»»åŠ¡
    const availableQuests = Object.values(QUEST_CHAINS).filter(quest => {
        const progress = state.questProgress?.[quest.id];
        const unlocked = isQuestUnlocked(quest);
        const notCompleted = progress?.status !== QUEST_STATUS.COMPLETED;
        return unlocked && notCompleted;
    });

    // æ¸²æŸ“ä»»åŠ¡å¡ç‰‡
    const renderQuestCard = (quest) => {
        const progress = state.questProgress?.[quest.id];
        const isStarted = progress?.status === QUEST_STATUS.IN_PROGRESS;
        const currentStep = isStarted ? quest.steps[progress.currentStep] : null;

        return (
            <div
                key={quest.id}
                onClick={() => setSelectedQuest(quest)}
                style={{
                    padding: 16,
                    background: isStarted
                        ? 'linear-gradient(135deg, rgba(201,162,39,0.15), rgba(139,115,25,0.1))'
                        : 'rgba(0,0,0,0.3)',
                    border: isStarted ? '2px solid #c9a227' : '2px solid #4a3c2a',
                    borderRadius: 10,
                    cursor: 'pointer',
                    transition: 'all 0.2s'
                }}
            >
                <div style={{ display: 'flex', alignItems: 'center', gap: 12, marginBottom: 8 }}>
                    <span style={{ fontSize: 32 }}>{quest.icon}</span>
                    <div>
                        <div style={{ fontSize: 16, color: '#ffd700', fontWeight: 600 }}>
                            {quest.name}
                        </div>
                        <div style={{ fontSize: 11, color: isStarted ? '#4CAF50' : '#888' }}>
                            {isStarted ? `è¿›è¡Œä¸­ï¼š${currentStep?.title}` : 'æœªå¼€å§‹'}
                        </div>
                    </div>
                </div>
                <div style={{ fontSize: 12, color: '#aaa', lineHeight: 1.5 }}>
                    {quest.description}
                </div>
            </div>
        );
    };

    // æ¸²æŸ“ä»»åŠ¡è¯¦æƒ…æ¨¡æ€æ¡†
    const renderQuestModal = () => {
        if (!selectedQuest) return null;

        const quest = selectedQuest;
        const progress = state.questProgress?.[quest.id];
        const isStarted = progress?.status === QUEST_STATUS.IN_PROGRESS;
        const currentStep = isStarted ? quest.steps[progress.currentStep] : quest.steps[Object.keys(quest.steps)[0]];
        const requirementMet = isStepRequirementMet(currentStep);

        return (
            <div style={{
                position: 'fixed',
                top: 0, left: 0, right: 0, bottom: 0,
                background: 'rgba(0,0,0,0.9)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 1000
            }} onClick={() => setSelectedQuest(null)}>
                <div style={{
                    width: 700,
                    maxHeight: '85vh',
                    overflowY: 'auto',
                    background: 'linear-gradient(135deg, #1a1510 0%, #0d0a07 100%)',
                    border: '3px solid #c9a227',
                    borderRadius: 12,
                    padding: 24
                }} onClick={e => e.stopPropagation()}>
                    {/* ä»»åŠ¡æ ‡é¢˜ */}
                    <div style={{
                        textAlign: 'center',
                        marginBottom: 20,
                        paddingBottom: 16,
                        borderBottom: '1px solid rgba(201,162,39,0.3)'
                    }}>
                        <div style={{ fontSize: 48, marginBottom: 8 }}>{quest.icon}</div>
                        <h2 style={{ margin: 0, color: '#ffd700', fontSize: 24 }}>{quest.name}</h2>
                        <div style={{ color: '#888', fontSize: 12, marginTop: 8 }}>
                            {currentStep?.title}
                        </div>
                    </div>

                    {/* å½“å‰æ­¥éª¤æè¿° */}
                    <div style={{
                        background: 'rgba(0,0,0,0.3)',
                        borderRadius: 8,
                        padding: 16,
                        marginBottom: 16,
                        border: '1px solid #4a3c2a'
                    }}>
                        <div style={{ fontSize: 14, color: '#e8dcc4', lineHeight: 1.6 }}>
                            {currentStep?.description}
                        </div>
                    </div>

                    {/* æ¡ä»¶æ£€æŸ¥ */}
                    {currentStep?.requirement && (
                        <div style={{
                            background: requirementMet ? 'rgba(76,175,80,0.1)' : 'rgba(244,67,54,0.1)',
                            borderRadius: 8,
                            padding: 12,
                            marginBottom: 16,
                            border: `1px solid ${requirementMet ? 'rgba(76,175,80,0.3)' : 'rgba(244,67,54,0.3)'}`
                        }}>
                            <div style={{
                                fontSize: 12,
                                color: requirementMet ? '#4CAF50' : '#f44336',
                                display: 'flex',
                                alignItems: 'center',
                                gap: 8
                            }}>
                                {requirementMet ? 'âœ“' : 'âœ—'}
                                {currentStep.requirement.type === 'character_level' &&
                                `éœ€è¦è§’è‰²ç­‰çº§ ${currentStep.requirement.level}`}
                                {currentStep.requirement.type === 'zone_battles' &&
                                `éœ€è¦åœ¨${ZONES[currentStep.requirement.zoneId]?.name}æˆ˜æ–—${currentStep.requirement.count}æ¬¡`}
                                {currentStep.requirement.type === 'boss_defeated' &&
                                `éœ€è¦å‡»è´¥${BOSS_DATA[currentStep.requirement.bossId]?.name}`}
                                {currentStep.requirement.type === 'have_gold' &&
                                `éœ€è¦${currentStep.requirement.amount}é‡‘å¸`}
                            </div>
                        </div>
                    )}

                    {/* å¯¹è¯æŒ‰é’® */}
                    {currentStep?.dialogues && currentStep.dialogues.length > 0 && (
                        <Button
                            onClick={() => {
                                setShowDialogue(true);
                                setDialogueIndex(0);
                            }}
                            style={{ width: '100%', marginBottom: 16 }}
                            variant="secondary"
                        >
                            ğŸ“– æŸ¥çœ‹å¯¹è¯
                        </Button>
                    )}

                    {/* é€‰æ‹©åˆ—è¡¨ */}
                    {currentStep?.choices && (
                        <div style={{ marginBottom: 16 }}>
                            <div style={{ fontSize: 14, color: '#c9a227', marginBottom: 12 }}>
                                åšå‡ºé€‰æ‹©ï¼š
                            </div>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                                {currentStep.choices.map(choice => {
                                    const canChoose = requirementMet &&
                                        (!choice.requireFlag || choice.requireFlag.every(f => progress?.flags?.includes(f)));

                                    return (
                                        <button
                                            key={choice.id}
                                            onClick={() => {
                                                if (!canChoose) return;

                                                if (!isStarted) {
                                                    dispatch({ type: 'START_QUEST', payload: { questId: quest.id }});
                                                }
                                                dispatch({
                                                    type: 'QUEST_CHOICE',
                                                    payload: { questId: quest.id, choiceId: choice.id }
                                                });

                                                // å¦‚æœæ˜¯ç»“å±€ï¼Œå…³é—­æ¨¡æ€æ¡†
                                                if (choice.nextStep && quest.steps[choice.nextStep]?.isEnding) {
                                                    setSelectedQuest(null);
                                                }
                                            }}
                                            disabled={!canChoose}
                                            style={{
                                                padding: '12px 16px',
                                                background: canChoose
                                                    ? 'linear-gradient(135deg, rgba(201,162,39,0.2), rgba(139,115,25,0.15))'
                                                    : 'rgba(60,60,60,0.3)',
                                                border: canChoose ? '2px solid #c9a227' : '2px solid #444',
                                                borderRadius: 8,
                                                color: canChoose ? '#ffd700' : '#666',
                                                cursor: canChoose ? 'pointer' : 'not-allowed',
                                                fontFamily: 'inherit',
                                                fontSize: 13,
                                                textAlign: 'left',
                                                transition: 'all 0.2s'
                                            }}
                                        >
                                            <div style={{ marginBottom: 4 }}>{choice.text}</div>
                                            {choice.rewards && (
                                                <div style={{ fontSize: 11, color: '#4CAF50' }}>
                                                    å¥–åŠ±ï¼š
                                                    {choice.rewards.gold && `ğŸª™${choice.rewards.gold} `}
                                                    {choice.rewards.exp && `â­${choice.rewards.exp}`}
                                                </div>
                                            )}
                                            {choice.requireFlag && !canChoose && (
                                                <div style={{ fontSize: 10, color: '#f44336', marginTop: 4 }}>
                                                    éœ€è¦ç‰¹å®šæ¡ä»¶
                                                </div>
                                            )}
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    {/* ç»“å±€æ£€æŸ¥ */}
                    {currentStep?.isEnding && (
                        <div style={{
                            background: 'linear-gradient(135deg, rgba(255,215,0,0.15), rgba(201,162,39,0.1))',
                            borderRadius: 10,
                            padding: 20,
                            border: '2px solid #ffd700',
                            textAlign: 'center'
                        }}>
                            <div style={{ fontSize: 18, color: '#ffd700', fontWeight: 700, marginBottom: 12 }}>
                                ğŸ† {currentStep.title}
                            </div>
                            <div style={{ fontSize: 13, color: '#e8dcc4', marginBottom: 16 }}>
                                {currentStep.description}
                            </div>

                            {/* ç»“å±€å¥–åŠ±é¢„è§ˆ */}
                            {currentStep.rewards && (
                                <div style={{
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: 8,
                                    padding: 12,
                                    marginBottom: 16
                                }}>
                                    <div style={{ fontSize: 12, color: '#c9a227', marginBottom: 8 }}>ç»“å±€å¥–åŠ±ï¼š</div>
                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8, justifyContent: 'center' }}>
                                        {currentStep.rewards.gold && (
                                            <span style={{ color: '#ffd700' }}>ğŸª™ {currentStep.rewards.gold}</span>
                                        )}
                                        {currentStep.rewards.exp && (
                                            <span style={{ color: '#4CAF50' }}>â­ {currentStep.rewards.exp}</span>
                                        )}
                                        {currentStep.rewards.title && (
                                            <span style={{ color: '#a335ee' }}>ğŸ… ç§°å·ï¼š{currentStep.rewards.title}</span>
                                        )}
                                    </div>
                                    {currentStep.rewards.items && (
                                        <div style={{ marginTop: 8, fontSize: 11, color: '#ff9800' }}>
                                            + {currentStep.rewards.items.length} ä»¶è£…å¤‡
                                        </div>
                                    )}
                                </div>
                            )}

                            <Button
                                onClick={() => {
                                    dispatch({ type: 'COMPLETE_QUEST_ENDING', payload: { questId: quest.id }});
                                    setSelectedQuest(null);
                                }}
                                disabled={!isStepRequirementMet(currentStep)}
                            >
                                ğŸ‰ å®Œæˆä»»åŠ¡
                            </Button>

                            {!isStepRequirementMet(currentStep) && (
                                <div style={{ fontSize: 11, color: '#f44336', marginTop: 8 }}>
                                    éœ€è¦æ»¡è¶³æ¡ä»¶æ‰èƒ½å®Œæˆ
                                </div>
                            )}
                        </div>
                    )}

                    {/* å…³é—­æŒ‰é’® */}
                    <div style={{ textAlign: 'center', marginTop: 16 }}>
                        <Button onClick={() => setSelectedQuest(null)} variant="secondary">
                            å…³é—­
                        </Button>
                    </div>
                </div>
            </div>
        );
    };

    // æ¸²æŸ“å¯¹è¯æ¨¡æ€æ¡†
    const renderDialogueModal = () => {
        if (!showDialogue || !selectedQuest) return null;

        const progress = state.questProgress?.[selectedQuest.id];
        const currentStep = progress?.currentStep
            ? selectedQuest.steps[progress.currentStep]
            : selectedQuest.steps[Object.keys(selectedQuest.steps)[0]];

        if (!currentStep?.dialogues) return null;

        const dialogue = currentStep.dialogues[dialogueIndex];
        const isLast = dialogueIndex >= currentStep.dialogues.length - 1;

        return (
            <div style={{
                position: 'fixed',
                top: 0, left: 0, right: 0, bottom: 0,
                background: 'rgba(0,0,0,0.95)',
                display: 'flex',
                alignItems: 'flex-end',
                justifyContent: 'center',
                zIndex: 1001,
                padding: 40
            }} onClick={() => {
                if (isLast) {
                    setShowDialogue(false);
                } else {
                    setDialogueIndex(prev => prev + 1);
                }
            }}>
                <div style={{
                    width: '100%',
                    maxWidth: 800,
                    background: 'linear-gradient(180deg, rgba(30,25,20,0.98), rgba(20,15,10,0.99))',
                    border: '3px solid #c9a227',
                    borderRadius: 12,
                    padding: 24,
                    marginBottom: 40
                }} onClick={e => e.stopPropagation()}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 16, marginBottom: 16 }}>
                        <div style={{
                            width: 60,
                            height: 60,
                            background: 'rgba(0,0,0,0.4)',
                            borderRadius: '50%',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontSize: 32,
                            border: '2px solid #4a3c2a'
                        }}>
                            {dialogue.portrait}
                        </div>
                        <div style={{ fontSize: 18, color: '#ffd700', fontWeight: 600 }}>
                            {dialogue.speaker}
                        </div>
                    </div>

                    <div style={{
                        fontSize: 16,
                        color: '#e8dcc4',
                        lineHeight: 1.8,
                        minHeight: 80
                    }}>
                        {dialogue.text}
                    </div>

                    <div style={{
                        marginTop: 16,
                        textAlign: 'right',
                        fontSize: 12,
                        color: '#888'
                    }}>
                        {isLast ? 'ç‚¹å‡»å…³é—­' : 'ç‚¹å‡»ç»§ç»­'} ({dialogueIndex + 1}/{currentStep.dialogues.length})
                    </div>
                </div>
            </div>
        );
    };

    return (
        <div>
            <Panel title="ğŸ“œ ä»»åŠ¡">
                <div style={{ fontSize: 12, color: '#888', marginBottom: 16 }}>
                    å®Œæˆä»»åŠ¡è·å¾—ä¸°åšå¥–åŠ±ã€‚æ¯æ¬¡è½®å›ä»»åŠ¡è¿›åº¦ä¼šé‡ç½®ï¼Œä½†è·å¾—çš„ç§°å·å’Œæˆå°±æ°¸ä¹…ä¿ç•™ã€‚
                </div>

                {/* å·²å®Œæˆçš„ä»»åŠ¡åˆ†æ”¯ */}
                {state.completedQuestBranches?.length > 0 && (
                    <div style={{
                        background: 'rgba(76,175,80,0.1)',
                        borderRadius: 8,
                        padding: 12,
                        marginBottom: 16,
                        border: '1px solid rgba(76,175,80,0.3)'
                    }}>
                        <div style={{ fontSize: 12, color: '#4CAF50', marginBottom: 8 }}>
                            ğŸ† å·²å®Œæˆçš„ä»»åŠ¡çº¿ï¼ˆå†å²è®°å½•ï¼‰
                        </div>
                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8 }}>
                            {state.completedQuestBranches.map((record, i) => (
                                <span key={i} style={{
                                    padding: '4px 10px',
                                    background: 'rgba(76,175,80,0.2)',
                                    borderRadius: 4,
                                    fontSize: 11,
                                    color: '#81c784'
                                }}>
                                    {QUEST_CHAINS[record.questId]?.name} - {record.branch === 'slay_prestor' ? 'å± é¾™è€…' : 'èµé‡‘çŒäºº'}
                                </span>
                            ))}
                        </div>
                    </div>
                )}

                {/* ä»»åŠ¡åˆ—è¡¨ */}
                {availableQuests.length === 0 ? (
                    <div style={{ textAlign: 'center', padding: 40, color: '#666' }}>
                        <div style={{ fontSize: 48, marginBottom: 16 }}>ğŸ”’</div>
                        <div>æš‚æ— å¯ç”¨ä»»åŠ¡</div>
                        <div style={{ fontSize: 12, marginTop: 8 }}>
                            å‡»è´¥ä¸–ç•Œé¦–é¢†éœæ ¼åè§£é”ç¬¬ä¸€ä¸ªä»»åŠ¡
                        </div>
                    </div>
                ) : (
                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',
                        gap: 16
                    }}>
                        {availableQuests.map(renderQuestCard)}
                    </div>
                )}
            </Panel>

            {renderQuestModal()}
            {renderDialogueModal()}
        </div>
    );
};

// ==================== åœ¨èœå•ä¸­æ·»åŠ ä»»åŠ¡é¡µé¢ ====================
// åœ¨ menus æ•°ç»„ä¸­æ·»åŠ ï¼š
// { id: 'quest', name: 'ä»»åŠ¡', icon: 'ğŸ“œ' },

// åœ¨ renderPage å‡½æ•°ä¸­æ·»åŠ ï¼š
// case 'quest': return <QuestPage state={state} dispatch={dispatch} />;

// ==================== Bosså‡†å¤‡æ¨¡æ€ï¼ˆé‡æ–°è®¾è®¡ç‰ˆï¼‰ ====================
const BossPrepareModal = ({ state, dispatch }) => {
    const bossId = state.prepareBoss;
    console.log('bossId:', bossId);
    console.log('BOSS_DATA:', BOSS_DATA);
    console.log('boss:', BOSS_DATA[bossId]);
    if (!bossId) return null;
    const boss = BOSS_DATA[bossId];
    const available = state.characters.filter(c => !state.assignments[c.id]);
    const [dragged, setDragged] = useState(null);

    const BOSS_ACTION_NAME = {
        espionage: 'è°æŠ¥',
        black_dragon_flame: 'é»‘é¾™ä¹‹ç‚',
        fangs_and_claws: 'å°–ç‰™ä¸åˆ©çˆª',
        normal_attack: 'æ™®é€šæ”»å‡»',
        // å…¶ä»–bossä¹Ÿå¯ä»¥é€æ­¥è¡¥é½
        mortal_strike: 'è‡´æ­»æ‰“å‡»',
        summon_cannoneers: 'ç«ç‚®æ‰‹å‡†å¤‡',
        board_the_deck: 'ç™»ä¸Šç”²æ¿',
        summon: 'å¬å”¤',
        strike: 'é‡å‡»',
        soul_storm:'çµé­‚å¼ºé£',
        fallen_crusaders :'å •è½çš„åå­—å†›',
        banish_soul:'æ”¾é€çµé­‚',
        soul_reaper:'çµé­‚æ”¶å‰²è€…',

        // âœ… è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸
        flame_strike: 'çƒˆç„°æ‰“å‡»',
        lava_burst: 'ç†”å²©çˆ†è£‚',
        battle_shout: 'æˆ˜æ–—æ€’å¼',

        // âœ… é»‘æš—é™¢é•¿åŠ ä¸
        shadow_bolt: 'æš—å½±ç®­',
        summon_apprentices: 'å¬å”¤äº¡çµå­¦å¾’',
        shadow_curse: 'æš—å½±è¯…å’’',
        dark_storm: 'é»‘æš—é£æš´',

        // âœ… ç‘æ–‡æˆ´å°”ç”·çˆµ
        cleave: 'é¡ºåŠˆæ–©',
        summon_skeleton_army: 'å¬å”¤éª·é«…å¤§å†›',
        shadow_shock: 'æš—å½±éœ‡å‡»',

        // âœ… é›·å¾·Â·é»‘æ‰‹
        flame_breath: 'çƒˆç„°åæ¯',
        leap_slash: 'è·³è·ƒæ–©å‡»',
    };

    const formatBossCycle = (boss) =>
        (boss?.cycle || []).map(id => BOSS_ACTION_NAME[id] || id).join(' â†’ ');

    // è®¡ç®—é˜Ÿä¼æ€»å±æ€§
    const teamStats = state.bossTeam.filter(Boolean).reduce((acc, charId) => {
        const char = state.characters.find(c => c.id === charId);
        if (char) {
            acc.totalHp += char.stats.maxHp || 0;
            acc.totalAttack += char.stats.attack || 0;
            acc.totalSpellPower += char.stats.spellPower || 0;
            acc.count += 1;
        }
        return acc;
    }, { totalHp: 0, totalAttack: 0, totalSpellPower: 0, count: 0 });

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.92)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20
        }}>
            <div style={{
                width: 1100,
                maxWidth: '95vw',
                maxHeight: '95vh',
                overflowY: 'auto',
                background: 'linear-gradient(180deg, #1a1208 0%, #0d0906 100%)',
                borderRadius: 16,
                border: '3px solid #8b6914',
                boxShadow: '0 0 60px rgba(139,105,20,0.4), inset 0 0 100px rgba(0,0,0,0.5)',
                position: 'relative'
            }}>
                {/* é¡¶éƒ¨è£…é¥°æ¡ */}
                <div style={{
                    height: 4,
                    background: 'linear-gradient(90deg, transparent, #c9a227, #ffd700, #c9a227, transparent)',
                    borderRadius: '16px 16px 0 0'
                }} />

                {/* æ ‡é¢˜åŒºåŸŸ */}
                <div style={{
                    textAlign: 'center',
                    padding: '20px 30px',
                    borderBottom: '1px solid rgba(201,162,39,0.2)',
                    background: 'linear-gradient(180deg, rgba(139,105,20,0.15) 0%, transparent 100%)'
                }}>
                    <div style={{
                        fontSize: 12,
                        color: '#888',
                        letterSpacing: 4,
                        marginBottom: 8
                    }}>
                        âš”ï¸ ä¸–ç•Œé¦–é¢†æŒ‘æˆ˜ âš”ï¸
                    </div>
                    <h2 style={{
                        margin: 0,
                        fontSize: 32,
                        color: '#ffd700',
                        textShadow: '0 0 20px rgba(255,215,0,0.5), 2px 2px 4px rgba(0,0,0,0.8)',
                        fontWeight: 700,
                        letterSpacing: 2
                    }}>
                        {boss.name}
                    </h2>
                </div>

                {/* ä¸»ä½“å†…å®¹ */}
                <div style={{
                    display: 'grid',
                    gridTemplateColumns: '320px 1fr',
                    gap: 0,
                    minHeight: 500
                }}>
                    {/* ==================== å·¦ä¾§ï¼šBOSSä¿¡æ¯åŒº ==================== */}
                    <div style={{
                        borderRight: '1px solid rgba(201,162,39,0.2)',
                        background: 'linear-gradient(180deg, rgba(80,20,20,0.2) 0%, rgba(40,10,10,0.3) 100%)',
                        padding: 20,
                        display: 'flex',
                        flexDirection: 'column'
                    }}>
                        {/* BOSSå›¾ç‰‡åŒºåŸŸ - å¸¦è¾¹æ¡†è£…é¥° */}
                        <div style={{
                            width: '100%',
                            aspectRatio: '1/1',
                            background: 'linear-gradient(135deg, rgba(100,30,30,0.3) 0%, rgba(40,10,10,0.5) 100%)',
                            border: '3px solid',
                            borderImage: 'linear-gradient(135deg, #8b3030, #4a1515, #8b3030) 1',
                            borderRadius: 12,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            marginBottom: 16,
                            position: 'relative',
                            overflow: 'hidden',
                            boxShadow: `
        inset 0 0 40px rgba(0,0,0,0.5), 
        0 4px 20px rgba(0,0,0,0.4),
        0 0 30px rgba(139,48,48,0.3)
    `
                        }}>
                            {WORLD_BOSSES[bossId]?.icon ? (
                                <img
                                    src={WORLD_BOSSES[bossId].icon}
                                    alt={boss.name}
                                    style={{
                                        width: '100%',
                                        height: '100%',
                                        objectFit: 'cover',
                                        filter: 'contrast(1.1) saturate(1.1)'  // è®©å›¾ç‰‡æ›´é²œè‰³
                                    }}
                                />
                            ) : (
                                <div style={{
                                    fontSize: 80,
                                    opacity: 0.6,
                                    filter: 'drop-shadow(0 0 20px rgba(255,100,100,0.5))'
                                }}>
                                    ğŸ²
                                </div>
                            )}

                            {/* é¡¶éƒ¨æ¸å˜é®ç½© - è®©å›¾ç‰‡è¾¹ç¼˜æ›´èåˆ */}
                            <div style={{
                                position: 'absolute',
                                top: 0,
                                left: 0,
                                right: 0,
                                height: '30%',
                                background: 'linear-gradient(180deg, rgba(0,0,0,0.4) 0%, transparent 100%)',
                                pointerEvents: 'none'
                            }} />

                            {/* åº•éƒ¨æ¸å˜é®ç½© */}
                            <div style={{
                                position: 'absolute',
                                bottom: 0,
                                left: 0,
                                right: 0,
                                height: '30%',
                                background: 'linear-gradient(0deg, rgba(0,0,0,0.6) 0%, transparent 100%)',
                                pointerEvents: 'none'
                            }} />

                            {/* è§’è½è£…é¥° */}
                            <div style={{
                                position: 'absolute',
                                top: 0,
                                left: 0,
                                right: 0,
                                bottom: 0,
                                border: '3px solid transparent',
                                borderImage: 'linear-gradient(45deg, #8b3030, transparent, transparent, #8b3030) 1',
                                pointerEvents: 'none'
                            }} />

                        </div>



                        {/* BOSSå±æ€§ */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: 8,
                            padding: 12,
                            marginBottom: 16,
                            border: '1px solid rgba(180,50,50,0.3)'
                        }}>
                            <div style={{
                                fontSize: 12,
                                color: '#ff6b6b',
                                fontWeight: 600,
                                marginBottom: 10,
                                textAlign: 'center',
                                borderBottom: '1px solid rgba(180,50,50,0.2)',
                                paddingBottom: 8
                            }}>
                                ğŸ“Š é¦–é¢†å±æ€§
                            </div>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 12 }}>
                                    <span style={{ color: '#888' }}>â¤ï¸ ç”Ÿå‘½å€¼</span>
                                    <span style={{ color: '#f44336', fontWeight: 600 }}>{boss.maxHp?.toLocaleString()}</span>
                                </div>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 12 }}>
                                    <span style={{ color: '#888' }}>âš”ï¸ æ”»å‡»åŠ›</span>
                                    <span style={{ color: '#ff9800', fontWeight: 600 }}>{boss.attack}</span>
                                </div>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 12 }}>
                                    <span style={{ color: '#888' }}>ğŸ›¡ï¸ é˜²å¾¡åŠ›</span>
                                    <span style={{ color: '#4CAF50', fontWeight: 600 }}>{boss.defense}</span>
                                </div>
                            </div>
                        </div>

                        {/* BOSSæŠ€èƒ½è¯´æ˜ */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: 8,
                            padding: 12,
                            flex: 1,
                            border: '1px solid rgba(180,50,50,0.3)'
                        }}>
                            <div style={{
                                fontSize: 12,
                                color: '#ff6b6b',
                                fontWeight: 600,
                                marginBottom: 10,
                                textAlign: 'center',
                                borderBottom: '1px solid rgba(180,50,50,0.2)',
                                paddingBottom: 8
                            }}>
                                ğŸ“œ æŠ€èƒ½æœºåˆ¶
                            </div>

                            <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                                {/* éœæ ¼çš„æŠ€èƒ½ */}
                                {bossId === 'hogger' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,100,100,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ’¥ é‡å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹ç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.heavyMultiplier}å€</span> æ”»å‡»çš„ç‰©ç†ä¼¤å®³
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ‘¥ å¬å”¤å°å¼Ÿ
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}</span> ä¸ª{boss.minion?.name || 'å°å¼Ÿ'}
                                                <br/>
                                                <span style={{ color: '#888' }}>
                            (HP:{boss.minion?.maxHp} / æ”»å‡»:{boss.minion?.attack})
                        </span>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {/* èŒƒå…‹é‡Œå¤«çš„æŠ€èƒ½ */}
                                {bossId === 'vancleef' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,100,100,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                âš”ï¸ è‡´æ­»æ‰“å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹ç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.mortalStrikeMultiplier}å€</span> æ”»å‡»ä¼¤å®³
                                                <br/>
                                                <span style={{ color: '#ff6b6b' }}>
                            å¹¶é™ä½ç›®æ ‡å—åˆ°æ²»ç–—æ•ˆæœ {(boss.mortalStrikeDebuff?.healingReduction || 0.5) * 100}%ï¼ŒæŒç»­{boss.mortalStrikeDebuff?.duration || 2}å›åˆ
                        </span>
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ”« ç«ç‚®æ‰‹å‡†å¤‡ï¼
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}</span> ä¸ª{boss.minion?.name || 'ç«ç‚®æ‰‹'}
                                                <br/>
                                                <span style={{ color: '#888' }}>
                            (HP:{boss.minion?.maxHp} / æ¯å›åˆå¯¹å…¨é˜Ÿé€ æˆBossæ”»å‡»Ã—{boss.minion?.aoeDamageMultiplier}ä¼¤å®³)
                        </span>
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ›¡ï¸ ç™»ä¸Šç”²æ¿ï¼
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å‘½ä»¤æ‰€æœ‰ç«ç‚®æ‰‹ç™»ä¸Šç”²æ¿
                                                <br/>
                                                <span style={{ color: '#2196F3' }}>
                            ç«ç‚®æ‰‹å…ç–«ä»»ä½•ä¼¤å®³
                        </span>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {bossId === 'prestor_lady' && (
                                    <div style={{
                                        marginTop: 12,
                                        padding: 12,
                                        background: 'rgba(120,30,30,0.12)',
                                        borderRadius: 8,
                                        border: '1px solid rgba(255,80,80,0.25)'
                                    }}>
                                        <div style={{ fontSize: 12, color: '#ffb3b3', fontWeight: 700, marginBottom: 8 }}>
                                            ğŸ‰ éšè—ä¸–ç•ŒBossï¼šæ™®ç‘æ–¯æ‰˜å¥³å£«ï¼ˆé»‘é¾™åŒ–èº«ï¼‰
                                        </div>

                                        <div style={{ display: 'grid', gap: 10, fontSize: 11, color: '#ddd', lineHeight: 1.6 }}>
                                            <div style={{ padding: 10, background: 'rgba(0,0,0,0.25)', borderRadius: 6 }}>
                                                <div style={{ color: '#ffd700', fontWeight: 700, marginBottom: 4 }}>æŠ€èƒ½1ï¼šè°æŠ¥</div>
                                                <div>
                                                    å¯¹å½“å‰ç›®æ ‡åŠå‘¨å›´é˜Ÿå‹é€ æˆæ€»è®¡ <b>Bossæ”»å‡»åŠ›Ã—{boss.espionageDamageMultiplier ?? 10}</b> çš„æš—å½±ä¼¤å®³ã€‚<br/>
                                                    <span style={{ color: '#aaa' }}>åˆ†æ•£ç«™ä½ï¼šåªå‘½ä¸­1å·ä½ï¼›é›†ä¸­ç«™ä½ï¼šå­˜æ´»æˆå‘˜åˆ†æ‘Šã€‚</span>
                                                </div>
                                            </div>

                                            <div style={{ padding: 10, background: 'rgba(0,0,0,0.25)', borderRadius: 6 }}>
                                                <div style={{ color: '#ffd700', fontWeight: 700, marginBottom: 4 }}>æŠ€èƒ½2ï¼šé»‘é¾™ä¹‹ç‚</div>
                                                <div>
                                                    å¯¹æ‰€æœ‰è§’è‰²æ–½åŠ  <b>1å±‚</b> é»‘é¾™ä¹‹ç‚ï¼ˆå¯å åŠ ï¼‰ã€‚æ¯å›åˆæŸå¤±
                                                    <b> Bossæ”»å‡»åŠ›Ã—{boss.blackFlameDoTMultiplier ?? 0.2}Ã—å±‚æ•°</b>ã€‚<br/>
                                                    <span style={{ color: '#aaa' }}>é»˜è®¤æŒç»­æ•´åœºæˆ˜æ–—ï¼ˆæ°¸ä¹…DOTï¼‰ã€‚</span>
                                                </div>
                                            </div>

                                            <div style={{ padding: 10, background: 'rgba(0,0,0,0.25)', borderRadius: 6 }}>
                                                <div style={{ color: '#ffd700', fontWeight: 700, marginBottom: 4 }}>æŠ€èƒ½3ï¼šå°–ç‰™ä¸åˆ©çˆª</div>
                                                <div>
                                                    å¯¹1å·ä½é€ æˆ <b>Bossæ”»å‡»åŠ›Ã—{boss.fangsMultiplier ?? 3}</b> çš„ç‰©ç†ä¼¤å®³ï¼Œé™„åŠ æµè¡€ã€‚<br/>
                                                    æµè¡€ï¼šæ¯å›åˆ <b>Bossæ”»å‡»åŠ›Ã—{boss.bleedDoTMultiplier ?? 0.8}</b>ï¼ŒæŒç»­ <b>{boss.bleedDuration ?? 3}</b> å›åˆã€‚
                                                </div>
                                            </div>

                                        </div>
                                    </div>
                                )}

                                {bossId === 'thalnos' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸŒ€ çµé­‚å¼ºé£
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹ç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.soulStormMultiplier}å€</span> æ”»å‡»çš„æš—å½±ä¼¤å®³
                                                <br/>
                                                å¹¶æ–½åŠ DOTï¼šæ¯å›åˆ <span style={{ color: '#ffd700' }}>{boss.soulStormDoTMultiplier}å€</span> æ”»å‡»ä¼¤å®³ï¼ŒæŒç»­ {boss.soulStormDoTDuration} å›åˆ
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>é›†ä¸­ç«™ä½ï¼šå¯¹æ‰€æœ‰ç›®æ ‡ç”Ÿæ•ˆ</span>
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ‘» æ”¾é€çµé­‚
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.banishSoulMultiplier}å€</span> æ”»å‡»çš„æš—å½±ä¼¤å®³
                                                <br/>
                                                <span style={{ color: '#f44336' }}>å¹¶ä½¿ç›®æ ‡ã€ææƒ§ã€‘ï¼Œæ— æ³•è¡ŒåŠ¨ {boss.fearDuration} å›åˆ</span>
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                âš”ï¸ å •è½çš„åå­—å†›
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}</span> ä¸ª{boss.minion?.name}
                                                <br/>
                                                <span style={{ color: '#888' }}>
                                                    (HP:{boss.minion?.maxHp} / æ”»å‡»:ç­‰äºBossæ”»å‡»)
                                                </span>
                                                <br/>
                                                åå­—å†›åªæ”»å‡»1å·ä½ï¼ˆå¦å…‹ï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,152,0,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #ff9800'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ffb74d', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ’€ çµé­‚æ”¶å‰²è€…
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹æ‰€æœ‰ç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>(å½“å‰å­˜æ´»åå­—å†›æ•°é‡ + {boss.soulReaperBaseMultiplier}) Ã— Bossæ”»å‡»</span> çš„æš—å½±ä¼¤å®³
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>åå­—å†›è¶Šå¤šï¼Œä¼¤å®³è¶Šé«˜ï¼</span>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {bossId === 'dagran_thaurissan' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,152,0,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #ff9800'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ffb74d', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ”¥ çƒˆç„°æ‰“å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å½“å‰å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.flameStrikeFireMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                å¹¶é¢å¤–é€ æˆ <span style={{ color: '#ffd700' }}>{boss.flameStrikePhysicalMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆå¯è¢«æŠ¤ç”²/æ ¼æŒ¡å‡å…ï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸŒ‹ ç†”å²©çˆ†è£‚
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.lavaBurstMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                å¹¶æ–½åŠ ã€ç¼çƒ§ã€‘DOTï¼šæ¯å›åˆ <span style={{ color: '#ffd700' }}>{boss.burnDoTMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°ä¼¤å®³ï¼ŒæŒç»­ {boss.burnDoTDuration} å›åˆ
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ“£ æˆ˜æ–—æ€’å¼
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                æœ¬åœºæˆ˜æ–— Boss æ”»å‡»æé«˜ <span style={{ color: '#ffd700' }}>{Math.round((boss.battleShoutAttackPct || 0.1) * 100)}%</span>ï¼ˆå¯å åŠ ï¼‰ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸ
                                            </div>
                                        </div>
                                    </>
                                )}


                                {bossId === 'darkmaster_gandling' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ¹ æš—å½±ç®­
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å½“å‰å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.shadowBoltMultiplier}å€</span> Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ‘¥ å¬å”¤äº¡çµå­¦å¾’
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}</span> ä¸ª{boss.minion?.name}
                                                <br/>
                                                <span style={{ color: '#888' }}>
                    (HP:{boss.minion?.maxHp} / æ”»å‡»&é˜²å¾¡: ç­‰äºBoss)
                </span>
                                                <br/>
                                                å­¦å¾’æ¯å›åˆå¯¹éšæœºç›®æ ‡é‡Šæ”¾ã€æš—å½±ç®­ã€‘ï¼šé€ æˆ <span style={{ color: '#ffd700' }}>{boss.minionShadowBoltMultiplier}å€</span> Bossæ”»å‡» çš„æš—å½±ä¼¤å®³
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ•¯ï¸ æš—å½±è¯…å’’
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹éšæœºç›®æ ‡æ–½åŠ <span style={{ color: '#ffd700' }}>è¯…å’’</span>ï¼šé­”æ³•æŠ—æ€§é™ä½ <span style={{ color: '#ffd700' }}>{boss.shadowCurseMagicResistDown}</span>
                                                ï¼ŒæŒç»­ {boss.shadowCurseDuration} å›åˆ
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>é­”æŠ—å¯ä¸ºè´Ÿï¼ŒæŒ‰å…¬å¼è®¡ç®—å¢ä¼¤</span>
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(0,0,0,0.22)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #673ab7'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#b388ff', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸŒªï¸ é»‘æš—é£æš´
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹ç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.darkStormMultiplier}å€</span> Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>é›†ä¸­ç«™ä½ï¼šå¯¹æ‰€æœ‰ç›®æ ‡ç”Ÿæ•ˆ</span>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {bossId === 'baron_rivendare' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸª“ é¡ºåŠˆæ–©
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                <span style={{ color: '#ff9800' }}>åˆ†æ•£ç«™ä½ï¼š</span>å¯¹å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.cleaveMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡å¯å‡å…ï¼‰
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>é›†ä¸­ç«™ä½ï¼š</span>å¯¹æ‰€æœ‰è§’è‰²é€ æˆ <span style={{ color: '#ffd700' }}>{boss.cleaveMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(0,0,0,0.22)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #673ab7'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#b388ff', fontWeight: 600, marginBottom: 4 }}>
                                                â˜ ï¸ è‡´æ­»æ‰“å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.mortalStrikeMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                                <br/>
                                                å¹¶æ–½åŠ <span style={{ color: '#ffd700' }}>å‡ç–—</span>ï¼šæ²»ç–—é‡é™ä½ <span style={{ color: '#ffd700' }}>{Math.round((boss.mortalStrikeDebuff?.healingReduction ?? 0.5) * 100)}%</span>ï¼ŒæŒç»­ {boss.mortalStrikeDebuff?.duration ?? 2} å›åˆ
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ•¯ï¸ æš—å½±éœ‡å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.shadowShockMultiplier}å€</span> Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                å¹¶æ–½åŠ DOTï¼šæ¯å›åˆ <span style={{ color: '#ffd700' }}>{boss.shadowShockDotMultiplier}å€</span> Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ŒæŒç»­ {boss.shadowShockDotDuration} å›åˆ
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ’€ å¬å”¤éª·é«…å¤§å†›
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}</span> ä¸ª{boss.minion?.name}
                                                <br/>
                                                éª·é«…æ¯å›åˆå¯¹å¦å…‹æŒ¥ç ï¼šé€ æˆ <span style={{ color: '#ffd700' }}>{boss.skeletonSlashMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                            </div>
                                        </div>
                                    </>
                                )}

                                {bossId === 'rend_blackhand' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,87,34,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #ff5722'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ffab91', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ”¥ çƒˆç„°åæ¯
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å½“å‰å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.flameBreathMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡å¯å‡å…ï¼‰
                                                <br/>
                                                å¹¶å¯¹<span style={{ color: '#ff9800' }}>æ‰€æœ‰è§’è‰²</span>é€ æˆä¸€æ¬¡ç­‰åŒäºâ€œå¦å…‹å®é™…æ‰¿ä¼¤â€çš„<span style={{ color: '#ff9800' }}>ç«ç„°ä¼¤å®³</span>ï¼ˆå„è‡ªè®¡ç®—é­”æŠ—ï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸª“ é¡ºåŠˆæ–©
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                <span style={{ color: '#ff9800' }}>åˆ†æ•£ç«™ä½ï¼š</span>å¯¹å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.cleaveMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡å¯å‡å…ï¼‰
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>é›†ä¸­ç«™ä½ï¼š</span>å¯¹æ‰€æœ‰è§’è‰²é€ æˆ <span style={{ color: '#ffd700' }}>{boss.cleaveMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ¦˜ è·³è·ƒæ–©å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                <span style={{ color: '#ff9800' }}>é›†ä¸­ç«™ä½ï¼š</span>å¯¹å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.leapSlashMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>åˆ†æ•£ç«™ä½ï¼š</span>å¯¹<span style={{ color: '#ffd700' }}>é™¤å¦å…‹å¤–</span>çš„éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.leapSlashMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                            </div>
                                        </div>
                                    </>
                                )}

                            </div>

                            <div style={{
                                marginTop: 12,
                                padding: 10,
                                background: 'rgba(255,215,0,0.1)',
                                borderRadius: 6,
                                border: '1px dashed rgba(255,215,0,0.3)'
                            }}>
                                <div style={{ fontSize: 11, color: '#c9a227', fontWeight: 600, marginBottom: 4 }}>
                                    ğŸ”„ æŠ€èƒ½å¾ªç¯
                                </div>
                                <div style={{ fontSize: 11, color: '#888' }}>
                                    {bossId === 'hogger' && 'å¬å”¤ â†’ é‡å‡» â†’ é‡å‡» â†’ é‡å‡» â†’ å¾ªç¯'}
                                    {bossId === 'vancleef' && 'è‡´æ­»æ‰“å‡» â†’ ç«ç‚®æ‰‹å‡†å¤‡ â†’ è‡´æ­»æ‰“å‡» â†’ ç™»ä¸Šç”²æ¿ â†’ å¾ªç¯'}
                                    {bossId !== 'hogger' && bossId !== 'vancleef' && (formatBossCycle(boss) || 'æœªçŸ¥')}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* ==================== å³ä¾§ï¼šé˜Ÿä¼é…ç½®åŒº ==================== */}
                    <div style={{
                        padding: 20,
                        display: 'flex',
                        flexDirection: 'column',
                        gap: 16
                    }}>
                        {/* é˜Ÿä¼é…ç½® */}
                        <div style={{
                            background: 'rgba(0,0,0,0.2)',
                            borderRadius: 10,
                            padding: 16,
                            border: '1px solid rgba(201,162,39,0.2)'
                        }}>
                            <div style={{
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center',
                                marginBottom: 12
                            }}>
                                <div style={{
                                    fontSize: 14,
                                    color: '#c9a227',
                                    fontWeight: 600
                                }}>
                                    âš”ï¸ é˜Ÿä¼é˜µå®¹
                                </div>
                                <div style={{
                                    fontSize: 11,
                                    color: '#888',
                                    padding: '4px 10px',
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: 4
                                }}>
                                    ä½ç½®1ä¼˜å…ˆå—åˆ°æ”»å‡»
                                </div>
                            </div>

                            <div style={{
                                display: 'grid',
                                gridTemplateColumns: 'repeat(3, 1fr)',
                                gap: 12
                            }}>
                                {[0, 1, 2].map(slot => {
                                    const charId = state.bossTeam[slot];
                                    const char = charId ? state.characters.find(c => c.id === charId) : null;

                                    return (
                                        <div
                                            key={slot}
                                            onDrop={(e) => {
                                                e.preventDefault();
                                                if (dragged) {
                                                    dispatch({ type: 'SET_BOSS_TEAM_SLOT', payload: { slot, charId: dragged } });
                                                }
                                                setDragged(null);
                                            }}
                                            onDragOver={e => e.preventDefault()}
                                            style={{
                                                padding: 16,
                                                borderRadius: 10,
                                                minHeight: 120,
                                                background: char
                                                    ? 'linear-gradient(135deg, rgba(201,162,39,0.15) 0%, rgba(139,115,25,0.1) 100%)'
                                                    : 'rgba(0,0,0,0.3)',
                                                border: char
                                                    ? '2px solid rgba(201,162,39,0.5)'
                                                    : '2px dashed rgba(74,60,42,0.5)',
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                transition: 'all 0.2s',
                                                cursor: 'default'
                                            }}
                                        >
                                            {/* ä½ç½®æ ‡ç­¾ */}
                                            <div style={{
                                                position: 'absolute',
                                                top: 8,
                                                left: 8,
                                                fontSize: 10,
                                                color: slot === 0 ? '#f44336' : '#888',
                                                fontWeight: 600,
                                                padding: '2px 6px',
                                                background: 'rgba(0,0,0,0.4)',
                                                borderRadius: 3
                                            }}>
                                                ä½ç½® {slot + 1} {slot === 0 && '(å¦å…‹ä½)'}
                                            </div>

                                            {char ? (
                                                <>
                                                    <div style={{
                                                        fontSize: 32,
                                                        marginBottom: 8
                                                    }}>
                                                        {char.classId === 'protection_warrior' ? 'ğŸ›¡ï¸' :
                                                            char.classId === 'discipline_priest' ? 'âœï¸' :
                                                                char.classId === 'frost_mage' ? 'â„ï¸' : 'ğŸ‘¤'}
                                                    </div>
                                                    <div style={{
                                                        fontSize: 13,
                                                        color: '#ffd700',
                                                        fontWeight: 600,
                                                        marginBottom: 4
                                                    }}>
                                                        {char.name}
                                                    </div>
                                                    <div style={{ fontSize: 11, color: '#888' }}>
                                                        Lv.{char.level} {CLASSES[char.classId].name}
                                                    </div>
                                                    <div style={{
                                                        fontSize: 10,
                                                        color: '#4CAF50',
                                                        marginTop: 4
                                                    }}>
                                                        HP: {char.stats.maxHp}
                                                    </div>

                                                    {/* ç§»é™¤æŒ‰é’® */}
                                                    <button
                                                        onClick={() => dispatch({
                                                            type: 'SET_BOSS_TEAM_SLOT',
                                                            payload: { slot, charId: null }
                                                        })}
                                                        style={{
                                                            position: 'absolute',
                                                            top: 8,
                                                            right: 8,
                                                            background: 'rgba(244,67,54,0.3)',
                                                            border: '1px solid rgba(244,67,54,0.5)',
                                                            borderRadius: 4,
                                                            color: '#f44336',
                                                            fontSize: 10,
                                                            padding: '2px 6px',
                                                            cursor: 'pointer'
                                                        }}
                                                    >
                                                        âœ•
                                                    </button>
                                                </>
                                            ) : (
                                                <>
                                                    <div style={{
                                                        fontSize: 32,
                                                        opacity: 0.3,
                                                        marginBottom: 8
                                                    }}>
                                                        â•
                                                    </div>
                                                    <div style={{
                                                        fontSize: 11,
                                                        color: '#555',
                                                        textAlign: 'center'
                                                    }}>
                                                        æ‹–æ‹½è§’è‰²åˆ°æ­¤å¤„
                                                    </div>
                                                </>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>

                            {/* é˜Ÿä¼æ€»å±æ€§ */}
                            {teamStats.count > 0 && (
                                <div style={{
                                    marginTop: 12,
                                    padding: 10,
                                    background: 'rgba(76,175,80,0.1)',
                                    borderRadius: 6,
                                    border: '1px solid rgba(76,175,80,0.2)',
                                    display: 'flex',
                                    justifyContent: 'space-around'
                                }}>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>é˜Ÿä¼æ€»HP</div>
                                        <div style={{ fontSize: 14, color: '#4CAF50', fontWeight: 600 }}>
                                            {teamStats.totalHp.toLocaleString()}
                                        </div>
                                    </div>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>æ€»æ”»å‡»</div>
                                        <div style={{ fontSize: 14, color: '#ff9800', fontWeight: 600 }}>
                                            {teamStats.totalAttack}
                                        </div>
                                    </div>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>æ€»æ³•å¼º</div>
                                        <div style={{ fontSize: 14, color: '#2196F3', fontWeight: 600 }}>
                                            {teamStats.totalSpellPower}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* å¯ç”¨è§’è‰²åˆ—è¡¨ */}
                        <div style={{
                            background: 'rgba(0,0,0,0.2)',
                            borderRadius: 10,
                            padding: 16,
                            border: '1px solid rgba(201,162,39,0.2)',
                            flex: 1
                        }}>
                            <div style={{
                                fontSize: 14,
                                color: '#c9a227',
                                fontWeight: 600,
                                marginBottom: 12
                            }}>
                                ğŸ‘¥ å¯ç”¨è§’è‰² <span style={{ color: '#888', fontWeight: 400 }}>ï¼ˆæ‹–æ‹½åˆ°ä¸Šæ–¹é˜Ÿä¼ä½ç½®ï¼‰</span>
                            </div>

                            {available.length === 0 ? (
                                <div style={{
                                    textAlign: 'center',
                                    padding: 30,
                                    color: '#555'
                                }}>
                                    æ²¡æœ‰å¯ç”¨è§’è‰²ï¼ˆè§’è‰²å¯èƒ½å·²è¢«æ´¾é£åˆ°å…¶ä»–åŒºåŸŸï¼‰
                                </div>
                            ) : (
                                <div style={{
                                    display: 'grid',
                                    gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))',
                                    gap: 10,
                                    maxHeight: 200,
                                    overflowY: 'auto',
                                    padding: 4
                                }}>
                                    {available.map(char => {
                                        const isInTeam = state.bossTeam.includes(char.id);
                                        return (
                                            <div
                                                key={char.id}
                                                draggable={!isInTeam}
                                                onDragStart={() => !isInTeam && setDragged(char.id)}
                                                style={{
                                                    padding: 12,
                                                    background: isInTeam
                                                        ? 'rgba(76,175,80,0.1)'
                                                        : 'rgba(0,0,0,0.3)',
                                                    border: isInTeam
                                                        ? '1px solid rgba(76,175,80,0.3)'
                                                        : '1px solid rgba(74,60,42,0.5)',
                                                    borderRadius: 8,
                                                    cursor: isInTeam ? 'default' : 'grab',
                                                    opacity: isInTeam ? 0.6 : 1,
                                                    transition: 'all 0.15s',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: 10
                                                }}
                                            >
                                                <div style={{ fontSize: 24 }}>
                                                    {char.classId === 'protection_warrior' ? 'ğŸ›¡ï¸' :
                                                        char.classId === 'discipline_priest' ? 'âœï¸' :
                                                            char.classId === 'frost_mage' ? 'â„ï¸' : 'ğŸ‘¤'}
                                                </div>
                                                <div>
                                                    <div style={{
                                                        fontSize: 12,
                                                        color: isInTeam ? '#4CAF50' : '#ffd700',
                                                        fontWeight: 600
                                                    }}>
                                                        {char.name} {isInTeam && 'âœ“'}
                                                    </div>
                                                    <div style={{ fontSize: 10, color: '#888' }}>
                                                        Lv.{char.level} {CLASSES[char.classId].name}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                        </div>

                        {/* æˆ˜æ–—ç­–ç•¥ */}
                        <div style={{
                            background: 'rgba(0,0,0,0.2)',
                            borderRadius: 10,
                            padding: 16,
                            border: '1px solid rgba(201,162,39,0.2)'
                        }}>
                            <div style={{
                                fontSize: 14,
                                color: '#c9a227',
                                fontWeight: 600,
                                marginBottom: 12
                            }}>
                                âš™ï¸ æˆ˜æ–—ç­–ç•¥
                            </div>

                            <div style={{
                                display: 'grid',
                                gridTemplateColumns: '1fr 1fr',
                                gap: 16
                            }}>
                                {/* æ”»å‡»ä¼˜å…ˆçº§ */}
                                <div style={{
                                    padding: 12,
                                    background: 'rgba(0,0,0,0.2)',
                                    borderRadius: 8,
                                    border: '1px solid rgba(74,60,42,0.3)'
                                }}>
                                    <div style={{ fontSize: 12, color: '#888', marginBottom: 8 }}>
                                        æ”»å‡»ä¼˜å…ˆçº§
                                    </div>
                                    <div style={{ display: 'flex', gap: 8 }}>
                                        <label style={{
                                            flex: 1,
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: 6,
                                            padding: '8px 12px',
                                            background: state.bossStrategy.priorityBoss
                                                ? 'rgba(244,67,54,0.15)'
                                                : 'rgba(0,0,0,0.2)',
                                            border: state.bossStrategy.priorityBoss
                                                ? '1px solid rgba(244,67,54,0.4)'
                                                : '1px solid transparent',
                                            borderRadius: 6,
                                            cursor: 'pointer',
                                            fontSize: 11
                                        }}>
                                            <input
                                                type="radio"
                                                name="priority"
                                                checked={state.bossStrategy.priorityBoss}
                                                onChange={() => dispatch({
                                                    type: 'SET_BOSS_STRATEGY',
                                                    payload: { key: 'priorityBoss', value: true }
                                                })}
                                            />
                                            <span style={{ color: state.bossStrategy.priorityBoss ? '#f44336' : '#888' }}>
                                                ğŸ¯ ä¼˜å…ˆBoss
                                            </span>
                                        </label>
                                        <label style={{
                                            flex: 1,
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: 6,
                                            padding: '8px 12px',
                                            background: !state.bossStrategy.priorityBoss
                                                ? 'rgba(156,39,176,0.15)'
                                                : 'rgba(0,0,0,0.2)',
                                            border: !state.bossStrategy.priorityBoss
                                                ? '1px solid rgba(156,39,176,0.4)'
                                                : '1px solid transparent',
                                            borderRadius: 6,
                                            cursor: 'pointer',
                                            fontSize: 11
                                        }}>
                                            <input
                                                type="radio"
                                                name="priority"
                                                checked={!state.bossStrategy.priorityBoss}
                                                onChange={() => dispatch({
                                                    type: 'SET_BOSS_STRATEGY',
                                                    payload: { key: 'priorityBoss', value: false }
                                                })}
                                            />
                                            <span style={{ color: !state.bossStrategy.priorityBoss ? '#ce93d8' : '#888' }}>
                                                ğŸ‘¥ ä¼˜å…ˆå°å¼Ÿ
                                            </span>
                                        </label>
                                    </div>
                                </div>

                                {/* ç«™ä½é€‰æ‹© */}
                                <div style={{
                                    padding: 12,
                                    background: 'rgba(0,0,0,0.2)',
                                    borderRadius: 8,
                                    border: '1px solid rgba(74,60,42,0.3)'
                                }}>
                                    <div style={{ fontSize: 12, color: '#888', marginBottom: 8 }}>
                                        ç«™ä½æ–¹å¼
                                    </div>
                                    <div style={{ display: 'flex', gap: 8 }}>
                                        <label style={{
                                            flex: 1,
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: 6,
                                            padding: '8px 12px',
                                            background: state.bossStrategy.stance === 'concentrated'
                                                ? 'rgba(33,150,243,0.15)'
                                                : 'rgba(0,0,0,0.2)',
                                            border: state.bossStrategy.stance === 'concentrated'
                                                ? '1px solid rgba(33,150,243,0.4)'
                                                : '1px solid transparent',
                                            borderRadius: 6,
                                            cursor: 'pointer',
                                            fontSize: 11
                                        }}>
                                            <input
                                                type="radio"
                                                name="stance"
                                                checked={state.bossStrategy.stance === 'concentrated'}
                                                onChange={() => dispatch({
                                                    type: 'SET_BOSS_STRATEGY',
                                                    payload: { key: 'stance', value: 'concentrated' }
                                                })}
                                            />
                                            <span style={{ color: state.bossStrategy.stance === 'concentrated' ? '#64b5f6' : '#888' }}>
                                                ğŸ“ é›†ä¸­ç«™ä½
                                            </span>
                                        </label>
                                        <label style={{
                                            flex: 1,
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: 6,
                                            padding: '8px 12px',
                                            background: state.bossStrategy.stance === 'dispersed'
                                                ? 'rgba(76,175,80,0.15)'
                                                : 'rgba(0,0,0,0.2)',
                                            border: state.bossStrategy.stance === 'dispersed'
                                                ? '1px solid rgba(76,175,80,0.4)'
                                                : '1px solid transparent',
                                            borderRadius: 6,
                                            cursor: 'pointer',
                                            fontSize: 11
                                        }}>
                                            <input
                                                type="radio"
                                                name="stance"
                                                checked={state.bossStrategy.stance === 'dispersed'}
                                                onChange={() => dispatch({
                                                    type: 'SET_BOSS_STRATEGY',
                                                    payload: { key: 'stance', value: 'dispersed' }
                                                })}
                                            />
                                            <span style={{ color: state.bossStrategy.stance === 'dispersed' ? '#81c784' : '#888' }}>
                                                ğŸ”€ åˆ†æ•£ç«™ä½
                                            </span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                {/* åº•éƒ¨æŒ‰é’®åŒº */}
                <div style={{
                    padding: '16px 24px',
                    borderTop: '1px solid rgba(201,162,39,0.2)',
                    background: 'linear-gradient(180deg, transparent, rgba(139,105,20,0.1))',
                    display: 'flex',
                    justifyContent: 'center',
                    gap: 16
                }}>
                    <Button
                        onClick={() => dispatch({ type: 'START_BOSS_COMBAT' })}
                        disabled={teamStats.count === 0}
                        style={{
                            padding: '12px 40px',
                            fontSize: 16,
                            fontWeight: 700
                        }}
                    >
                        âš”ï¸ å¼€å§‹æˆ˜æ–—
                    </Button>
                    <Button
                        variant="secondary"
                        onClick={() => dispatch({ type: 'CLOSE_BOSS_PREPARE' })}
                        style={{
                            padding: '12px 30px'
                        }}
                    >
                        å–æ¶ˆ
                    </Button>
                </div>

                {/* åº•éƒ¨è£…é¥°æ¡ */}
                <div style={{
                    height: 4,
                    background: 'linear-gradient(90deg, transparent, #c9a227, #ffd700, #c9a227, transparent)',
                    borderRadius: '0 0 16px 16px'
                }} />
            </div>
        </div>
    );
};

// ==================== Bossæˆ˜æ–—æ˜¾ç¤ºæ¨¡æ€ ====================
const BossCombatModal = ({ combat, state }) => {
    if (!combat) return null;
    const boss = BOSS_DATA[combat.bossId];
    if (!boss) return null;

    const minionConfig = boss.minion || { name: 'å°å¼Ÿ', maxHp: 100 };
    const minionName = minionConfig.name || 'å°å¼Ÿ';

    // è®¡ç®—å­˜æ´»äººæ•°
    const aliveCount = combat.playerStates.filter(p => p.currentHp > 0).length;
    const totalCount = combat.playerStates.length;

    return (
        <div style={{
            position: 'fixed',
            top: '50%', left: '50%',
            transform: 'translate(-50%, -50%)',
            width: '90%',
            maxWidth: 1200,
            height: '90%',
            background: 'linear-gradient(135deg, rgba(30,15,15,0.98) 0%, rgba(15,8,8,0.99) 100%)',
            display: 'flex',
            flexDirection: 'column',
            zIndex: 1000,
            border: '4px solid #c9a227',
            borderRadius: 16,
            overflow: 'hidden',
            boxShadow: '0 0 60px rgba(201,162,39,0.4), inset 0 0 100px rgba(0,0,0,0.5)'
        }}>
            {/* é¡¶éƒ¨æ ‡é¢˜æ  */}
            <div style={{
                padding: '16px 24px',
                textAlign: 'center',
                background: 'linear-gradient(180deg, rgba(139,105,20,0.2) 0%, transparent 100%)',
                borderBottom: '1px solid rgba(201,162,39,0.3)'
            }}>
                <div style={{
                    fontSize: 12,
                    color: '#888',
                    letterSpacing: 3,
                    marginBottom: 6
                }}>
                    âš”ï¸ ä¸–ç•Œé¦–é¢†æˆ˜æ–—è¿›è¡Œä¸­ âš”ï¸
                </div>
                <div style={{
                    fontSize: 28,
                    color: '#ffd700',
                    fontWeight: 700,
                    textShadow: '0 0 20px rgba(255,215,0,0.5), 2px 2px 4px rgba(0,0,0,0.8)'
                }}>
                    {boss.name}
                </div>
                <div style={{
                    marginTop: 8,
                    display: 'flex',
                    justifyContent: 'center',
                    gap: 20,
                    fontSize: 13
                }}>
                    <span style={{ color: '#4CAF50' }}>
                        ç¬¬ <span style={{ fontSize: 18, fontWeight: 700 }}>{combat.round}</span> å›åˆ
                    </span>
                    <span style={{ color: '#888' }}>|</span>
                    <span style={{ color: aliveCount > 0 ? '#4CAF50' : '#f44336' }}>
                        å­˜æ´»: {aliveCount}/{totalCount}
                    </span>
                </div>
            </div>

            {/* ä¸»æˆ˜æ–—åŒºåŸŸ */}
            <div style={{
                display: 'grid',
                gridTemplateColumns: '1fr 1fr',
                gap: 0,
                flex: 1,
                overflow: 'hidden'
            }}>
                {/* å·¦ä¾§ï¼šæˆ‘æ–¹é˜Ÿä¼ */}
                <div style={{
                    borderRight: '1px solid rgba(201,162,39,0.2)',
                    padding: 20,
                    overflowY: 'auto',
                    background: 'linear-gradient(135deg, rgba(76,175,80,0.05) 0%, transparent 100%)'
                }}>
                    <h3 style={{
                        color: '#4CAF50',
                        marginBottom: 16,
                        paddingBottom: 10,
                        borderBottom: '1px solid rgba(76,175,80,0.3)',
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span style={{ fontSize: 20 }}>ğŸ›¡ï¸</span>
                        æˆ‘æ–¹é˜Ÿä¼
                    </h3>

                    {combat.playerStates.map((p, i) => {
                        // âœ… å…³é”®ä¿®å¤ï¼šç¡®ä¿æ˜¾ç¤ºçš„è¡€é‡ä¸å°äº0
                        const displayHp = Math.max(0, Math.floor(p.currentHp));
                        const maxHp = p.char.stats.maxHp || 1;
                        const isDead = p.currentHp <= 0;
                        const hpPercent = Math.max(0, Math.min(100, (displayHp / maxHp) * 100));

                        // æ ¹æ®è¡€é‡ç™¾åˆ†æ¯”å†³å®šé¢œè‰²
                        const getHpColor = () => {
                            if (isDead) return '#666';
                            if (hpPercent > 50) return '#4CAF50';
                            if (hpPercent > 25) return '#ff9800';
                            return '#f44336';
                        };

                        return (
                            <div
                                key={i}
                                style={{
                                    marginBottom: 16,
                                    padding: 14,
                                    background: isDead
                                        ? 'rgba(0,0,0,0.4)'
                                        : 'rgba(0,0,0,0.25)',
                                    borderRadius: 10,
                                    border: isDead
                                        ? '1px solid rgba(100,100,100,0.3)'
                                        : '1px solid rgba(76,175,80,0.2)',
                                    opacity: isDead ? 0.6 : 1,
                                    transition: 'all 0.3s',
                                    position: 'relative',
                                    overflow: 'hidden'
                                }}
                            >
                                {/* æ­»äº¡é®ç½© */}
                                {isDead && (
                                    <div style={{
                                        position: 'absolute',
                                        top: 0,
                                        left: 0,
                                        right: 0,
                                        bottom: 0,
                                        background: 'repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(0,0,0,0.1) 10px, rgba(0,0,0,0.1) 20px)',
                                        pointerEvents: 'none',
                                        zIndex: 1
                                    }} />
                                )}

                                {/* è§’è‰²ä¿¡æ¯å¤´éƒ¨ */}
                                <div style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    marginBottom: 10,
                                    position: 'relative',
                                    zIndex: 2
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                                        {/* ä½ç½®æ ‡è¯† */}
                                        <div style={{
                                            width: 28,
                                            height: 28,
                                            borderRadius: '50%',
                                            background: isDead
                                                ? 'rgba(100,100,100,0.3)'
                                                : i === 0
                                                    ? 'linear-gradient(135deg, #f44336, #c62828)'
                                                    : 'linear-gradient(135deg, #4CAF50, #2e7d32)',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            fontSize: 12,
                                            fontWeight: 700,
                                            color: '#fff',
                                            boxShadow: isDead ? 'none' : '0 2px 8px rgba(0,0,0,0.3)'
                                        }}>
                                            {i + 1}
                                        </div>

                                        {/* èŒä¸šå›¾æ ‡ */}
                                        <span style={{ fontSize: 20, filter: isDead ? 'grayscale(100%)' : 'none' }}>
                                            {p.char.classId === 'protection_warrior' ? 'ğŸ›¡ï¸' :
                                                p.char.classId === 'discipline_priest' ? 'âœï¸' :
                                                    p.char.classId === 'frost_mage' ? 'â„ï¸' : 'ğŸ‘¤'}
                                        </span>

                                        {/* åå­—å’Œç­‰çº§ */}
                                        <div>
                                            <div style={{
                                                fontSize: 14,
                                                fontWeight: 600,
                                                color: isDead ? '#888' : '#ffd700'
                                            }}>
                                                {p.char.name}
                                            </div>
                                            <div style={{ fontSize: 11, color: '#888' }}>
                                                Lv.{p.char.level} {CLASSES[p.char.classId]?.name || ''}
                                            </div>
                                        </div>
                                    </div>

                                    {/* çŠ¶æ€æ ‡ç­¾ */}
                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end', gap: 4 }}>
                                        {isDead ? (
                                            <span style={{
                                                padding: '4px 10px',
                                                background: 'linear-gradient(135deg, rgba(100,100,100,0.4), rgba(60,60,60,0.4))',
                                                borderRadius: 4,
                                                fontSize: 12,
                                                fontWeight: 700,
                                                color: '#aaa',
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: 4,
                                                border: '1px solid rgba(100,100,100,0.3)'
                                            }}>
                                                ğŸ’€ æ­»äº¡
                                            </span>
                                        ) : (
                                            <>
                                                {/* å‡ç–—debuff */}
                                                {p.debuffs?.mortalStrike && (
                                                    <span style={{
                                                        padding: '3px 8px',
                                                        background: 'rgba(255,100,100,0.2)',
                                                        borderRadius: 4,
                                                        fontSize: 10,
                                                        color: '#ff6b6b',
                                                        border: '1px solid rgba(255,100,100,0.3)'
                                                    }}>
                                                        ğŸ©¸ å‡ç–— {(p.debuffs.mortalStrike.healingReduction * 100)}% ({p.debuffs.mortalStrike.duration}å›åˆ)
                                                    </span>
                                                )}

                                                {/* ææƒ§debuff */}
                                                {p.debuffs?.fear && (
                                                    <span style={{
                                                        padding: '3px 8px',
                                                        background: 'rgba(180,120,255,0.18)',
                                                        borderRadius: 4,
                                                        fontSize: 10,
                                                        color: '#c6a0ff',
                                                        border: '1px solid rgba(180,120,255,0.28)'
                                                    }}>
                                                        ğŸ˜± ææƒ§ ({p.debuffs.fear.duration}å›åˆ)
                                                    </span>
                                                )}

                                                {/* Buffæ˜¾ç¤º */}
                                                {p.buffs && p.buffs.length > 0 && (
                                                    <div style={{ display: 'flex', gap: 4 }}>
                                                        {p.buffs.slice(0, 3).map((buff, bi) => (
                                                            <span key={bi} style={{
                                                                padding: '2px 6px',
                                                                background: 'rgba(76,175,80,0.2)',
                                                                borderRadius: 3,
                                                                fontSize: 9,
                                                                color: '#4CAF50'
                                                            }}>
                                                                {buff.type === 'icy_veins' ? 'â„ï¸' : 'âœ¨'} {buff.duration}
                                                            </span>
                                                        ))}
                                                    </div>
                                                )}
                                            </>
                                        )}
                                    </div>
                                </div>

                                {/* âœ… ç¾åŒ–åçš„è¡€æ¡ */}
                                <div style={{ position: 'relative', zIndex: 2 }}>
                                    <div style={{
                                        display: 'flex',
                                        justifyContent: 'space-between',
                                        fontSize: 11,
                                        color: isDead ? '#666' : '#aaa',
                                        marginBottom: 4
                                    }}>
                                        <span>ç”Ÿå‘½å€¼</span>
                                        <span style={{
                                            color: isDead ? '#666' : getHpColor(),
                                            fontWeight: 600
                                        }}>
                                            {/* âœ… å…³é”®ï¼šæ˜¾ç¤º0è€Œä¸æ˜¯è´Ÿæ•° */}
                                            {displayHp} / {Math.floor(maxHp)}
                                            {isDead && ' (æ­»äº¡)'}
                                        </span>
                                    </div>
                                    <div style={{
                                        height: 12,
                                        background: 'rgba(0,0,0,0.5)',
                                        borderRadius: 6,
                                        overflow: 'hidden',
                                        border: '1px solid rgba(255,255,255,0.1)',
                                        boxShadow: 'inset 0 2px 4px rgba(0,0,0,0.3)'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            // âœ… å…³é”®ï¼šè¡€æ¡å®½åº¦åŸºäºä¿®æ­£åçš„ç™¾åˆ†æ¯”
                                            width: `${hpPercent}%`,
                                            background: isDead
                                                ? '#444'
                                                : `linear-gradient(90deg, ${getHpColor()}, ${getHpColor()}cc)`,
                                            transition: 'width 0.3s ease-out, background 0.3s',
                                            boxShadow: isDead ? 'none' : `0 0 10px ${getHpColor()}66`,
                                            borderRadius: 6
                                        }} />
                                    </div>
                                </div>

                                {/* å¯’å†°æŒ‡/ç¥¸ç¦ç›¸ä¾/å¹»æƒ³æ›²å±‚æ•°æ˜¾ç¤º */}
                                {!isDead && (p.fingersOfFrost > 0 || p.fortuneMisfortuneStacks > 0 || (p.fantasiaStacks || 0) > 0) && (
                                    <div style={{
                                        marginTop: 8,
                                        display: 'flex',
                                        gap: 8,
                                        position: 'relative',
                                        zIndex: 2
                                    }}>
                                        {p.fingersOfFrost > 0 && (
                                            <span style={{
                                                padding: '2px 8px',
                                                background: 'rgba(33,150,243,0.2)',
                                                borderRadius: 4,
                                                fontSize: 10,
                                                color: '#64b5f6',
                                                border: '1px solid rgba(33,150,243,0.3)'
                                            }}>
                                                â„ï¸ å¯’å†°æŒ‡ Ã—{p.fingersOfFrost}
                                            </span>
                                        )}
                                        {p.fortuneMisfortuneStacks > 0 && (
                                            <span style={{
                                                padding: '2px 8px',
                                                background: 'rgba(255,215,0,0.2)',
                                                borderRadius: 4,
                                                fontSize: 10,
                                                color: '#ffd700',
                                                border: '1px solid rgba(255,215,0,0.3)'
                                            }}>
                                                â˜¯ï¸ ç¥¸ç¦ Ã—{p.fortuneMisfortuneStacks}
                                            </span>
                                        )}
                                        {(p.fantasiaStacks || 0) > 0 && (
                                            <span style={{
                                                padding: '2px 8px',
                                                background: 'rgba(156,39,176,0.2)',
                                                borderRadius: 4,
                                                fontSize: 10,
                                                color: '#ce93d8',
                                                border: '1px solid rgba(156,39,176,0.3)'
                                            }}>
                                                ğŸ¼ å¹»æƒ³æ›² Ã—{p.fantasiaStacks}
                                            </span>
                                        )}
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>

                {/* å³ä¾§ï¼šæ•Œäºº */}
                <div style={{
                    padding: 20,
                    overflowY: 'auto',
                    background: 'linear-gradient(135deg, rgba(244,67,54,0.05) 0%, transparent 100%)'
                }}>
                    <h3 style={{
                        color: '#f44336',
                        marginBottom: 16,
                        paddingBottom: 10,
                        borderBottom: '1px solid rgba(244,67,54,0.3)',
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span style={{ fontSize: 20 }}>ğŸ‘¹</span>
                        æ•Œæ–¹å•ä½
                    </h3>

                    {/* Bossè¡€æ¡ */}
                    <div style={{
                        marginBottom: 20,
                        padding: 16,
                        background: 'linear-gradient(135deg, rgba(244,67,54,0.1) 0%, rgba(0,0,0,0.3) 100%)',
                        borderRadius: 12,
                        border: '2px solid rgba(244,67,54,0.3)',
                        boxShadow: '0 4px 20px rgba(244,67,54,0.2)'
                    }}>
                        <div style={{
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            marginBottom: 12
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                                <span style={{ fontSize: 28 }}>ğŸ²</span>
                                <div>
                                    <div style={{
                                        fontSize: 18,
                                        fontWeight: 700,
                                        color: '#ff6b6b',
                                        textShadow: '0 0 10px rgba(255,107,107,0.5)'
                                    }}>
                                        {boss.name}
                                    </div>
                                    <div style={{ fontSize: 11, color: '#888' }}>ä¸–ç•Œé¦–é¢†</div>
                                </div>
                            </div>
                            <div style={{
                                fontSize: 14,
                                color: '#ff6b6b',
                                fontWeight: 600
                            }}>
                                {Math.max(0, Math.floor(combat.bossHp)).toLocaleString()} / {boss.maxHp.toLocaleString()}
                            </div>
                        </div>

                        {/* Bossè¡€æ¡ */}
                        <div style={{
                            height: 20,
                            background: 'rgba(0,0,0,0.5)',
                            borderRadius: 10,
                            overflow: 'hidden',
                            border: '1px solid rgba(255,107,107,0.3)',
                            boxShadow: 'inset 0 2px 6px rgba(0,0,0,0.4)'
                        }}>
                            <div style={{
                                height: '100%',
                                width: `${Math.max(0, Math.min(100, (combat.bossHp / boss.maxHp) * 100))}%`,
                                background: 'linear-gradient(90deg, #f44336, #ff6b6b, #f44336)',
                                transition: 'width 0.3s ease-out',
                                boxShadow: '0 0 15px rgba(244,67,54,0.6)',
                                borderRadius: 10,
                                position: 'relative',
                                overflow: 'hidden'
                            }}>
                                {/* è¡€æ¡é—ªå…‰æ•ˆæœ */}
                                <div style={{
                                    position: 'absolute',
                                    top: 0,
                                    left: 0,
                                    right: 0,
                                    height: '50%',
                                    background: 'linear-gradient(180deg, rgba(255,255,255,0.3), transparent)',
                                    borderRadius: '10px 10px 0 0'
                                }} />
                            </div>
                        </div>

                        {/* Boss DOTæ˜¾ç¤º */}
                        {combat.bossDots && combat.bossDots.length > 0 && (
                            <div style={{
                                marginTop: 10,
                                display: 'flex',
                                flexWrap: 'wrap',
                                gap: 6
                            }}>
                                {combat.bossDots.map((dot, di) => (
                                    <span key={di} style={{
                                        padding: '3px 8px',
                                        background: 'rgba(156,39,176,0.2)',
                                        borderRadius: 4,
                                        fontSize: 10,
                                        color: '#ce93d8',
                                        border: '1px solid rgba(156,39,176,0.3)'
                                    }}>
                                        ğŸ”¥ {dot.name || 'DOT'} ({dot.duration}å›åˆ)
                                    </span>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* å°å¼Ÿ/ç«ç‚®æ‰‹è¡€æ¡ */}
                    {combat.minions && combat.minions.length > 0 && (
                        <div>
                            <div style={{
                                fontSize: 14,
                                marginBottom: 12,
                                color: '#ce93d8',
                                display: 'flex',
                                alignItems: 'center',
                                gap: 8
                            }}>
                                <span style={{ fontSize: 16 }}>ğŸ‘¥</span>
                                {minionName} ({combat.minions.filter(m => m.hp > 0).length}/{combat.minions.length} å­˜æ´»)
                            </div>

                            <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                                {combat.minions.map((m, i) => {
                                    const minionMaxHp = m.maxHp || minionConfig.maxHp;
                                    const minionDisplayHp = Math.max(0, Math.floor(m.hp));
                                    const minionIsDead = m.hp <= 0;
                                    const minionHpPercent = Math.max(0, Math.min(100, (minionDisplayHp / minionMaxHp) * 100));

                                    return (
                                        <div key={i} style={{
                                            padding: 12,
                                            background: minionIsDead
                                                ? 'rgba(0,0,0,0.3)'
                                                : m.immune
                                                    ? 'rgba(33,150,243,0.1)'
                                                    : 'rgba(156,39,176,0.1)',
                                            borderRadius: 8,
                                            border: minionIsDead
                                                ? '1px solid rgba(100,100,100,0.2)'
                                                : m.immune
                                                    ? '1px solid rgba(33,150,243,0.3)'
                                                    : '1px solid rgba(156,39,176,0.3)',
                                            opacity: minionIsDead ? 0.5 : 1
                                        }}>
                                            <div style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'center',
                                                marginBottom: 6
                                            }}>
                                                <span style={{
                                                    fontSize: 12,
                                                    color: minionIsDead ? '#666' : m.immune ? '#64b5f6' : '#ce93d8'
                                                }}>
                                                    {minionName} {i + 1}
                                                    {minionIsDead && ' (æ­»äº¡)'}
                                                </span>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                                                    {/* å…ç–«çŠ¶æ€ */}
                                                    {m.immune && !minionIsDead && (
                                                        <span style={{
                                                            fontSize: 10,
                                                            color: '#2196F3',
                                                            padding: '2px 6px',
                                                            background: 'rgba(33,150,243,0.2)',
                                                            borderRadius: 4,
                                                            fontWeight: 600
                                                        }}>
                                                            ğŸ›¡ï¸ å…ç–«ä¸­
                                                        </span>
                                                    )}
                                                    <span style={{
                                                        fontSize: 11,
                                                        color: minionIsDead ? '#666' : '#aaa'
                                                    }}>
                                                        {minionDisplayHp} / {minionMaxHp}
                                                    </span>
                                                </div>
                                            </div>

                                            {/* å°å¼Ÿè¡€æ¡ */}
                                            <div style={{
                                                height: 8,
                                                background: 'rgba(0,0,0,0.4)',
                                                borderRadius: 4,
                                                overflow: 'hidden'
                                            }}>
                                                <div style={{
                                                    height: '100%',
                                                    width: `${minionHpPercent}%`,
                                                    background: minionIsDead
                                                        ? '#444'
                                                        : m.immune
                                                            ? 'linear-gradient(90deg, #2196F3, #64b5f6)'
                                                            : 'linear-gradient(90deg, #9C27B0, #ce93d8)',
                                                    transition: 'width 0.3s',
                                                    borderRadius: 4
                                                }} />
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                </div>
            </div>

            {/* æˆ˜æ–—æ—¥å¿— */}
            <div style={{
                height: 180,
                overflowY: 'auto',
                padding: '12px 16px',
                background: 'linear-gradient(180deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0.4) 100%)',
                fontSize: 12,
                borderTop: '2px solid rgba(201,162,39,0.3)',
                fontFamily: 'monospace'
            }}>
                <div style={{
                    fontSize: 11,
                    color: '#888',
                    marginBottom: 8,
                    borderBottom: '1px solid rgba(255,255,255,0.1)',
                    paddingBottom: 6
                }}>
                    ğŸ“œ æˆ˜æ–—æ—¥å¿—ï¼ˆæœ€è¿‘200æ¡ï¼‰
                </div>
                {combat.logs.slice(-200).map((log, i) => {
                    // âœ… å…¼å®¹å­—ç¬¦ä¸²å’Œå¯¹è±¡ä¸¤ç§æ ¼å¼
                    const isObject = typeof log === 'object' && log !== null;
                    const round = isObject ? log.round : null;
                    const text = isObject ? log.text : log;

                    return (
                        <div key={i} style={{
                            padding: '3px 0',
                            borderBottom: '1px solid rgba(255,255,255,0.03)',
                            color: text.includes('æ­»äº¡') || text.includes('é˜µäº¡') ? '#f44336' :
                                text.includes('å…ç–«') ? '#2196F3' :
                                    text.includes('è‡´æ­»æ‰“å‡»') ? '#ff6b6b' :
                                        text.includes('ç«ç‚®æ‰‹') || text.includes('å¬å”¤') ? '#ce93d8' :
                                            text.includes('ç™»ä¸Šç”²æ¿') ? '#64b5f6' :
                                                text.includes('æ²»ç–—') || text.includes('æ¢å¤') ? '#4CAF50' :
                                                    text.includes('æš´å‡»') ? '#ff9800' :
                                                        text.includes('èƒœåˆ©') ? '#ffd700' :
                                                            '#ccc'
                        }}>
                            {/* âœ… æ˜¾ç¤ºå›åˆæ•° */}
                            {round && <span style={{ color: '#888' }}>[å›åˆ{round}] </span>}
                            {text}
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

// ==================== éœæ ¼å‰§æƒ…æ¨¡æ€æ¡† ====================
const HoggerPlotModal = ({ state, dispatch }) => {
    if (!state.showHoggerPlot) return null;
    return (
        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }}>
            <div style={{ width: 600, padding: 40, background: '#1a1510', border: '3px solid #c9a227', borderRadius: 12, textAlign: 'center' }}>
                <h2 style={{ color: '#ffd700', marginBottom: 30 }}>è½®å›ä¹‹å§‹</h2>
                <p style={{ fontSize: 16, lineHeight: 1.8, color: '#e8dcc4' }}>
                    ä½ æ„Ÿåˆ°ä¸€é˜µå¤´æ™•ç›®çœ©ï¼Œè¿‡å¾€çš„ç§ç§ç™½é©¹è¿‡éš™ï¼Œç†Ÿæ‚‰çš„æ„Ÿè§‰æ¶Œä¸Šå¿ƒå¤´ï¼Œä»¿ä½›è¿™å·²ç»æ˜¯ä½ æ— æ•°æ¬¡å‡»è´¥è¿‡çš„å¯¹æ‰‹ï¼Œ<br/>
                    è¿™ä¸€ä¸–ä½ å‡»è´¥äº†å¼ºåŠ²çš„å¯¹æ‰‹éœæ ¼ï¼Œä¸‰åå¹´æ²³ä¸œä¸‰åå¹´æ²³è¥¿ï¼Œè«æ¬ºå°‘å¹´ç©·ã€‚
                </p>
                <Button onClick={() => dispatch({ type: 'CLOSE_HOGGER_PLOT' })} style={{ marginTop: 30 }}>
                    ç¡®å®š
                </Button>
            </div>
        </div>
    );
};

// ==================== è¡€è‰²åå­—å†›çš„å¾½ç« æ¨¡æ€æ¡†ï¼ˆé€‰æ‹©ç›®æ ‡è£…å¤‡ï¼‰ ====================
const ScarletBadgeModal = ({ state, dispatch }) => {
    if (!state.showScarletBadgeModal) return null;

    const badgeItemId = state.pendingBadgeItemId || 'IT_SCARLET_CRUSADER_BADGE';
    const rule = BADGE_UPGRADE_RULES?.[badgeItemId] || BADGE_UPGRADE_RULES.IT_SCARLET_CRUSADER_BADGE;

    const [selectedId, setSelectedId] = React.useState('');

    // èƒŒåŒ…é‡Œå¯å‡çº§çš„è¡€è‰²ä¿®é“é™¢è£…å¤‡
    const invCandidates = (state.inventory || [])
        .filter(i => i?.type === 'equipment' && i.instanceId && rule.isEligible(i))
        .map(eq => ({
            instanceId: eq.instanceId,
            label: `ğŸ’ èƒŒåŒ… Â· ${eq.name}ï¼ˆLv.${eq.currentLevel ?? eq.level ?? 0} â†’ Lv.${Math.min(rule.cap ?? 100, (eq.maxLevel ?? 100), (eq.currentLevel ?? eq.level ?? 0) + (rule.inc ?? 2))}ï¼‰`,
            eq
        }));

    // å·²ç©¿æˆ´çš„å¯å‡çº§è£…å¤‡
    const equippedCandidates = [];
    (state.characters || []).forEach(c => {
        Object.values(c.equipment || {}).forEach(eq => {
            if (!eq?.instanceId) return;
            if (!rule.isEligible(eq)) return;
            equippedCandidates.push({
                instanceId: eq.instanceId,
                label: `ğŸ§ ${c.name} Â· ${eq.name}ï¼ˆLv.${eq.currentLevel ?? eq.level ?? 0} â†’ Lv.${Math.min(rule.cap ?? 100, (eq.maxLevel ?? 100), (eq.currentLevel ?? eq.level ?? 0) + (rule.inc ?? 2))}ï¼‰`,
                eq
            });
        });
    });

    // å»é‡ï¼ˆåŒä¸€ä»¶è£…å¤‡ä¸åº”é‡å¤å‡ºç°ï¼‰
    const seen = new Set();
    const candidates = [...invCandidates, ...equippedCandidates].filter(c => {
        if (seen.has(c.instanceId)) return false;
        seen.add(c.instanceId);
        return true;
    });

    return (
        <div
            style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: 'rgba(0,0,0,0.9)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 2200,
                padding: 20
            }}
            onClick={() => dispatch({ type: 'CLOSE_SCARLET_BADGE_MODAL' })}
        >
            <div
                style={{
                    width: 620,
                    maxWidth: '95vw',
                    padding: 28,
                    background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                    border: `3px solid ${rule.theme?.border || '#c62828'}`,
                    borderRadius: 14,
                    boxShadow: `0 10px 36px ${rule.theme?.shadow || 'rgba(198,40,40,0.25)'}`
                }}
                onClick={(e) => e.stopPropagation()}
            >
                <h2 style={{ margin: 0, color: rule.theme?.title || '#ff6b6b', textAlign: 'center' }}>{rule.title}</h2>
                <div style={{ marginTop: 12, fontSize: 13, color: '#e8dcc4', lineHeight: 1.7, textAlign: 'center' }}>

                    é€‰æ‹©ä¸€ä»¶ã€{rule.zoneLabel}ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ <b style={{ color: '#ffd700' }}>+{rule.inc ?? 2}</b>ï¼ˆæœ€é«˜{rule.cap ?? 100}çº§ï¼‰ã€‚

                </div>

                <div style={{ marginTop: 18, padding: 14, background: 'rgba(0,0,0,0.35)', borderRadius: 10, border: '1px solid rgba(255,255,255,0.08)' }}>
                    {candidates.length === 0 ? (
                        <div style={{ color: '#ff6b6b', fontSize: 13, textAlign: 'center' }}>
                            å½“å‰æ²¡æœ‰å¯å‡çº§çš„ã€{rule.zoneLabel}ã€‘è£…å¤‡ï¼ˆèƒŒåŒ…æˆ–å·²ç©¿æˆ´ï¼‰ã€‚
                        </div>
                    ) : (
                        <>
                            <div style={{ fontSize: 12, color: '#c9a227', marginBottom: 10 }}>å¯é€‰æ‹©ç›®æ ‡</div>
                            <select
                                value={selectedId}
                                onChange={(e) => setSelectedId(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '10px 12px',
                                    background: 'rgba(0,0,0,0.45)',
                                    border: '1px solid rgba(255,255,255,0.15)',
                                    borderRadius: 8,
                                    color: '#fff',
                                    fontSize: 13,
                                    cursor: 'pointer'
                                }}
                            >
                                <option value="">è¯·é€‰æ‹©è£…å¤‡...</option>
                                {candidates.map(c => (
                                    <option key={c.instanceId} value={c.instanceId}>{c.label}</option>
                                ))}
                            </select>
                        </>
                    )}
                </div>

                <div style={{ display: 'flex', gap: 14, justifyContent: 'center', marginTop: 22 }}>
                    <Button
                        variant="danger"
                        disabled={candidates.length === 0 || !selectedId}
                        onClick={() => {
                            dispatch({ type: 'APPLY_SCARLET_BADGE', payload: { targetInstanceId: selectedId } });
                        }}
                    >
                        âœ… ç¡®è®¤å‡çº§
                    </Button>
                    <Button variant="secondary" onClick={() => dispatch({ type: 'CLOSE_SCARLET_BADGE_MODAL' })}>
                        å–æ¶ˆ
                    </Button>
                </div>
            </div>
        </div>
    );
};

// ==================== é‡ç”Ÿç¡®è®¤æ¨¡æ€æ¡† ====================
const RebirthConfirmModal = ({ state, dispatch }) => {
    if (!state.showRebirthConfirm) return null;
    const equippedCount = state.characters.reduce((s, c) => s + Object.values(c.equipment || {}).filter(Boolean).length, 0);
    const spaceNeeded = state.inventory.length + equippedCount > state.inventorySize;

    return (
        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }}>
            <div style={{ width: 500, padding: 30, background: '#1a1510', border: '3px solid #ff6b6b', borderRadius: 12 }}>
                <h2 style={{ color: '#ff6b6b', textAlign: 'center' }}>é‡ç”Ÿè½®å›ç¡®è®¤</h2>
                <p style={{ lineHeight: 1.6, margin: '20px 0' }}>
                    é‡ç”Ÿè½®å›å°†é‡ç½®ç‹å›½çš„å»ºç­‘ã€èµ„æºã€ç ”ç©¶ç­‰çº§ä»¥åŠè§’è‰²ï¼Œ<br/>
                    ä½†é“å…·æ å’Œè£…å¤‡ä¼šä¿ç•™ã€‚<br/>
                    âœ… åŠŸèƒ½å»ºç­‘å°†å…¨éƒ¨ä¿ç•™ï¼ˆä¸ä¼šæ¶ˆå¤±ï¼‰ã€‚<br/><br/>
                    {spaceNeeded ?
                        <span style={{ color: '#ff6b6b' }}>âš ï¸ èƒŒåŒ…ç©ºé—´ä¸è¶³ï¼Œæ— æ³•å®¹çº³æ‰€æœ‰è£…å¤‡ï¼</span> :
                        `éœ€è¦ ${equippedCount} ä¸ªèƒŒåŒ…ç©ºæ ¼å­˜æ”¾å½“å‰è£…å¤‡ã€‚`
                    }
                </p>
                <div style={{ display: 'flex', gap: 20, justifyContent: 'center' }}>
                    <Button onClick={() => dispatch({ type: 'PERFORM_REBIRTH' })} variant="danger" disabled={spaceNeeded}>
                        ç¡®è®¤é‡ç”Ÿ
                    </Button>
                    <Button onClick={() => dispatch({ type: 'CLOSE_REBIRTH_CONFIRM' })} variant="secondary">
                        å–æ¶ˆ
                    </Button>
                </div>
            </div>
        </div>
    );
};

// ==================== é‡ç”Ÿå‰§æƒ…æ¨¡æ€æ¡† ====================
const RebirthPlotModal = ({ state, dispatch }) => {
    if (!state.showRebirthPlot) return null;
    const p = state.showRebirthPlot;
    const bossNames = (p.defeatedBosses || []).map(id => {
        const names = {
            hogger: 'éœæ ¼',
            vancleef: 'èŒƒå…‹é‡Œå¤«',
            prestor_lady: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
            thalnos: 'è¨å°”è¯ºæ–¯',
            dagran_thaurissan: 'ç´¢ç‘æ£®å¤§å¸',
            darkmaster_gandling: 'é»‘æš—é™¢é•¿åŠ ä¸',
            baron_rivendare: 'ç‘æ–‡æˆ´å°”ç”·çˆµ',
            rend_blackhand: 'é›·å¾·é»‘æ‰‹'
        };
        return names[id] || id;
    });
    return (
        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.95)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }}>
            <div style={{ width: 700, padding: 40, background: '#1a1510', border: '4px solid #ffd700', borderRadius: 16, textAlign: 'center' }}>
                <h2 style={{ color: '#ffd700', marginBottom: 30 }}>ç¬¬ {p.rebirthCount} ä¸–</h2>
                <p style={{ fontSize: 18, lineHeight: 2, color: '#e8dcc4' }}>
                    ä½ çœ¼å‰ä¸€é»‘ï¼Œä¸Šä¸€ä¸–ç»å†äº† {p.frame} å¸§çš„åŠªåŠ›ï¼Œ
                    {bossNames.length > 0 ? `å‡»è´¥äº†${bossNames.join('ã€')}ï¼Œ` : ''}
                    æœ€é«˜ç­‰çº§è¾¾åˆ° Lv.{p.maxLevel || 0}ã€‚<br/>
                    è¿™ä¸€ä¸–ï¼Œä½ è·å¾—äº† {p.newExp}% ç»éªŒå€¼ã€{p.newGold}% é‡‘å¸ã€{p.newDrop}% æ‰è½ã€<br/>
                    {p.newResearch}% ç ”ç©¶é€Ÿåº¦å¢å¹…ï¼Œå¹¶è·å¾—äº†ç¾ç»Šã€Œ{p.newBond}ã€ã€‚<br/><br/>
                    ä½ ç¼“ç¼“çå¼€åŒçœ¼ï¼Œ<br/>
                    è¿™æ˜¯ä½ ç»å†çš„ç¬¬ {p.rebirthCount} ä¸–ï¼Œè¿™ä¸€ä¸–ä½ æ„Ÿåˆ°å…¨èº«å……æ»¡äº†åŠ›é‡ï¼Œfighting!
                </p>
                <Button onClick={() => dispatch({ type: 'CLOSE_REBIRTH_PLOT' })} style={{ marginTop: 40, padding: '12px 40px', fontSize: 18 }}>
                    å¼€å§‹æ–°çš„ä¸€ä¸–
                </Button>
            </div>
        </div>
    );
};

// ==================== æœ¬ä¸–é‡ç”ŸåŠ æˆæ¨¡æ€æ¡† ====================
const RebirthBonusModal = ({ state, onClose }) => {
    const bonuses = state.rebirthBonuses || { exp: 0, gold: 0, drop: 0, researchSpeed: 0 };
    const bonds = state.rebirthBonds || [];
    const rebirthCount = state.rebirthCount || 0;

    // ç¾ç»Šè¯¦ç»†ä¿¡æ¯
    const BOND_DETAILS = {
        baoernai: {
            name: 'åŒ…äºŒå¥¶',
            description: 'é˜Ÿä¼ä¸­æœ‰1ä¸ªé˜²æŠ¤æˆ˜å£«å’Œ2ä¸ªæˆ’å¾‹ç‰§å¸ˆæ—¶ï¼Œæ¯å›åˆæˆ˜å£«å¯¹æ‰€æœ‰æ•Œäººé€ æˆæ ¼æŒ¡å€¼80%çš„é¢å¤–ä¼¤å®³'
        },
        jianyue: {
            name: 'ç®€çº¦è€Œä¸ç®€å•',
            description: 'é˜Ÿä¼å…¨ä¸ºåŒä¸€èŒä¸šæ—¶ï¼Œæ™®é€šæ”»å‡»ä¼¤å®³æé«˜150%'
        }
    };

    // æ‰€æœ‰å¯èƒ½çš„ç¾ç»Šæ± 
    const ALL_BONDS = ['baoernai', 'jianyue'];

    // BossåŠ æˆé…ç½®
    const BOSS_BONUS_CONFIG = {
        hogger: { name: 'éœæ ¼', bonus: 0.05 },
        vancleef: { name: 'èŒƒå…‹é‡Œå¤«', bonus: 0.10 },
        prestor_lady:{ name: 'æ™®ç‘æ–¯æ‰˜å¥³å£«', bonus: 0.15 },
        thalnos: { name: 'è£‚é­‚è€…è¨å°”è¯ºæ–¯', bonus: 0.15 },
        dagran_thaurissan: { name: 'è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸', bonus: 0.15 },
        darkmaster_gandling:{ name: 'é»‘æš—é™¢é•¿åŠ ä¸', bonus: 0.20 },
        baron_rivendare: { name: 'ç‘æ–‡æˆ´å°”ç”·çˆµ', bonus: 0.20 },
        rend_blackhand:{ name: 'é›·å¾·é»‘æ‰‹', bonus: 0.20 },
    };

    // å»é‡åçš„å·²è·å¾—ç¾ç»Š
    const uniqueBonds = [...new Set(bonds)];

    // ==================== è®¡ç®—é¢„æµ‹åŠ æˆï¼ˆæ–°å…¬å¼ï¼‰ ====================
    // å¸§æ•°åŠ æˆï¼šå¯¹æ•°å‡½æ•°ï¼Œ3600å¸§â†’10%, 36000å¸§â†’20%, 86400å¸§â†’30%
    const frame = state.lifeFrame || 0;
    const frameBonus = frame >= 360 ? 0.1 * Math.log10(frame / 360) : 0;

    // ç­‰çº§åŠ æˆï¼šæ¯çº§0.2%
    const maxLevel = state.characters.reduce((m, c) => Math.max(m, c.level || 0), 0);
    const levelBonus = maxLevel * 0.002;

    // BossåŠ æˆ
    const defeatedBosses = state.defeatedBosses || [];
    const totalBossBonus = defeatedBosses.reduce((sum, bossId) => sum + (BOSS_BONUS_CONFIG[bossId]?.bonus || 0), 0);

    // æ€»é¢„æµ‹åŠ æˆ
    // ä¸‰é¡¹ä¹˜åŒºï¼šå¸§æ•° / æœ€é«˜ç­‰çº§ / Bosså‡»æ€ â€”â€” ä¹˜ç®—ï¼Œä¸åŠ ç®—
    const predictedExp = (1 + frameBonus) * (1 + levelBonus) * (1 + totalBossBonus) - 1;
    const predictedGold = predictedExp;
    const predictedDrop = predictedExp * 0.6;
    const predictedResearch = predictedExp * 0.5;

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.9)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 2000
        }} onClick={onClose}>
            <div style={{
                width: 680,
                maxHeight: '85vh',
                overflowY: 'auto',
                padding: 30,
                background: 'linear-gradient(135deg, #1a1510 0%, #0d0a07 100%)',
                border: '3px solid #c9a227',
                borderRadius: 12,
                boxShadow: '0 8px 32px rgba(201,162,39,0.3)'
            }} onClick={(e) => e.stopPropagation()}>
                <h2 style={{
                    color: '#ffd700',
                    textAlign: 'center',
                    marginBottom: 24,
                    textShadow: '2px 2px 4px rgba(0,0,0,0.8)'
                }}>
                    âš¡ è½®å›åŠ æˆæ€»è§ˆ
                </h2>

                {/* é‡ç”Ÿæ¬¡æ•° */}
                <div style={{
                    textAlign: 'center',
                    marginBottom: 24,
                    padding: '12px 20px',
                    background: 'rgba(201,162,39,0.15)',
                    borderRadius: 8,
                    border: '1px solid rgba(201,162,39,0.3)'
                }}>
                    <span style={{ color: '#c9a227', fontSize: 14 }}>å·²è½®å› </span>
                    <span style={{ color: '#ffd700', fontSize: 24, fontWeight: 700 }}>{rebirthCount}</span>
                    <span style={{ color: '#c9a227', fontSize: 14 }}> ä¸–</span>
                </div>

                {/* å½“å‰ç”Ÿæ•ˆåŠ æˆï¼ˆæ¥è‡ªä¸Šä¸€ä¸–ï¼‰ */}
                <div style={{
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 8,
                    padding: 16,
                    marginBottom: 20,
                    border: '1px solid #4a3c2a'
                }}>
                    <h3 style={{ color: '#c9a227', fontSize: 14, marginBottom: 12, borderBottom: '1px solid rgba(201,162,39,0.2)', paddingBottom: 8 }}>
                        ğŸ“Š å½“å‰ç”Ÿæ•ˆåŠ æˆï¼ˆæ¥è‡ªä¸Šä¸€ä¸–ï¼‰
                    </h3>
                    {rebirthCount === 0 ? (
                        <div style={{ color: '#666', textAlign: 'center', padding: 12, fontSize: 13 }}>
                            å°šæœªè½®å›ï¼Œæš‚æ— ç”Ÿæ•ˆåŠ æˆ
                        </div>
                    ) : (
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 12 }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', padding: '8px 12px', background: 'rgba(76,175,80,0.1)', borderRadius: 6, border: '1px solid rgba(76,175,80,0.3)' }}>
                                <span style={{ color: '#888' }}>â­ ç»éªŒå€¼</span>
                                <span style={{ color: '#4CAF50', fontWeight: 600 }}>+{(bonuses.exp * 100).toFixed(1)}%</span>
                            </div>
                            <div style={{ display: 'flex', justifyContent: 'space-between', padding: '8px 12px', background: 'rgba(255,215,0,0.1)', borderRadius: 6, border: '1px solid rgba(255,215,0,0.3)' }}>
                                <span style={{ color: '#888' }}>ğŸª™ é‡‘å¸</span>
                                <span style={{ color: '#ffd700', fontWeight: 600 }}>+{(bonuses.gold * 100).toFixed(1)}%</span>
                            </div>
                            <div style={{ display: 'flex', justifyContent: 'space-between', padding: '8px 12px', background: 'rgba(163,51,238,0.1)', borderRadius: 6, border: '1px solid rgba(163,51,238,0.3)' }}>
                                <span style={{ color: '#888' }}>ğŸ“¦ æ‰è½</span>
                                <span style={{ color: '#a335ee', fontWeight: 600 }}>+{(bonuses.drop * 100).toFixed(1)}%</span>
                            </div>
                            <div style={{ display: 'flex', justifyContent: 'space-between', padding: '8px 12px', background: 'rgba(0,112,221,0.1)', borderRadius: 6, border: '1px solid rgba(0,112,221,0.3)' }}>
                                <span style={{ color: '#888' }}>ğŸ”¬ ç ”ç©¶é€Ÿåº¦</span>
                                <span style={{ color: '#0070dd', fontWeight: 600 }}>+{(bonuses.researchSpeed * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                    )}
                </div>

                {/* é¢„æµ‹ï¼šå¦‚æœç°åœ¨é‡ç”Ÿèƒ½è·å¾—çš„åŠ æˆ */}
                <div style={{
                    background: 'rgba(255,107,107,0.1)',
                    borderRadius: 8,
                    padding: 16,
                    marginBottom: 20,
                    border: '1px solid rgba(255,107,107,0.3)'
                }}>
                    <h3 style={{ color: '#ff6b6b', fontSize: 14, marginBottom: 12, borderBottom: '1px solid rgba(255,107,107,0.2)', paddingBottom: 8 }}>
                        ğŸ”® è‹¥æ­¤åˆ»é‡ç”Ÿï¼Œä¸‹ä¸€ä¸–å°†è·å¾—
                    </h3>

                    {/* å½“å‰è¿›åº¦æ˜ç»† */}
                    <div style={{
                        background: 'rgba(0,0,0,0.2)',
                        borderRadius: 6,
                        padding: 12,
                        marginBottom: 12,
                        fontSize: 12
                    }}>
                        <div style={{ color: '#888', marginBottom: 8 }}>æœ¬ä¸–è¿›åº¦ï¼š</div>
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 8 }}>
                            <div>
                                <span style={{ color: '#666' }}>å¸§æ•°ï¼š</span>
                                <span style={{ color: '#ffd700' }}>{Math.floor(frame)}</span>
                                <span style={{ color: '#4CAF50', marginLeft: 4 }}>â†’ +{(frameBonus * 100).toFixed(1)}%</span>
                            </div>
                            <div>
                                <span style={{ color: '#666' }}>æœ€é«˜ç­‰çº§ï¼š</span>
                                <span style={{ color: '#ffd700' }}>Lv.{maxLevel}</span>
                                <span style={{ color: '#4CAF50', marginLeft: 4 }}>â†’ +{(levelBonus * 100).toFixed(1)}%</span>
                            </div>
                            <div>
                                <span style={{ color: '#666' }}>Bosså‡»æ€ï¼š</span>
                                <span style={{ color: '#ffd700' }}>{defeatedBosses.length}ä¸ª</span>
                                <span style={{ color: '#4CAF50', marginLeft: 4 }}>â†’ +{(totalBossBonus * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                        {defeatedBosses.length > 0 && (
                            <div style={{ marginTop: 8, display: 'flex', gap: 6, flexWrap: 'wrap' }}>
                                {defeatedBosses.map(bossId => (
                                    <span key={bossId} style={{
                                        padding: '2px 6px',
                                        background: 'rgba(255,107,107,0.2)',
                                        borderRadius: 3,
                                        fontSize: 10,
                                        color: '#ff6b6b'
                                    }}>
                                        âœ“ {BOSS_BONUS_CONFIG[bossId]?.name || bossId}
                                    </span>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* é¢„æµ‹åŠ æˆæ•°å€¼ */}
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 10 }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', padding: '6px 10px', background: 'rgba(0,0,0,0.2)', borderRadius: 4 }}>
                            <span style={{ color: '#888', fontSize: 12 }}>â­ ç»éªŒå€¼</span>
                            <span style={{ color: '#4CAF50', fontWeight: 600, fontSize: 12 }}>+{(predictedExp * 100).toFixed(1)}%</span>
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'space-between', padding: '6px 10px', background: 'rgba(0,0,0,0.2)', borderRadius: 4 }}>
                            <span style={{ color: '#888', fontSize: 12 }}>ğŸª™ é‡‘å¸</span>
                            <span style={{ color: '#ffd700', fontWeight: 600, fontSize: 12 }}>+{(predictedGold * 100).toFixed(1)}%</span>
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'space-between', padding: '6px 10px', background: 'rgba(0,0,0,0.2)', borderRadius: 4 }}>
                            <span style={{ color: '#888', fontSize: 12 }}>ğŸ“¦ æ‰è½</span>
                            <span style={{ color: '#a335ee', fontWeight: 600, fontSize: 12 }}>+{(predictedDrop * 100).toFixed(1)}%</span>
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'space-between', padding: '6px 10px', background: 'rgba(0,0,0,0.2)', borderRadius: 4 }}>
                            <span style={{ color: '#888', fontSize: 12 }}>ğŸ”¬ ç ”ç©¶é€Ÿåº¦</span>
                            <span style={{ color: '#0070dd', fontWeight: 600, fontSize: 12 }}>+{(predictedResearch * 100).toFixed(1)}%</span>
                        </div>
                    </div>

                    {/* ç¾ç»Šæ±  */}
                    <div style={{ marginTop: 12, padding: '8px 12px', background: 'rgba(255,215,0,0.1)', borderRadius: 6, border: '1px dashed rgba(255,215,0,0.3)' }}>
                        <div style={{ fontSize: 11, color: '#888', marginBottom: 4 }}>ç¾ç»Šï¼šéšæœºè·å¾—ä»¥ä¸‹ä¹‹ä¸€ï¼ˆåŒä¸€ç¾ç»Šåªç”Ÿæ•ˆä¸€æ¬¡ï¼‰</div>
                        <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
                            {ALL_BONDS.map(bondId => {
                                const owned = uniqueBonds.includes(bondId);
                                return (
                                    <span key={bondId} style={{
                                        padding: '3px 8px',
                                        background: owned ? 'rgba(102,102,102,0.3)' : 'rgba(201,162,39,0.2)',
                                        borderRadius: 4,
                                        fontSize: 11,
                                        color: owned ? '#666' : '#ffd700',
                                        textDecoration: owned ? 'line-through' : 'none'
                                    }}>
                                        {BOND_DETAILS[bondId]?.name || bondId}{owned ? 'ï¼ˆå·²æœ‰ï¼‰' : ''}
                                    </span>
                                );
                            })}
                        </div>
                    </div>

                    {/* æç¤ºï¼šåŠ æˆä¸å åŠ  */}
                    <div style={{ marginTop: 10, fontSize: 11, color: '#888', textAlign: 'center' }}>
                        âš ï¸ é‡ç”Ÿåï¼Œä¸Šè¿°åŠ æˆå°†<span style={{ color: '#ff6b6b' }}>æ›¿æ¢</span>å½“å‰ç”Ÿæ•ˆåŠ æˆï¼ˆä¸å åŠ ï¼‰
                    </div>
                </div>

                {/* å·²è·å¾—ç¾ç»Šåˆ—è¡¨ */}
                <div style={{
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 8,
                    padding: 16,
                    marginBottom: 20,
                    border: '1px solid #4a3c2a'
                }}>
                    <h3 style={{ color: '#c9a227', fontSize: 14, marginBottom: 12, borderBottom: '1px solid rgba(201,162,39,0.2)', paddingBottom: 8 }}>
                        ğŸ”— å·²è·å¾—ç¾ç»Š ({uniqueBonds.length}/{ALL_BONDS.length})
                    </h3>
                    {uniqueBonds.length === 0 ? (
                        <div style={{ color: '#666', textAlign: 'center', padding: 20 }}>
                            æš‚æ— ç¾ç»Š
                        </div>
                    ) : (
                        <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                            {uniqueBonds.map(bondId => {
                                const detail = BOND_DETAILS[bondId] || { name: bondId, description: 'æœªçŸ¥ç¾ç»Š' };
                                return (
                                    <div key={bondId} style={{
                                        padding: 12,
                                        background: 'linear-gradient(135deg, rgba(201,162,39,0.1), rgba(139,115,25,0.05))',
                                        borderRadius: 6,
                                        border: '1px solid rgba(201,162,39,0.3)'
                                    }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 6 }}>
                                            <span style={{ color: '#ffd700', fontWeight: 600 }}>
                                                âœ“ {detail.name}
                                            </span>
                                            <span style={{ fontSize: 11, color: '#4CAF50' }}>ç”Ÿæ•ˆä¸­</span>
                                        </div>
                                        <div style={{ color: '#aaa', fontSize: 12, lineHeight: 1.5 }}>
                                            {detail.description}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    )}
                </div>

                {/* ç¾ç»Šæ± ä¸€è§ˆ */}
                <div style={{
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 8,
                    padding: 16,
                    border: '1px solid #4a3c2a'
                }}>
                    <h3 style={{ color: '#c9a227', fontSize: 14, marginBottom: 12, borderBottom: '1px solid rgba(201,162,39,0.2)', paddingBottom: 8 }}>
                        ğŸ“œ ç¾ç»Šæ± ä¸€è§ˆ
                    </h3>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                        {ALL_BONDS.map(bondId => {
                            const detail = BOND_DETAILS[bondId] || { name: bondId, description: 'æœªçŸ¥ç¾ç»Š' };
                            const owned = uniqueBonds.includes(bondId);
                            return (
                                <div key={bondId} style={{
                                    padding: 10,
                                    background: owned ? 'rgba(76,175,80,0.1)' : 'rgba(0,0,0,0.2)',
                                    borderRadius: 6,
                                    border: owned ? '1px solid rgba(76,175,80,0.3)' : '1px solid rgba(74,60,42,0.5)'
                                }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 4 }}>
                                        <span style={{ color: owned ? '#4CAF50' : '#888', fontWeight: 600, fontSize: 13 }}>
                                            {owned ? 'âœ“ ' : ''}{detail.name}
                                        </span>
                                        {owned && (
                                            <span style={{ fontSize: 11, color: '#4CAF50' }}>å·²è·å¾—</span>
                                        )}
                                    </div>
                                    <div style={{ color: '#777', fontSize: 11, lineHeight: 1.4 }}>
                                        {detail.description}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>

                <div style={{ textAlign: 'center', marginTop: 24 }}>
                    <Button onClick={onClose} variant="secondary">
                        å…³é—­
                    </Button>
                </div>
            </div>
        </div>
    );
};

// ==================== ä»»åŠ¡è¿½è¸ªæ‚¬æµ®UI ====================
const QuestTracker = ({ state, dispatch, onOpenQuestPage }) => {
    const [isCollapsed, setIsCollapsed] = useState(false);
    const [expandedQuests, setExpandedQuests] = useState(new Set());
    const [isMinimized, setIsMinimized] = useState(false);

    // è·å–æ‰€æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡
    const activeQuests = Object.entries(state.questProgress || {})
        .filter(([_, progress]) => progress.status === 'in_progress')
        .map(([questId, progress]) => ({
            questId,
            progress,
            questData: QUEST_CHAINS[questId]
        }))
        .filter(q => q.questData);

    // æ£€æŸ¥æ­¥éª¤æ¡ä»¶è¿›åº¦
    const getRequirementProgress = (requirement) => {
        if (!requirement) return { met: true, current: 0, target: 0, text: '' };

        switch (requirement.type) {
            case 'zone_battles': {
                const zone = ZONES[requirement.zoneId];
                const zoneName = zone?.name || requirement.zoneId;
                const current = state.questBattleProgress?.[requirement.zoneId] || 0;
                const target = requirement.count;
                return {
                    met: current >= target,
                    current,
                    target,
                    text: `åœ¨${zoneName}æˆ˜æ–—`,
                    icon: 'âš”ï¸'
                };
            }
            case 'character_level': {
                const maxLevel = Math.max(...state.characters.map(c => c.level), 0);
                return {
                    met: maxLevel >= requirement.level,
                    current: maxLevel,
                    target: requirement.level,
                    text: `è§’è‰²ç­‰çº§è¾¾åˆ°`,
                    icon: 'â­'
                };
            }
            case 'boss_defeated': {
                const bossName = BOSS_DATA[requirement.bossId]?.name || requirement.bossId;
                const defeated = state.defeatedBosses?.includes(requirement.bossId);
                return {
                    met: defeated,
                    current: defeated ? 1 : 0,
                    target: 1,
                    text: `å‡»è´¥${bossName}`,
                    icon: 'ğŸ²'
                };
            }
            case 'have_gold': {
                return {
                    met: state.resources.gold >= requirement.amount,
                    current: Math.floor(state.resources.gold),
                    target: requirement.amount,
                    text: `å‡†å¤‡é‡‘å¸`,
                    icon: 'ğŸª™'
                };
            }
            case 'have_item': {
                const hasItem = state.inventory.some(i => i.id === requirement.itemId) ||
                    state.questItems?.some(i => i.id === requirement.itemId);
                const itemName = QUEST_ITEMS[requirement.itemId]?.name ||
                    ITEMS[requirement.itemId]?.name ||
                    requirement.itemId;
                return {
                    met: hasItem,
                    current: hasItem ? 1 : 0,
                    target: 1,
                    text: `è·å¾—${itemName}`,
                    icon: 'ğŸ“¦'
                };
            }
            default:
                return { met: true, current: 0, target: 0, text: '' };
        }
    };

    // åˆ‡æ¢ä»»åŠ¡å±•å¼€çŠ¶æ€
    const toggleQuestExpand = (questId) => {
        setExpandedQuests(prev => {
            const next = new Set(prev);
            if (next.has(questId)) {
                next.delete(questId);
            } else {
                next.add(questId);
            }
            return next;
        });
    };

    // ==================== æœ€å°åŒ–æ¨¡å¼ï¼ˆæ— è®ºæœ‰æ²¡æœ‰ä»»åŠ¡éƒ½é€‚ç”¨ï¼‰ ====================
    if (isMinimized) {
        return (
            <div
                onClick={() => setIsMinimized(false)}
                style={{
                    position: 'fixed',
                    top: 100,
                    right: 16,
                    width: 50,
                    height: 50,
                    background: 'linear-gradient(135deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))',
                    border: '2px solid #c9a227',
                    borderRadius: '50%',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    cursor: 'pointer',
                    boxShadow: '0 4px 20px rgba(201,162,39,0.3)',
                    zIndex: 100,
                    transition: 'all 0.3s'
                }}
                title="å±•å¼€ä»»åŠ¡è¿½è¸ª"
            >
                <div style={{ position: 'relative' }}>
                    <span style={{ fontSize: 24 }}>ğŸ“œ</span>
                    {/* ä»»åŠ¡æ•°é‡å¾½ç« ï¼ˆåªæœ‰æœ‰ä»»åŠ¡æ—¶æ‰æ˜¾ç¤ºï¼‰ */}
                    {activeQuests.length > 0 && (
                        <div style={{
                            position: 'absolute',
                            top: -8,
                            right: -8,
                            background: '#f44336',
                            color: '#fff',
                            fontSize: 10,
                            fontWeight: 700,
                            width: 18,
                            height: 18,
                            borderRadius: '50%',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            border: '2px solid #1a1510'
                        }}>
                            {activeQuests.length}
                        </div>
                    )}
                </div>
            </div>
        );
    }

    // ==================== æ²¡æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡æ—¶çš„æ˜¾ç¤º ====================
    if (activeQuests.length === 0) {
        return (
            <div style={{
                position: 'fixed',
                top: 100,
                right: 16,
                width: 280,
                background: 'linear-gradient(135deg, rgba(30,25,20,0.95) 0%, rgba(20,15,12,0.98) 100%)',
                border: '2px solid #4a3c2a',
                borderRadius: 10,
                padding: 12,
                boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                zIndex: 100,
                transition: 'all 0.3s'
            }}>
                <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between'
                }}>
                    <div style={{
                        fontSize: 13,
                        color: '#c9a227',
                        fontWeight: 600,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span>ğŸ“œ</span>
                        ä»»åŠ¡è¿½è¸ª
                    </div>
                    {/* âœ… ä¿®å¤ï¼šæ·»åŠ æœ€å°åŒ–å’ŒæŸ¥çœ‹ä»»åŠ¡æŒ‰é’® */}
                    <div style={{ display: 'flex', gap: 4 }}>
                        <button
                            onClick={() => setIsMinimized(true)}
                            style={{
                                background: 'rgba(100,100,100,0.3)',
                                border: '1px solid #666',
                                color: '#ccc',
                                fontSize: 12,
                                cursor: 'pointer',
                                padding: '4px 8px',
                                borderRadius: 4,
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                minWidth: 24,
                                minHeight: 24
                            }}
                            title="æœ€å°åŒ–"
                        >
                            â–
                        </button>
                        <button
                            onClick={() => onOpenQuestPage?.()}
                            style={{
                                background: 'rgba(201,162,39,0.2)',
                                border: '1px solid #c9a227',
                                borderRadius: 4,
                                color: '#c9a227',
                                fontSize: 10,
                                padding: '4px 8px',
                                cursor: 'pointer'
                            }}
                        >
                            æŸ¥çœ‹ä»»åŠ¡
                        </button>
                    </div>
                </div>
                <div style={{
                    marginTop: 12,
                    textAlign: 'center',
                    color: '#666',
                    fontSize: 12,
                    padding: '16px 0'
                }}>
                    <div style={{ fontSize: 24, marginBottom: 8 }}>ğŸ“­</div>
                    æš‚æ— è¿›è¡Œä¸­çš„ä»»åŠ¡
                </div>
            </div>
        );
    }

    // ==================== æœ‰ä»»åŠ¡æ—¶çš„æ­£å¸¸æ˜¾ç¤º ====================
    return (
        <div style={{
            position: 'fixed',
            top: 100,
            right: 16,
            width: isCollapsed ? 50 : 300,
            maxHeight: 'calc(100vh - 140px)',
            background: 'linear-gradient(135deg, rgba(30,25,20,0.97) 0%, rgba(20,15,12,0.99) 100%)',
            border: '2px solid #c9a227',
            borderRadius: 10,
            overflow: 'hidden',
            boxShadow: '0 4px 24px rgba(0,0,0,0.6), 0 0 20px rgba(201,162,39,0.15)',
            zIndex: 100,
            transition: 'width 0.3s ease',
            display: 'flex',
            flexDirection: 'column'
        }}>
            {/* æ ‡é¢˜æ  */}
            <div style={{
                padding: '10px 12px',
                background: 'linear-gradient(180deg, rgba(201,162,39,0.15) 0%, transparent 100%)',
                borderBottom: '1px solid rgba(201,162,39,0.3)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                flexShrink: 0
            }}>
                {!isCollapsed && (
                    <div style={{
                        fontSize: 14,
                        color: '#ffd700',
                        fontWeight: 600,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span>ğŸ“œ</span>
                        ä»»åŠ¡è¿½è¸ª
                        <span style={{
                            fontSize: 11,
                            color: '#888',
                            fontWeight: 400
                        }}>
                            ({activeQuests.length})
                        </span>
                    </div>
                )}

                <div style={{ display: 'flex', gap: 4 }}>
                    {!isCollapsed && (
                        <button
                            onClick={() => setIsMinimized(true)}
                            style={{
                                background: 'rgba(100,100,100,0.3)',
                                border: '1px solid #666',
                                color: '#ccc',
                                fontSize: 12,
                                cursor: 'pointer',
                                padding: '4px 8px',
                                borderRadius: 4,
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                minWidth: 24,
                                minHeight: 24
                            }}
                            title="æœ€å°åŒ–"
                        >
                            â–
                        </button>
                    )}
                    <button
                        onClick={() => setIsCollapsed(!isCollapsed)}
                        style={{
                            background: 'transparent',
                            border: 'none',
                            color: '#c9a227',
                            fontSize: 16,
                            cursor: 'pointer',
                            padding: '2px 6px',
                            borderRadius: 4,
                            transition: 'transform 0.3s'
                        }}
                        title={isCollapsed ? 'å±•å¼€' : 'æŠ˜å '}
                    >
                        {isCollapsed ? 'â—€' : 'â–¶'}
                    </button>
                </div>
            </div>

            {/* ä»»åŠ¡åˆ—è¡¨ */}
            {!isCollapsed && (
                <div style={{
                    flex: 1,
                    overflowY: 'auto',
                    padding: 8
                }}>
                    {activeQuests.map(({ questId, progress, questData }) => {
                        const currentStep = questData.steps[progress.currentStep];
                        const isExpanded = expandedQuests.has(questId);
                        const requirement = currentStep?.requirement;
                        const reqProgress = getRequirementProgress(requirement);

                        return (
                            <div
                                key={questId}
                                style={{
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: 8,
                                    marginBottom: 8,
                                    border: '1px solid rgba(201,162,39,0.2)',
                                    overflow: 'hidden',
                                    transition: 'all 0.2s'
                                }}
                            >
                                {/* ä»»åŠ¡æ ‡é¢˜ */}
                                <div
                                    onClick={() => toggleQuestExpand(questId)}
                                    style={{
                                        padding: '10px 12px',
                                        cursor: 'pointer',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: 10,
                                        background: isExpanded
                                            ? 'rgba(201,162,39,0.1)'
                                            : 'transparent',
                                        transition: 'background 0.2s'
                                    }}
                                >
                                    <span style={{
                                        fontSize: 20,
                                        transition: 'transform 0.2s',
                                        transform: isExpanded ? 'scale(1.1)' : 'scale(1)'
                                    }}>
                                        {questData.icon}
                                    </span>
                                    <div style={{ flex: 1, minWidth: 0 }}>
                                        <div style={{
                                            fontSize: 12,
                                            color: '#ffd700',
                                            fontWeight: 600,
                                            whiteSpace: 'nowrap',
                                            overflow: 'hidden',
                                            textOverflow: 'ellipsis'
                                        }}>
                                            {questData.name}
                                        </div>
                                        <div style={{
                                            fontSize: 10,
                                            color: '#888',
                                            marginTop: 2,
                                            whiteSpace: 'nowrap',
                                            overflow: 'hidden',
                                            textOverflow: 'ellipsis'
                                        }}>
                                            {currentStep?.title}
                                        </div>
                                    </div>
                                    <span style={{
                                        color: '#666',
                                        fontSize: 12,
                                        transition: 'transform 0.2s',
                                        transform: isExpanded ? 'rotate(90deg)' : 'rotate(0)'
                                    }}>
                                        â–¶
                                    </span>
                                </div>

                                {/* å±•å¼€å†…å®¹ */}
                                {isExpanded && (
                                    <div style={{
                                        padding: '0 12px 12px',
                                        borderTop: '1px solid rgba(201,162,39,0.1)'
                                    }}>
                                        {/* å½“å‰ç›®æ ‡ */}
                                        {requirement && (
                                            <div style={{
                                                marginTop: 10,
                                                padding: 10,
                                                background: reqProgress.met
                                                    ? 'rgba(76,175,80,0.15)'
                                                    : 'rgba(255,152,0,0.1)',
                                                borderRadius: 6,
                                                border: `1px solid ${reqProgress.met
                                                    ? 'rgba(76,175,80,0.3)'
                                                    : 'rgba(255,152,0,0.3)'}`
                                            }}>
                                                <div style={{
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: 8,
                                                    marginBottom: 6
                                                }}>
                                                    <span style={{ fontSize: 14 }}>{reqProgress.icon}</span>
                                                    <span style={{
                                                        fontSize: 11,
                                                        color: reqProgress.met ? '#4CAF50' : '#ff9800',
                                                        fontWeight: 600
                                                    }}>
                                                        {reqProgress.text}
                                                    </span>
                                                </div>

                                                {/* è¿›åº¦æ¡ */}
                                                <div style={{
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: 8
                                                }}>
                                                    <div style={{
                                                        flex: 1,
                                                        height: 6,
                                                        background: 'rgba(0,0,0,0.4)',
                                                        borderRadius: 3,
                                                        overflow: 'hidden'
                                                    }}>
                                                        <div style={{
                                                            height: '100%',
                                                            width: `${Math.min(100, (reqProgress.current / reqProgress.target) * 100)}%`,
                                                            background: reqProgress.met
                                                                ? 'linear-gradient(90deg, #4CAF50, #81c784)'
                                                                : 'linear-gradient(90deg, #ff9800, #ffb74d)',
                                                            borderRadius: 3,
                                                            transition: 'width 0.3s'
                                                        }} />
                                                    </div>
                                                    <span style={{
                                                        fontSize: 10,
                                                        color: reqProgress.met ? '#4CAF50' : '#ff9800',
                                                        fontWeight: 600,
                                                        minWidth: 45,
                                                        textAlign: 'right'
                                                    }}>
                                                        {reqProgress.current >= 1000
                                                            ? `${(reqProgress.current/1000).toFixed(1)}k`
                                                            : reqProgress.current
                                                        } / {reqProgress.target >= 1000
                                                        ? `${(reqProgress.target/1000).toFixed(1)}k`
                                                        : reqProgress.target
                                                    }
                                                    </span>
                                                </div>
                                            </div>
                                        )}

                                        {/* æ­¥éª¤æè¿° */}
                                        <div style={{
                                            marginTop: 10,
                                            fontSize: 11,
                                            color: '#aaa',
                                            lineHeight: 1.5,
                                            padding: '8px 0'
                                        }}>
                                            {currentStep?.description?.substring(0, 100)}
                                            {currentStep?.description?.length > 100 && '...'}
                                        </div>

                                        {/* å·²è·å¾—çš„æ ‡è®° */}
                                        {progress.flags && progress.flags.length > 0 && (
                                            <div style={{
                                                marginTop: 8,
                                                display: 'flex',
                                                flexWrap: 'wrap',
                                                gap: 4
                                            }}>
                                                {progress.flags.slice(0, 3).map(flag => (
                                                    <span key={flag} style={{
                                                        fontSize: 9,
                                                        padding: '2px 6px',
                                                        background: 'rgba(156,39,176,0.2)',
                                                        borderRadius: 3,
                                                        color: '#ce93d8',
                                                        border: '1px solid rgba(156,39,176,0.3)'
                                                    }}>
                                                        âœ“ {flag.replace(/_/g, ' ')}
                                                    </span>
                                                ))}
                                                {progress.flags.length > 3 && (
                                                    <span style={{
                                                        fontSize: 9,
                                                        padding: '2px 6px',
                                                        color: '#888'
                                                    }}>
                                                        +{progress.flags.length - 3}
                                                    </span>
                                                )}
                                            </div>
                                        )}

                                        {/* æ“ä½œæŒ‰é’® */}
                                        <div style={{
                                            marginTop: 10,
                                            display: 'flex',
                                            gap: 8
                                        }}>
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    onOpenQuestPage?.(questId);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '6px 10px',
                                                    background: 'linear-gradient(180deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))',
                                                    border: '1px solid #c9a227',
                                                    borderRadius: 4,
                                                    color: '#ffd700',
                                                    fontSize: 11,
                                                    cursor: 'pointer',
                                                    fontFamily: 'inherit'
                                                }}
                                            >
                                                æŸ¥çœ‹è¯¦æƒ…
                                            </button>

                                            {currentStep?.dialogues && (
                                                <button
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        dispatch({
                                                            type: 'SHOW_QUEST_DIALOGUE',
                                                            payload: { questId }
                                                        });
                                                    }}
                                                    style={{
                                                        padding: '6px 10px',
                                                        background: 'rgba(0,0,0,0.3)',
                                                        border: '1px solid #4a3c2a',
                                                        borderRadius: 4,
                                                        color: '#888',
                                                        fontSize: 11,
                                                        cursor: 'pointer',
                                                        fontFamily: 'inherit'
                                                    }}
                                                    title="æŸ¥çœ‹å¯¹è¯"
                                                >
                                                    ğŸ’¬
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>
            )}

            {/* åº•éƒ¨å¿«æ·æŒ‰é’® */}
            {!isCollapsed && (
                <div style={{
                    padding: 8,
                    borderTop: '1px solid rgba(201,162,39,0.2)',
                    flexShrink: 0
                }}>
                    <button
                        onClick={() => onOpenQuestPage?.()}
                        style={{
                            width: '100%',
                            padding: '8px 12px',
                            background: 'rgba(0,0,0,0.3)',
                            border: '1px solid #4a3c2a',
                            borderRadius: 6,
                            color: '#c9a227',
                            fontSize: 12,
                            cursor: 'pointer',
                            fontFamily: 'inherit',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: 6
                        }}
                    >
                        <span>ğŸ“‹</span>
                        æ‰“å¼€ä»»åŠ¡åˆ—è¡¨
                    </button>
                </div>
            )}
        </div>
    );
};

// ==================== ä»»åŠ¡æç¤ºToastç»„ä»¶ ====================
const QuestToast = ({ message, type, onClose }) => {
    useEffect(() => {
        const timer = setTimeout(onClose, 3000);
        return () => clearTimeout(timer);
    }, [onClose]);

    const colors = {
        progress: { bg: 'rgba(255,152,0,0.9)', border: '#ff9800', icon: 'ğŸ“' },
        complete: { bg: 'rgba(76,175,80,0.9)', border: '#4CAF50', icon: 'âœ…' },
        reward: { bg: 'rgba(156,39,176,0.9)', border: '#9C27B0', icon: 'ğŸ' },
        unlock: { bg: 'rgba(33,150,243,0.9)', border: '#2196F3', icon: 'ğŸ”“' }
    };

    const style = colors[type] || colors.progress;

    return (
        <div style={{
            position: 'fixed',
            top: 80,
            left: '50%',
            transform: 'translateX(-50%)',
            padding: '12px 24px',
            background: style.bg,
            border: `2px solid ${style.border}`,
            borderRadius: 8,
            color: '#fff',
            fontSize: 14,
            fontWeight: 600,
            boxShadow: '0 4px 20px rgba(0,0,0,0.4)',
            zIndex: 2000,
            display: 'flex',
            alignItems: 'center',
            gap: 10,
            animation: 'slideDown 0.3s ease'
        }}>
            <span style={{ fontSize: 20 }}>{style.icon}</span>
            {message}
        </div>
    );
};

// ==================== ä»»åŠ¡ç›®æ ‡æ‚¬æµ®æŒ‡ç¤ºå™¨ ====================
const QuestObjectiveIndicator = ({ zone, requirement, progress }) => {
    if (!requirement || requirement.zoneId !== zone.id) return null;

    const current = progress || 0;
    const target = requirement.count;
    const percent = Math.min(100, (current / target) * 100);

    return (
        <div style={{
            position: 'absolute',
            top: -8,
            right: -8,
            background: current >= target
                ? 'linear-gradient(135deg, #4CAF50, #81c784)'
                : 'linear-gradient(135deg, #ff9800, #ffc107)',
            borderRadius: '50%',
            width: 28,
            height: 28,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            border: '2px solid #1a1510',
            boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
            animation: current >= target ? 'none' : 'pulse 2s infinite'
        }}>
            <span style={{ fontSize: 14 }}>
                {current >= target ? 'âœ“' : 'ğŸ“œ'}
            </span>
        </div>
    );
};

// ==================== MAIN APP ====================
export default function WoWIdleGame() {
    const [state, dispatch] = useReducer(gameReducer, initialState);
    const [consoleOpen, setConsoleOpen] = useState(false);
    const [command, setCommand] = useState('');
    const [consoleLogs, setConsoleLogs] = useState([]);
    const [isPaused, setIsPaused] = useState(false);
    const [showExport, setShowExport] = useState(false);
    const [importData, setImportData] = useState('');
    const [showRebirthBonus, setShowRebirthBonus] = useState(false);
    const intervalRef = useRef(null);
    const saveIntervalRef = useRef(null);

    const lastTickRef = useRef(Date.now());
    const hiddenAtRef = useRef(null);
    // çŠ¶æ€
    const [questToasts, setQuestToasts] = useState([]);

    // æ·»åŠ toastçš„å‡½æ•°
    const addQuestToast = useCallback((message, type = 'progress') => {
        const id = Date.now();
        setQuestToasts(prev => [...prev, { id, message, type }]);
    }, []);

    // ç§»é™¤toast
    const removeQuestToast = useCallback((id) => {
        setQuestToasts(prev => prev.filter(t => t.id !== id));
    }, []);

    // æ‰“å¼€ä»»åŠ¡é¡µé¢çš„å‡½æ•°
    const handleOpenQuestPage = useCallback((questId) => {
        dispatch({ type: 'SET_MENU', payload: 'quest' });
        if (questId) {
            // å¯ä»¥è®¾ç½®é€‰ä¸­çš„ä»»åŠ¡
            dispatch({ type: 'SELECT_QUEST', payload: questId });
        }
    }, [dispatch]);


    // æŒ‰ ` é”®å¼€å…³æ§åˆ¶å°
    useEffect(() => {
        const handleKeyDown = (e) => {
            if (e.key === '`') {
                e.preventDefault();
                setConsoleOpen(prev => !prev);
                setCommand(''); // æ‰“å¼€æ—¶æ¸…ç©ºè¾“å…¥
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, []);

    useEffect(() => {
        const onVisChange = () => {
            if (document.hidden) {
                // åˆ‡èµ°ï¼šè®°å½•éšè—å¼€å§‹æ—¶é—´
                hiddenAtRef.current = Date.now();
                return;
            }

            // åˆ‡å›ï¼šè®¡ç®—ç¦»å¼€ç§’æ•°
            const hiddenAt = hiddenAtRef.current;
            hiddenAtRef.current = null;
            if (!hiddenAt) return;

            const deltaSeconds = Math.floor((Date.now() - hiddenAt) / 1000);
            if (deltaSeconds <= 0) return;

            // âœ… è¡¥ä¸€å‘ tick
            dispatch({ type: "TICK", payload: { deltaSeconds } });

            // âœ… å…³é”®ï¼šåŒæ­¥ lastTickRefï¼Œé˜²æ­¢ interval ä¸‹ä¸€æ¬¡åˆç”¨æ—§çš„ lastTickRef å†è¡¥ä¸€é
            if (lastTickRef?.current != null) {
                lastTickRef.current = Date.now();
            }
        };

        document.addEventListener("visibilitychange", onVisChange);
        return () => document.removeEventListener("visibilitychange", onVisChange);
    }, [dispatch]); // lastTickRef æ˜¯ refï¼Œä¸ç”¨æ”¾ä¾èµ–

    // åŠ è½½å­˜æ¡£
    useEffect(() => {
        const savedState = loadFromLocalStorage();
        if (savedState) {
            // åˆå¹¶åˆå§‹çŠ¶æ€å’Œä¿å­˜çš„çŠ¶æ€ï¼Œç¡®ä¿æ–°å­—æ®µæœ‰é»˜è®¤å€¼
            const mergedState = {
                ...initialState,
                ...savedState,

                // âœ… å…³é”®ï¼šé˜²æ­¢æ—§å­˜æ¡£æŠŠå¯¹è±¡å­—æ®µè¦†ç›–æˆ null
                buildings: savedState.buildings && typeof savedState.buildings === 'object' ? savedState.buildings : {},
                functionalBuildings: savedState.functionalBuildings && typeof savedState.functionalBuildings === 'object' ? savedState.functionalBuildings : {},
                resourceAssignments: savedState.resourceAssignments && typeof savedState.resourceAssignments === 'object' ? savedState.resourceAssignments : {},
                assignments: savedState.assignments && typeof savedState.assignments === 'object' ? savedState.assignments : {},
                research: savedState.research && typeof savedState.research === 'object' ? savedState.research : {},
                dropFilters: savedState.dropFilters && typeof savedState.dropFilters === 'object' ? savedState.dropFilters : {},
                maxCharacterSlots: initialState.maxCharacterSlots,
                zones: JSON.parse(JSON.stringify(ZONES)),
                combatLogs: savedState.combatLogs || [],
                offlineRewards: null
            };

            // ä½¿ç”¨å¯¼å…¥åŠŸèƒ½åŠ è½½çŠ¶æ€
            dispatch({ type: 'IMPORT_SAVE', payload: encodeBase64(JSON.stringify(mergedState)) });
        }

        dispatch({ type: 'CALCULATE_OFFLINE_REWARDS' });
    }, []);

    // è‡ªåŠ¨ä¿å­˜ï¼ˆæ¯10ç§’ï¼‰
    useEffect(() => {
        saveIntervalRef.current = setInterval(() => {
            saveToLocalStorage(state);
        }, 10000);

        return () => {
            if (saveIntervalRef.current) {
                clearInterval(saveIntervalRef.current);
                saveToLocalStorage(state); // åœ¨ç»„ä»¶å¸è½½æ—¶ä¹Ÿä¿å­˜ä¸€æ¬¡
            }
        };
    }, [state]);

    // æ¸¸æˆä¸»å¾ªç¯
    useEffect(() => {
        if (!isPaused) {
            intervalRef.current = setInterval(() => {
                const now = Date.now();
                const deltaSeconds = Math.max(1, Math.floor((now - lastTickRef.current) / 1000));
                lastTickRef.current = now;

                dispatch({ type: 'TICK', payload: { deltaSeconds } });
            }, 1000);
        }
        return () => clearInterval(intervalRef.current);
    }, [isPaused]);




    const executeCommand = (cmd) => {
        const trimmed = cmd.trim();
        if (!trimmed) return;

        setConsoleLogs(prev => [...prev, `> ${trimmed}`]);

        const parts = trimmed.split(' ');
        const mainCmd = parts[0].toLowerCase();

        if (mainCmd === 'add') {
            const subCmd = parts[1]?.toLowerCase();

            if (subCmd === 'gold' && parts[2]) {
                const amount = parseFloat(parts[2]);
                if (!isNaN(amount) && amount > 0) {
                    dispatch({ type: 'CHEAT_ADD_GOLD', payload: amount });
                    setConsoleLogs(prev => [...prev, `âœ“ æˆåŠŸæ·»åŠ  ${amount} é‡‘å¸`]);
                } else {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šé‡‘å¸æ•°é‡å¿…é¡»æ˜¯æ­£æ•°']);
                }
            }
            else if (subCmd === 'equip' && parts[2]) {
                const equipArg = parts[2];
                const [idRaw, levelStr] = equipArg.split(',');
                if (!idRaw) {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šè£…å¤‡IDä¸èƒ½ä¸ºç©º']);
                    return;
                }

                const id = idRaw.trim().toUpperCase();
                const level = parseInt(levelStr?.trim()) || 1;
                const clampedLevel = Math.max(1, Math.min(100, level));

                const tpl = getEquipmentTemplate(id) ;
                if (!tpl) {
                    setConsoleLogs(prev => [...prev, `âœ— é”™è¯¯ï¼šæ‰¾ä¸åˆ°è£…å¤‡ ID "${id}"`]);
                    return;
                }

                const instance = {
                    ...tpl,
                    instanceId: `cheat_${Date.now()}_${Math.random().toString(36)}`,
                    qualityColor: getRarityColor(tpl.rarity),
                    currentLevel: clampedLevel,
                    stats: scaleStats(tpl.baseStats, tpl.growth, clampedLevel)
                };

                dispatch({ type: 'CHEAT_ADD_EQUIPMENT', payload: instance });
                setConsoleLogs(prev => [...prev, `âœ“ æˆåŠŸæ·»åŠ  ${tpl.name} (ID: ${id}) Lv.${clampedLevel}`]);

                if (clampedLevel >= 100) {
                    dispatch({ type: 'CHEAT_ADD_LV100_CODEX', payload: id });
                }
            }
            else if (subCmd === 'bagslot' && parts[2]) {
                const amount = parseInt(parts[2]);
                if (!isNaN(amount) && amount > 0) {
                    dispatch({ type: 'CHEAT_ADD_BAGSLOT', payload: amount });
                    setConsoleLogs(prev => [...prev, `âœ“ æˆåŠŸå¢åŠ  ${amount} ä¸ªèƒŒåŒ…æ ä½ï¼ˆå½“å‰æ€»æ ä½ï¼š${state.inventorySize + amount}ï¼‰`]);
                } else {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šæ ä½æ•°é‡å¿…é¡»æ˜¯æ­£æ•´æ•°']);
                }
            }
            // ===== æ–°å¢ï¼šadd exp =====
            else if (subCmd === 'exp' && parts[2]) {
                const expArg = parts[2];
                const [amountStr, indexStr] = expArg.split(',');
                const amount = parseInt(amountStr?.trim());
                const index1Based = parseInt(indexStr?.trim());

                if (isNaN(amount) || amount <= 0) {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šç»éªŒå€¼å¿…é¡»æ˜¯æ­£æ•´æ•°']);
                    return;
                }
                if (isNaN(index1Based) || index1Based < 1 || index1Based > state.characters.length) {
                    setConsoleLogs(prev => [...prev, `âœ— é”™è¯¯ï¼šè§’è‰²ç´¢å¼•æ— æ•ˆï¼ˆå½“å‰æœ‰ ${state.characters.length} ä¸ªè§’è‰²ï¼Œç´¢å¼•èŒƒå›´ 1~${state.characters.length}ï¼‰`]);
                    return;
                }

                const charIndex = index1Based - 1; // è½¬ä¸º0-basedç´¢å¼•
                dispatch({ type: 'CHEAT_ADD_EXP', payload: { amount, charIndex } });
                const char = state.characters[charIndex];
                setConsoleLogs(prev => [...prev, `âœ“ æˆåŠŸç»™ ${char.name} (ç¬¬${index1Based}ä¸ªè§’è‰²) æ·»åŠ  ${amount} ç»éªŒ`]);
            }// ===== æ–°å¢ï¼šadd rebirth bonus exp,gold,drop,researchSpeed =====
            else if (subCmd === 'rebirth' && parts[2]?.toLowerCase() === 'bonus' && parts[3]) {
                const values = parts[3].split(',').map(s => parseFloat(s.trim()));
                if (values.length !== 4 || values.some(v => Number.isNaN(v)) || values.some(v => v < 0)) {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šç”¨æ³• add rebirth bonus <exp,gold,drop,researchSpeed>ï¼ˆ4ä¸ªéè´Ÿæ•°å­—ï¼‰']);
                    setConsoleLogs(prev => [...prev, '   ç¤ºä¾‹ï¼šadd rebirth bonus 0.2,0.2,0.1,0.1']);
                    return;
                }

                const [exp, gold, drop, researchSpeed] = values;
                dispatch({ type: 'CHEAT_SET_REBIRTH_BONUS', payload: { exp, gold, drop, researchSpeed } });
                setConsoleLogs(prev => [...prev, `âœ“ å·²è®¾ç½®è½®å›åŠ æˆï¼šexp=${exp}, gold=${gold}, drop=${drop}, research=${researchSpeed}`]);
            }
            else {
                setConsoleLogs(prev => [...prev, 'âœ— ç”¨æ³•ï¼š']);
                setConsoleLogs(prev => [...prev, '   add gold <æ•°é‡>']);
                setConsoleLogs(prev => [...prev, '   add equip <è£…å¤‡ID>,<ç­‰çº§>ï¼ˆç­‰çº§å¯é€‰ï¼‰']);
                setConsoleLogs(prev => [...prev, '   add bagslot <æ•°é‡>']);
                setConsoleLogs(prev => [...prev, '   add exp <ç»éªŒå€¼>,<è§’è‰²ç´¢å¼•>ï¼ˆç´¢å¼•ä»1å¼€å§‹ï¼‰']);
                setConsoleLogs(prev => [...prev, '   ç¤ºä¾‹ï¼šadd exp 99999,1']);
            }
        }
        else {
            setConsoleLogs(prev => [...prev, 'âœ— æœªçŸ¥å‘½ä»¤ï¼Œç›®å‰ä»…æ”¯æŒ add gold / add equip / add bagslot / add exp']);
        }

        setCommand('');
    };

    const exportSave = () => {
        const saveData = encodeBase64(JSON.stringify(state));
        navigator.clipboard?.writeText(saveData);
        setShowExport(true);
        setTimeout(() => setShowExport(false), 2000);
    };

    const importSave = () => {
        if (importData.trim()) {
            dispatch({ type: 'IMPORT_SAVE', payload: importData.trim() });
            setImportData('');
        }
    };

    const menus = [
        { id: 'map', name: 'åœ°å›¾', icon: 'ğŸ—ºï¸' },
        { id: 'character', name: 'è§’è‰²', icon: 'ğŸ‘¥' },
        { id: 'talent', name: 'å¤©èµ‹', icon: 'ğŸŒŸ' },
        { id: 'inventory', name: 'é“å…·', icon: 'ğŸ“¦' },
        { id: 'city', name: 'ä¸»åŸ', icon: 'ğŸ°' },
        { id: 'research', name: 'ç ”ç©¶', icon: 'ğŸ”¬' },
        { id: 'worldboss', name: 'ä¸–ç•Œé¦–é¢†', icon: 'ğŸ²' },
        { id: 'achievement', name: 'æˆå°±', icon: 'ğŸ†' },
        { id: 'codex', name: 'å›¾é‰´', icon: 'ğŸ“š' },
        { id: 'quest', name: 'ä»»åŠ¡', icon: 'ğŸ“œ' },
    ];

    const renderPage = () => {
        switch (state.currentMenu) {
            case 'map': return <MapPage state={state} dispatch={dispatch} />;
            case 'character': return <CharacterPage state={state} dispatch={dispatch} />;
            case 'talent': return <TalentPage state={state} dispatch={dispatch} />;
            case 'inventory': return <InventoryPage state={state} dispatch={dispatch} />;
            case 'city': return <CityPage state={state} dispatch={dispatch} />;
            case 'research': return <ResearchPage state={state} dispatch={dispatch} />;
            case 'worldboss': return <WorldBossPage state={state} dispatch={dispatch}/>;
            case 'achievement': return <AchievementPage state={state} />;
            case 'codex': return <CodexPage state={state} dispatch={dispatch} />;
            case 'quest': return <QuestPage state={state} dispatch={dispatch} />;
            default: return <MapPage state={state} dispatch={dispatch} />;
        }
    };

    return (
        <div style={{
            minHeight: '100vh',
            width: '100%',
            boxSizing: 'border-box',
            background: 'linear-gradient(135deg, #1a1510 0%, #0d0a07 50%, #151210 100%)',
            fontFamily: '"Noto Serif SC", "Cinzel", Georgia, serif',
            color: '#e8dcc4',
            padding: 16,
        }}>
            <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Noto+Serif+SC:wght@400;600&display=swap');
        
        * { box-sizing: border-box; }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background: #4a3c2a; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #5a4c3a; }
        
        select, input { font-family: inherit; }
      `}</style>

            {state.offlineRewards && (
                <OfflineRewardsModal
                    rewards={state.offlineRewards.rewards}
                    actualSeconds={state.offlineRewards.actualSeconds}
                    maxSeconds={state.offlineRewards.maxSeconds}
                    onClaim={() => dispatch({
                        type: 'APPLY_OFFLINE_REWARDS',
                        payload: state.offlineRewards
                    })}
                    onDismiss={() => dispatch({ type: 'DISMISS_OFFLINE_REWARDS' })}
                />
            )}

            {/* ===== æ·»åŠ ä¸¤ä¸ªBossæ¨¡æ€ ===== */}
            {state.prepareBoss && <BossPrepareModal state={state} dispatch={dispatch} />}
            {state.bossCombat && <BossCombatModal combat={state.bossCombat} state={state} />}

            <HoggerPlotModal state={state} dispatch={dispatch} />
            <ScarletBadgeModal state={state} dispatch={dispatch} />
            <RebirthConfirmModal state={state} dispatch={dispatch} />
            {state.showRebirthPlot && <RebirthPlotModal state={state} dispatch={dispatch} />}
            {showRebirthBonus && <RebirthBonusModal state={state} onClose={() => setShowRebirthBonus(false)} />}

            {/* Header */}
            <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: 16,
                padding: '12px 20px',
                background: 'linear-gradient(180deg, rgba(40,30,20,0.9), rgba(25,18,12,0.95))',
                border: '2px solid #4a3c2a',
                borderRadius: 8,
                boxShadow: '0 4px 12px rgba(0,0,0,0.5)',
            }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: 16 }}>
                    <h1 style={{
                        margin: 0,
                        fontSize: 24,
                        color: '#c9a227',
                        textShadow: '2px 2px 4px rgba(0,0,0,0.8)',
                        fontWeight: 700,
                    }}>
                        âš”ï¸ è‰¾æ³½æ‹‰æ–¯ä¸‡ä¸–è½®å›
                    </h1>
                    <span style={{
                        padding: '4px 12px',
                        background: 'rgba(201,162,39,0.2)',
                        borderRadius: 4,
                        fontSize: 12,
                        color: '#c9a227',
                    }}>
            æœ¬ä¸–å¸§: {Math.floor(state.lifeFrame || 0)} ï½œ æ€»å¸§: {Math.floor(state.frame)}
          </span>
                </div>

                <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                        <span style={{ fontSize: 12, color: '#888' }}>ğŸª™ {Math.floor(state.resources.gold)}</span>
                    </div>

                    <Button onClick={() => setShowRebirthBonus(true)} variant="secondary" style={{ padding: '6px 10px', fontSize: 11 }}>
                        âš¡ è½®å›åŠ æˆ
                    </Button>

                    {state.rebirthUnlocked && (
                        <Button onClick={() => dispatch({ type: 'OPEN_REBIRTH_CONFIRM' })} variant="danger">
                            é‡ç”Ÿè½®å›
                        </Button>
                    )}

                    <Button onClick={() => setIsPaused(!isPaused)} variant="secondary">
                        {isPaused ? 'â–¶ï¸ ç»§ç»­' : 'â¸ï¸ æš‚åœ'}
                    </Button>

                    <Button onClick={exportSave} variant="secondary">
                        {showExport ? 'âœ“ å·²å¤åˆ¶' : 'ğŸ’¾ å¯¼å‡º'}
                    </Button>

                    <div style={{ display: 'flex', gap: 4 }}>
                        <input
                            type="text"
                            placeholder="ç²˜è´´å­˜æ¡£..."
                            value={importData}
                            onChange={(e) => setImportData(e.target.value)}
                            style={{
                                padding: '6px 10px',
                                width: 120,
                                background: 'rgba(0,0,0,0.4)',
                                border: '1px solid #4a3c2a',
                                borderRadius: 4,
                                color: '#fff',
                                fontSize: 12,
                            }}
                        />
                        <Button onClick={importSave} variant="secondary">å¯¼å…¥</Button>
                    </div>
                </div>
            </div>

            {/* Navigation */}
            <div style={{
                display: 'flex',
                gap: 4,
                marginBottom: 16,
                padding: 4,
                background: 'rgba(0,0,0,0.3)',
                borderRadius: 8,
                border: '1px solid #3a3a3a',
            }}>
                {menus.map(menu => (
                    <button
                        key={menu.id}
                        onClick={() => dispatch({ type: 'SET_MENU', payload: menu.id })}
                        style={{
                            flex: 1,
                            padding: '12px 16px',
                            background: state.currentMenu === menu.id
                                ? 'linear-gradient(180deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))'
                                : 'transparent',
                            border: state.currentMenu === menu.id
                                ? '1px solid #c9a227'
                                : '1px solid transparent',
                            borderRadius: 6,
                            color: state.currentMenu === menu.id ? '#ffd700' : '#888',
                            cursor: 'pointer',
                            fontFamily: 'inherit',
                            fontSize: 13,
                            transition: 'all 0.2s',
                            textShadow: state.currentMenu === menu.id ? '0 0 10px rgba(255,215,0,0.5)' : 'none',
                        }}
                    >
                        {menu.icon} {menu.name}
                    </button>
                ))}
            </div>

            {/* Content */}
            <div style={{ minHeight: 'calc(100vh - 160px)' }}>
                {renderPage()}
            </div>

            {/* ä»»åŠ¡è¿½è¸ªæ‚¬æµ®UI */}
            <QuestTracker
                state={state}
                dispatch={dispatch}
                onOpenQuestPage={handleOpenQuestPage}
            />

            {/* ä»»åŠ¡æç¤ºToasts */}
            {questToasts.map(toast => (
                <QuestToast
                    key={toast.id}
                    message={toast.message}
                    type={toast.type}
                    onClose={() => removeQuestToast(toast.id)}
                />
            ))}

            {/* å¼€å‘è€…æ§åˆ¶å° */}
            {consoleOpen && (
                <div style={{
                    position: 'fixed',
                    bottom: 0,
                    left: 0,
                    right: 0,
                    background: 'rgba(0,0,0,0.95)',
                    borderTop: '2px solid #0f0',
                    padding: '10px',
                    zIndex: 9999,
                    fontFamily: 'monospace',
                    color: '#0f0',
                    maxHeight: '40vh',
                    display: 'flex',
                    flexDirection: 'column'
                }}>
                    <div style={{
                        flex: 1,
                        overflowY: 'auto',
                        marginBottom: '8px',
                        paddingRight: '8px'
                    }}>
                        {consoleLogs.map((log, i) => (
                            <div key={i}>{log}</div>
                        ))}
                    </div>
                    <input
                        autoFocus
                        value={command}
                        onChange={(e) => setCommand(e.target.value)}
                        onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                                executeCommand(command);
                            }
                        }}
                        placeholder="è¾“å…¥å‘½ä»¤ï¼ŒæŒ‰ Enter æ‰§è¡Œï¼ŒæŒ‰ ` å…³é—­"
                        style={{
                            width: '100%',
                            background: 'transparent',
                            border: '1px solid #0f0',
                            color: '#0f0',
                            padding: '8px',
                            fontFamily: 'monospace',
                            outline: 'none'
                        }}
                    />
                </div>
            )}
        </div>
    );
}

// ==================== CSSåŠ¨ç”»ï¼ˆæ·»åŠ åˆ°styleæ ‡ç­¾ä¸­ï¼‰   ====================
const questAnimationStyles = `
    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    }
    
    @keyframes pulse {
        0%, 100% {
            transform: scale(1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }
        50% {
            transform: scale(1.1);
            box-shadow: 0 2px 16px rgba(255,152,0,0.6);
        }
    }
    
    @keyframes glow {
        0%, 100% {
            box-shadow: 0 0 5px rgba(201,162,39,0.3);
        }
        50% {
            box-shadow: 0 0 20px rgba(201,162,39,0.6);
        }
    }
`;

// ==================== å¢å¼ºç‰ˆä»»åŠ¡è¿½è¸ªï¼ˆå¸¦åœ°å›¾æ ‡è®°ï¼‰ ====================
const EnhancedQuestTracker = ({ state, dispatch, onOpenQuestPage }) => {
    const [isCollapsed, setIsCollapsed] = useState(false);
    const [expandedQuests, setExpandedQuests] = useState(new Set());
    const [isMinimized, setIsMinimized] = useState(false);
    const [showHints, setShowHints] = useState(true);

    // è·å–æ‰€æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡
    const activeQuests = Object.entries(state.questProgress || {})
        .filter(([_, progress]) => progress.status === 'in_progress')
        .map(([questId, progress]) => ({
            questId,
            progress,
            questData: QUEST_CHAINS[questId]
        }))
        .filter(q => q.questData);

    // è·å–å½“å‰æ­¥éª¤éœ€è¦å»çš„åœ°ç‚¹
    const getQuestLocations = () => {
        const locations = [];

        activeQuests.forEach(({ questId, progress, questData }) => {
            const currentStep = questData.steps[progress.currentStep];
            if (!currentStep?.requirement) return;

            const req = currentStep.requirement;

            if (req.type === 'zone_battles' && req.zoneId) {
                locations.push({
                    questId,
                    questName: questData.name,
                    stepTitle: currentStep.title,
                    zoneId: req.zoneId,
                    zoneName: ZONES[req.zoneId]?.name,
                    type: 'battle',
                    current: state.questBattleProgress?.[req.zoneId] || 0,
                    target: req.count
                });
            }

            if (req.type === 'boss_defeated' && req.bossId) {
                locations.push({
                    questId,
                    questName: questData.name,
                    stepTitle: currentStep.title,
                    bossId: req.bossId,
                    bossName: BOSS_DATA[req.bossId]?.name,
                    type: 'boss',
                    completed: state.defeatedBosses?.includes(req.bossId)
                });
            }
        });

        return locations;
    };

    const questLocations = getQuestLocations();

    // æ£€æŸ¥æ­¥éª¤æ¡ä»¶è¿›åº¦
    const getRequirementProgress = (requirement) => {
        if (!requirement) return { met: true, current: 0, target: 0, text: '' };

        switch (requirement.type) {
            case 'zone_battles': {
                const zone = ZONES[requirement.zoneId];
                const zoneName = zone?.name || requirement.zoneId;
                const current = state.questBattleProgress?.[requirement.zoneId] || 0;
                const target = requirement.count;
                return {
                    met: current >= target,
                    current,
                    target,
                    text: `åœ¨${zoneName}æˆ˜æ–—`,
                    icon: 'âš”ï¸',
                    hint: `å‰å¾€åœ°å›¾ > ${zoneName}æ´¾é£è§’è‰²æˆ˜æ–—`
                };
            }
            case 'character_level': {
                const maxLevel = Math.max(...state.characters.map(c => c.level), 0);
                return {
                    met: maxLevel >= requirement.level,
                    current: maxLevel,
                    target: requirement.level,
                    text: `è§’è‰²ç­‰çº§è¾¾åˆ°`,
                    icon: 'â­',
                    hint: 'é€šè¿‡æˆ˜æ–—è·å¾—ç»éªŒå‡çº§'
                };
            }
            case 'boss_defeated': {
                const bossName = BOSS_DATA[requirement.bossId]?.name || requirement.bossId;
                const defeated = state.defeatedBosses?.includes(requirement.bossId);
                return {
                    met: defeated,
                    current: defeated ? 1 : 0,
                    target: 1,
                    text: `å‡»è´¥${bossName}`,
                    icon: 'ğŸ²',
                    hint: `å‰å¾€ä¸–ç•Œé¦–é¢†æŒ‘æˆ˜${bossName}`
                };
            }
            case 'have_gold': {
                return {
                    met: state.resources.gold >= requirement.amount,
                    current: Math.floor(state.resources.gold),
                    target: requirement.amount,
                    text: `å‡†å¤‡é‡‘å¸`,
                    icon: 'ğŸª™',
                    hint: 'é€šè¿‡æˆ˜æ–—å’Œå‡ºå”®ç‰©å“è·å¾—é‡‘å¸'
                };
            }
            case 'have_item': {
                const hasItem = state.inventory.some(i => i.id === requirement.itemId) ||
                    state.questItems?.some(i => i.id === requirement.itemId);
                const itemName = QUEST_ITEMS[requirement.itemId]?.name ||
                    ITEMS[requirement.itemId]?.name ||
                    requirement.itemId;
                return {
                    met: hasItem,
                    current: hasItem ? 1 : 0,
                    target: 1,
                    text: `è·å¾—${itemName}`,
                    icon: 'ğŸ“¦',
                    hint: 'é€šè¿‡æ¢ç´¢æˆ–æˆ˜æ–—è·å¾—ç‰©å“'
                };
            }
            default:
                return { met: true, current: 0, target: 0, text: '', hint: '' };
        }
    };

    // åˆ‡æ¢ä»»åŠ¡å±•å¼€çŠ¶æ€
    const toggleQuestExpand = (questId) => {
        setExpandedQuests(prev => {
            const next = new Set(prev);
            if (next.has(questId)) {
                next.delete(questId);
            } else {
                next.add(questId);
            }
            return next;
        });
    };

    // å¿«é€Ÿå¯¼èˆªåˆ°ç›®æ ‡ä½ç½®
    const navigateToLocation = (location) => {
        if (location.type === 'battle' && location.zoneId) {
            dispatch({ type: 'SET_MENU', payload: 'map' });
        } else if (location.type === 'boss') {
            dispatch({ type: 'SET_MENU', payload: 'worldboss' });
        }
    };

    // å¦‚æœæ²¡æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡
    if (activeQuests.length === 0) {
        return (
            <div style={{
                position: 'fixed',
                top: 100,
                right: 16,
                width: 280,
                background: 'linear-gradient(135deg, rgba(30,25,20,0.95) 0%, rgba(20,15,12,0.98) 100%)',
                border: '2px solid #4a3c2a',
                borderRadius: 10,
                padding: 12,
                boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                zIndex: 100
            }}>
                <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between'
                }}>
                    <div style={{
                        fontSize: 13,
                        color: '#c9a227',
                        fontWeight: 600,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span>ğŸ“œ</span>
                        ä»»åŠ¡è¿½è¸ª
                    </div>
                </div>
                <div style={{
                    marginTop: 12,
                    textAlign: 'center',
                    color: '#666',
                    fontSize: 12,
                    padding: '16px 0'
                }}>
                    <div style={{ fontSize: 24, marginBottom: 8 }}>ğŸ“­</div>
                    æš‚æ— è¿›è¡Œä¸­çš„ä»»åŠ¡
                    <button
                        onClick={() => onOpenQuestPage?.()}
                        style={{
                            display: 'block',
                            width: '100%',
                            marginTop: 12,
                            padding: '8px 12px',
                            background: 'rgba(201,162,39,0.2)',
                            border: '1px solid #c9a227',
                            borderRadius: 6,
                            color: '#c9a227',
                            fontSize: 11,
                            cursor: 'pointer',
                            fontFamily: 'inherit'
                        }}
                    >
                        æŸ¥çœ‹å¯ç”¨ä»»åŠ¡
                    </button>
                </div>
            </div>
        );
    }

    // æœ€å°åŒ–æ¨¡å¼
    if (isMinimized) {
        return (
            <div
                onClick={() => setIsMinimized(false)}
                style={{
                    position: 'fixed',
                    top: 100,
                    right: 16,
                    width: 50,
                    height: 50,
                    background: 'linear-gradient(135deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))',
                    border: '2px solid #c9a227',
                    borderRadius: '50%',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    cursor: 'pointer',
                    boxShadow: '0 4px 20px rgba(201,162,39,0.3)',
                    zIndex: 100,
                    animation: 'glow 2s infinite'
                }}
                title="å±•å¼€ä»»åŠ¡è¿½è¸ª"
            >
                <div style={{ position: 'relative' }}>
                    <span style={{ fontSize: 24 }}>ğŸ“œ</span>
                    <div style={{
                        position: 'absolute',
                        top: -8,
                        right: -8,
                        background: '#f44336',
                        color: '#fff',
                        fontSize: 10,
                        fontWeight: 700,
                        width: 18,
                        height: 18,
                        borderRadius: '50%',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        border: '2px solid #1a1510'
                    }}>
                        {activeQuests.length}
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div style={{
            position: 'fixed',
            top: 100,
            right: 16,
            width: isCollapsed ? 50 : 320,
            maxHeight: 'calc(100vh - 140px)',
            background: 'linear-gradient(135deg, rgba(30,25,20,0.97) 0%, rgba(20,15,12,0.99) 100%)',
            border: '2px solid #c9a227',
            borderRadius: 10,
            overflow: 'hidden',
            boxShadow: '0 4px 24px rgba(0,0,0,0.6), 0 0 20px rgba(201,162,39,0.15)',
            zIndex: 100,
            transition: 'width 0.3s ease',
            display: 'flex',
            flexDirection: 'column'
        }}>
            {/* æ ‡é¢˜æ  */}
            <div style={{
                padding: '10px 12px',
                background: 'linear-gradient(180deg, rgba(201,162,39,0.15) 0%, transparent 100%)',
                borderBottom: '1px solid rgba(201,162,39,0.3)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                flexShrink: 0
            }}>
                {!isCollapsed && (
                    <div style={{
                        fontSize: 14,
                        color: '#ffd700',
                        fontWeight: 600,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span>ğŸ“œ</span>
                        ä»»åŠ¡è¿½è¸ª
                        <span style={{
                            fontSize: 11,
                            color: '#888',
                            fontWeight: 400
                        }}>
                            ({activeQuests.length})
                        </span>
                    </div>
                )}

                <div style={{ display: 'flex', gap: 4 }}>
                    {!isCollapsed && (
                        <>
                            <button
                                onClick={() => setShowHints(!showHints)}
                                style={{
                                    background: showHints ? 'rgba(201,162,39,0.2)' : 'transparent',
                                    border: showHints ? '1px solid #c9a227' : 'none',
                                    color: showHints ? '#c9a227' : '#666',
                                    fontSize: 12,
                                    cursor: 'pointer',
                                    padding: '2px 6px',
                                    borderRadius: 4
                                }}
                                title={showHints ? 'éšè—æç¤º' : 'æ˜¾ç¤ºæç¤º'}
                            >
                                ğŸ’¡
                            </button>
                            <button
                                onClick={() => setIsMinimized(true)}
                                style={{
                                    background: 'transparent',
                                    border: 'none',
                                    color: '#888',
                                    fontSize: 14,
                                    cursor: 'pointer',
                                    padding: '2px 6px',
                                    borderRadius: 4
                                }}
                                title="æœ€å°åŒ–"
                            >
                                â”€
                            </button>
                        </>
                    )}
                    <button
                        onClick={() => setIsCollapsed(!isCollapsed)}
                        style={{
                            background: 'transparent',
                            border: 'none',
                            color: '#c9a227',
                            fontSize: 16,
                            cursor: 'pointer',
                            padding: '2px 6px',
                            borderRadius: 4
                        }}
                        title={isCollapsed ? 'å±•å¼€' : 'æŠ˜å '}
                    >
                        {isCollapsed ? 'â—€' : 'â–¶'}
                    </button>
                </div>
            </div>

            {/* ä»»åŠ¡åˆ—è¡¨ */}
            {!isCollapsed && (
                <div style={{
                    flex: 1,
                    overflowY: 'auto',
                    padding: 8
                }}>
                    {activeQuests.map(({ questId, progress, questData }) => {
                        const currentStep = questData.steps[progress.currentStep];
                        const isExpanded = expandedQuests.has(questId);
                        const requirement = currentStep?.requirement;
                        const reqProgress = getRequirementProgress(requirement);

                        return (
                            <div
                                key={questId}
                                style={{
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: 8,
                                    marginBottom: 8,
                                    border: '1px solid rgba(201,162,39,0.2)',
                                    overflow: 'hidden'
                                }}
                            >
                                {/* ä»»åŠ¡æ ‡é¢˜ */}
                                <div
                                    onClick={() => toggleQuestExpand(questId)}
                                    style={{
                                        padding: '10px 12px',
                                        cursor: 'pointer',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: 10,
                                        background: isExpanded ? 'rgba(201,162,39,0.1)' : 'transparent'
                                    }}
                                >
                                    <span style={{ fontSize: 20 }}>{questData.icon}</span>
                                    <div style={{ flex: 1, minWidth: 0 }}>
                                        <div style={{
                                            fontSize: 12,
                                            color: '#ffd700',
                                            fontWeight: 600,
                                            whiteSpace: 'nowrap',
                                            overflow: 'hidden',
                                            textOverflow: 'ellipsis'
                                        }}>
                                            {questData.name}
                                        </div>
                                        <div style={{
                                            fontSize: 10,
                                            color: '#888',
                                            marginTop: 2
                                        }}>
                                            {currentStep?.title}
                                        </div>
                                    </div>

                                    {/* å¿«é€ŸçŠ¶æ€æŒ‡ç¤º */}
                                    {requirement && (
                                        <div style={{
                                            width: 24,
                                            height: 24,
                                            borderRadius: '50%',
                                            background: reqProgress.met
                                                ? 'rgba(76,175,80,0.3)'
                                                : 'rgba(255,152,0,0.3)',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            fontSize: 12
                                        }}>
                                            {reqProgress.met ? 'âœ“' : reqProgress.icon}
                                        </div>
                                    )}

                                    <span style={{
                                        color: '#666',
                                        fontSize: 12,
                                        transform: isExpanded ? 'rotate(90deg)' : 'rotate(0)',
                                        transition: 'transform 0.2s'
                                    }}>
                                        â–¶
                                    </span>
                                </div>

                                {/* å±•å¼€å†…å®¹ */}
                                {isExpanded && (
                                    <div style={{
                                        padding: '0 12px 12px',
                                        borderTop: '1px solid rgba(201,162,39,0.1)'
                                    }}>
                                        {/* å½“å‰ç›®æ ‡ */}
                                        {requirement && (
                                            <div style={{
                                                marginTop: 10,
                                                padding: 10,
                                                background: reqProgress.met
                                                    ? 'rgba(76,175,80,0.15)'
                                                    : 'rgba(255,152,0,0.1)',
                                                borderRadius: 6,
                                                border: `1px solid ${reqProgress.met
                                                    ? 'rgba(76,175,80,0.3)'
                                                    : 'rgba(255,152,0,0.3)'}`
                                            }}>
                                                <div style={{
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: 8,
                                                    marginBottom: 6
                                                }}>
                                                    <span style={{ fontSize: 14 }}>{reqProgress.icon}</span>
                                                    <span style={{
                                                        fontSize: 11,
                                                        color: reqProgress.met ? '#4CAF50' : '#ff9800',
                                                        fontWeight: 600,
                                                        flex: 1
                                                    }}>
                                                        {reqProgress.text}
                                                    </span>
                                                    <span style={{
                                                        fontSize: 10,
                                                        color: reqProgress.met ? '#4CAF50' : '#ff9800'
                                                    }}>
                                                        {reqProgress.current}/{reqProgress.target}
                                                    </span>
                                                </div>

                                                {/* è¿›åº¦æ¡ */}
                                                <div style={{
                                                    height: 4,
                                                    background: 'rgba(0,0,0,0.4)',
                                                    borderRadius: 2,
                                                    overflow: 'hidden'
                                                }}>
                                                    <div style={{
                                                        height: '100%',
                                                        width: `${Math.min(100, (reqProgress.current / reqProgress.target) * 100)}%`,
                                                        background: reqProgress.met
                                                            ? '#4CAF50'
                                                            : 'linear-gradient(90deg, #ff9800, #ffc107)',
                                                        borderRadius: 2,
                                                        transition: 'width 0.3s'
                                                    }} />
                                                </div>

                                                {/* æç¤º */}
                                                {showHints && !reqProgress.met && reqProgress.hint && (
                                                    <div style={{
                                                        marginTop: 8,
                                                        fontSize: 10,
                                                        color: '#888',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: 4
                                                    }}>
                                                        <span>ğŸ’¡</span>
                                                        {reqProgress.hint}
                                                    </div>
                                                )}
                                            </div>
                                        )}

                                        {/* å¿«é€Ÿå¯¼èˆªæŒ‰é’® */}
                                        {questLocations.filter(l => l.questId === questId).map((location, idx) => (
                                            <button
                                                key={idx}
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    navigateToLocation(location);
                                                }}
                                                style={{
                                                    width: '100%',
                                                    marginTop: 8,
                                                    padding: '8px 10px',
                                                    background: 'linear-gradient(135deg, rgba(33,150,243,0.2), rgba(21,101,192,0.15))',
                                                    border: '1px solid rgba(33,150,243,0.4)',
                                                    borderRadius: 6,
                                                    color: '#64b5f6',
                                                    fontSize: 11,
                                                    cursor: 'pointer',
                                                    fontFamily: 'inherit',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    gap: 6
                                                }}
                                            >
                                                <span>ğŸ§­</span>
                                                å‰å¾€ {location.zoneName || location.bossName}
                                            </button>
                                        ))}

                                        {/* æŸ¥çœ‹è¯¦æƒ…æŒ‰é’® */}
                                        <button
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                onOpenQuestPage?.(questId);
                                            }}
                                            style={{
                                                width: '100%',
                                                marginTop: 8,
                                                padding: '8px 10px',
                                                background: 'rgba(0,0,0,0.3)',
                                                border: '1px solid #4a3c2a',
                                                borderRadius: 6,
                                                color: '#c9a227',
                                                fontSize: 11,
                                                cursor: 'pointer',
                                                fontFamily: 'inherit'
                                            }}
                                        >
                                            ğŸ“– æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ…
                                        </button>
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>
            )}
        </div>
    );
};

export { QuestTracker, EnhancedQuestTracker, QuestToast, QuestObjectiveIndicator, questAnimationStyles };