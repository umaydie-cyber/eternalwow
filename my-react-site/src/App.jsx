import React, { useState, useEffect, useCallback, useReducer, useRef } from 'react';

// ==================== GAME DATA ====================
const RACES = ['äººç±»', 'çŸ®äºº', 'æš—å¤œç²¾çµ', 'ä¾å„’', 'å…½äºº', 'å·¨é­”', 'ç‰›å¤´äºº', 'äº¡çµ'];

// ==================== BOSS BONUS CONFIG ====================
// ç»Ÿä¸€ç»´æŠ¤ï¼šBoss åç§° & é‡ç”ŸåŠ æˆï¼ˆé¿å…å¤šå¤„é‡å¤å¯¼è‡´ä¸ä¸€è‡´ï¼‰
const BOSS_BONUS_CONFIG = {
    hogger: { name: 'éœæ ¼', bonus: 0.05 },
    vancleef: { name: 'èŒƒå…‹é‡Œå¤«', bonus: 0.10 },
    prestor_lady: { name: 'æ™®ç‘æ–¯æ‰˜å¥³å£«', bonus: 0.15 },
    thalnos: { name: 'è£‚é­‚è€…è¨å°”è¯ºæ–¯', bonus: 0.15 },
    dagran_thaurissan: { name: 'è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸', bonus: 0.15 },
    darkmaster_gandling: { name: 'é»‘æš—é™¢é•¿åŠ ä¸', bonus: 0.20 },
    baron_rivendare: { name: 'ç‘æ–‡æˆ´å°”ç”·çˆµ', bonus: 0.20 },
    rend_blackhand: { name: 'é›·å¾·é»‘æ‰‹', bonus: 0.20 },
    hakkar: { name: 'è¡€ç¥å“ˆå¡', bonus: 0.25 },
    ossirian: { name: 'æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰', bonus: 0.25 },
    garr: { name: 'åŠ å°”', bonus: 0.25 },
    baron_geddon: { name: 'è¿¦é¡¿ç”·çˆµ', bonus: 0.25 },
    // âœ… æ–°å¢ï¼šç†”ç«ä¹‹å¿ƒ - ç„šåŒ–è€…å¤é›·æ›¼æ ¼
    golemagg: { name: 'ç„šåŒ–è€…å¤é›·æ›¼æ ¼', bonus: 0.25 },
    // âœ… æ–°å¢ï¼šç†”ç«ä¹‹å¿ƒ - ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯
    majordomo_executus: { name: 'ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯', bonus: 0.25 },

    // âœ… æ–°å¢ï¼šå›¢é˜Ÿé¦–é¢† - ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯
    // è¯´æ˜ï¼šå›¢é˜Ÿé¦–é¢†ä¸ä¸–ç•Œé¦–é¢†å…±ç”¨åŒä¸€å¥—æˆ˜æ–—/å¥–åŠ±ç»“ç®—æœºåˆ¶ï¼Œä»…åœ¨ UI/é˜Ÿä¼äººæ•°ä¸ŠåšåŒºåˆ†ã€‚
    ragnaros: { name: 'ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯', bonus: 0.30 },
};

// å…¼å®¹æ—§ä»£ç ï¼šæ´¾ç”Ÿå‡º names / bossBonus ä¸¤ä¸ªå¯¹è±¡ï¼ˆä¸å†æ‰‹å†™ç»´æŠ¤ï¼‰
const BOSS_NAMES = Object.fromEntries(
    Object.entries(BOSS_BONUS_CONFIG).map(([id, cfg]) => [id, cfg.name])
);
const BOSS_BONUS = Object.fromEntries(
    Object.entries(BOSS_BONUS_CONFIG).map(([id, cfg]) => [id, cfg.bonus])
);

// ==================== RACE TRAITS ====================
// è¯´æ˜ï¼šç§æ—è¢«åŠ¨æŠ€èƒ½/æ•ˆæœä¸å ç”¨æŠ€èƒ½æ ï¼ˆSkillEditor ä¼šè¿‡æ»¤ passiveï¼‰ã€‚
// å¦‚éœ€æ‰©å±•å…¶å®ƒç§æ—ï¼Œå¾€è¿™é‡Œç»§ç»­åŠ å³å¯ã€‚
const RACE_TRAITS = {
    'äººç±»': {
        // åˆå§‹é¢å¤–æŠ€èƒ½ï¼ˆä¼šå†™è¿›è§’è‰² skills åˆ—è¡¨ï¼Œç”¨äºå±•ç¤ºï¼‰
        extraSkills: ['racial_human_spirit', 'racial_human_hospitality'],
        // äººç±»ç²¾é­‚ï¼šå…¨èƒ½/ç²¾é€š/æš´å‡»/æ€¥é€Ÿ +2
        statBonus: { versatility: 2, mastery: 2, critRate: 2, haste: 2 },
        // å®¾è‡³å¦‚å½’ï¼šåœ°å›¾æˆ˜æ–—ç»“æŸåå›å¤æœ€å¤§ç”Ÿå‘½å€¼çš„ 10%
        mapCombatEndHealPct: 0.10,
    },
    'çŸ®äºº': {
        // é€‰æ‹©çŸ®äººè§’è‰²ï¼šé¢å¤–è·å¾—ä¸¤ä¸ªç§æ—æŠ€èƒ½
        extraSkills: ['racial_dwarf_spirit', 'racial_dwarf_stoneform'],
        // çŸ®äººç²¾é­„ï¼šæš´å‡»ä¼¤å®³ +15%ï¼ˆä»¥å€ç‡åŠ æˆï¼š0.15 => +15%ï¼‰
        statBonus: { critDamage: 0.15 },
        // çŸ³åƒå½¢æ€ï¼šæˆ˜æ–—ä¸­é¦–æ¬¡å—åˆ°è¯…å’’/ä¸­æ¯’æ•ˆæœæ—¶å…ç–«ï¼ˆæ¯ç§å„ 1 æ¬¡ï¼‰
        firstDebuffImmunity: { curse: true, poison: true },
    },
    'æš—å¤œç²¾çµ': {
        // é€‰æ‹©æš—å¤œç²¾çµè§’è‰²ï¼šé¢å¤–è·å¾—ä¸¤ä¸ªç§æ—æŠ€èƒ½
        extraSkills: ['racial_nightelf_spirit', 'racial_nightelf_shadowmeld'],
        // ç²¾çµç²¾é­„ï¼šæ—©æ™¨6ç‚¹-æ™šä¸Š6ç‚¹æš´å‡»+6ï¼›æ™šä¸Š6ç‚¹-æ¬¡æ—¥æ—©æ™¨6ç‚¹æ€¥é€Ÿ+6
        timeBasedStatBonus: {
            dayStart: 6,
            nightStart: 18,
            dayBonus: { critRate: 6 },
            nightBonus: { haste: 6 },
        },
        // éšéï¼šåœ°å›¾æˆ˜æ–—ç¬¬ä¸€æ ¼æŠ€èƒ½é€ æˆçš„ä¼¤å®³æé«˜20%ï¼ˆä¹˜ç®—ï¼‰
        mapFirstSlotDamageMult: 1.2,
    },
    'ä¾å„’': {
        // é€‰æ‹©ä¾å„’è§’è‰²ï¼šé¢å¤–è·å¾—ä¸¤ä¸ªç§æ—æŠ€èƒ½
        extraSkills: ['racial_gnome_spirit', 'racial_gnome_familiarity'],
        // ä¾å„’ç²¾é­„ï¼šå…¨èƒ½ +6
        statBonus: { versatility: 6 },
        // ç†Ÿç¨”ï¼šé‡‡é›†ç†Ÿç»ƒ +30
        gatherStatBonus: { proficiency: 30 },
    },
    'å…½äºº': {
        // é€‰æ‹©å…½äººè§’è‰²ï¼šé¢å¤–è·å¾—ä¸¤ä¸ªç§æ—æŠ€èƒ½
        extraSkills: ['racial_orc_spirit', 'racial_orc_bloodfury'],
        // å…½äººç²¾é­„ï¼šç²¾é€š +3ï¼Œå…¨èƒ½ +3
        statBonus: { mastery: 3, versatility: 3 },
        // è¡€æ€§ç‹‚æ€’ï¼šå‰4ä¸ªæŠ€èƒ½æ ¼é€ æˆçš„ä¼¤å®³æé«˜10%ï¼ˆä¹˜ç®—ï¼‰
        firstNSlotDamageMult: { n: 4, mult: 1.10 },
    },
    'å·¨é­”': {
        // é€‰æ‹©å·¨é­”è§’è‰²ï¼šé¢å¤–è·å¾—ä¸¤ä¸ªç§æ—æŠ€èƒ½
        extraSkills: ['racial_troll_spirit', 'racial_troll_berserking'],
        // å·¨é­”ç²¾é­„ï¼šè·å¾—6ç²¾é€š
        statBonus: { mastery: 6 },
        // ç‹‚æš´ï¼šå‰4ä¸ªæŠ€èƒ½æ ¼é¢å¤–è·å¾—20æ€¥é€Ÿï¼ˆåŠ æ³•ï¼‰
        firstNSlotStatBonus: { n: 4, stats: { haste: 20 } },
    },
    'ç‰›å¤´äºº': {
        // é€‰æ‹©ç‰›å¤´äººè§’è‰²ï¼šé¢å¤–è·å¾—ä¸¤ä¸ªç§æ—æŠ€èƒ½
        extraSkills: ['racial_tauren_spirit', 'racial_tauren_cultivation'],
        // ç‰›å¤´ç²¾é­„ï¼šè·å¾—10%é¢å¤–ç”Ÿå‘½å€¼ï¼ˆä¹˜åŒºï¼‰
        hpPctBonus: 0.10,
        // æ ½åŸ¹ï¼šå¢åŠ 30ç‚¹ç²¾ç»†
        gatherStatBonus: { precision: 30 },
    },
    'äº¡çµ': {
        // é€‰æ‹©äº¡çµè§’è‰²ï¼šé¢å¤–è·å¾—ä¸¤ä¸ªç§æ—æŠ€èƒ½
        extraSkills: ['racial_undead_spirit', 'racial_undead_will'],
        // äº¡çµç²¾é­„ï¼šè·å¾—6æš´å‡»
        statBonus: { critRate: 6 },
        // äº¡çµæ„å¿—ï¼šBossæˆ˜æ–—ä¸­å…ç–«å—åˆ°çš„ç¬¬ä¸€æ¬¡ææƒ§æ•ˆæœ
        firstFearImmunity: true,
    },

};


const CLASSES = {
    protection_warrior: {
        id: 'protection_warrior',
        name: 'é˜²æŠ¤æˆ˜å£«',
        baseStats: { hp: 150, mp: 50, attack: 15, spellPower: 5, armor: 30, magicResist: 10, blockValue: 20},
        baseGatherStats: { proficiency: 5, precision: 3, perception: 2 },
        skills: [
            { level: 1, skillId: 'basic_attack' },
            { level: 1, skillId: 'rest' },
            { level: 1, skillId: 'mastery_precise_block' },
            { level: 3, skillId: 'shield_bash' },
            { level: 5, skillId: 'shield_block' },
            { level: 10, skillId: 'revenge' },
            { level: 20, skillId: 'thunder_strike' },
            { level: 30, skillId: 'shield_wall' },
            { level: 50, skillId: 'victory_rush' },
        ]
    },
    discipline_priest: {
        id: 'discipline_priest',
        name: 'æˆ’å¾‹ç‰§å¸ˆ',
        baseStats: {
            hp: 100,
            mp: 120,
            attack: 5,
            spellPower: 15,
            armor: 10,
            magicResist: 20,
        },
        baseGatherStats: { proficiency: 5, precision: 3, perception: 2 },
        skills: [
            { level: 1, skillId: 'basic_attack' },
            { level: 1, skillId: 'rest' },
            { level: 1, skillId: 'mastery_atonement' },
            { level: 3, skillId: 'smite' },
            { level: 5, skillId: 'shadow_word_pain' },
            { level: 10, skillId: 'mind_blast' },
            { level: 20, skillId: 'power_word_radiance' },
            { level: 30, skillId: 'penance' },
            { level: 50, skillId: 'holy_nova' },
        ]
    },
    frost_mage: {
        id: 'frost_mage',
        name: 'å†°éœœæ³•å¸ˆ',
        baseStats: {
            hp: 90,
            mp: 150,
            attack: 5,
            spellPower: 18,
            armor: 8,
            magicResist: 25,
        },
        baseGatherStats: { proficiency: 5, precision: 3, perception: 2 },
        skills: [
            { level: 1, skillId: 'basic_attack' },
            { level: 1, skillId: 'rest' },
            { level: 1, skillId: 'mastery_deep_winter' },
            { level: 3, skillId: 'frostbolt' },
            { level: 5, skillId: 'ice_lance' },
            { level: 10, skillId: 'blizzard' },
            { level: 20, skillId: 'frozen_orb' },
            { level: 30, skillId: 'icy_veins' },
            { level: 40, skillId: 'comet_storm' },
            { level: 50, skillId: 'ice_barrier' },
            { level: 52, skillId: 'conditional_frost_strike' },
        ]
    },
    outlaw_rogue: {
        id: 'outlaw_rogue',
        name: 'ç‹‚å¾’ç›—è´¼',
        baseStats: {
            hp: 120,
            mp: 60,
            attack: 18,
            spellPower: 5,
            armor: 18,
            magicResist: 10,
        },
        baseGatherStats: { proficiency: 5, precision: 3, perception: 2 },
        skills: [
            { level: 1, skillId: 'basic_attack' },
            { level: 1, skillId: 'rest' },
            { level: 1, skillId: 'mastery_sword_heart' },
            { level: 3, skillId: 'blade_flurry' },
            { level: 5, skillId: 'shadowstrike' },
            { level: 10, skillId: 'eviscerate' },
            { level: 20, skillId: 'ambush' },
            { level: 30, skillId: 'crimson_vial' },
            { level: 40, skillId: 'slice_and_dice' },
            { level: 50, skillId: 'between_the_eyes' },
            { level: 60, skillId: 'adrenaline_rush' },
        ]
    }
};

// ==================== èµ„æºå»ºç­‘ï¼ˆä¸å¯å»ºé€ ï¼Œç”¨äºæ´¾é£é‡‡é›†ï¼‰ ====================
const RESOURCE_BUILDINGS = {
    lumber_mill: {
        id: 'lumber_mill',
        name: 'ä¼æœ¨åœº',
        icon: 'ğŸª“',
        description: 'æ´¾é£è§’è‰²ç ä¼æœ¨æ',
        resourceType: 'wood',
        baseProduction: 5,
        maxWorkers: 3,
        // å±æ€§æƒé‡ï¼šç†Ÿç»ƒ60%ã€ç²¾ç»†20%ã€æ„ŸçŸ¥20%
        statWeights: { proficiency: 0.6, precision: 0.2, perception: 0.2 }
    },
    iron_mine: {
        id: 'iron_mine',
        name: 'é“çŸ¿åœº',
        icon: 'â›ï¸',
        description: 'æ´¾é£è§’è‰²å¼€é‡‡é“çŸ¿',
        resourceType: 'ironOre',
        baseProduction: 3,
        maxWorkers: 3,
        statWeights: { proficiency: 0.5, precision: 0.3, perception: 0.2 }
    },
    gathering_hut: {
        id: 'gathering_hut',
        name: 'é‡‡é›†æ‰€',
        icon: 'ğŸŒ¿',
        description: 'æ´¾é£è§’è‰²é‡‡é›†è‰è¯',
        resourceType: 'herb',
        baseProduction: 4,
        maxWorkers: 3,
        statWeights: { proficiency: 0.3, precision: 0.3, perception: 0.4 }
    },
    hunter_lodge: {
        id: 'hunter_lodge',
        name: 'çŒäººå°å±‹',
        icon: 'ğŸ¹',
        description: 'æ´¾é£è§’è‰²ç‹©çŒè·å–æ¯›çš®',
        resourceType: 'leather',
        baseProduction: 3,
        maxWorkers: 3,
        statWeights: { proficiency: 0.4, precision: 0.4, perception: 0.2 }
    },
    mana_well: {
        id: 'mana_well',
        name: 'é­”åŠ›ä¹‹æº',
        icon: 'ğŸ’',
        description: 'æ´¾é£è§’è‰²æ±²å–é­”æ³•ç²¾å',
        resourceType: 'magicEssence',
        baseProduction: 1,
        maxWorkers: 2,
        statWeights: { proficiency: 0.2, precision: 0.3, perception: 0.5 }
    },
    foundry: {
        id: 'foundry',
        name: 'é“¸é€ å‚',
        icon: 'ğŸ”¥',
        description: 'æ´¾é£è§’è‰²å°†é“çŸ¿ç‚¼æˆé“é”­ï¼ˆæ¶ˆè€—é“çŸ¿ï¼‰',
        resourceType: 'ironIngot',
        baseProduction: 2,
        maxWorkers: 2,
        consumption: { ironOre: 3 },
        statWeights: { proficiency: 0.5, precision: 0.4, perception: 0.1 }
    },
    alchemy_lab: {
        id: 'alchemy_lab',
        name: 'ç‚¼é‡‘å®éªŒå®¤',
        icon: 'âš—ï¸',
        description: 'æ´¾é£è§’è‰²ç‚¼åˆ¶ç‚¼é‡‘æ²¹ï¼ˆæ¶ˆè€—è‰è¯ï¼‰',
        resourceType: 'alchemyOil',
        baseProduction: 2,
        maxWorkers: 2,
        consumption: { herb: 2 },
        statWeights: { proficiency: 0.3, precision: 0.5, perception: 0.2 }
    },
};

// ==================== åŠŸèƒ½å»ºç­‘ï¼ˆå¯å»ºé€ å¤šä¸ªï¼‰ ====================
const FUNCTIONAL_BUILDINGS = {
    plaza_fountain: {
        id: 'plaza_fountain',
        name: 'å¹¿åœºå–·æ³‰',
        icon: 'â›²',
        description: 'æ‰€æœ‰è„±æˆ˜è‹±é›„æ¯ç§’é¢å¤–å›å¤2ç‚¹ç”Ÿå‘½',
        cost: { gold: 10000, wood: 10000, ironOre: 8000 },
        maxCount: 500,
        effect: { type: 'regen', value: 2 }
    },

    // âœ… æ–°å¢ï¼šå–·æ³‰å¼ºåŒ–å»ºç­‘ï¼ˆå„ 20ï¼Œä¸Šé™åå…±è®¡ +200% å–·æ³‰æ•ˆç‡ï¼›ç‹¬ç«‹ä¹˜åŒºï¼‰
    // è§„åˆ™ï¼šæ¯åº§æä¾› +10% å–·æ³‰æ•ˆç‡ï¼ˆçº¿æ€§å åŠ ï¼‰ï¼Œ20 åº§ = +200% => å€ç‡ 3.0
    // ä¸¤ä¸ªå»ºç­‘å±äºç‹¬ç«‹ä¹˜åŒºï¼šæœ€ç»ˆå–·æ³‰æ•ˆç‡å€ç‡ = è‰åªå€ç‡ Ã— å¤–é¥°å€ç‡
    fountain_lawn: {
        id: 'fountain_lawn',
        name: 'å–·æ³‰è‰åª',
        icon: 'ğŸŒ¿',
        description: 'æ¯åº§æé«˜å–·æ³‰æ•ˆç‡10%ï¼ˆæœ€å¤š+200%ï¼‰ï¼›ä»…å½±å“â€œå¹¿åœºå–·æ³‰â€çš„è„±æˆ˜å›è¡€ã€‚',
        unlockBoss: 'dagran_thaurissan',
        cost: { gold: 1000000, wood: 800000, herb: 800000 },
        maxCount: 20,
        effect: { type: 'fountainEfficiency', value: 0.10 }
    },
    fountain_decor: {
        id: 'fountain_decor',
        name: 'å–·æ³‰å¤–é¥°',
        icon: 'ğŸª·',
        description: 'æ¯åº§æé«˜å–·æ³‰æ•ˆç‡10%ï¼ˆæœ€å¤š+200%ï¼‰ï¼›ä»…å½±å“â€œå¹¿åœºå–·æ³‰â€çš„è„±æˆ˜å›è¡€ã€‚',
        unlockBoss: 'rend_blackhand',
        cost: { gold: 2500000, ironIngot: 900000, magicEssence: 600000 },
        maxCount: 20,
        effect: { type: 'fountainEfficiency', value: 0.10 }
    },
    warehouse: {
        id: 'warehouse',
        name: 'ä»“åº“',
        icon: 'ğŸšï¸',
        description: 'å¢åŠ 1ä¸ªèƒŒåŒ…æ ¼å­',
        cost: { gold: 80000, ironOre: 30000,ironIngot: 15000, magicEssence: 15000,alchemyOil:10000},
        maxCount: 150,
        effect: { type: 'inventorySize', value: 1 }
    },
    training_dummy: {
        id: 'training_dummy',
        name: 'è®­ç»ƒå‡äºº',
        icon: 'ğŸ¯',
        description: 'æ‰€æœ‰è§’è‰²ç»éªŒè·å–æé«˜1%',
        cost: { gold: 500000, leather: 30000, ironOre: 30000,ironIngot: 15000, magicEssence: 15000 },
        maxCount: 30,
        effect: { type: 'expBonus', value: 0.01 }
    },
    mechanical_arm: {
        id: 'mechanical_arm',
        name: 'æœºæ¢°è‡‚',
        icon: 'ğŸ¦¾',
        description: 'å¼ºåŒ–ä¸€ä¸ªèƒŒåŒ…æ ä½ï¼Œä½¿å…¶è‡ªåŠ¨åˆæˆ',
        cost: { gold: 500000, ironIngot: 20000, magicEssence: 20000, alchemyOil: 15000 },
        maxCount: 10,
        effect: { type: 'autoMerge', value: 1 }
    },

    glow_lighthouse: {
        id: 'glow_lighthouse',
        name: 'è¾‰å…‰ç¯å¡”',
        icon: 'ğŸ—¼',
        description: 'æ¯åº§ä½¿è§’è‰²è„±ç¦»æˆ˜æ–—æ‰€éœ€æ—¶é—´é™ä½1ç§’ï¼ˆæœ€å¤šé™ä½2ç§’ï¼‰',
        cost: { gold: 1000000, ironOre: 200000, wood: 500000, alchemyOil: 100000 },
        maxCount: 2,
        effect: { type: 'outOfCombatDelay', value: -1 }
    },



    // âœ… æ–°å¢ï¼šå¯»é¾™ä¼šï¼ˆæ¯çº§+5%è£…å¤‡/ç‰©å“æ‰è½æ¦‚ç‡ï¼Œæ»¡çº§+100%ï¼‰
    dragon_seekers_guild: {
        id: 'dragon_seekers_guild',
        name: 'å¯»é¾™ä¼š',
        icon: 'ğŸ‰',
        description: 'æ¯çº§æé«˜è£…å¤‡/ç‰©å“æ‰è½æ¦‚ç‡5%ï¼ˆæ»¡çº§+100%ï¼š0.1%â†’0.2%ï¼‰',
        cost: { gold: 50000, ironIngot: 30000, magicEssence: 30000 },
        maxCount: 20,
        effect: { type: 'dropBonus', value: 0.05 }
    },
};

// ==================== TALENTS ====================
// å¤©èµ‹è§¦å‘ç±»å‹ï¼ˆç”¨äºæœªæ¥æ‰©å±•ï¼‰
const TALENT_TYPES = {
    AURA: 'aura',          // æˆ˜æ–—ä¸­å¸¸é©»/å…‰ç¯ç±»ï¼ˆå¦‚æŠ¤ç”²+100ã€å§¿æ€ï¼‰
    ON_HIT: 'on_hit',      // å‘½ä¸­/ä½¿ç”¨æ™®é€šæ”»å‡»åè§¦å‘
    ON_BLOCK: 'on_block',  // æˆåŠŸæ ¼æŒ¡åè§¦å‘
};

// è§„åˆ™ï¼šæ¯10çº§ä¸€è¡Œï¼Œæ¯è¡Œ3é€‰1ã€‚æœªåˆ°ç­‰çº§ä¸èƒ½ç‚¹ã€‚ç‚¹äº®ååŒæ’å…¶å®ƒå˜é»‘ã€‚
// ç›®å‰åªå®ç°æˆ˜å£«ï¼ˆé˜²æŠ¤æˆ˜å£«ï¼‰10/20çº§ï¼Œ30-70çº§é¢„ç•™å ä½ã€‚
const TALENTS = {
    protection_warrior: [
        {
            tier: 10,
            options: [
                { id: 'plain', type: TALENT_TYPES.ON_HIT, name: 'è´¨æœ´', description: 'æ™®é€šæ”»å‡»ä½¿ä½ åœ¨æœ¬åœºæˆ˜æ–—ä¸­çš„æ”»å‡»å¼ºåº¦æé«˜5ç‚¹ã€‚' },
                { id: 'block_master', type: TALENT_TYPES.ON_BLOCK, name: 'æ ¼æŒ¡å¤§å¸ˆ', description: 'æˆ˜æ–—ä¸­æ¯æ¬¡æˆåŠŸçš„æ ¼æŒ¡éƒ½ä¼šä½¿ä½ åœ¨æœ¬åœºæˆ˜æ–—ä¸­çš„æ ¼æŒ¡å€¼æé«˜10ç‚¹ã€‚' },
                { id: 'armor_up', type: TALENT_TYPES.AURA, name: 'å ç”²è¿‡', description: 'ä½ åœ¨æˆ˜æ–—ä¸­çš„æŠ¤ç”²å€¼æå‡100ç‚¹ã€‚' },
            ]
        },
        {
            tier: 20,
            options: [
                { id: 'defense_stance', type: TALENT_TYPES.AURA, name: 'é˜²å¾¡å§¿æ€', description: 'ä½ åœ¨æˆ˜æ–—ä¸­å—åˆ°çš„ä¼¤å®³é™ä½20%ã€‚' },
                { id: 'battle_stance', type: TALENT_TYPES.AURA, name: 'æˆ˜æ–—å§¿æ€', description: 'ä½ åœ¨æˆ˜æ–—ä¸­çš„æ”»å‡»å¼ºåº¦æå‡10%ã€‚' },
                { id: 'berserk_stance', type: TALENT_TYPES.AURA, name: 'ç‹‚æš´å§¿æ€', description: 'ä½ åœ¨æˆ˜æ–—ä¸­è·å¾—é¢å¤–çš„8%æš´å‡»å’Œ20%æš´å‡»ä¼¤å®³ã€‚' },
            ]
        },
        {
            tier: 30,
            options: [
                { id: 'brutal_momentum', type: TALENT_TYPES.ON_HIT, name: 'æ®‹æš´åŠ¨åŠ›', description: 'ä½ çš„é‡ä¼¤é€ æˆçš„ä¼¤å®³çš„150%ä¼šæ²»ç–—ä½ ã€‚' },
                { id: 'demoralizing_shout', type: TALENT_TYPES.ON_HIT, name: 'æŒ«å¿—æ€’å¼', description: 'ä½ çš„é›·éœ†ä¸€å‡»ä¼šä¸ºç›®æ ‡æ–½åŠ debuffã€æŒ«å¿—æ€’å¼ã€‘ï¼Œä½¿å…¶é€ æˆçš„æ‰€æœ‰ä¼¤å®³é™ä½20%ã€‚' },
                { id: 'mountain_king', type: TALENT_TYPES.ON_HIT, name: 'å±±ä¸˜ä¹‹ç‹', description: 'é›·éœ†ä¸€å‡»æœ‰50%å‡ ç‡å†æ¬¡é‡Šæ”¾ä¸€æ¬¡ã€‚' },
            ]
        },
        {
            tier: 40,
            options: [
                { id: 'guardian_shield', type: TALENT_TYPES.AURA, name: 'æŠ¤å«ç¥ç›¾', description: 'ä½ çš„ç›¾å¢™å¯ä»¥é…ç½®2æ¬¡ã€‚' },
                { id: 'indomitable_might', type: TALENT_TYPES.AURA, name: 'æ— åšä¸æ‘§ä¹‹åŠ›', description: 'ä½ çš„ç›¾å¢™åŒæ—¶ä½¿ä½ é€ æˆçš„ä¼¤å®³æé«˜50%ã€‚' },
                { id: 'fortified_wall', type: TALENT_TYPES.AURA, name: 'åšæ¯…é•¿åŸ', description: 'ç›¾å¢™çš„å‡ä¼¤æé«˜åˆ°75%ã€‚' },
            ]
        },
        {
            tier: 50,
            options: [
                {
                    id: 'crit_breakthrough',
                    type: TALENT_TYPES.AURA,
                    name: 'çˆ†å‘çªç ´',
                    description: 'è¶…è¿‡100%çš„æš´å‡»ç‡ä¼šç›´æ¥è½¬åŒ–ä¸ºå¯¹æ€»ä¼¤å®³çš„åŠ æˆã€‚'
                },
                {
                    id: 'block_breakthrough',
                    type: TALENT_TYPES.AURA,
                    name: 'æ ¼æŒ¡çªç ´',
                    description: 'è¶…è¿‡95%çš„æ ¼æŒ¡ç‡ä¼šç›´æ¥è½¬åŒ–ä¸ºå¯¹æ€»æ ¼æŒ¡å€¼çš„åŠ æˆã€‚'
                },
                {
                    id: 'holy_sword',
                    type: TALENT_TYPES.ON_HIT,
                    name: 'åœ£å‰‘',
                    description: 'æ™®é€šæ”»å‡»ä¼šé¢å¤–é€ æˆ100%ç»“ç®—æ ¼æŒ¡å€¼çš„ä¼¤å®³ã€‚'
                },
            ]
        },
        {
            tier: 60,
            options: [
                {
                    id: 'titan_bulwark',
                    type: TALENT_TYPES.AURA,
                    name: 'æ³°å¦å£å’',
                    description: 'ã€ç›¾å¢™ã€‘æŒç»­æ—¶é—´+2å›åˆï¼ˆ2â†’4ï¼‰ã€‚ç›¾å¢™æœŸé—´é¢å¤–è·å¾—ï¼šç²¾é€š+20ï¼Œå…¨èƒ½+10ã€‚'
                },
                {
                    id: 'shield_spikes',
                    type: TALENT_TYPES.ON_BLOCK,
                    name: 'ç›¾åˆºåå‡»',
                    description: 'æ¯æ¬¡æˆåŠŸæ ¼æŒ¡åï¼Œå¯¹æ”»å‡»è€…é€ æˆç­‰åŒäºæœ¬æ¬¡è¢«æ ¼æŒ¡æ‰çš„ä¼¤å®³å€¼çš„çœŸå®ä¼¤å®³ã€‚'
                },
                {
                    id: 'blood_and_thunder',
                    type: TALENT_TYPES.AURA,
                    name: 'é›·éœ†æ²¸è¡€',
                    description: 'ã€é›·éœ†ä¸€å‡»ã€‘æš´å‡»æ–½åŠ çš„ã€é‡ä¼¤ã€‘æŒç»­æ—¶é—´+2ï¼ˆ3â†’5ï¼‰ï¼Œæ¯å›åˆä¼¤å®³+20%ï¼ˆ0.5Ã—æ”»å‡»å¼ºåº¦â†’0.6Ã—æ”»å‡»å¼ºåº¦ï¼‰ã€‚'
                },
            ]
        },
        ...[70].map(tier => ({
            tier,
            options: [
                { id: `t${tier}_a`, name: 'ï¼ˆé¢„ç•™ï¼‰å¤©èµ‹A', description: 'å¾…å®ç°' },
                { id: `t${tier}_b`, name: 'ï¼ˆé¢„ç•™ï¼‰å¤©èµ‹B', description: 'å¾…å®ç°' },
                { id: `t${tier}_c`, name: 'ï¼ˆé¢„ç•™ï¼‰å¤©èµ‹C', description: 'å¾…å®ç°' },
            ]
        }))
    ],
    discipline_priest: [
        {
            tier: 10,
            options: [
                {
                    id: 'shadow_amp',
                    name: 'æš—å½±å¢å¹…',
                    description: 'æˆ˜æ–—ä¸­æš—å½±ä¼¤å®³æé«˜20%',
                    type: 'aura'
                },
                {
                    id: 'holy_vuln',
                    name: 'ç¥åœ£å¢å¹…',
                    description: 'æƒ©å‡»ä½¿ç›®æ ‡å—åˆ°çš„æ³•æœ¯ä¼¤å®³æé«˜10%ï¼ŒæŒç»­2å›åˆ',
                    type: 'on_hit'
                },
                {
                    id: 'holy_infusion',
                    name: 'ç¥åœ£çŒæ³¨',
                    description: 'æƒ©å‡»ä½¿ä½ æœ¬åœºæˆ˜æ–—æ³•æœ¯å¼ºåº¦+2',
                    type: 'on_cast'
                }
            ]
        },
        {
            tier: 20,
            options: [
                {
                    id: 'radiance_plus',
                    name: 'åœ£å…‰çš„è®¸è¯º',
                    description: 'çœŸè¨€æœ¯ï¼šè€€å¯å¤šé…ç½®1æ¬¡',
                    type: 'aura'
                },
                {
                    id: 'long_atonement',
                    name: 'æŒä¹…ä¹‹å…‰',
                    description: 'æ•‘èµæŒç»­æ—¶é—´+2å›åˆ',
                    type: 'aura'
                },
                {
                    id: 'dark_side',
                    name: 'é˜´æš—é¢ä¹‹åŠ›',
                    description: 'å¿ƒçµéœ‡çˆ†ä¼¤å®³æé«˜80%',
                    type: 'aura'
                }
            ]
        },
        {
            tier: 30,
            options: [
                {
                    id: 'pwt',
                    name: 'çœŸè¨€æœ¯ï¼šè€',
                    description: 'å…¨é˜Ÿç”Ÿå‘½å€¼æé«˜10%',
                    type: 'aura'
                },
                {
                    id: 'holy_enlight',
                    name: 'ç¥åœ£å¯è¿ª',
                    description: 'å…¨é˜Ÿæ³•æœ¯å¼ºåº¦æé«˜5%',
                    type: 'aura'
                },
                {
                    id: 'shadowfiend',
                    name: 'æš—å½±é­”',
                    description: 'æ¯å›åˆé€ æˆ0.6å€æ³•æœ¯å¼ºåº¦çš„æš—å½±ä¼¤å®³',
                    type: 'dot'
                }
            ]
        },
        {
            tier: 40,
            options: [
                {
                    id: 'fortune_misfortune',
                    name: 'ç¥¸ç¦ç›¸ä¾',
                    description: 'æƒ©å‡»å’Œå¿ƒçµéœ‡çˆ†è·å¾—buffã€ç¥¸ç¦ç›¸ä¾ã€‘ï¼Œæ¯å±‚ä½¿è‹¦ä¿®çš„æ²»ç–—é‡æé«˜25%ï¼Œä½¿ç”¨è‹¦ä¿®åæ¸…ç©ºå±‚æ•°',
                    type: 'on_cast'
                },
                {
                    id: 'ultimate_penance',
                    name: 'ç»ˆæè‹¦ä¿®',
                    description: 'è‹¦ä¿®è¿˜ä¼šå¯¹å½“å‰ç›®æ ‡é€ æˆ2å€æ³•æœ¯å¼ºåº¦çš„ä¼¤å®³',
                    type: 'aura'
                },
                {
                    id: 'borrowed_time',
                    name: 'äº‰åˆ†å¤ºç§’',
                    description: 'é‡Šæ”¾è‹¦ä¿®ä½¿ä½ çš„æ€¥é€Ÿæé«˜30%ï¼ŒæŒç»­4å›åˆ',
                    type: 'on_cast'
                }
            ]
        },
        {
            tier: 50,
            options: [
                {
                    id: 'fantasia',
                    name: 'å¹»æƒ³æ›²',
                    description: 'æ¯å›åˆè·å¾—ä¸€å±‚å¹»æƒ³æ›²ï¼›æ¯å±‚ä½¿ä½ çš„ä¸‹ä¸€ä¸ªã€ç¥åœ£æ–°æ˜Ÿã€‘ä¼¤å®³ä¸æ²»ç–—é‡æé«˜20%ï¼Œæ–½æ”¾åæ¸…ç©ºå±‚æ•°',
                    type: 'on_turn'
                },
                {
                    id: 'holy_barrier',
                    name: 'ç¥åœ£éšœå£',
                    description: 'ã€ç¥åœ£æ–°æ˜Ÿã€‘ä¸ºå…¨é˜Ÿæ–½åŠ 2å›åˆæ•‘èµæ•ˆæœï¼Œå¹¶æ–½åŠ 2å€æ³•æœ¯å¼ºåº¦çš„æŠ¤ç›¾',
                    type: 'on_cast'
                },
                {
                    id: 'holy_avatar',
                    name: 'ç¥åœ£åŒ–èº«',
                    description: 'ä½ çš„æ³•æœ¯å¼ºåº¦æé«˜20%',
                    type: 'aura'
                }
            ]
        },
        {
            tier: 60,
            options: [
                {
                    id: 'pain_suppression',
                    name: 'ç—›è‹¦å‹åˆ¶',
                    description: 'è‹¦ä¿®ä½¿å½“å‰ç›®æ ‡è·å¾—30%å‡ä¼¤ï¼ˆä¹˜ç®—ï¼‰ï¼ŒæŒç»­2å›åˆ',
                    type: 'on_cast'
                },
                {
                    id: 'benevolence',
                    name: 'ä»æ…ˆ',
                    description: 'ã€æ•‘èµã€‘é¢å¤–è·å¾—5%å‡ä¼¤æ•ˆæœï¼ˆä¹˜ç®—ï¼‰',
                    type: 'aura'
                },
                {
                    id: 'mindbender',
                    name: 'å‚¬å¿ƒé­”',
                    description: 'è‹¥å·²ç‚¹30çº§ã€æš—å½±é­”ã€‘ï¼Œåˆ™æš—å½±é­”é€ æˆçš„ä¼¤å®³ç³»æ•°æå‡è‡³1.2å€æ³•æœ¯å¼ºåº¦',
                    type: 'aura'
                }
            ]
        }
    ],
    frost_mage: [
        {
            tier: 10,
            options: [
                {
                    id: 'lingering_cold',
                    name: 'å»¶ç»µå¯’å†·',
                    description: 'å¯’å†°ç®­ä½¿ä½ çš„æ³•æœ¯å¼ºåº¦æé«˜5ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸ',
                    type: 'on_cast'
                },
                {
                    id: 'piercing_cold',
                    name: 'å¯’å†·åˆºéª¨',
                    description: 'çˆ†å‡»ç‡æé«˜10',
                    type: 'aura'
                },
                {
                    id: 'frost_amp',
                    name: 'å¯’å†°å¢å¹…',
                    description: 'æ³•æœ¯ä¼¤å®³æé«˜10%',
                    type: 'aura'
                }
            ]
        },
        {
            tier: 20,
            options: [
                {
                    id: 'fingers_of_frost',
                    name: 'å¯’å†°æŒ‡',
                    description: 'å¯’å†°ç®­æœ‰50%æ¦‚ç‡ä½¿ä½ è·å¾—1å±‚å¯’å†°æŒ‡æ•ˆæœï¼Œå¯’å†°æŒ‡ä½¿ä¸‹ä¸€ä¸ªå†°æªæœ¯çš„ä¼¤å®³æé«˜100%',
                    type: 'on_cast'
                },
                {
                    id: 'cold_wisdom',
                    name: 'å†°å†·æ™ºæ…§',
                    description: 'å¯’å†°ç®­æœ‰25%æ¦‚ç‡é¢å¤–å¯¹ç›®æ ‡æ–½æ”¾å†°é£æš´',
                    type: 'on_cast'
                },
                {
                    id: 'endless_winter',
                    name: 'æ— å°½å¯’å†¬',
                    description: 'å¯’å†°å®ç æŒç»­æ—¶é—´æé«˜2å›åˆï¼Œä¼¤å®³æé«˜åˆ°0.8å€æ³•æœ¯å¼ºåº¦',
                    type: 'aura'
                }
            ]
        },
        {
            tier: 30,
            options: [
                {
                    id: 'frozen_touch',
                    name: 'å†°å†»ä¹‹è§¦',
                    description: 'ä½ çš„å†°æªæœ¯é€ æˆçš„ä¼¤å®³æå‡25%',
                    type: 'aura'
                },
                {
                    id: 'cold_intuition',
                    name: 'å†°å†·ç›´è§‰',
                    description: 'ä½ çš„å†°å†·æ™ºæ…§è§¦å‘æ¦‚ç‡æé«˜è‡³40%',
                    type: 'aura'
                },
                {
                    id: 'orb_mastery',
                    name: 'å®ç ç²¾é€š',
                    description: 'ä½ çš„å¯’å†°å®ç é€ æˆDOTä¼¤å®³æ—¶æœ‰25%æ¦‚ç‡ç”Ÿæˆä¸€å±‚å¯’å†°æŒ‡',
                    type: 'on_hit'
                }
            ]
        },
        {
            tier: 40,
            options: [
                {
                    id: 'glacial_spike',
                    name: 'å†°å·çªè¿›',
                    description: 'ä½ çš„å½—æ˜Ÿé£æš´æ¯é€ æˆä¸€æ¬¡ä¼¤å®³ï¼Œè·å–ä¸€å±‚å¯’å†°æŒ‡',
                    type: 'on_hit'
                },
                {
                    id: 'double_comet',
                    name: 'åŒå½—æ˜Ÿ',
                    description: 'ä½ çš„å½—æ˜Ÿé£æš´å¯ä»¥é…ç½®2æ¬¡',
                    type: 'aura'
                },
                {
                    id: 'arcane_intellect',
                    name: 'å¥¥æœ¯æ™ºæ…§',
                    description: 'ä½ çš„å°é˜Ÿæ‰€æœ‰æˆå‘˜çš„æ³•æœ¯å¼ºåº¦æé«˜10%',
                    type: 'aura'
                }
            ]
        },
        {
            tier: 50,
            options: [
                {
                    id: 'frost_crit_breakthrough',
                    type: TALENT_TYPES.AURA,
                    name: 'å¯’å†°çªç ´',
                    description: 'è¶…è¿‡100%çš„æš´å‡»ç‡ä¼šç›´æ¥è½¬åŒ–ä¸ºå¯¹æ€»ä¼¤å®³çš„åŠ æˆã€‚å†°é£æš´æŒç»­æœŸé—´ï¼Œä½ çš„æ‰€æœ‰æš´å‡»ç‡éƒ½è½¬åŒ–ä¸ºä¼¤å®³å¢å¹…ï¼ˆä¸å†è§¦å‘æš´å‡»åˆ¤å®šï¼‰ã€‚'
                },
                {
                    id: 'glacial_mastery',
                    type: TALENT_TYPES.AURA,
                    name: 'æå¯’ç²¾é€š',
                    description: 'å†°æªæœ¯çš„æš´å‡»ä¼¤å®³é¢å¤–å¢åŠ 100%ï¼ˆæ€»è®¡+300%ï¼‰ã€‚å¯’å†°æŒ‡æ•ˆæœæå‡è‡³150%ä¼¤å®³åŠ æˆã€‚'
                },
                {
                    id: 'absolute_zero',
                    type: TALENT_TYPES.AURA,
                    name: 'ç»å¯¹é›¶åº¦',
                    description: 'å†°é£æš´çš„æŒç»­æ—¶é—´å»¶é•¿2å›åˆï¼Œæ¯å›åˆä¼¤å®³æé«˜50%ã€‚å†°é£æš´æœŸé—´ä½ çš„æ‰€æœ‰å†°éœœä¼¤å®³é¢å¤–æé«˜25%ã€‚'
                }
            ]
        },
    ],

    // ==================== ç‹‚å¾’ç›—è´¼ï¼ˆ10çº§å¤©èµ‹ï¼‰ ====================
    outlaw_rogue: [
        {
            tier: 10,
            options: [
                {
                    id: 'swift_hands',
                    type: TALENT_TYPES.AURA,
                    name: 'è¿…æ·ä¹‹æ‰‹',
                    description: 'æ™®é€šæ”»å‡»åŸºç¡€ä¼¤å®³ä»1.2æé«˜è‡³1.4ã€‚'
                },
                {
                    id: 'cunning_plan',
                    type: TALENT_TYPES.AURA,
                    name: 'ç‹¡è¯ˆè®¡è°‹',
                    description: 'è¿å‡»ç‚¹ï¼ˆæ˜Ÿï¼‰ä¸Šé™é¢å¤–æé«˜2ç‚¹ï¼ˆ5â†’7ï¼‰ã€‚'
                },
                {
                    id: 'opportunity',
                    type: TALENT_TYPES.AURA,
                    name: 'å¯ä¹˜ä¹‹æœº',
                    description: 'å½±è¢­é¢å¤–è·å¾—1é¢—æ˜Ÿã€‚'
                }
            ]
        },
        {
            tier: 20,
            options: [
                {
                    id: 'agile_movement',
                    type: TALENT_TYPES.AURA,
                    name: 'çŸ«å¥çµåŠ¨',
                    description: 'å‰‘åˆƒä¹±èˆçš„åˆå§‹ä¼¤å®³æé«˜100%ï¼Œå¹¶ä¸”æ¯å‡»ä¸­ä¸€ä¸ªç›®æ ‡äº§ç”Ÿ1é¢—æ˜Ÿã€‚'
                },
                {
                    id: 'ruthless',
                    type: TALENT_TYPES.AURA,
                    name: 'æ— æƒ…',
                    description: 'æ¶ˆè€—æ˜Ÿçš„æŠ€èƒ½æ¯æ¶ˆè€—1é¢—æ˜Ÿï¼Œå°±æœ‰20%æ¦‚ç‡è·å¾—1é¢—æ˜Ÿã€‚'
                },
                {
                    id: 'fatal_empowerment',
                    type: TALENT_TYPES.AURA,
                    name: 'ç´¢å‘½å¼ºèƒ½',
                    description: 'æ¶ˆè€—æ˜Ÿçš„æŠ€èƒ½æ¯æ¶ˆè€—1é¢—æ˜Ÿï¼Œæœ€ç»ˆä¼¤å®³æé«˜5%ã€‚'
                }
            ]
        },
        {
            tier: 30,
            options: [
                {
                    id: 'juggling_strikes',
                    type: TALENT_TYPES.ON_HIT,
                    name: 'æ‚è€æ‰“å‡»',
                    description: 'æ™®é€šæ”»å‡»å’Œå½±è¢­ä½¿ä½ åœ¨æœ¬åœºæˆ˜æ–—ä¸­è·å¾—ã€æ‚è€ã€‘ï¼šå…¨èƒ½+2ï¼Œå¯å åŠ ï¼Œæœ€å¤š25å±‚ã€‚'
                },
                {
                    id: 'hidden_edge_time',
                    type: TALENT_TYPES.ON_HIT,
                    name: 'è—é”‹å¯»æ—¶',
                    description: 'ä¼å‡»æœ‰80%æ¦‚ç‡å†æ¬¡å‘åŠ¨ï¼ˆæ¯ä¸ªæŠ€èƒ½æ ¼ä»…åˆ¤å®šä¸€æ¬¡ï¼‰ã€‚'
                },
                {
                    id: 'blade_dash',
                    type: TALENT_TYPES.ON_HIT,
                    name: 'åˆ€é”‹å†²åˆº',
                    description: 'ä¼å‡»ä½¿ä½ è·å¾—ã€åˆ€é”‹å†²åˆºã€‘ï¼šæš´å‡»ä¼¤å®³+50%ï¼ŒæŒç»­4å›åˆã€‚'
                }
            ]
        },

        {
            tier: 40,
            options: [
                {
                    id: 'cold_blood',
                    type: TALENT_TYPES.AURA,
                    name: 'å†·è¡€',
                    description: 'ä½ çš„ç¬¬ä¸€æ ¼æŠ€èƒ½æš´å‡»ç‡æé«˜100%ï¼Œæš´å‡»ä¼¤å®³æé«˜50%ã€‚'
                },
                {
                    id: 'deep_stratagem',
                    type: TALENT_TYPES.AURA,
                    name: 'æ·±é‚ƒè¯¡è®¡',
                    description: 'è¿å‡»ç‚¹ï¼ˆæ˜Ÿï¼‰ä¸Šé™é¢å¤–æé«˜1ç‚¹ï¼Œæ™®é€šæ”»å‡»æš´å‡»æœ‰50%æ¦‚ç‡è·å¾—1é¢—æ˜Ÿã€‚'
                },
                {
                    id: 'swift_slashes',
                    type: TALENT_TYPES.AURA,
                    name: 'è¿…çŒ›æŒ¥ç ',
                    description: 'åˆ‡å‰²é¢å¤–ä½¿ä½ è·å¾—åŸºäºåˆ‡å‰²æ¶ˆè€—æ˜Ÿæ•°*10çš„å…¨èƒ½ã€‚'
                }
            ]
        },

        // ==================== ç‹‚å¾’ç›—è´¼ï¼ˆ50çº§å¤©èµ‹ï¼‰ ====================
        {
            tier: 50,
            options: [
                {
                    id: 'crit_breakthrough',
                    type: TALENT_TYPES.AURA,
                    name: 'çˆ†å‘çªç ´',
                    description: 'è¶…è¿‡100%çš„æš´å‡»ç‡ä¼šç›´æ¥è½¬åŒ–ä¸ºå¯¹æš´å‡»ä¼¤å®³çš„åŠ æˆï¼ˆä¸æˆ˜å£«è¯¥å¤©èµ‹å®Œå…¨ä¸€è‡´ï¼‰ã€‚'
                },
                {
                    id: 'potent_vial',
                    type: TALENT_TYPES.AURA,
                    name: 'å¼ºæ•ˆç“¶å‰‚',
                    description: 'ã€çŒ©çº¢ä¹‹ç“¶ã€‘æŒç»­å›åˆå»¶é•¿è‡³6å›åˆã€‚'
                },
                {
                    id: 'erratic',
                    type: TALENT_TYPES.AURA,
                    name: 'é£˜å¿½ä¸å®š',
                    description: 'ä½¿ä½ å—åˆ°çš„æ‰€æœ‰ä¼¤å®³é™ä½20%ã€‚'
                }
            ]
        },

        // ==================== ç‹‚å¾’ç›—è´¼ï¼ˆ60çº§å¤©èµ‹ï¼‰ ====================
        {
            tier: 60,
            options: [
                {
                    id: 'delayed_power',
                    type: TALENT_TYPES.AURA,
                    name: 'å»¶æ—¶ä¹‹åŠ›',
                    description: 'ã€å†²åŠ¨ã€‘æŒç»­8å›åˆã€‚'
                },
                {
                    id: 'impatient',
                    type: TALENT_TYPES.AURA,
                    name: 'æ€¥ä¸å¯è€',
                    description: 'ã€å†²åŠ¨ã€‘æ•ˆæœå†…æå‡ï¼ˆå½“å‰æ˜Ÿæ•°*3%ï¼‰çš„æ€»ä¼¤å®³ã€‚'
                },
                {
                    id: 'reckless_bravery',
                    type: TALENT_TYPES.ON_HIT,
                    name: 'èƒ†å¤§å¦„ä¸º',
                    description: 'æ™®é€šæ”»å‡»è§¦å‘è¿å‡»çš„æ¦‚ç‡æé«˜10%ï¼Œå½“æ™®é€šæ”»å‡»è§¦å‘è¿å‡»æ—¶ï¼Œä½ è·å¾—20ç²¾é€šï¼Œå¯å åŠ ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸã€‚'
                }
            ]
        }
    ]

};

// ==================== ç›—è´¼ï¼šè¿å‡»ç‚¹ï¼ˆæ˜Ÿï¼‰ä¸Šé™ ====================
// é»˜è®¤ä¸Šé™ä¸º 5ï¼›ç‹‚å¾’ç›—è´¼ 10çº§å¤©èµ‹ã€ç‹¡è¯ˆè®¡è°‹ã€‘å¯æå‡è‡³ 7ï¼›40çº§å¤©èµ‹ã€æ·±é‚ƒè¯¡è®¡ã€‘é¢å¤– +1ã€‚
const BASE_MAX_COMBO_POINTS = 5;
function getMaxComboPointsForChar(char) {
    let max = BASE_MAX_COMBO_POINTS;
    if (!char) return max;

    if (char.classId === 'outlaw_rogue') {
        // 10çº§å¤©èµ‹ï¼šç‹¡è¯ˆè®¡è°‹ï¼ˆ+2ï¼‰
        if (char.talents?.[10] === 'cunning_plan') max += 2;
        // 40çº§å¤©èµ‹ï¼šæ·±é‚ƒè¯¡è®¡ï¼ˆ+1ï¼‰
        if (char.talents?.[40] === 'deep_stratagem') max += 1;
    }

    return max;
}

const SKILLS = {
    basic_attack: {
        limit: 20,
        id: 'basic_attack',
        name: 'æ™®é€šæ”»å‡»',
        description: 'é€ æˆåŸºäºæ”»å‡»å¼ºåº¦çš„ä¼¤å®³',
        icon: 'âš”ï¸',
        type: 'damage',
        calculate: (char) => {
            // æ€¥é€Ÿï¼šæ™®é€šæ”»å‡»ä¼¤å®³æé«˜ï¼ˆæ€¥é€Ÿ * 2%ï¼‰
            const hasteMult = 1 + (((char?.stats?.haste) || 0) * 0.02);

            // ç›—è´¼10çº§å¤©èµ‹ï¼šè¿…æ·ä¹‹æ‰‹ - æ™®æ”»åŸºç¡€å€ç‡ 1.2 -> 1.4
            const baseMult = (char?.classId === 'outlaw_rogue' && char?.talents?.[10] === 'swift_hands') ? 1.4 : 1.2;

            let damage = char.stats.attack * baseMult * (char.stats.basicAttackMultiplier || 1) * hasteMult;

            // ===== 50çº§å¤©èµ‹ï¼šçˆ†å‘çªç ´ - è¶…è¿‡100%çš„æš´å‡»ç‡è½¬åŒ–ä¸ºä¼¤å®³åŠ æˆ =====
            let effectiveCritRate = char.stats.critRate || 0;
            let critBreakthroughBonus = 1;
            if (char.talents?.[50] === 'crit_breakthrough' && effectiveCritRate > 100) {
                const excessCrit = effectiveCritRate - 100;
                critBreakthroughBonus = 1 + (excessCrit / 100); // è¶…å‡ºéƒ¨åˆ†ç›´æ¥åŠ æˆ
                effectiveCritRate = 100; // æš´å‡»ç‡å°é¡¶100%
            }
            damage *= critBreakthroughBonus;

            // æš´å‡»åˆ¤å®š
            if (Math.random() < effectiveCritRate / 100) {
                damage *= char.stats.critDamage;
                return {
                    damage: Math.floor(damage),
                    isCrit: true,
                    // 50çº§å¤©èµ‹ï¼šåœ£å‰‘ - æ™®æ”»é¢å¤–é€ æˆæ ¼æŒ¡å€¼ä¼¤å®³
                    holySwordDamage: char.talents?.[50] === 'holy_sword'
                        ? Math.floor((char.stats.blockValue || 0) * 1.0)
                        : 0
                };
            }

            damage *= (1 + char.stats.versatility / 100);
            return {
                damage: Math.floor(damage),
                isCrit: false,
                // 50çº§å¤©èµ‹ï¼šåœ£å‰‘ - æ™®æ”»é¢å¤–é€ æˆæ ¼æŒ¡å€¼ä¼¤å®³
                holySwordDamage: char.talents?.[50] === 'holy_sword'
                    ? Math.floor((char.stats.blockValue || 0) * 1.0)
                    : 0
            };
        }
    },
    rest: {
        limit: 20,
        id: 'rest',
        name: 'ä¼‘æ¯',
        description: 'å›å¤åŸºäºè¡€é‡ä¸Šé™çš„ç”Ÿå‘½',
        icon: 'ğŸ’¤',
        type: 'heal',
        calculate: (char) => ({ heal: Math.floor(char.stats.maxHp * 0.05) })
    },

    // ==================== ç§æ—æŠ€èƒ½ ====================
    racial_human_spirit: {
        id: 'racial_human_spirit',
        name: 'äººç±»ç²¾é­‚',
        icon: 'ğŸ§¬',
        type: 'passive',
        description: 'å…¨èƒ½+2ï¼Œç²¾é€š+2ï¼Œæš´å‡»+2ï¼Œæ€¥é€Ÿ+2ã€‚'
    },
    racial_human_hospitality: {
        id: 'racial_human_hospitality',
        name: 'å®¾è‡³å¦‚å½’',
        icon: 'ğŸ ',
        type: 'passive',
        description: 'ç‚‰çŸ³...å•Šä¸å¯¹ï¼Œåœ°å›¾æˆ˜æ–—ç»“æŸåï¼Œå›å¤æœ€å¤§ç”Ÿå‘½å€¼çš„10%ã€‚'
    },

    racial_dwarf_spirit: {
        id: 'racial_dwarf_spirit',
        name: 'çŸ®äººç²¾é­„',
        icon: 'ğŸª¨',
        type: 'passive',
        description: 'æš´å‡»ä¼¤å®³ +15%ã€‚'
    },
    racial_dwarf_stoneform: {
        id: 'racial_dwarf_stoneform',
        name: 'çŸ³åƒå½¢æ€',
        icon: 'ğŸ—¿',
        type: 'passive',
        description: 'æˆ˜æ–—ä¸­é¦–æ¬¡å—åˆ°ã€è¯…å’’ã€‘ä¸ã€ä¸­æ¯’ã€‘æ•ˆæœæ—¶å…ç–«ï¼ˆæ¯ç§å„ 1 æ¬¡ï¼‰ã€‚'
    },

    racial_nightelf_spirit: {
        id: 'racial_nightelf_spirit',
        name: 'ç²¾çµç²¾é­„',
        icon: 'ğŸŒ™',
        type: 'passive',
        description: 'æ—©æ™¨6ç‚¹-æ™šä¸Š6ç‚¹ï¼šæš´å‡»ç‡+6ï¼›æ™šä¸Š6ç‚¹-æ¬¡æ—¥æ—©æ™¨6ç‚¹ï¼šæ€¥é€Ÿ+6ã€‚'
    },
    racial_nightelf_shadowmeld: {
        id: 'racial_nightelf_shadowmeld',
        name: 'éšé',
        icon: 'ğŸ«¥',
        type: 'passive',
        description: 'åœ°å›¾æˆ˜æ–—ä¸­ï¼šç¬¬1æ ¼æŠ€èƒ½é€ æˆçš„ä¼¤å®³æé«˜20%ï¼ˆä¹˜ç®—ï¼‰ã€‚'
    },

    racial_gnome_spirit: {
        id: 'racial_gnome_spirit',
        name: 'ä¾å„’ç²¾é­„',
        icon: 'âš™ï¸',
        type: 'passive',
        description: 'å…¨èƒ½ +6ã€‚'
    },
    racial_gnome_familiarity: {
        id: 'racial_gnome_familiarity',
        name: 'ç†Ÿç¨”',
        icon: 'ğŸ”§',
        type: 'passive',
        description: 'ä¸€ä¸ªå‘å¾®çš„ä¾å„’ï¼Ÿç†Ÿç»ƒå¢åŠ 30ã€‚'
    },


    racial_orc_spirit: {
        id: 'racial_orc_spirit',
        name: 'å…½äººç²¾é­„',
        icon: 'ğŸ©¸',
        type: 'passive',
        description: 'ç²¾é€š +3ï¼Œå…¨èƒ½ +3ã€‚'
    },
    racial_orc_bloodfury: {
        id: 'racial_orc_bloodfury',
        name: 'è¡€æ€§ç‹‚æ€’',
        icon: 'ğŸ”¥',
        type: 'passive',
        description: 'å…½äººæ°¸ä¸ä¸ºå¥´ï¼å‰4ä¸ªæŠ€èƒ½æ ¼é€ æˆçš„ä¼¤å®³æé«˜10%ã€‚'
    },




    racial_troll_spirit: {
        id: 'racial_troll_spirit',
        name: 'å·¨é­”ç²¾é­„',
        icon: 'ğŸŒ€',
        type: 'passive',
        description: 'ç²¾é€š +6ã€‚'
    },
    racial_troll_berserking: {
        id: 'racial_troll_berserking',
        name: 'ç‹‚æš´',
        icon: 'ğŸ’¢',
        type: 'passive',
        description: 'å‰4ä¸ªæŠ€èƒ½æ ¼é¢å¤–è·å¾—20æ€¥é€Ÿï¼ˆåŠ æ³•ï¼‰ã€‚'
    },

    racial_tauren_spirit: {
        id: 'racial_tauren_spirit',
        name: 'ç‰›å¤´ç²¾é­„',
        icon: 'ğŸ‚',
        type: 'passive',
        description: 'æœ€å¤§ç”Ÿå‘½å€¼ +10%ã€‚'
    },
    racial_tauren_cultivation: {
        id: 'racial_tauren_cultivation',
        name: 'æ ½åŸ¹',
        icon: 'ğŸŒ±',
        type: 'passive',
        description: 'é‡‡é›†ç²¾ç»† +30ã€‚'
    },

    racial_undead_spirit: {
        id: 'racial_undead_spirit',
        name: 'äº¡çµç²¾é­„',
        icon: 'ğŸ’€',
        type: 'passive',
        description: 'æš´å‡»ç‡ +6ã€‚'
    },
    racial_undead_will: {
        id: 'racial_undead_will',
        name: 'äº¡çµæ„å¿—',
        icon: 'ğŸ§ ',
        type: 'passive',
        description: 'Bossæˆ˜æ–—ä¸­å…ç–«å—åˆ°çš„ç¬¬ä¸€æ¬¡ææƒ§æ•ˆæœã€‚'
    },



    mastery_precise_block: {
        id: 'mastery_precise_block',
        name: 'ç²¾é€šï¼šç²¾ç¡®æ ¼æŒ¡',
        icon: 'ğŸ¯',
        iconUrl : 'icons/wow/vanilla/abilities/Ability_Warrior_DefensiveStance.png',
        type: 'passive',
        description: 'è¢«åŠ¨ï¼šæ ¼æŒ¡å€¼æé«˜(10 + ç²¾é€š/4)%ã€‚è¯¥æå‡åŸºäºåŸå§‹æ ¼æŒ¡æ•°å€¼ã€‚'
    },

    victory_rush: {
        id: 'victory_rush',
        name: 'ä¹˜èƒœè¿½å‡»',
        icon: 'ğŸ†',
        type: 'passive',
        description: 'æˆ˜æ–—èƒœåˆ©åæ¢å¤æœ€å¤§ç”Ÿå‘½å€¼çš„20%ã€‚'
    },

    shield_bash: {
        limit: 3,
        id: 'shield_bash',
        name: 'ç›¾ç‰ŒçŒ›å‡»',
        description: 'é€ æˆåŸºäºæ”»å‡»å¼ºåº¦å’Œæ ¼æŒ¡å€¼çš„ä¼¤å®³',
        icon: 'ğŸ›¡ï¸',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Fire_FireArmor.png',
        type: 'damage',
        calculate: (char) => {
            let damage = char.stats.attack * 1.5 + char.stats.blockValue * 0.3;
            damage *= (1 + char.stats.mastery / 100);
            if (Math.random() < char.stats.critRate/100) {
                damage *= char.stats.critDamage;
                return { damage: Math.floor(damage), isCrit: true };
            }
            damage *= (1 + char.stats.versatility / 100);
            return { damage: Math.floor(damage), isCrit: false };
        }
    },
    shield_block: {
        limit: 2,
        id: 'shield_block',
        name: 'ç›¾ç‰Œæ ¼æŒ¡',
        description: 'è·å¾—40%æ ¼æŒ¡ç‡åŠ æˆï¼ŒæŒç»­2å¸§',
        icon: 'ğŸ”°',
        iconUrl : 'icons/wow/vanilla/abilities/Ability_Defend.png',
        type: 'buff',
        duration: 2,
        calculate: () => ({ buff: { blockRate: 0.4, duration: 2 } })
    },
    revenge: {
        limit: 2,
        id: 'revenge',
        name: 'å¤ä»‡',
        description: 'é€ æˆåŸºäºæ”»å‡»å¼ºåº¦çš„é«˜é¢ä¼¤å®³',
        icon: 'ğŸ’¥',
        iconUrl : 'icons/wow/vanilla/abilities/Ability_Warrior_Revenge.png',
        type: 'damage',
        calculate: (char) => {
            let damage = char.stats.attack * 2.5;
            if (Math.random() < char.stats.critRate/100) {
                damage *= char.stats.critDamage;
                return { damage: Math.floor(damage), isCrit: true };
            }
            damage *= (1 + char.stats.versatility / 100);
            return { damage: Math.floor(damage), isCrit: false };
        }
    },
    thunder_strike: {
        id: 'thunder_strike',
        name: 'é›·éœ†ä¸€å‡»',
        icon: 'âš¡',
        iconUrl : 'icons/wow/vanilla/abilities/Ability_ThunderClap.png',
        type: 'aoe_damage',
        limit: 2,
        description: 'å¯¹æ‰€æœ‰æ•Œäººé€ æˆ0.8å€æ”»å‡»å¼ºåº¦çš„ä¼¤å®³ï¼Œæš´å‡»æ—¶å¯¹æ¯ä¸ªç›®æ ‡æ–½åŠ é‡ä¼¤ï¼ˆDOT 0.5å€æ”»å‡»å¼ºåº¦ï¼ŒæŒç»­3å›åˆï¼‰',
        calculate: (char) => {
            let baseDamage = char.stats.attack * 0.8;

            // æš´å‡»åˆ¤å®š
            const isCrit = Math.random() < (char.stats.critRate / 100);
            if (isCrit) {
                baseDamage *= char.stats.critDamage;
            }

            // å…¨èƒ½åŠ æˆ
            baseDamage *= (1 + char.stats.versatility / 100);

            const damage = Math.floor(baseDamage);

            // æš´å‡»æ—¶ç”Ÿæˆçš„DOTï¼ˆæ¯ç›®æ ‡ç‹¬ç«‹ï¼‰
            // 60çº§å¤©èµ‹ï¼šé›·éœ†æ²¸è¡€ - å¼ºåŒ–æš´å‡»é‡ä¼¤
            const hasBloodAndThunder = char.talents?.[60] === 'blood_and_thunder';
            const dot = isCrit ? {
                damagePerTurn: Math.floor(char.stats.attack * (hasBloodAndThunder ? 0.6 : 0.5)),
                duration: hasBloodAndThunder ? 5 : 3,
                name: 'é‡ä¼¤'
            } : null;

            return {
                aoeDamage: damage,
                isCrit,
                dotOnCrit: dot  // æˆ˜æ–—ç³»ç»Ÿä¼šæ£€æŸ¥è¿™ä¸ªå¹¶å¯¹æ¯ä¸ªç›®æ ‡æ–½åŠ 
            };
        }
    },

    shield_wall: {
        id: 'shield_wall',
        name: 'ç›¾å¢™',
        icon: 'ğŸ›¡ï¸',
        iconUrl : 'icons/wow/vanilla/abilities/Ability_Warrior_ShieldWall.png',
        type: 'buff',
        limit: 1, // åŸºç¡€1æ¬¡ï¼ŒæŠ¤å«ç¥ç›¾å¤©èµ‹å¯æå‡åˆ°2æ¬¡
        description: 'å—åˆ°çš„æ‰€æœ‰ä¼¤å®³é™ä½50%ï¼ŒæŒç»­2å›åˆ',
        duration: 2,
        calculate: (char) => {
            // 40çº§å¤©èµ‹ï¼šåšæ¯…é•¿åŸ - å‡ä¼¤æé«˜åˆ°75%
            const damageTakenMult = char.talents?.[40] === 'fortified_wall' ? 0.25 : 0.5;
            // 40çº§å¤©èµ‹ï¼šæ— åšä¸æ‘§ä¹‹åŠ› - é€ æˆä¼¤å®³æé«˜50%
            const damageDealtMult = char.talents?.[40] === 'indomitable_might' ? 1.5 : 1;

            // 60çº§å¤©èµ‹ï¼šæ³°å¦å£å’ - ç›¾å¢™å»¶é•¿å¹¶æä¾›é¢æ¿å±æ€§
            const hasTitanBulwark = char.talents?.[60] === 'titan_bulwark';
            const duration = hasTitanBulwark ? 5 : 3;

            return {
                buff: {
                    damageTakenMult,
                    damageDealtMult,
                    duration,
                    ...(hasTitanBulwark ? { masteryBonus: 20, versatilityBonus: 10 } : {})
                }
            };
        }
    },
    mastery_atonement: {
        id: 'mastery_atonement',
        name: 'ç²¾é€šï¼šæ•‘èµ',
        icon: 'âœï¸',
        iconUrl : 'icons/wow/vanilla/items/INV_Banner_01.png',
        type: 'passive',
        description: 'è¢«åŠ¨ï¼šæ•‘èµæ²»ç–—æ¯”ä¾‹æå‡(ç²¾é€š/10)%ã€‚è¯¥æ•°å€¼ç›´æ¥åŠ åœ¨åŸºç¡€20%ä¸Šã€‚'
    },
    smite: {
        id: 'smite',
        name: 'æƒ©å‡»',
        icon: 'âœ¨',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Holy_HolySmite.png',
        type: 'damage',
        limit: 3,
        description: 'é€ æˆåŸºäºæ³•æœ¯å¼ºåº¦çš„ç¥åœ£ä¼¤å®³',
        calculate: (char) => {
            let damage = char.stats.spellPower * 1.2;
            return {
                damage: Math.floor(damage),
                school: 'holy'
            };
        }
    },
    shadow_word_pain: {
        id: 'shadow_word_pain',
        name: 'çœŸè¨€æœ¯ï¼šç—›',
        icon: 'ğŸ©¸',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Shadow_ShadowWordPain.png',
        type: 'dot',
        limit: 2,
        description: 'æŒç»­3å›åˆé€ æˆæš—å½±ä¼¤å®³',
        calculate: (char) => ({
            dot: {
                school: 'shadow',
                damagePerTurn: Math.floor(char.stats.spellPower * 0.6),
                duration: 3
            }
        })
    },
    mind_blast: {
        id: 'mind_blast',
        name: 'å¿ƒçµéœ‡çˆ†',
        icon: 'ğŸ§ ',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Shadow_UnholyFrenzy.png',
        type: 'damage',
        limit: 2,
        description: 'é€ æˆé«˜é¢æš—å½±ä¼¤å®³',
        calculate: (char) => {
            let damage = char.stats.spellPower * 2.0;
            const isCrit = Math.random() < (char.stats.critRate||0) / 100;
            if (isCrit) {
                damage *= char.stats.critDamage;
            }
            return {
                damage: Math.floor(damage),
                isCrit: isCrit,
                school: 'shadow'
            };
        }
    },
    power_word_radiance: {
        id: 'power_word_radiance',
        name: 'çœŸè¨€æœ¯ï¼šè€€',
        icon: 'ğŸŒŸ',
        iconUrl : 'icons/wow/vanilla/spells/yao.png',
        type: 'heal',
        limit: 2,
        description: 'ä¸ºå…¨é˜Ÿæ²»ç–—å¹¶æ–½åŠ ã€æ•‘èµã€‘',
        calculate: (char) => ({
            healAll: Math.floor(char.stats.spellPower * 1.5),
            applyAtonement: {
                duration: 2
            }
        })
    },
    penance: {
        id: 'penance',
        name: 'è‹¦ä¿®',
        icon: 'âœï¸',
        iconUrl : 'icons/wow/vanilla/spells/kuxiu.png',
        type: 'heal',
        limit: 2,
        description: 'å¯¹æœ€å‰æ’çš„é˜Ÿå‹å›å¤3å€æ³•æœ¯å¼ºåº¦çš„ç”Ÿå‘½å€¼',
        calculate: (char, combatContext) => {
            let healAmount = Math.floor(char.stats.spellPower * 3);

            // 40çº§å¤©èµ‹ï¼šç¥¸ç¦ç›¸ä¾ - æ¯å±‚æé«˜25%æ²»ç–—é‡
            const fortuneStacks = combatContext?.fortuneMisfortuneStacks || 0;
            if (char.talents?.[40] === 'fortune_misfortune' && fortuneStacks > 0) {
                healAmount = Math.floor(healAmount * (1 + fortuneStacks * 0.25));
            }

            const result = {
                penanceHeal: healAmount,
                clearFortuneStacks: char.talents?.[40] === 'fortune_misfortune'
            };

            // 40çº§å¤©èµ‹ï¼šç»ˆæè‹¦ä¿® - è¿˜ä¼šé€ æˆ2å€æ³•å¼ºä¼¤å®³ï¼ˆâœ… å¯æš´å‡»ï¼‰
            if (char.talents?.[40] === 'ultimate_penance') {
                let damage = (Number(char.stats.spellPower) || 0) * 2;
                const critRate = (Number(char.stats.critRate) || 0) / 100;
                const isCrit = Math.random() < critRate;

                if (isCrit) {
                    damage *= (Number(char.stats.critDamage) || 2.0);
                }

                result.penanceDamage = Math.floor(damage);
                result.penanceDamageIsCrit = isCrit;
            }

            // 40çº§å¤©èµ‹ï¼šäº‰åˆ†å¤ºç§’ - é‡Šæ”¾åæ€¥é€Ÿ+30%æŒç»­4å›åˆ
            if (char.talents?.[40] === 'borrowed_time') {
                result.applyHasteBuff = {
                    hasteBonus: 30,
                    duration: 4
                };
            }

            return result;
        }
    },
    holy_nova: {
        id: 'holy_nova',
        name: 'ç¥åœ£æ–°æ˜Ÿ',
        icon: 'ğŸ’¥',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Holy_HolyNova.png',
        type: 'aoe_hybrid',
        limit: 1,
        description: 'å¯¹æ‰€æœ‰æ•Œäººé€ æˆ 2å€æ³•æœ¯å¼ºåº¦ çš„ç¥åœ£ä¼¤å®³ï¼Œå¹¶å¯¹æ‰€æœ‰é˜Ÿå‹æ¢å¤ 2å€æ³•æœ¯å¼ºåº¦ çš„ç”Ÿå‘½å€¼',
        calculate: (char, combatContext) => {
            const base = Math.floor(char.stats.spellPower * 2);

            // 50çº§å¤©èµ‹ï¼šå¹»æƒ³æ›² - æ¯å±‚ä½¿ä¸‹ä¸€ä¸ªç¥åœ£æ–°æ˜Ÿä¼¤å®³/æ²»ç–— +20%ï¼Œæ–½æ”¾åæ¸…ç©º
            const fantasiaStacks = Number(combatContext?.fantasiaStacks) || 0;
            const fantasiaMult = (char.talents?.[50] === 'fantasia' && fantasiaStacks > 0)
                ? (1 + fantasiaStacks * 0.20)
                : 1;

            const amount = Math.floor(base * fantasiaMult);

            const result = {
                aoeDamage: amount,
                healAll: amount,
                school: 'holy',

                fantasiaStacksUsed: (fantasiaMult > 1) ? fantasiaStacks : 0,
                clearFantasiaStacks: (fantasiaMult > 1)
            };

            // 50çº§å¤©èµ‹ï¼šç¥åœ£éšœå£ - ç¥åœ£æ–°æ˜Ÿä¸ºå…¨é˜Ÿæ–½åŠ 2å›åˆæ•‘èµï¼Œå¹¶æ–½åŠ 2å€æ³•æœ¯å¼ºåº¦æŠ¤ç›¾ï¼ˆåœ¨Bossæˆ˜ä¼šæ‰©å±•åˆ°å…¨é˜Ÿï¼‰
            if (char.talents?.[50] === 'holy_barrier') {
                result.applyAtonement = { duration: 2 };
                const sp = Number(char.stats.spellPower) || 0;
                result.shield = {
                    type: 'holy_barrier',
                    name: 'ç¥åœ£éšœå£',
                    amount: Math.floor(sp * 2),
                    maxAmount: Math.floor(sp * 2),
                    duration: 2
                };
            }

            return result;
        }
    },


    // ==================== å†°éœœæ³•å¸ˆæŠ€èƒ½ ====================
    mastery_deep_winter: {
        id: 'mastery_deep_winter',
        name: 'ç²¾é€šï¼šæ·±å†¬ä¹‹å¯’',
        icon: 'â„ï¸',
        iconUrl : 'icons/wow/vanilla/spells/Spell_Frost_FrostWard.png',
        type: 'passive',
        description: 'è¢«åŠ¨ï¼šå†°æªæœ¯çš„åŸºç¡€æŠ€èƒ½å€ç‡æå‡(ç²¾é€š/2)%ã€‚è¯¥æ•°å€¼ç›´æ¥åŠ åœ¨åŸºç¡€120%ä¸Šã€‚'
    },
    frostbolt: {
        id: 'frostbolt',
        name: 'å¯’å†°ç®­',
        icon: 'â„ï¸',
        iconUrl: 'icons/wow/vanilla/spells/Spell_Frost_FrostBolt02.png',
        type: 'damage',
        limit: 8,
        description: 'é€ æˆ1.8å€æ³•æœ¯å¼ºåº¦çš„å†°éœœä¼¤å®³',
        calculate: (char, combatContext) => {
            let damage = char.stats.spellPower * 1.8;

            // å†°å†·è¡€è„‰buffï¼šå†°éœœä¼¤å®³æé«˜50%
            if (combatContext?.icyVeinsBuff) {
                damage *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æ³•æœ¯ä¼¤å®³æé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                damage *= 1.1;
            }

            // 50çº§å¤©èµ‹ï¼šç»å¯¹é›¶åº¦ - å†°é£æš´æœŸé—´æ‰€æœ‰å†°éœœä¼¤å®³é¢å¤–+25%
            if (char.talents?.[50] === 'absolute_zero' && combatContext?.blizzardActive) {
                damage *= 1.25;
            }

            // æš´å‡»åˆ¤å®š
            let critRate = char.stats.critRate || 0;
            // 10çº§å¤©èµ‹ï¼šå¯’å†·åˆºéª¨ - æš´å‡»ç‡æé«˜10
            if (char.talents?.[10] === 'piercing_cold') {
                critRate += 10;
            }

            // ===== 50çº§å¤©èµ‹ï¼šå¯’å†°çªç ´ =====
            let critBreakthroughBonus = 1;
            let forcedCritConversion = false;

            if (char.talents?.[50] === 'frost_crit_breakthrough') {
                if (combatContext?.blizzardActive) {
                    // å†°é£æš´æœŸé—´ï¼šæ‰€æœ‰æš´å‡»ç‡è½¬åŒ–ä¸ºä¼¤å®³åŠ æˆ
                    critBreakthroughBonus = 1 + (critRate / 100);
                    forcedCritConversion = true;
                    critRate = 0;
                } else if (critRate > 100) {
                    // éå†°é£æš´æœŸé—´ï¼šè¶…è¿‡100%çš„æš´å‡»è½¬åŒ–ä¸ºä¼¤å®³
                    const excessCrit = critRate - 100;
                    critBreakthroughBonus = 1 + (excessCrit / 100);
                    critRate = 100;
                }
            }

            damage *= critBreakthroughBonus;

            const isCrit = !forcedCritConversion && Math.random() < critRate / 100;
            if (isCrit) {
                damage *= char.stats.critDamage;
            }

            return {
                damage: Math.floor(damage),
                isCrit,
                school: 'frost',
                triggerFrostboltTalents: true,
                critConverted: forcedCritConversion
            };
        }
    },
    ice_lance: {
        id: 'ice_lance',
        name: 'å†°æªæœ¯',
        icon: 'ğŸ”±',
        iconUrl: 'icons/wow/vanilla/spells/Spell_Frost_FrostBlast.png',
        type: 'damage',
        limit: 8,
        description: 'é€ æˆ1.2å€æ³•æœ¯å¼ºåº¦çš„å†°éœœä¼¤å®³ï¼Œçˆ†å‡»ä¼¤å®³é¢å¤–å¢åŠ 200%',
        calculate: (char, combatContext) => {
            const baseMult = char.stats.iceLanceBaseMultiplier ?? 1.2;
            let damage = char.stats.spellPower * baseMult;

            // å†°å†·è¡€è„‰buffï¼šå†°éœœä¼¤å®³æé«˜50%
            if (combatContext?.icyVeinsBuff) {
                damage *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æ³•æœ¯ä¼¤å®³æé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                damage *= 1.1;
            }

            // 30çº§å¤©èµ‹ï¼šå†°å†»ä¹‹è§¦ - å†°æªæœ¯ä¼¤å®³æå‡25%
            if (char.talents?.[30] === 'frozen_touch') {
                damage *= 1.25;
            }

            // 20çº§å¤©èµ‹ï¼šå¯’å†°æŒ‡ - æ¶ˆè€—ä¸€å±‚å¯’å†°æŒ‡ï¼Œä¼¤å®³æé«˜100%ï¼ˆæˆ–150%å¦‚æœæœ‰æå¯’ç²¾é€šï¼‰
            const fingersOfFrost = combatContext?.fingersOfFrost || 0;
            let consumeFinger = false;
            if (char.talents?.[20] === 'fingers_of_frost' && fingersOfFrost > 0) {
                // 50çº§å¤©èµ‹ï¼šæå¯’ç²¾é€š - å¯’å†°æŒ‡æ•ˆæœæå‡è‡³150%
                const fingerBonus = char.talents?.[50] === 'glacial_mastery' ? 2.5 : 2;
                damage *= fingerBonus;
                consumeFinger = true;
            }

            // ===== 50çº§å¤©èµ‹ï¼šç»å¯¹é›¶åº¦ - å†°é£æš´æœŸé—´æ‰€æœ‰å†°éœœä¼¤å®³é¢å¤–+25% =====
            if (char.talents?.[50] === 'absolute_zero' && combatContext?.blizzardActive) {
                damage *= 1.25;
            }

            // æš´å‡»åˆ¤å®š
            let critRate = char.stats.critRate || 0;
            // 10çº§å¤©èµ‹ï¼šå¯’å†·åˆºéª¨ - æš´å‡»ç‡æé«˜10
            if (char.talents?.[10] === 'piercing_cold') {
                critRate += 10;
            }

            // ===== 50çº§å¤©èµ‹ï¼šå¯’å†°çªç ´ =====
            let critBreakthroughBonus = 1;
            let forcedCritConversion = false; // å†°é£æš´æœŸé—´å¼ºåˆ¶è½¬æ¢æ‰€æœ‰æš´å‡»

            if (char.talents?.[50] === 'frost_crit_breakthrough') {
                // å†°é£æš´æœŸé—´ï¼šæ‰€æœ‰æš´å‡»ç‡è½¬åŒ–ä¸ºä¼¤å®³åŠ æˆï¼Œä¸å†æš´å‡»
                if (combatContext?.blizzardActive) {
                    critBreakthroughBonus = 1 + (critRate / 100);
                    forcedCritConversion = true;
                    critRate = 0; // ä¸å†è¿›è¡Œæš´å‡»åˆ¤å®š
                } else {
                    // éå†°é£æš´æœŸé—´ï¼šè¶…è¿‡100%çš„æš´å‡»è½¬åŒ–ä¸ºä¼¤å®³
                    if (critRate > 100) {
                        const excessCrit = critRate - 100;
                        critBreakthroughBonus = 1 + (excessCrit / 100);
                        critRate = 100;
                    }
                }
            }

            damage *= critBreakthroughBonus;

            // å†°é£æš´DOTæœŸé—´å¿…å®šçˆ†å‡»ï¼ˆé™¤éè¢«å¯’å†°çªç ´è½¬æ¢ï¼‰
            let forceCrit = false;
            if (combatContext?.blizzardActive && !forcedCritConversion) {
                forceCrit = true;
            }

            const isCrit = !forcedCritConversion && (forceCrit || Math.random() < critRate / 100);
            if (isCrit) {
                // åŸºç¡€æš´å‡»ä¼¤å®³ + é¢å¤–200%ï¼ˆæˆ–300%å¦‚æœæœ‰æå¯’ç²¾é€šï¼‰
                const extraCritDamage = char.talents?.[50] === 'glacial_mastery' ? 3 : 2;
                damage *= (char.stats.critDamage + extraCritDamage);
            }

            return {
                damage: Math.floor(damage),
                isCrit,
                school: 'frost',
                consumeFingersOfFrost: consumeFinger,
                critConverted: forcedCritConversion // æ ‡è®°æš´å‡»è¢«è½¬æ¢
            };
        }
    },
    blizzard: {
        id: 'blizzard',
        name: 'å†°é£æš´',
        icon: 'ğŸŒ¨ï¸',
        iconUrl: 'icons/wow/vanilla/spells/bingfengbao.png',
        type: 'dot',
        limit: 2,
        description: 'DOTæŒç»­3å›åˆï¼Œæ¯å›åˆé€ æˆ1å€æ³•æœ¯å¼ºåº¦çš„å†°éœœä¼¤å®³ï¼ŒæŒç»­æœŸé—´å†°æªæœ¯å¿…å®šçˆ†å‡»',
        calculate: (char, combatContext) => {
            let damagePerTurn = char.stats.spellPower * 1;
            let duration = 3;

            // 50çº§å¤©èµ‹ï¼šç»å¯¹é›¶åº¦ - æŒç»­æ—¶é—´+2ï¼Œä¼¤å®³+50%
            if (char.talents?.[50] === 'absolute_zero') {
                duration = 5;
                damagePerTurn *= 1.5;
            }

            // å†°å†·è¡€è„‰buffï¼šå†°éœœä¼¤å®³æé«˜50%
            if (combatContext?.icyVeinsBuff) {
                damagePerTurn *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æ³•æœ¯ä¼¤å®³æé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                damagePerTurn *= 1.1;
            }

            return {
                dot: {
                    school: 'frost',
                    name: 'å†°é£æš´',
                    damagePerTurn: Math.floor(damagePerTurn),
                    duration: duration,
                    enableIceLanceCrit: true // æ ‡è®°å†°æªæœ¯å¿…å®šçˆ†å‡»
                }
            };
        }
    },
    frozen_orb: {
        id: 'frozen_orb',
        name: 'å¯’å†°å®ç ',
        icon: 'ğŸ”®',
        iconUrl : 'icons/wow/vanilla/spells/hanbingbaozhu.png',
        type: 'aoe_dot',
        limit: 2,
        description: 'å¯¹æ‰€æœ‰æ•Œæ–¹å•ä½æ–½åŠ DOTï¼ŒæŒç»­3å›åˆï¼Œæ¯å›åˆé€ æˆ0.5å€æ³•æœ¯å¼ºåº¦çš„ä¼¤å®³',
        calculate: (char, combatContext) => {
            let damagePerTurn = char.stats.spellPower * 0.5;
            let duration = 3;

            // 20çº§å¤©èµ‹ï¼šæ— å°½å¯’å†¬ - æŒç»­æ—¶é—´+2ï¼Œä¼¤å®³æé«˜åˆ°0.8å€
            if (char.talents?.[20] === 'endless_winter') {
                duration = 5;
                damagePerTurn = char.stats.spellPower * 0.8;
            }

            // å†°å†·è¡€è„‰buffï¼šå†°éœœä¼¤å®³æé«˜50%
            if (combatContext?.icyVeinsBuff) {
                damagePerTurn *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æ³•æœ¯ä¼¤å®³æé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                damagePerTurn *= 1.1;
            }

            // 50çº§å¤©èµ‹ï¼šç»å¯¹é›¶åº¦ - å†°é£æš´æœŸé—´æ‰€æœ‰å†°éœœä¼¤å®³é¢å¤–+25%
            if (char.talents?.[50] === 'absolute_zero' && combatContext?.blizzardActive) {
                damagePerTurn *= 1.25;
            }

            return {
                aoeDot: {
                    school: 'frost',
                    name: 'å¯’å†°å®ç ',
                    damagePerTurn: Math.floor(damagePerTurn),
                    duration: duration,
                    canGenerateFinger: char.talents?.[30] === 'orb_mastery'
                }
            };
        }
    },
    icy_veins: {
        id: 'icy_veins',
        name: 'å†°å†·è¡€è„‰',
        icon: 'ğŸ’ ',
        iconUrl : 'icons/wow/vanilla/spells/spell_frost_coldhearted.jpg',
        type: 'buff',
        limit: 1,
        description: 'ä½ é€ æˆçš„å†°éœœä¼¤å®³æé«˜50%ï¼Œæ€¥é€Ÿæé«˜50%ï¼ŒæŒç»­4å›åˆ',
        calculate: (char) => {
            return {
                buff: {
                    type: 'icy_veins',
                    frostDamageMult: 1.5,
                    hasteBonus: 50,
                    duration: 4
                }
            };
        }
    },
    comet_storm: {
        id: 'comet_storm',
        name: 'å½—æ˜Ÿé£æš´',
        icon: 'â˜„ï¸',
        iconUrl : 'icons/wow/vanilla/spells/huixingfengbao.png',
        type: 'aoe_damage',
        limit: 1,
        description: 'å¯¹æ‰€æœ‰æ•Œäººé€ æˆ3å€æ³•æœ¯å¼ºåº¦çš„ä¼¤å®³',
        calculate: (char, combatContext) => {
            let damage = char.stats.spellPower * 3;

            // å†°å†·è¡€è„‰buffï¼šå†°éœœä¼¤å®³æé«˜50%
            if (combatContext?.icyVeinsBuff) {
                damage *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æ³•æœ¯ä¼¤å®³æé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                damage *= 1.1;
            }

            // 50çº§å¤©èµ‹ï¼šç»å¯¹é›¶åº¦ - å†°é£æš´æœŸé—´æ‰€æœ‰å†°éœœä¼¤å®³é¢å¤–+25%
            if (char.talents?.[50] === 'absolute_zero' && combatContext?.blizzardActive) {
                damage *= 1.25;
            }

            // æš´å‡»åˆ¤å®š
            let critRate = char.stats.critRate || 0;
            if (char.talents?.[10] === 'piercing_cold') {
                critRate += 10;
            }

            // ===== 50çº§å¤©èµ‹ï¼šå¯’å†°çªç ´ =====
            let critBreakthroughBonus = 1;
            let forcedCritConversion = false;

            if (char.talents?.[50] === 'frost_crit_breakthrough') {
                if (combatContext?.blizzardActive) {
                    critBreakthroughBonus = 1 + (critRate / 100);
                    forcedCritConversion = true;
                    critRate = 0;
                } else if (critRate > 100) {
                    const excessCrit = critRate - 100;
                    critBreakthroughBonus = 1 + (excessCrit / 100);
                    critRate = 100;
                }
            }

            damage *= critBreakthroughBonus;

            const isCrit = !forcedCritConversion && Math.random() < critRate / 100;
            if (isCrit) {
                damage *= char.stats.critDamage;
            }

            return {
                aoeDamage: Math.floor(damage),
                isCrit,
                school: 'frost',
                generateFingerOnHit: char.talents?.[40] === 'glacial_spike',
                critConverted: forcedCritConversion
            };
        }
    },ice_barrier: {
        id: 'ice_barrier',
        name: 'å¯’å†°æŠ¤ä½“',
        icon: 'ğŸ§Š',
        iconUrl: 'icons/wow/vanilla/spells/Spell_Ice_Lament.png',
        type: 'shield',
        limit: 1,
        description: 'ä¸ºè‡ªå·±æ–½åŠ ä¸€ä¸ªæŠ¤ç›¾ï¼Œå¸æ”¶2.5å€æ³•æœ¯å¼ºåº¦çš„ä¼¤å®³ï¼ŒæŒç»­4å›åˆã€‚æŠ¤ç›¾å­˜åœ¨æ—¶å—å‡»æœ‰25%æ¦‚ç‡è·å¾—1å±‚å¯’å†°æŒ‡ã€‚',
        calculate: (char, combatContext) => {
            let shieldAmount = char.stats.spellPower * 2.5;

            // å†°å†·è¡€è„‰å¢å¼ºæŠ¤ç›¾
            if (combatContext?.icyVeinsBuff) {
                shieldAmount *= 1.5;
            }

            // 10çº§å¤©èµ‹ï¼šå¯’å†°å¢å¹… - æŠ¤ç›¾é‡ä¹Ÿæé«˜10%
            if (char.talents?.[10] === 'frost_amp') {
                shieldAmount *= 1.1;
            }

            return {
                shield: {
                    type: 'ice_barrier',
                    name: 'å¯’å†°æŠ¤ä½“',
                    amount: Math.floor(shieldAmount),
                    maxAmount: Math.floor(shieldAmount),
                    duration: 4,
                    // å—å‡»æ—¶è§¦å‘æ•ˆæœ
                    onHitEffect: {
                        type: 'generate_finger',
                        chance: 0.25
                    }
                }
            };
        }
    },

    // ==================== ç‹‚å¾’ç›—è´¼ ====================
    mastery_sword_heart: {
        id: 'mastery_sword_heart',
        name: 'ç²¾é€šï¼šé€šæ˜å‰‘å¿ƒ',
        icon: 'ğŸ—¡ï¸',
        iconUrl: 'icons/wow/vanilla/abilities/Ability_Warrior_Challange.png',
        type: 'passive',
        description: 'è¢«åŠ¨ï¼šå‰‘åˆƒä¹±èˆå¤åˆ¶ä¼¤å®³çš„æ¯”ä¾‹æé«˜ï¼ˆç²¾é€š/10ï¼‰%ã€‚ä½ å¯ä»¥ç§¯æ”’â€œæ˜Ÿâ€ï¼ˆè¿å‡»ç‚¹ï¼‰æ¥åŠ å¼ºã€åˆºéª¨ã€‘ã€åˆ‡å‰²ã€‘ã€æ­£ä¸­çœ‰å¿ƒã€‘ï¼Œæœ€é«˜5æ˜Ÿï¼ˆ10çº§å¤©èµ‹ã€ç‹¡è¯ˆè®¡è°‹ã€‘å¯æé«˜è‡³7æ˜Ÿï¼›40çº§å¤©èµ‹ã€æ·±é‚ƒè¯¡è®¡ã€‘é¢å¤–+1ï¼‰ã€‚'
    },
    blade_flurry: {
        id: 'blade_flurry',
        name: 'å‰‘åˆƒä¹±èˆ',
        icon: 'ğŸŒ€',
        iconUrl: 'icons/wow/vanilla/abilities/Ability_Warrior_PunishingBlow.png',
        type: 'aoe_damage',
        limit: 1,
        description: 'å¯¹æ‰€æœ‰ç›®æ ‡é€ æˆ1å€æ”»å‡»å¼ºåº¦çš„ä¼¤å®³ã€‚æœ¬åœºæˆ˜æ–—ä¸­ä½ çš„æ™®é€šæ”»å‡»ã€åˆºéª¨ã€ä¼å‡»ã€æ­£ä¸­çœ‰å¿ƒä¼šå¯¹ä¸»ç›®æ ‡å¤–çš„æ‰€æœ‰æ•Œäººé€ æˆæœ¬æ¬¡ä¼¤å®³*50%çš„å¤åˆ¶ä¼¤å®³ï¼ˆç²¾é€šæé«˜æ¯”ä¾‹ï¼‰ã€‚',
        calculate: (char, combatContext = {}) => {
            const enemyCountRaw = Number(combatContext?.enemyCount);
            const enemyCount = (Number.isFinite(enemyCountRaw) && enemyCountRaw > 0)
                ? Math.floor(enemyCountRaw)
                : 1;

            let damage = (char.stats.attack || 0) * 1.0;

            // 20çº§å¤©èµ‹ï¼šçŸ«å¥çµåŠ¨ - å‰‘åˆƒä¹±èˆåˆå§‹ä¼¤å®³+100%ï¼Œå¹¶ä¸”æ¯å‘½ä¸­ä¸€ä¸ªç›®æ ‡è·å¾—1æ˜Ÿ
            const hasAgileMovement = (char?.classId === 'outlaw_rogue' && char?.talents?.[20] === 'agile_movement');
            if (hasAgileMovement) {
                damage *= 2;
            }

            const critRate = Number(char.stats.critRate) || 0;
            const isCrit = Math.random() < critRate / 100;
            if (isCrit) {
                damage *= (Number(char.stats.critDamage) || 2.0);
            }

            // å…¨èƒ½ï¼šé€šç”¨ä¹˜åŒº
            damage *= (1 + (Number(char.stats.versatility) || 0) / 100);

            const result = {
                aoeDamage: Math.floor(damage),
                isCrit,
                buff: {
                    type: 'blade_flurry',
                    name: 'å‰‘åˆƒä¹±èˆ',
                    duration: 999
                }
            };

            if (hasAgileMovement) {
                result.generateComboPoints = enemyCount;
            }

            return result;
        }
    },

    shadowstrike: {
        id: 'shadowstrike',
        name: 'å½±è¢­',
        icon: 'ğŸ—¡ï¸',
        iconUrl: 'icons/wow/vanilla/abilities/yingxi.png',
        type: 'damage',
        limit: 8,
        description: 'é€ æˆ1.2å€æ”»å‡»å¼ºåº¦çš„ä¼¤å®³ï¼Œè·å¾—1é¢—æ˜Ÿï¼ˆ10çº§å¤©èµ‹ã€å¯ä¹˜ä¹‹æœºã€‘å¯é¢å¤–+1ï¼‰ã€‚',
        calculate: (char) => {
            let damage = (char.stats.attack || 0) * 1.2;
            const critRate = Number(char.stats.critRate) || 0;
            const isCrit = Math.random() < critRate / 100;
            if (isCrit) damage *= (Number(char.stats.critDamage) || 2.0);
            damage *= (1 + (Number(char.stats.versatility) || 0) / 100);

            // ç›—è´¼10çº§å¤©èµ‹ï¼šå¯ä¹˜ä¹‹æœº - å½±è¢­é¢å¤–è·å¾— 1 æ˜Ÿ
            const extraCombo = (char?.classId === 'outlaw_rogue' && char?.talents?.[10] === 'opportunity') ? 1 : 0;
            return {
                damage: Math.floor(damage),
                isCrit,
                generateComboPoints: 1 + extraCombo
            };
        }
    },
    eviscerate: {
        id: 'eviscerate',
        name: 'åˆºéª¨',
        icon: 'ğŸ©¸',
        iconUrl: 'icons/wow/vanilla/abilities/cigu.png',
        type: 'damage',
        limit: 8,
        description: 'é€ æˆ1.5 +ï¼ˆå½“å‰æ˜Ÿæ•°*0.5ï¼‰å€æ”»å‡»å¼ºåº¦çš„ä¼¤å®³ï¼Œæ¶ˆè€—æ‰€æœ‰æ˜Ÿã€‚',
        calculate: (char, combatContext) => {
            const maxCombo = getMaxComboPointsForChar(char);
            const combo = Math.max(0, Math.min(maxCombo, Math.floor(Number(combatContext?.comboPoints) || 0)));
            const mult = 1.5 + combo * 0.5;

            let damage = (char.stats.attack || 0) * mult;
            const critRate = Number(char.stats.critRate) || 0;
            const isCrit = Math.random() < critRate / 100;
            if (isCrit) damage *= (Number(char.stats.critDamage) || 2.0);
            damage *= (1 + (Number(char.stats.versatility) || 0) / 100);

            return {
                damage: Math.floor(damage),
                isCrit,
                consumeComboPoints: 'all'
            };
        }
    },
    ambush: {
        id: 'ambush',
        name: 'ä¼å‡»',
        icon: 'ğŸ¥·',
        iconUrl: 'icons/wow/vanilla/abilities/fuji.png',
        type: 'damage',
        limit: 2,
        description: 'é€ æˆ2å€æ”»å‡»å¼ºåº¦çš„ä¼¤å®³ï¼Œè·å¾—2é¢—æ˜Ÿã€‚',
        calculate: (char) => {
            let damage = (char.stats.attack || 0) * 2.0;
            const critRate = Number(char.stats.critRate) || 0;
            const isCrit = Math.random() < critRate / 100;
            if (isCrit) damage *= (Number(char.stats.critDamage) || 2.0);
            damage *= (1 + (Number(char.stats.versatility) || 0) / 100);
            return {
                damage: Math.floor(damage),
                isCrit,
                generateComboPoints: 2
            };
        }
    },
    crimson_vial: {
        id: 'crimson_vial',
        name: 'çŒ©çº¢ä¹‹ç“¶',
        icon: 'ğŸ§ª',
        iconUrl: 'icons/wow/vanilla/abilities/xinghongzhiping.png',
        type: 'buff',
        limit: 1,
        description: 'æ¯å›åˆå›å¤15%ç”Ÿå‘½å€¼ï¼ŒæŒç»­3å›åˆï¼ˆè‹¥ç‚¹å‡º50çº§å¤©èµ‹ã€å¼ºæ•ˆç“¶å‰‚ã€‘åˆ™æŒç»­6å›åˆï¼‰ã€‚',
        calculate: (char) => {
            const duration = (char?.classId === 'outlaw_rogue' && char?.talents?.[50] === 'potent_vial') ? 6 : 3;
            return {
                buff: {
                    type: 'crimson_vial',
                    name: 'çŒ©çº¢ä¹‹ç“¶',
                    healPctPerTurn: 0.15,
                    duration
                }
            };
        }
    },
    slice_and_dice: {
        id: 'slice_and_dice',
        name: 'åˆ‡å‰²',
        icon: 'âš¡',
        iconUrl: 'icons/wow/vanilla/abilities/qiege.png',
        type: 'buff',
        limit: 1,
        description: 'æ€¥é€Ÿæé«˜20 +ï¼ˆå½“å‰æ˜Ÿæ•°*20ï¼‰ï¼ŒæŒç»­8å›åˆï¼Œæ¶ˆè€—æ‰€æœ‰æ˜Ÿã€‚',
        calculate: (char, combatContext) => {
            const maxCombo = getMaxComboPointsForChar(char);
            const combo = Math.max(0, Math.min(maxCombo, Math.floor(Number(combatContext?.comboPoints) || 0)));
            const hasteBonus = 20 + combo * 20;

            // 40çº§å¤©èµ‹ï¼šè¿…çŒ›æŒ¥ç  - åˆ‡å‰²é¢å¤–æä¾›å…¨èƒ½ï¼ˆæ¯æ¶ˆè€—1æ˜Ÿ +10å…¨èƒ½ï¼‰
            const hasSwiftSlashes = (char?.classId === 'outlaw_rogue' && char?.talents?.[40] === 'swift_slashes');
            const versatilityBonus = hasSwiftSlashes ? combo * 10 : 0;

            return {
                buff: {
                    type: 'slice_and_dice',
                    name: 'åˆ‡å‰²',
                    hasteBonus,
                    versatilityBonus,
                    duration: 8
                },
                consumeComboPoints: 'all'
            };
        }
    },
    between_the_eyes: {
        id: 'between_the_eyes',
        name: 'æ­£ä¸­çœ‰å¿ƒ',
        icon: 'ğŸ¯',
        iconUrl: 'icons/wow/vanilla/abilities/zhengzhongmeixin.png',
        type: 'damage',
        limit: 1,
        description: 'é€ æˆ2 +ï¼ˆå½“å‰æ˜Ÿæ•°*0.5ï¼‰å€æ”»å‡»å¼ºåº¦çš„ä¼¤å®³ï¼Œæé«˜10 +ï¼ˆå½“å‰æ˜Ÿæ•°*5ï¼‰çš„æš´å‡»ç‡ï¼ŒæŒç»­4å›åˆï¼Œæ¶ˆè€—æ‰€æœ‰æ˜Ÿã€‚',
        calculate: (char, combatContext) => {
            const maxCombo = getMaxComboPointsForChar(char);
            const combo = Math.max(0, Math.min(maxCombo, Math.floor(Number(combatContext?.comboPoints) || 0)));
            const mult = 2 + combo * 0.5;
            const critRateBonus = 10 + combo * 5;

            let damage = (char.stats.attack || 0) * mult;
            const critRate = Number(char.stats.critRate) || 0;
            const isCrit = Math.random() < critRate / 100;
            if (isCrit) damage *= (Number(char.stats.critDamage) || 2.0);
            damage *= (1 + (Number(char.stats.versatility) || 0) / 100);

            return {
                damage: Math.floor(damage),
                isCrit,
                buff: {
                    type: 'between_the_eyes',
                    name: 'æ­£ä¸­çœ‰å¿ƒ',
                    critRateBonus,
                    duration: 4
                },
                consumeComboPoints: 'all'
            };
        }
    },
    adrenaline_rush: {
        id: 'adrenaline_rush',
        name: 'å†²åŠ¨',
        icon: 'ğŸ”¥',
        iconUrl: 'icons/wow/vanilla/abilities/chongdong.png',
        type: 'buff',
        limit: 1,
        description: 'è·å¾—20æ€¥é€Ÿï¼Œæ¯å›åˆè·å–1é¢—æ˜Ÿï¼ŒæŒç»­5å›åˆã€‚',
        calculate: (char) => {
            // 60çº§å¤©èµ‹ï¼šå»¶æ—¶ä¹‹åŠ› - å†²åŠ¨æŒç»­æ—¶é—´å»¶é•¿è‡³8å›åˆ
            const duration = (char?.classId === 'outlaw_rogue' && char?.talents?.[60] === 'delayed_power')
                ? 8
                : 5;
            return {
                buff: {
                    type: 'adrenaline_rush',
                    name: 'å†²åŠ¨',
                    hasteBonus: 20,
                    comboPerTurn: 1,
                    duration
                }
            };
        }
    },

    // åœ¨ SKILLS å¯¹è±¡ä¸­æ·»åŠ 
    conditional_frost_strike: {
        id: 'conditional_frost_strike',
        name: 'å†°éœœæ‰“å‡»ï¼ˆæ™ºèƒ½ï¼‰',
        icon: 'ğŸ§Š',
        iconUrl: 'icons/wow/vanilla/spells/Spell_Frost_IceStorm.png',
        type: 'conditional',  // æ–°ç±»å‹ï¼šæ¡ä»¶æŠ€èƒ½
        limit: 8,
        description: 'æœ‰å¯’å†°æŒ‡æ—¶é‡Šæ”¾å†°æªæœ¯ï¼Œå¦åˆ™é‡Šæ”¾å¯’å†°ç®­',

        // æ¡ä»¶é…ç½®
        condition: {
            type: 'has_buff',
            buffName: 'fingersOfFrost',  // æ£€æŸ¥å¯’å†°æŒ‡å±‚æ•°
            minStacks: 1
        },
        skillIfTrue: 'ice_lance',    // æ»¡è¶³æ¡ä»¶ç”¨å†°æª
        skillIfFalse: 'frostbolt',   // ä¸æ»¡è¶³ç”¨å†°ç®­

        // calculate ä¼šåœ¨æˆ˜æ–—ç³»ç»Ÿä¸­è¢«æ›¿æ¢ä¸ºå®é™…æŠ€èƒ½çš„ calculate
        calculate: (char, combatContext) => {
            // è¿™ä¸ªå‡½æ•°å®é™…ä¸Šä¸ä¼šè¢«ç›´æ¥è°ƒç”¨
            // æˆ˜æ–—ç³»ç»Ÿä¼šæ ¹æ®æ¡ä»¶é€‰æ‹©çœŸæ­£çš„æŠ€èƒ½
            return {};
        }
    },
};

const ZONES = {
    elwynn_forest: {
        id: 'elwynn_forest',
        name: 'è‰¾å°”æ–‡æ£®æ—',
        level: 1,
        type: 'explore',
        enemies: [
            { name: 'ç‹¼', hp: 30, attack: 5, defense: 2, exp: 10, gold: 5 },
            { name: 'åœŸåŒª', hp: 50, attack: 8, defense: 5, exp: 20, gold: 15 },
        ],
        resources: ['æœ¨æ', 'è‰è¯'],
        unlocked: true
    },
    westfall: {
        id: 'westfall',
        name: 'è¥¿éƒ¨è’é‡',
        level: 10,
        type: 'explore',
        enemies: [
            { name: 'æ”¶å‰²æœºå‚€å„¡', hp: 250, attack: 25, defense: 20, exp: 45, gold: 35 },
            { name: 'è¿ªè²äºšç›—è´¼', hp: 300, attack: 30, defense: 18, exp: 50, gold: 40 },
        ],
        resources: ['æœ¨æ', 'æ¯›çš®'],
        unlocked: false,
        unlockLevel: 10
    },
    redridge: {
        id: 'redridge',
        name: 'èµ¤è„Šå±±',
        level: 20,
        type: 'explore',
        enemies: [
            { name: 'è±ºç‹¼äºº', hp: 1500, attack: 55, defense: 40, exp: 80, gold: 70 },
            { name: 'é»‘çŸ³å…½äºº', hp: 2000, attack: 85, defense: 50, exp: 120, gold: 100 },
        ],
        resources: ['æœ¨æ', 'é“çŸ¿'],
        unlocked: false,
        unlockLevel: 20
    },
    barrens: {
        id: 'barrens',
        name: 'è´«ç˜ ä¹‹åœ°',
        level: 25,
        type: 'explore',
        enemies: [
            {
                name: 'é£é™©æŠ•èµ„å…¬å¸é›‡å‘˜',
                hp: 5000,
                attack: 100,
                defense: 90,
                exp: 1200,
                gold: 800
            },
            {
                name: 'è´«ç˜ ä¹‹åœ°å°é‡çŒª',
                hp: 8000,
                attack: 75,
                defense: 100,
                exp: 1100,
                gold: 900
            }
        ],
        resources: ['æ¯›çš®','é“çŸ¿'],
        unlocked: false,
        unlockLevel: 25
    },
    stranglethorn_vale: {
        id: 'stranglethorn_vale',
        name: 'è†æ£˜è°·',
        level: 30,
        type: 'explore',
        enemies: [
            {
                name: 'ä¸›æ—å¤§çŒ©çŒ©',
                hp: 9000,
                attack: 140,
                defense: 100,
                exp: 1700,
                gold: 1200
            },
            {
                name: 'è¡€é¡¶å·¨é­”',
                hp: 7000,
                attack: 150,
                defense: 110,
                exp: 1800,
                gold: 1200
            },
            {
                name: 'å·´å°”ç‘Ÿæ‹‰',
                hp: 15000,
                attack: 200,
                defense: 130,
                exp: 2500,
                gold: 1900
            },
            {
                name: 'é‚¦åŠ æ‹‰ä»€',
                hp: 12000,
                attack: 250,
                defense: 120,
                exp: 2500,
                gold: 2000
            }
        ],
        resources: ['æ¯›çš®', 'è‰è¯'],
        unlocked: false,
        unlockLevel: 30
    },
    dustwallow_marsh: {
        id: 'dustwallow_marsh',
        name: 'å°˜æ³¥æ²¼æ³½',
        level: 35,
        type: 'explore',
        enemies: [
            {
                name: 'å¥¥å¦®å…‹å¸Œäºšçš„çˆªç‰™',
                hp: 28000,
                attack: 280,
                defense: 200,
                exp: 2000,
                gold: 1800
            },
            {
                name: 'çŸ³æ§Œé£Ÿäººé­”',
                hp: 26000,
                attack: 250,
                defense: 240,
                exp: 1800,
                gold: 1600
            },
            {
                name: 'åˆ©é½¿é³„é±¼',
                hp: 30000,
                attack: 300,
                defense: 180,
                exp: 2200,
                gold: 1900
            }
        ],
        resources: ['è‰è¯', 'æ¯›çš®'],
        unlocked: false,
        unlockLevel: 35
    },
    desolace: {
        id: 'desolace',
        name: 'å‡„å‡‰ä¹‹åœ°',
        level: 35,
        type: 'explore',
        enemies: [
            {
                name: 'æ¯’åˆºé­ç¬è€…',
                hp: 28000,
                attack: 420,
                defense: 200,
                exp: 2000,
                gold: 1800
            },
            {
                name: 'è¨ç‰¹æ½œè¡Œè€…',
                hp: 26000,
                attack: 380,
                defense: 240,
                exp: 1800,
                gold: 1600
            },
            {
                name: 'åŠäººé©¬å¯æ±—',
                hp: 30000,
                attack: 450,
                defense: 180,
                exp: 2200,
                gold: 1900
            }
        ],
        resources: ['è‰è¯', 'æ¯›çš®'],
        unlocked: false,
        unlockLevel: 35
    },
    tanaris: {
        id: 'tanaris',
        name: 'å¡”çº³åˆ©æ–¯',
        level: 40,
        type: 'explore',
        enemies: [
            {
                name: 'æ²™é¡¹å·«åŒ»',
                hp: 42000,
                attack: 500,
                defense: 250,
                exp: 3000,
                gold: 2500
            },
            {
                name: 'é’¢è…­é’³å˜´é¾Ÿ',
                hp: 49000,
                attack: 550,
                defense: 300,
                exp: 3200,
                gold: 3000
            },
            {
                name: 'æé¡»èˆ¹é•¿',
                hp: 42000,
                attack: 600,
                defense: 280,
                exp: 3200,
                gold: 3000
            },
            {
                name: 'å®‰å›¾è‹å°”',
                hp: 47000,
                attack: 850,
                defense: 400,
                exp: 3500,
                gold: 4000
            }
        ],
        resources: ['è‰è¯', 'çŸ¿çŸ³', 'æ¯›çš®'],
        unlocked: false,
        unlockLevel: 40
    },
    scarlet_monastery: {
        id: 'scarlet_monastery',
        name: 'è¡€è‰²ä¿®é“é™¢',
        level: 45,
        type: 'explore',
        enemies: [
            {
                name: 'è¡€è‰²æ‹·é—®è€…',
                hp: 82000,
                attack: 1250,
                defense: 500,
                exp: 4000,
                gold: 4000
            },
            {
                name: 'è¡€è‰²åƒ§ä¾£',
                hp: 100000,
                attack: 1150,
                defense: 600,
                exp: 4500,
                gold: 5000
            },
            {
                name: 'è¡€è‰²æ‹›é­‚å¸ˆ',
                hp: 82000,
                attack: 1200,
                defense: 550,
                exp: 4500,
                gold: 5000
            },
            {
                name: 'è¡€è‰²å·«å¸ˆ',
                hp: 90000,
                attack: 1400,
                defense: 600,
                exp: 5000,
                gold: 5500
            }
        ],
        resources: ['è‰è¯', 'æ¯›çš®'],
        unlocked: false,
        unlockLevel: 45
    },
    blackrock_depths: {
        id: 'blackrock_depths',
        name: 'é»‘çŸ³æ·±æ¸Š',
        level: 50,
        type: 'explore',
        enemies: [
            {
                name: 'é»‘é“çŸ®äººå®ˆå«',
                hp: 132000,
                attack: 3200,
                defense: 1400,
                exp: 5000,
                gold: 5500
            },
            {
                name: 'è¢«å¥´å½¹çš„åœŸå…ƒç´ ',
                hp: 150000,
                attack: 2500,
                defense: 1900,
                exp: 5500,
                gold: 5000
            },
            {
                name: 'æˆ˜æ–—å‚€å„¡',
                hp: 182000,
                attack: 3500,
                defense: 1750,
                exp: 6500,
                gold: 6000
            }
        ],
        resources: ['é“çŸ¿', 'çŸ¿çŸ³'],
        unlocked: false,
        unlockLevel: 50
    },
    sunken_temple: {
        id: 'sunken_temple',
        name: 'æ²‰æ²¡çš„ç¥åº™',
        level: 50,
        type: 'explore',
        enemies: [
            {
                name: 'ç»¿é¾™å®ˆå«',
                hp: 140000,
                attack: 3100,
                defense: 1300,
                exp: 5600,
                gold: 5500
            },
            {
                name: 'æ½œä¼çš„é£Ÿè…è€…',
                hp: 150000,
                attack: 3300,
                defense: 1850,
                exp: 6600,
                gold: 5800
            },
            {
                name: 'å“ˆå¡ä¹‹å­',
                hp: 200000,
                attack: 3500,
                defense: 1950,
                exp: 7000,
                gold: 6500
            }
        ],
        resources: ['è‰è¯', 'é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 50
    },


    lower_blackrock_spire: {
        id: 'lower_blackrock_spire',
        name: 'é»‘çŸ³å¡”ä¸‹',
        level: 55,
        type: 'explore',
        enemies: [
            { name: 'é»‘é“åº§ç‹¼', hp: 230000, attack: 4800, defense: 2300, exp: 8000, gold: 7000 },
            { name: 'çƒŸç½‘å°èœ˜è››', hp: 200000, attack: 4500, defense: 2100, exp: 7600, gold: 6800 },
            { name: 'é£Ÿäººé­”æ³•å¸ˆ', hp: 260000, attack: 5200, defense: 2400, exp: 9000, gold: 7500 },
            { name: 'å…½äººå†›å®˜', hp: 280000, attack: 5600, defense: 2600, exp: 9500, gold: 8000 },
        ],
        resources: ['é“çŸ¿', 'é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 55
    },
    scholomance: {
        id: 'scholomance',
        name: 'é€šçµå­¦é™¢',
        level: 55,
        type: 'explore',
        enemies: [
            { name: 'é€šçµå­¦é™¢å­¦å¾’', hp: 220000, attack: 4800, defense: 2200, exp: 8400, gold: 7200 },
            { name: 'é»‘æš—å¬å”¤å¸ˆ', hp: 260000, attack: 5400, defense: 2500, exp: 9200, gold: 7800 },
            { name: 'åœ°ç©´èœ˜è››', hp: 240000, attack: 5200, defense: 2300, exp: 8800, gold: 7600 },
            { name: 'æ„é€ ä½“', hp: 320000, attack: 5000, defense: 3000, exp: 9800, gold: 8200 },
        ],
        resources: ['é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 55
    },
    stratholme: {
        id: 'stratholme',
        name: 'æ–¯å¦ç´¢å§†',
        level: 55,
        type: 'explore',
        enemies: [
            { name: 'è¡€è‰²æŒ‡æŒ¥å®˜', hp: 300000, attack: 5800, defense: 2700, exp: 10000, gold: 8500 },
            { name: 'è‹ç™½å°–å•¸è€…', hp: 260000, attack: 6000, defense: 2400, exp: 9800, gold: 8300 },
            { name: 'éª·é«…æ³•å¸ˆ', hp: 240000, attack: 5600, defense: 2300, exp: 9200, gold: 8000 },
            { name: 'è…çƒ‚æ†æ¶', hp: 350000, attack: 6200, defense: 3200, exp: 11000, gold: 9000 },
        ],
        resources: ['é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 55
    },
    upper_blackrock_spire: {
        id: 'upper_blackrock_spire',
        name: 'é»‘çŸ³å¡”ä¸Š',
        level: 60,
        type: 'explore',
        enemies: [
            { name: 'çƒˆç„°å«å£«çºµç«è€…', hp: 420000, attack: 7200, defense: 3400, exp: 14000, gold: 11000 },
            { name: 'ç£·å–‰ä¸­å«', hp: 500000, attack: 7600, defense: 4200, exp: 15000, gold: 12000 },
            { name: 'é»‘æ‰‹åˆºå®¢', hp: 380000, attack: 8500, defense: 3200, exp: 15500, gold: 12500 },
            { name: 'é»‘è‰²é›é¾™', hp: 560000, attack: 8200, defense: 4000, exp: 17000, gold: 13500 },
        ],
        resources: ['é“çŸ¿', 'é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 60
    },
    zul_gurub: {
        id: 'zul_gurub',
        name: 'ç¥–å°”æ ¼æ‹‰å¸ƒ',
        level: 60,
        type: 'explore',
        enemies: [
            { name: 'å¤æ‹‰å·´ä»€ç‹‚æš´è€…', hp: 1820000, attack: 11500, defense: 6100, exp: 27500, gold: 15000 },
            { name: 'è§…è¡€è™è ', hp: 1820000, attack: 10800, defense: 6500, exp: 25000, gold: 15500 },
            { name: 'å“ˆå¡è±è¡€ç¥­ç¥€', hp: 1860000, attack: 10200, defense: 6700, exp: 26500, gold: 17000 },
            { name: 'æš—å½±é»‘è±¹', hp: 1990000, attack: 12000, defense: 6300, exp: 27000, gold: 18500 },
        ],
        resources: ['è‰è¯', 'æ¯›çš®', 'é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 60
    },

    // ==================== å®‰çªæ‹‰åºŸå¢Ÿï¼ˆ60çº§ï¼‰ ====================
    // æ•°å€¼å‚è€ƒç¥–å°”æ ¼æ‹‰å¸ƒï¼šæ”»å‡»/é˜²å¾¡/æ”¶ç›Šçº¦ +10%ï¼Œç”Ÿå‘½å€¼å…è®¸ç•¥å¾®è¶…æ ‡
    ruins_of_ahnqiraj: {
        id: 'ruins_of_ahnqiraj',
        name: 'å®‰çªæ‹‰åºŸå¢Ÿ',
        level: 60,
        type: 'explore',
        enemies: [
            { name: 'å®‰çªæ‹‰æ€æ‰‹', hp: 2300000, attack: 13200, defense: 6930, exp: 29700, gold: 20350 },
            { name: 'ä½æ‹‰å·¨åƒ', hp: 2350000, attack: 11220, defense: 7370, exp: 29150, gold: 18700 },
            { name: 'é»‘æ›œçŸ³æ¯ç­è€…', hp: 2150000, attack: 12650, defense: 6710, exp: 30250, gold: 18500 },
            { name: 'é˜¿åŠªæ¯”æ–¯å®ˆæŠ¤è€…', hp: 2520000, attack: 13880, defense: 7150, exp: 31500, gold: 24050 },
        ],
        resources: ['é“çŸ¿', 'é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 60
    },
    // ==================== ç†”ç«ä¹‹å¿ƒï¼ˆ60çº§ï¼‰ ====================
    molten_core: {
        id: 'molten_core',
        name: 'ç†”ç«ä¹‹å¿ƒ',
        level: 60,
        type: 'explore',
        enemies: [
            { name: 'ç†”å²©æ­¼ç­è€…', hp: 3600000, attack: 16000, defense: 8200, exp: 36000, gold: 26000 },
            { name: 'ç«ç„°è¡Œè€…ç¥­å¸', hp: 3450000, attack: 15000, defense: 7900, exp: 35000, gold: 25500 },
            { name: 'ä¸Šå¤ç†”å²©çŠ¬', hp: 3900000, attack: 16500, defense: 8000, exp: 37000, gold: 27000 },
            { name: 'ç†”ç«æ¶é­”å«å£«', hp: 4000000, attack: 17500, defense: 8600, exp: 39000, gold: 29000 },
        ],
        resources: ['é“çŸ¿', 'é­”æ³•ç²¾å'],
        unlocked: false,
        unlockLevel: 60
    },


};

const DROP_TABLES = {
    elwynn_forest: {
        equipment: [
            {
                id: 'EQ_001',
                chance: 0.05, // 5%
            },
            {
                id: 'EQ_002',
                chance: 0.05, // 5%
            },
            {
                id: 'EQ_003',
                chance: 0.001, // 0.1%
            },
            {
                id: 'EQ_004',
                chance: 0.001, // 0.1%
            },
            {
                id: 'EQ_005',
                chance: 0.05, // 5%
            }
        ],
        items: [
            {
                id: 'IT_001',
                chance: 0.05
            }
        ]
    },
    westfall: {
        equipment: [
            { id: 'EQ_006', chance: 0.03 },
            { id: 'EQ_007', chance: 0.03 },
            { id: 'EQ_008', chance: 0.03 },
            { id: 'EQ_009', chance: 0.03 },
            { id: 'EQ_010', chance: 0.03 },
            { id: 'EQ_011', chance: 0.03 },
            { id: 'EQ_012', chance: 0.03 },
            { id: 'EQ_013', chance: 0.001 } // 0.1%
        ]
    },
    redridge: {
        equipment: [
            { id: 'EQ_014', chance: 0.01 },   // 1%
            { id: 'EQ_015', chance: 0.01 },   // 1%
            { id: 'EQ_016', chance: 0.01 },   // 1%
            { id: 'EQ_017', chance: 0.01 },   // 1%
            { id: 'EQ_018', chance: 0.001 }  // 0.1%
        ]
    },
    barrens: {
        equipment: [
            { id: 'EQ_019', chance: 0.01 },   // 1%
            { id: 'EQ_020', chance: 0.003 },  // 0.3%
            { id: 'EQ_021', chance: 0.003 },  // 0.3%
            { id: 'EQ_022', chance: 0.01 },   // 1%
            { id: 'EQ_023', chance: 0.01 },   // 1%
            { id: 'EQ_024', chance: 0.001 },  // 0.1%
            { id: 'EQ_025', chance: 0.003 },  // 0.3%
            { id: 'EQ_026', chance: 0.003 }   // 0.3%
        ]
    },
    stranglethorn_vale: {
        equipment: [
            { id: 'EQ_027', chance: 0.01 },
            { id: 'EQ_028', chance: 0.01 },
            { id: 'EQ_029', chance: 0.01 },
            { id: 'EQ_030', chance: 0.001 },
            { id: 'EQ_031', chance: 0.003 },
            { id: 'EQ_032', chance: 0.003 },
            { id: 'EQ_003', chance: 0.005 },
            { id: 'EQ_004', chance: 0.005 },
        ],
        items: [
            { id: 'IT_STV_001', chance: 0.005 },
            { id: 'IT_STV_002', chance: 0.005 },
            { id: 'IT_STV_003', chance: 0.005 },
            { id: 'IT_STV_004', chance: 0.005 }
        ]
    },
    dustwallow_marsh: {
        items: [
            {
                id: 'IT_BLACK_DRAGON_PROOF',
                chance: 0.001   // 0.1%ï¼Œä½œä¸ºå‰§æƒ…é’¥åŒ™ï¼Œåˆç†ä½†ä¸æ³›æ»¥
            }
        ]
    },
    desolace: {
        equipment: [
            { id: 'EQ_033', chance: 0.003 }, // 0.3%
            { id: 'EQ_034', chance: 0.003 }, // 0.1%
            { id: 'EQ_035', chance: 0.01  }, // 1%
            { id: 'EQ_036', chance: 0.003 }, // 0.3%
            { id: 'EQ_037', chance: 0.003 }, // 0.3%
            { id: 'EQ_038', chance: 0.003 }, // 0.3%
            { id: 'EQ_039', chance: 0.003 }, // 0.3%
            { id: 'EQ_040', chance: 0.003 }  // 0.3%
        ]
    },
    tanaris: {
        equipment: [
            { id: 'EQ_041', chance: 0.001 }, // 0.1%
            { id: 'EQ_042', chance: 0.001 }, // 0.1%
            { id: 'EQ_043', chance: 0.003 }, // 0.3%
            { id: 'EQ_045', chance: 0.003 }, // 0.3%
            { id: 'EQ_046', chance: 0.003 }, // 0.3%
            { id: 'EQ_047', chance: 0.003 }, // 0.3%
            { id: 'EQ_048', chance: 0.01  },  // 1%
            { id: 'EQ_003', chance: 0.01 },
            { id: 'EQ_004', chance: 0.01 },
        ]
    },
    scarlet_monastery: {
        equipment: [
            { id: 'EQ_049', chance: 0.01 },   // 1%
            { id: 'EQ_050', chance: 0.003 },  // 0.3%
            { id: 'EQ_051', chance: 0.003 },  // 0.3%
            { id: 'EQ_052', chance: 0.01 },   // 1%
            { id: 'EQ_053', chance: 0.003 },  // 0.3%
            { id: 'EQ_054', chance: 0.003 },  // 0.3%
            { id: 'EQ_055', chance: 0.001 },  // 0.1%
            { id: 'EQ_056', chance: 0.003 },   // 0.3%
            { id: 'EQ_057', chance: 0.001 },  // 0.1%
            { id: 'EQ_058', chance: 0.003 },  // 0.3%
            { id: 'EQ_059', chance: 0.003 },  // 0.3%
            { id: 'EQ_060', chance: 0.003 },  // 0.3%
            { id: 'EQ_061', chance: 0.003 }   // 0.3%
        ]
    },
    blackrock_depths: {
        equipment: [
            { id: 'EQ_062', chance: 0.003 }, // 0.3%
            { id: 'EQ_063', chance: 0.003 },  // 0.3%
            { id: 'EQ_003', chance: 0.01 },
            { id: 'EQ_004', chance: 0.01 },
        ]
    },
    sunken_temple: {
        equipment: [
            { id: 'EQ_064', chance: 0.003 },  // 0.3%
            { id: 'EQ_065', chance: 0.003 },  // 0.3%
            { id: 'EQ_066', chance: 0.003 },  // 0.3%
            { id: 'EQ_067', chance: 0.003 },  // 0.3%
            { id: 'EQ_068', chance: 0.003 },  // 0.3%
            { id: 'EQ_069', chance: 0.003 },  // 0.3%
            { id: 'EQ_070', chance: 0.003 },  // 0.3%
            { id: 'EQ_071', chance: 0.001 },  // 0.1% ç¨€æœ‰
            { id: 'EQ_072', chance: 0.001 },  // 0.1% ç¨€æœ‰
            { id: 'EQ_073', chance: 0.001 }   // 0.1% ç¨€æœ‰
        ]
    },


    lower_blackrock_spire: {
        equipment: [
            { id: 'EQ_074', chance: 0.003 },  // å‹‡æ°”è…°å¸¦
            { id: 'EQ_075', chance: 0.003 },  // è¿…å½±è…°å¸¦
            { id: 'EQ_076', chance: 0.003 },  // è™”è¯šè…°å¸¦
            { id: 'EQ_077', chance: 0.003 },  // åšå­¦è€…è…°å¸¦
            { id: 'EQ_078', chance: 0.003 },  // å‹‡æ°”æ‰‹å¥—
            { id: 'EQ_079', chance: 0.003 },  // è¿…å½±æ‰‹å¥—
            { id: 'EQ_080', chance: 0.003 },  // è™”è¯šæ‰‹å¥—
            { id: 'EQ_081', chance: 0.003 },  // åšå­¦è€…æ‰‹å¥—
            { id: 'EQ_082', chance: 0.0015 }, // å–·æ¯’è€…
            { id: 'EQ_083', chance: 0.001 },  // çº¢æœ¨ä¹‹ç¯
            { id: 'EQ_084', chance: 0.0015 }, // å“ˆé›·è‚¯çš„é¡¹åœˆ
            { id: 'EQ_085', chance: 0.001 },  // ç‡ƒæ£˜å®é’»
            { id: 'EQ_086', chance: 0.001 }  // é»‘é¸­
        ]
    },
    scholomance: {
        equipment: [
            { id: 'EQ_090', chance: 0.003 },  // å‹‡æ°”å¤´ç›”
            { id: 'EQ_091', chance: 0.003 },  // è™”è¯šå¤´å† 
            { id: 'EQ_092', chance: 0.003 },  // è¿…å½±ç½©å¸½
            { id: 'EQ_093', chance: 0.003 },  // åšå­¦è€…å¤´å† 
            { id: 'EQ_087', chance: 0.001 },  // ä¸Šå¤éª¨å¼“
            { id: 'EQ_088', chance: 0.0008 }, // é™¢é•¿ä¹‹æ–
            { id: 'EQ_089', chance: 0.0015 }, // å™¬éª¨é“é’ˆ
            { id: 'EQ_094', chance: 0.0008 },  // è«é‡Œè¥¿å¥¥çš„ç»Ÿå¾¡æŒ‡ç¯
            { id: 'EQ_003', chance: 0.02 },
            { id: 'EQ_004', chance: 0.02 },
        ]
    },
    stratholme: {
        equipment: [
            { id: 'EQ_099', chance: 0.003 },  // å‹‡æ°”æŠ¤è…¿
            { id: 'EQ_100', chance: 0.003 },  // è¿…å½±æŠ¤è…¿
            { id: 'EQ_101', chance: 0.003 },  // è™”è¯šæŠ¤è…¿
            { id: 'EQ_102', chance: 0.003 },  // åšå­¦è€…æŠ¤è…¿
            { id: 'EQ_096', chance: 0.0015 }, // çŸ¥è¯†å®å…¸
            { id: 'EQ_097', chance: 0.0015 }, // ç§˜æœ¯ä¹‹æ˜Ÿ
            { id: 'EQ_098', chance: 0.001 },  // é»‘çˆµå£«æ–—ç¯·
            { id: 'EQ_095', chance: 0.0005 },  // ç‘æ–‡æˆ´å°”ä¹‹å‰‘
            { id: 'EQ_003', chance: 0.02 },
            { id: 'EQ_004', chance: 0.02 },
        ]
    },
    upper_blackrock_spire: {
        equipment: [
            { id: 'EQ_109', chance: 0.003 },  // å‹‡æ°”èƒ¸ç”²
            { id: 'EQ_110', chance: 0.003 },  // è¿…å½±å¤–å¥—
            { id: 'EQ_111', chance: 0.003 },  // è™”è¯šé•¿è¢
            { id: 'EQ_112', chance: 0.003 },  // åšå­¦è€…é•¿è¢
            { id: 'EQ_105', chance: 0.0015 }, // çŸ³æ¥ ä¹‹ç¯
            { id: 'EQ_106', chance: 0.0015 }, // ç—›è‹¦æŒ‡ç¯
            { id: 'EQ_107', chance: 0.0015 }, // é¾™äººä¹‹ç›¾
            { id: 'EQ_108', chance: 0.001 },  // é›·å¾·ä¹‹çœ¼
            { id: 'EQ_103', chance: 0.0005 }, // æ¶é­”ä¹‹å‡»
            { id: 'EQ_104', chance: 0.0005 },  // é›·å¾·åŒåˆƒ
            { id: 'EQ_003', chance: 0.05 },
            { id: 'EQ_004', chance: 0.05 },
        ]
    },



    zul_gurub: {
        equipment: [
            { id: 'EQ_137', chance: 0.001 },  // åå™¬æŠ«é£
            { id: 'EQ_138', chance: 0.001 },  // æ›¼å¤šåŸºå°”çš„å¾½è®°
            { id: 'EQ_135', chance: 0.0015 }, // é‡‘åº¦çš„å„è¿è¢‹
            { id: 'EQ_136', chance: 0.0015 }, // å“ˆå¡è±æˆ˜åˆƒ
            { id: 'EQ_132', chance: 0.0008 }, // è¡€é¢†ä¸»åº‡æŠ¤è€…
            { id: 'EQ_133', chance: 0.0008 }, // å¨…å°”ç½—çš„æ„å¿—
            { id: 'EQ_134', chance: 0.0008 }, // é‡‘åº¦çš„å¦–å™¨
            { id: 'EQ_131', chance: 0.0005 },  // è¾›æ´›æ–¯è¯¸ç•Œçš„æ¯ç­è€…
            { id: 'EQ_125', chance: 0.001 },
            { id: 'EQ_128', chance: 0.001 },
        ],
        // âœ… æ–°å¢ï¼šç¥–å°”æ ¼æ‹‰å¸ƒåéª‘ï¼ˆä¸è¿›èƒŒåŒ…ï¼Œåªç‚¹äº®åéª‘å›¾é‰´ï¼‰
        mounts: [
            { id: 'MOUNT_RAZZASHI_RAPTOR', chance: 0.0005 }, // 0.05%
            { id: 'MOUNT_SWIFT_ZULIAN_TIGER', chance: 0.0005 }, // 0.05%
        ]
    },

    // ==================== å®‰çªæ‹‰åºŸå¢Ÿï¼ˆ60çº§ï¼‰æ‰è½ ====================
    ruins_of_ahnqiraj: {
        equipment: [
            { id: 'EQ_142', chance: 0.001 },  // æ²™æ¼ é£æš´æŠ«é£ï¼ˆå¦å…‹æŠ«é£ï¼‰
            { id: 'EQ_145', chance: 0.001 },  // å…¶æ‹‰å¸ç‹æŠ«é£ï¼ˆæ³•å¼ºæŠ«é£ï¼‰
            { id: 'EQ_140', chance: 0.001 },  // æ‹‰è´¾å…‹æ–¯çš„å¾½è®°ï¼ˆå¦å…‹æˆ’æŒ‡1ï¼‰
            { id: 'EQ_144', chance: 0.001 },  // æµæ²™å é¥°ï¼ˆé¡¹é“¾ï¼‰
            { id: 'EQ_141', chance: 0.0015 }, // ç‹‚æš´ä¸“æ³¨ä¹‹çˆªï¼ˆå‰¯æ‰‹ï¼‰
            { id: 'EQ_139', chance: 0.0008 }, // æ²™å°˜æŠ¤ç¬¦ï¼ˆé¥°å“2ï¼‰
            { id: 'EQ_143', chance: 0.0005 }, // åºŸå¢Ÿæ³•æ–ï¼ˆæ­¦å™¨ï¼‰
            { id: 'EQ_125', chance: 0.001 },
            { id: 'EQ_128', chance: 0.001 },
        ]
    },
    // ==================== ç†”ç«ä¹‹å¿ƒï¼ˆ60çº§ï¼‰æ‰è½ ====================
    molten_core: {
        equipment: [
            // åŠ›é‡ï¼ˆæˆ˜å£«ï¼‰4ä»¶å¥—
            { id: 'EQ_146', chance: 0.00025 },  // åŠ›é‡å¤´ç›”
            { id: 'EQ_147', chance: 0.00025 },  // åŠ›é‡æŠ¤è…•
            { id: 'EQ_148', chance: 0.00025 },  // åŠ›é‡è…°å¸¦
            { id: 'EQ_149', chance: 0.00025 },  // åŠ›é‡é©¬é´

            // å¤œå¹•æ€æ‰‹ï¼ˆç›—è´¼ï¼‰4ä»¶å¥—
            { id: 'EQ_150', chance: 0.00025 },  // å¤œå¹•æ€æ‰‹å¤´å·¾
            { id: 'EQ_151', chance: 0.00025 },  // å¤œå¹•æ€æ‰‹æŠ¤è…•
            { id: 'EQ_152', chance: 0.00025 },  // å¤œå¹•æ€æ‰‹è…°å¸¦
            { id: 'EQ_153', chance: 0.00025 },  // å¤œå¹•æ€æ‰‹é•¿é´

            // å¥¥æœ¯å¸ˆï¼ˆæ³•å¸ˆï¼‰4ä»¶å¥—
            { id: 'EQ_154', chance: 0.00025 },  // å¥¥æœ¯å¸ˆå¤´å† 
            { id: 'EQ_155', chance: 0.00025 },  // å¥¥æœ¯å¸ˆæŠ¤è…•
            { id: 'EQ_156', chance: 0.00025 },  // å¥¥æœ¯å¸ˆè…°å¸¦
            { id: 'EQ_157', chance: 0.00025 },  // å¥¥æœ¯å¸ˆä¾¿é‹

            // é¢„è¨€ï¼ˆç‰§å¸ˆï¼‰4ä»¶å¥—
            { id: 'EQ_158', chance: 0.00025 },  // é¢„è¨€å¤´é¥°
            { id: 'EQ_159', chance: 0.00025 },  // é¢„è¨€è‡‚ç”²
            { id: 'EQ_160', chance: 0.00025 },  // é¢„è¨€æŸå¸¦
            { id: 'EQ_161', chance: 0.00025 },  // é¢„è¨€ä¹‹é´

            // é¥°å“ / æˆ’æŒ‡ / æ­¦å™¨
            { id: 'EQ_162', chance: 0.0004 },  // ç«ç„°ç¬¦å’’ï¼ˆé­”æŠ—é¥°å“ï¼‰
            { id: 'EQ_163', chance: 0.0004 },  // æ²‰é‡çš„é»‘é“æˆ’æŒ‡ï¼ˆå¦å…‹æˆ’æŒ‡ï¼‰
            { id: 'EQ_164', chance: 0.0004 },  // æ³•æœ¯èƒ½é‡ä¹‹æˆ’ï¼ˆæ³•å¼ºæˆ’æŒ‡1ï¼‰
            { id: 'EQ_166', chance: 0.0004 },  // è¿…å‡»æˆ’æŒ‡ï¼ˆæ”»å¼ºæˆ’æŒ‡1ï¼‰

            { id: 'EQ_165', chance: 0.0004 },  // é’»å­”è™«ä¹‹ç¢Ÿï¼ˆå¦å…‹ç›¾ç‰Œï¼‰
            { id: 'EQ_170', chance: 0.0004 },  // ç†”ç«çŠ¬ç‰™ï¼ˆæ”»å¼ºå‰¯æ‰‹ï¼‰

            { id: 'EQ_167', chance: 0.00025 },   // æ®‹å¿åˆ©åˆƒï¼ˆç›—è´¼æš´å‡»çˆ†å‘æ­¦å™¨ï¼‰
            { id: 'EQ_169', chance: 0.00025 },   // ç¢§ç©ºä¹‹æ­Œï¼ˆæ³•å¼ºæ­¦å™¨ï¼‰
            { id: 'EQ_168', chance: 0.0001 },  // ç¥ˆç¦ï¼ˆæ©™ï¼‰
            { id: 'EQ_171', chance: 0.0004 },  // ä¸çŸ­æš‚èƒ½é‡æŠ¤ç¬¦
        ]
    },


};

// ==================== å¾½ç«  / è£…å¤‡æ± åˆ¤å®šï¼ˆé…ç½®åŒ– + å…æšä¸¾ï¼‰ ====================
// ç›®æ ‡ï¼šæŠ½è±¡ BADGE_EQUIP_IDS + is******Equipment çš„é‡å¤é€»è¾‘ï¼Œä¿æŒç°æœ‰é€»è¾‘ä¸å˜ï¼š
// 1) ä»ç„¶åªå…è®¸ type === 'equipment' çš„é“å…·
// 2) ä»ç„¶ä¼˜å…ˆç”¨è£…å¤‡æ¨¡æ¿ tpl.setId å‘½ä¸­ï¼ˆæœªæ¥æ‰©å±•æ›´çœäº‹ï¼‰
// 3) å½“æœªè®¾ç½® setId æ—¶ï¼Œç”¨ EQ_### çš„æ•°å€¼èŒƒå›´æ¥åˆ¤å®šï¼ˆé¿å…æšä¸¾ä¸€å † EQ_xxxï¼‰
//
// å¦‚æœªæ¥æ–°å¢å¾½ç« /åœ°å›¾ï¼šåªéœ€è¦åŠ é…ç½®ï¼Œä¸éœ€è¦å†å†™ Set / isXXX() å‡½æ•°ã€‚

// è£…å¤‡æ± é…ç½®ï¼ˆå¯å•ç‹¬æŠ½åˆ° json æ–‡ä»¶ï¼‰
// - setIds:   å…è®¸é€šè¿‡è£…å¤‡æ¨¡æ¿çš„ setId å‘½ä¸­ï¼ˆå¯å¡«å¤šä¸ªï¼Œæ–¹ä¾¿å¤ç”¨/å…¼å®¹ï¼‰
// - eqIdRanges: å…è®¸é€šè¿‡ EQ_### çš„åŒºé—´å‘½ä¸­ï¼ˆæ”¯æŒå¤šä¸ªåŒºé—´ï¼‰
const BADGE_EQUIP_POOLS = {
    scarlet_monastery: {
        setIds: ['scarlet_crusader'],
        eqIdRanges: [[49, 61]],
    },
    elwynn_westfall_redridge: {
        setIds: ['elwynn_westfall_redridge'],
        eqIdRanges: [[1, 18]],
    },
    barrens: {
        setIds: ['barrens'],
        eqIdRanges: [[19, 26]],
    },
    stranglethorn_tanaris: {
        setIds: ['stranglethorn_tanaris'],
        eqIdRanges: [[27, 32], [41, 48]], // âœ… è¦†ç›– EQ_044ï¼ˆé­ç¬è€…è‹è¨æ–¯ï¼‰
    },
    // ç´¢ç‘æ£®å¤§å¸å¾½ç« ï¼šæ²‰æ²¡çš„ç¥åº™ / é»‘çŸ³æ·±æ¸Š
    // å…¼å®¹æ—§é€»è¾‘ï¼ˆæ›¾ä½¿ç”¨ setId==='blackrock_depths'ï¼‰ï¼šè¿™é‡Œå…è®¸æœªæ¥æŠŠæ²‰æ²¡ç¥åº™è£…å¤‡ä¹Ÿæ ‡æˆ sunken_temple
    sunken_temple_blackrock_depths: {
        setIds: ['blackrock_depths', 'sunken_temple'],
        eqIdRanges: [[62, 73]],
    },
    scholomance: {
        setIds: ['scholomance'],
        eqIdRanges: [[87, 94], [113, 116]],
    },
    stratholme: {
        setIds: ['stratholme'],
        eqIdRanges: [[95, 102], [117, 120]],
    },
    upper_blackrock_spire: {
        setIds: ['upper_blackrock_spire'],
        eqIdRanges: [[103, 112], [121, 124]],
    },
    zul_gurub: {
        setIds: ['zul_gurub'],
        eqIdRanges: [[131, 138]],
    },
    ruins_of_ahnqiraj: {
        setIds: ['ruins_of_ahnqiraj'],
        eqIdRanges: [[139, 145]],
    },
    // ç«ç„°ä¹‹ç‹çš„å¾½ç« ï¼šç†”ç«ä¹‹å¿ƒï¼ˆå«BOSSæ‰è½/ä¼ å¥‡ï¼‰
    molten_core: {
        // å…¼å®¹æœªæ¥æ‰©å±•ï¼šä¼˜å…ˆé€šè¿‡ setId å‘½ä¸­ï¼ˆT1/T2ï¼‰
        setIds: ['might_set', 'nightslayer_set', 'arcanist_set', 'prophecy_set', 'wrath_set', 'bloodfang_set', 'netherwind_set', 'transcendence_set'],
        // ç†”ç«ä¹‹å¿ƒç›¸å…³è£…å¤‡ ID èŒƒå›´ï¼ˆè¦†ç›–ï¼šåœ°å›¾æ‰è½ + Bossæ‰è½ + é£å‰‘/æ©™é”¤ç­‰ä¼ å¥‡ï¼‰
        eqIdRanges: [[146, 201]],
    },
};

// æŠŠ 'EQ_001' -> 1ï¼›ä¸ç¬¦åˆæ ¼å¼è¿”å› null
function parseEqTemplateNumber(eqId) {
    if (typeof eqId !== 'string') return null;
    const m = /^EQ_(\d+)$/.exec(eqId);
    if (!m) return null;
    const n = Number(m[1]);
    return Number.isFinite(n) ? n : null;
}

function normalizeRanges(ranges) {
    if (!Array.isArray(ranges)) return [];
    return ranges
        .filter(r => Array.isArray(r) && r.length >= 2)
        .map(([a, b]) => {
            const min = Number(a);
            const max = Number(b);
            if (!Number.isFinite(min) || !Number.isFinite(max)) return null;
            return min <= max ? [min, max] : [max, min];
        })
        .filter(Boolean);
}

/**
 * ç”Ÿæˆâ€œè£…å¤‡æ˜¯å¦å±äºæŸä¸ªè£…å¤‡æ± â€çš„åˆ¤å®šå‡½æ•°ã€‚
 * æ³¨æ„ï¼šè¿™é‡Œä¸ä¼šåœ¨åˆ›å»ºæ—¶è¯»å– FIXED_EQUIPMENTSï¼ˆé¿å…åˆå§‹åŒ–é¡ºåºé—®é¢˜ï¼‰ï¼Œåªä¼šåœ¨çœŸæ­£åˆ¤å®šæ—¶è¯»å–ã€‚
 */
function makeBadgeEquipPredicate(poolKey) {
    const pool = BADGE_EQUIP_POOLS?.[poolKey] || {};
    const setIdSet = new Set((pool.setIds || []).filter(Boolean));
    const ranges = normalizeRanges(pool.eqIdRanges);

    return (eq) => {
        if (!eq || eq.type !== 'equipment') return false;

        const tpl = FIXED_EQUIPMENTS?.[eq.id];
        if (tpl?.setId && setIdSet.has(tpl.setId)) return true;

        const n = parseEqTemplateNumber(eq.id);
        if (n == null) return false;

        for (const [min, max] of ranges) {
            if (n >= min && n <= max) return true;
        }
        return false;
    };
}

// ==================== å¾½ç« å‡çº§è§„åˆ™ï¼ˆé…ç½®é©±åŠ¨ï¼‰ ====================
// ä»¥åæ–°å¢ Boss å¾½ç« ï¼šåªéœ€è¦åœ¨ BADGE_UPGRADE_RULES_CONFIG é‡ŒåŠ ä¸€æ¡é…ç½®ï¼›æ— éœ€æ–°å¢ isXXX() å‡½æ•°ã€‚
const BADGE_UPGRADE_RULES_CONFIG = {
    IT_SCARLET_CRUSADER_BADGE: {
        title: 'è¡€è‰²åå­—å†›çš„å¾½ç« ',
        zoneLabel: 'è¡€è‰²ä¿®é“é™¢',
        inc: 2,
        cap: 100,
        equipPool: 'scarlet_monastery',
        theme: { border: '#c62828', title: '#ff6b6b', shadow: 'rgba(198,40,40,0.25)' }
    },
    IT_HOGGER_BADGE: {
        title: 'éœæ ¼çš„æ²¾è¡€å¾½ç« ',
        zoneLabel: 'è‰¾å°”æ–‡æ£®æ— / è¥¿éƒ¨è’é‡ / èµ¤è„Šå±±',
        inc: 2,
        cap: 100,
        equipPool: 'elwynn_westfall_redridge',
        theme: { border: '#8d6e63', title: '#ffd700', shadow: 'rgba(141,110,99,0.25)' }
    },
    IT_VANCLEEF_BADGE: {
        title: 'è¿ªè²äºšå¾½ç« ',
        zoneLabel: 'è´«ç˜ ä¹‹åœ°',
        inc: 2,
        cap: 100,
        equipPool: 'barrens',
        theme: { border: '#263238', title: '#90caf9', shadow: 'rgba(38,50,56,0.25)' }
    },
    IT_PRESTOR_BADGE: {
        title: 'é»‘é¾™åŒ–èº«å¾½ç« ',
        zoneLabel: 'è†æ£˜è°· / å¡”çº³åˆ©æ–¯',
        inc: 2,
        cap: 100,
        equipPool: 'stranglethorn_tanaris',
        theme: { border: '#2b2d42', title: '#b388ff', shadow: 'rgba(179,136,255,0.22)' }
    },
    IT_THAURISSAN_BADGE: {
        title: 'ç´¢ç‘æ£®å¤§å¸çš„å¾½ç« ',
        zoneLabel: 'æ²‰æ²¡çš„ç¥åº™ / é»‘çŸ³æ·±æ¸Š',
        inc: 2,
        cap: 100,
        equipPool: 'sunken_temple_blackrock_depths',
        theme: { border: '#c62828', title: '#ff6b6b', shadow: 'rgba(198,40,40,0.25)' }
    },
    IT_GANDLING_BADGE: {
        title: 'åŠ ä¸çš„å¾½ç« ',
        zoneLabel: 'é€šçµå­¦é™¢',
        inc: 2,
        cap: 100,
        equipPool: 'scholomance',
        theme: { border: '#4a148c', title: '#ce93d8', shadow: 'rgba(74,20,140,0.25)' }
    },
    IT_RIVENDARE_BADGE: {
        title: 'ç‘æ–‡æˆ´å°”ç”·çˆµçš„å¾½ç« ',
        zoneLabel: 'æ–¯å¦ç´¢å§†',
        inc: 2,
        cap: 100,
        equipPool: 'stratholme',
        theme: { border: '#263238', title: '#b388ff', shadow: 'rgba(38,50,56,0.25)' }
    },
    IT_REND_BADGE: {
        title: 'é›·å¾·é»‘æ‰‹çš„å¾½ç« ',
        zoneLabel: 'é»‘çŸ³å¡”ä¸Š',
        inc: 2,
        cap: 100,
        equipPool: 'upper_blackrock_spire',
        theme: { border: '#4e342e', title: '#ffab91', shadow: 'rgba(78,52,46,0.25)' }
    },
    IT_HAKKAR_BADGE: {
        title: 'å¤ºçµè€…çš„å¾½ç« ',
        zoneLabel: 'ç¥–å°”æ ¼æ‹‰å¸ƒ',
        inc: 2,
        cap: 100,
        equipPool: 'zul_gurub',
        theme: { border: '#4a148c', title: '#4CAF50', shadow: 'rgba(78,52,46,0.25)' }
    },
    IT_OSSIRIAN_BADGE: {
        title: 'æ— ç–¤è€…çš„å¾½ç« ',
        zoneLabel: 'å®‰çªæ‹‰åºŸå¢Ÿ',
        inc: 2,
        cap: 100,
        equipPool: 'ruins_of_ahnqiraj',
        theme: { border: '#b08900', title: '#ffd54f', shadow: 'rgba(176,137,0,0.25)' }
    },

    // âœ… æ–°å¢ï¼šå›¢é˜Ÿé¦–é¢† - ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯å¾½ç« 
    IT_RAGNAROS_BADGE: {
        title: 'ç«ç„°ä¹‹ç‹çš„å¾½ç« ',
        zoneLabel: 'ç†”ç«ä¹‹å¿ƒ / ç†”ç«ä¹‹å¿ƒBOSSæ‰è½',
        inc: 2,
        cap: 100,
        equipPool: 'molten_core',
        theme: { border: '#ff6f00', title: '#ffcc80', shadow: 'rgba(255,111,0,0.28)' }
    },

};

// ç”Ÿæˆæœ€ç»ˆè¿è¡Œæ—¶è§„åˆ™å¯¹è±¡ï¼ˆä¿æŒç°æœ‰ä»£ç çš„è®¿é—®æ–¹å¼ä¸å˜ï¼šBADGE_UPGRADE_RULES[badgeId].isEligible(eq)ï¼‰
const BADGE_UPGRADE_RULES = Object.fromEntries(
    Object.entries(BADGE_UPGRADE_RULES_CONFIG).map(([badgeId, cfg]) => [
        badgeId,
        {
            badgeId,
            ...cfg,
            isEligible: makeBadgeEquipPredicate(cfg.equipPool),
        }
    ])
);

const FIXED_EQUIPMENTS = {
    EQ_001: {
        id: 'EQ_001',
        name: 'åˆå¿ƒè€…çš„ç›¾ç‰Œ',
        icon: "icons/wow/vanilla/armor/INV_Shield_09.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'green',

        setId: 'beginner_set',
        setName: 'åˆå¿ƒè€…å¥—è£…',

        level: 8,
        maxLevel: 100,
        baseStats: {
            armor: 10,
            blockValue: 20,
            blockRate: 5
        },
        growth: {
            armor: 2,
            blockValue: 2,
            blockRate: 2
        }
    },
    EQ_002: {
        id: 'EQ_002',
        name: 'åˆå¿ƒè€…çš„å°åˆ€',
        icon: "icons/wow/vanilla/weapons/INV_Sword_12.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'green',

        setId: 'beginner_set',
        setName: 'åˆå¿ƒè€…å¥—è£…',

        level: 8,
        maxLevel: 100,
        baseStats: {
            attack: 20,
            critRate: 3,
            critDamage: 0.10
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_003: {
        id: 'EQ_003',
        name: 'ç¥ç§˜æ£®æ—åŠå ',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Necklace_11.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',

        setId: 'secret_set',
        setName: 'ç¥ç§˜å¥—è£…',

        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            versatility: 10
        },
        growth: {
            hp: 2,
            versatility: 2
        }
    },
    EQ_004: {
        id: 'EQ_004',
        name: 'ç¥ç§˜æ£®æ—æˆ’æŒ‡',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_12.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'blue',

        setId: 'secret_set',
        setName: 'ç¥ç§˜å¥—è£…',

        level: 1,
        maxLevel: 100,
        baseStats: {
            mp: 100,
            versatility: 10
        },
        growth: {
            mp: 2,
            versatility: 2
        }
    },
    EQ_005: {
        id: 'EQ_005',
        name: 'åˆå¿ƒè€…çš„æ‹æ–',
        icon: "icons/wow/vanilla/weapons/INV_Staff_02.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'green',

        setId: 'beginner_set',
        setName: 'åˆå¿ƒè€…å¥—è£…',

        level: 8,
        maxLevel: 100,
        baseStats: {
            spellPower: 30
        },
        growth: {
            spellPower: 2
        }
    },
    REBIRTH_INVITATION: {
        id: 'REBIRTH_INVITATION',
        name: 'ç ´ç¢æ—¶ç©ºçš„é‚€è¯·å‡½',
        type: 'consumable',
        rarity: 'purple',
        icon: 'icons/wow/vanilla/items/INV_Misc_Note_04.png',
        canUse: true,
        description: 'ä½¿ç”¨åè§£é”é‡ç”Ÿè½®å›'
    }
    ,
    EQ_006: {
        id: 'EQ_006',
        name: 'æ—…è¡Œè€…çš„å¤´ç›”',
        icon: 'icons/wow/vanilla/armor/INV_Helmet_16.png',
        type: 'equipment',
        slot: 'head',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 150,
            armor: 30
        },
        growth: {
            hp: 2,
            armor: 2
        }
    },
    EQ_007: {
        id: 'EQ_007',
        name: 'æ—…è¡Œè€…çš„æŠ¤è‚©',
        icon: 'icons/wow/vanilla/armor/INV_Shoulder_08.png',
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 120,
            armor: 25,
            spellPower: 15
        },
        growth: {
            hp: 2,
            armor: 2,
            spellPower: 2
        }
    },
    EQ_008: {
        id: 'EQ_008',
        name: 'æ—…è¡Œè€…çš„èƒ¸ç”²',
        icon: 'icons/wow/vanilla/armor/INV_Shirt_01.png',
        type: 'equipment',
        slot: 'chest',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 20
        },
        growth: {
            hp: 2,
            armor: 2
        }
    },
    EQ_009: {
        id: 'EQ_009',
        name: 'æ—…è¡Œè€…çš„æŠ¤è…•',
        icon: 'icons/wow/vanilla/armor/INV_Bracer_11.png',
        type: 'equipment',
        slot: 'wrist',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 100,
            armor: 20,
            attack: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            attack: 2
        }
    },
    EQ_010: {
        id: 'EQ_010',
        name: 'æ—…è¡Œè€…çš„æ‰‹å¥—',
        icon: 'icons/wow/vanilla/armor/INV_Gauntlets_05.png',
        type: 'equipment',
        slot: 'hands',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 120,
            armor: 10,
            attack: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            attack: 2
        }
    },
    EQ_011: {
        id: 'EQ_011',
        name: 'æ—…è¡Œè€…çš„æŠ¤è…¿',
        icon: 'icons/wow/vanilla/armor/INV_Pants_01.png',
        type: 'equipment',
        slot: 'legs',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 20,
            spellPower: 15
        },
        growth: {
            hp: 2,
            armor: 2,
            spellPower: 2
        }
    },
    EQ_012: {
        id: 'EQ_012',
        name: 'æ—…è¡Œè€…çš„å¸ƒé´',
        icon: 'icons/wow/vanilla/armor/INV_Boots_05.png',
        type: 'equipment',
        slot: 'feet',
        rarity: 'green',

        setId: 'traveler_set',
        setName: 'æ—…è¡Œè€…å¥—è£…',

        level: 2,
        maxLevel: 100,
        baseStats: {
            hp: 150,
            armor: 30
        },
        growth: {
            hp: 2,
            armor: 2
        }
    },
    EQ_013: {
        id: 'EQ_013',
        name: 'ç¥ç§˜å±±è„‰æˆ’æŒ‡',
        icon: 'icons/wow/vanilla/armor/INV_Jewelry_Ring_31.png',
        type: 'equipment',
        slot: 'ring2',
        rarity: 'blue',

        level: 1,
        maxLevel: 100,
        baseStats: {
            mastery: 10
        },
        growth: {
            mastery: 2
        }
    },EQ_014: {
        id: 'EQ_014',
        name: 'å±±è„‰å«å£«ä¹‹åˆº',
        icon: 'icons/wow/vanilla/weapons/INV_Sword_12.png',
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'green',
        level: 1,
        maxLevel: 100,
        baseStats: {
            attack: 120,
            versatility: 10,
            mastery: 10
        },
        growth: {
            attack: 2,
            versatility: 2,
            mastery: 2
        }
    },
    EQ_015: {
        id: 'EQ_015',
        name: 'å±±è„‰å«å£«ä¹‹å™¬',
        icon: 'icons/wow/vanilla/weapons/INV_Staff_06.png',
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'green',
        level: 1,
        maxLevel: 100,
        baseStats: {
            spellPower: 180,
            versatility: 10,
            mastery: 10
        },
        growth: {
            spellPower: 2,
            versatility: 2,
            mastery: 2
        }
    },
    EQ_016: {
        id: 'EQ_016',
        name: 'å±±è„‰å«å£«ä¹‹ç›¾',
        icon: 'icons/wow/vanilla/armor/INV_Shield_13.png',
        type: 'equipment',
        slot: 'offHand',
        rarity: 'green',
        level: 1,
        maxLevel: 100,
        baseStats: {
            blockRate: 15,
            blockValue: 80,
            mastery: 10
        },
        growth: {
            blockRate: 2,
            blockValue: 2,
            mastery: 2
        }
    },
    EQ_017: {
        id: 'EQ_017',
        name: 'å±±è„‰å«å£«é­”å…¸',
        icon: 'icons/wow/vanilla/items/INV_Misc_Orb_02.png',
        type: 'equipment',
        slot: 'offHand',
        rarity: 'green',
        level: 1,
        maxLevel: 100,
        baseStats: {
            spellPower: 100,
            versatility: 10,
            mastery: 20
        },
        growth: {
            spellPower: 2,
            versatility: 2,
            mastery: 2
        }
    },
    EQ_018: {
        id: 'EQ_018',
        name: 'å±±è„‰å«å£«ä¹‹å¿ƒ',
        icon: 'icons/wow/vanilla/trade/INV_Stone_01.png',
        type: 'equipment',
        slot: 'trinket1',
        rarity: 'blue',
        level: 1,
        maxLevel: 100,
        baseStats: {
            spellPower: 120,
            attack: 80,
            mastery: 10,
            versatility: 10
        },
        growth: {
            spellPower: 2,
            attack: 2,
            mastery: 2,
            versatility: 2
        }
    },EQ_019: {
        id: 'EQ_019',
        name: 'å°–ç‰™æ‰‹å¥—',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_18.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'green',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 30,
            critRate: 2,
            critDamage: 0.10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_020: {
        id: 'EQ_020',
        name: 'å°–ç‰™æŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_02.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 300,
            armor: 40,
            critRate: 3,
            critDamage: 0.10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_021: {
        id: 'EQ_021',
        name: 'å°–ç‰™é“ ç”²',
        icon: "icons/wow/vanilla/armor/INV_Chest_Leather_08.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 300,
            armor: 40,
            critRate: 3,
            critDamage: 0.10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_022: {
        id: 'EQ_022',
        name: 'å°–ç‰™è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_10.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'green',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 30,
            critRate: 2,
            critDamage: 0.10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_023: {
        id: 'EQ_023',
        name: 'å°–ç‰™è¶³å«',
        icon: "icons/wow/vanilla/armor/INV_Boots_05.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'green',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 250,
            armor: 30,
            critRate: 2,
            critDamage: 0.10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_024: {
        id: 'EQ_024',
        name: 'æ¯’è›‡',
        icon: "icons/wow/vanilla/weapons/INV_Weapon_Bow_10.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        setId: 'venom_embrace',
        setName: 'æ¯’è›‡çš„æ‹¥æŠ±',
        level: 1,
        maxLevel: 100,
        baseStats: {
            attack: 250,
            critRate: 20,
            critDamage: 0.5,  // 50% é¢å¤–æš´å‡»ä¼¤å®³
            versatility: 5
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2,
            versatility: 2
        }
    },
    EQ_025: {
        id: 'EQ_025',
        name: 'ç”Ÿå‘½ä¹‹æ ¹',
        icon: "icons/wow/vanilla/weapons/INV_Staff_26.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 1,
        maxLevel: 100,
        baseStats: {
            spellPower: 200,
            hp: 300,
            versatility: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            versatility: 2
        }
    },
    EQ_026: {
        id: 'EQ_026',
        name: 'å…‹é›·ä»€ä¹‹èƒŒ',
        icon: "icons/wow/vanilla/armor/INV_Shield_18.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 1,
        maxLevel: 100,
        baseStats: {
            blockRate: 20,
            blockValue: 100,
            hp: 400
        },
        growth: {
            blockRate: 2,
            blockValue: 2,
            hp: 2
        }
    },
    EQ_027: {
        id: 'EQ_027',
        name: 'é”ˆæ°´å¤´ç›”',
        icon: "icons/wow/vanilla/armor/INV_Helmet_20.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'green',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 300,
            armor: 40,
            haste: 5,
            mastery: 5
        },
        growth: {
            hp: 2,
            armor: 2,
            haste: 2,
            mastery: 2
        }
    },

    EQ_028: {
        id: 'EQ_028',
        name: 'é”ˆæ°´æŠ¤è‚©',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_06.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'green',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 220,
            armor: 35,
            haste: 5,
            mastery: 5
        },
        growth: {
            hp: 2,
            armor: 2,
            haste: 2,
            mastery: 2
        }
    },

    EQ_029: {
        id: 'EQ_029',
        name: 'é”ˆæ°´æŠ¤è…•',
        icon: "icons/wow/vanilla/armor/INV_Bracer_03.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'green',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 30,
            haste: 5,
            mastery: 5
        },
        growth: {
            hp: 2,
            armor: 2,
            haste: 2,
            mastery: 2
        }
    },
    EQ_030: {
        id: 'EQ_030',
        name: 'ä¹”ä¸¹æ³•æ–',
        icon: "icons/wow/vanilla/weapons/INV_Wand_06.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            mastery: 10,
            haste: 10,
            versatility: 10,
            critRate: 10
        },
        growth: {
            spellPower: 2,
            mastery: 2,
            haste: 2,
            versatility: 2,
            critRate: 2
        }
    },
    EQ_031: {
        id: 'EQ_031',
        name: 'çŸ­æš‚èƒ½é‡æŠ¤ç¬¦',
        icon: "icons/wow/vanilla/items/INV_Misc_StoneTablet_11.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 150
        },
        growth: {
            spellPower: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [0, 4],
            spellPowerBonus: 600,
            bonus:{spellPower:600}
        }
    },
    EQ_032: {
        id: 'EQ_032',
        name: 'å¼ºæ”»æŠ¤ç¬¦',
        icon: "icons/wow/vanilla/items/INV_Misc_Head_Troll_01.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 150
        },
        growth: {
            attack: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [0, 4],
            attackBonus: 600
        }
    },
    IT_BLACK_DRAGON_PROOF: {
        id: 'IT_BLACK_DRAGON_PROOF',
        name: 'é»‘é¾™åŒ–èº«çš„è¯æ˜',
        icon: "icons/wow/vanilla/items/INV_Misc_Head_Dragon_01.png",
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        description: 'ä½¿ç”¨åï¼Œæ­éœ²çœŸç›¸ï¼Œè§£é”éšè—Bossã€æ™®ç‘æ–¯æ‰˜å¥³å£«ã€‘'
    },
    EQ_033: {
        id: 'EQ_033',
        name: 'å¤©é€‰è€…å°è®°',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Talisman_08.png",
        type: 'equipment',
        slot: 'trinket1',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            versatility: 10,
            haste: 10,
            mastery: 10,
            critRate: 10
        },
        growth: {
            hp: 2,
            versatility: 2,
            haste: 2,
            mastery: 2,
            critRate: 2
        }
    },
    EQ_034: {
        id: 'EQ_034',
        name: 'ç—›å‡»ä¹‹åˆƒ',
        icon: "icons/wow/vanilla/weapons/INV_Sword_36.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 350,
            critRate: 15,
            critDamage: 0.40
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_035: {
        id: 'EQ_035',
        name: 'çƒ­æƒ…æš—å½±å é¥°',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Necklace_07.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'green',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 200,
            hp: 500
        },
        growth: {
            spellPower: 2,
            hp: 2
        }
    },
    EQ_036: {
        id: 'EQ_036',
        name: 'è±ç‘Ÿå¾·æ–¯ä¹‹çœ¼',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_08.png",
        type: 'equipment',
        slot: 'ring2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 200,
            hp: 300,
            critRate: 5
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2
        }
    },
    EQ_037: {
        id: 'EQ_037',
        name: 'å‘æ˜å®¶çš„èšç„¦å‰‘',
        icon: "icons/wow/vanilla/weapons/INV_Sword_14.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            critRate: 15,
            critDamage: 0.40
        },
        growth: {
            spellPower: 2,
            critRate: 2,
            critDamage: 2
        }
    },
    EQ_038: {
        id: 'EQ_038',
        name: 'å…ƒç´ çŸ³è„ŠæŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_04.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 400,
            armor: 50,
            blockRate: 5
        },
        growth: {
            hp: 2,
            armor: 2,
            blockRate: 2
        }
    },
    EQ_039: {
        id: 'EQ_039',
        name: 'é»‘çŸ³æˆ’æŒ‡',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_17.png",
        type: 'equipment',
        slot: 'ring2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 200,
            hp: 300,
            armor: 50,
            versatility: 5
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            versatility: 2
        }
    },
    EQ_040: {
        id: 'EQ_040',
        name: 'å‰å…¹æ´›å…‹çš„é«˜ç§‘æŠ€åœ†ç›¾',
        icon: "icons/wow/vanilla/armor/INV_Shield_10.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 600,
            armor: 100,
            blockRate: 20,
            blockValue: 200
        },
        growth: {
            hp: 2,
            armor: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_041: {
        id: 'EQ_041',
        name: 'åå‡»è€…æ¡‘è¨æ–¯',
        icon: "icons/wow/vanilla/weapons/INV_Sword_45.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 500,
            versatility: 20,
            haste: 20
        },
        growth: {
            attack: 2,
            versatility: 2,
            haste: 2
        }
    },
    EQ_042: {
        id: 'EQ_042',
        name: 'ä¿æŠ¤è€…åŠ è¨æ–¯',
        icon: "icons/wow/vanilla/weapons/INV_Sword_43.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 500,
            mastery: 20,
            critRate: 20
        },
        growth: {
            attack: 2,
            mastery: 2,
            critRate: 2
        }
    },
    EQ_043: {
        id: 'EQ_043',
        name: 'ç¥–ç©†æ‹‰æ©çš„èƒ½é‡æ³•æ–',
        icon: "icons/wow/vanilla/weapons/INV_Staff_10.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 550,
            critRate: 15,
            mastery: 15
        },
        growth: {
            spellPower: 2,
            critRate: 2,
            mastery: 2
        }
    },
    EQ_044: {
        id: 'EQ_044',
        name: 'é­ç¬è€…è‹è¨æ–¯',
        icon: "icons/wow/vanilla/weapons/INV_Sword_40.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'orange',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1200,
            mastery: 10,
            haste: 10,
            versatility: 10
        },
        growth: {
            attack: 2,
            mastery: 2,
            haste: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'basic_attack_repeat',
            chance: 0.5
        },
        synth: { from: ['EQ_041', 'EQ_042'], requireLevel: 100 }
    },
    EQ_045: {
        id: 'EQ_045',
        name: 'å¤§åè›‹é¢å…·',
        icon: "icons/wow/vanilla/items/INV_Banner_01.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 100,
            hp: 300,
            armor: 50,
            versatility: 5
        },
        growth: {
            spellPower: 2,
            hp: 2,
            armor: 2,
            versatility: 2
        }
    },
    EQ_046: {
        id: 'EQ_046',
        name: 'ç‹‚ä¹±è€…çš„æ‹¥æŠ±',
        icon: "icons/wow/vanilla/abilities/Ability_Mount_WhiteDireWolf.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 100,
            hp: 400,
            armor: 50,
            critRate: 5
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2
        }
    },
    EQ_047: {
        id: 'EQ_047',
        name: 'å¤§åè›‹è‚©ç”²',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_01.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 300,
            armor: 50,
            versatility: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            versatility: 2
        }
    },
    EQ_048: {
        id: 'EQ_048',
        name: 'é—ªäº®è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_22.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'green',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 300,
            armor: 40,
            versatility: 5
        },
        growth: {
            hp: 2,
            armor: 2,
            versatility: 2
        }
    },
    // ==================== è¡€è‰²ä¿®é“é™¢è£…å¤‡ ====================
    EQ_049: {
        id: 'EQ_049',
        name: 'è¡€è‰²åå­—å†›è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_16.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'green',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            armor: 50,
            versatility: 10,
            blockRate: 2
        },
        growth: {
            hp: 2,
            armor: 2,
            versatility: 2,
            blockRate: 2
        }
    },
    EQ_050: {
        id: 'EQ_050',
        name: 'è¡€è‰²åå­—å†›æŠ¤èƒ¸',
        icon: "icons/wow/vanilla/armor/INV_Chest_Chain_16.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 600,
            armor: 80,
            mastery: 10,
            blockRate: 3
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2
        }
    },
    EQ_051: {
        id: 'EQ_051',
        name: 'è¡€è‰²åå­—å†›æŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_06.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 600,
            armor: 80,
            mastery: 10,
            versatility: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_052: {
        id: 'EQ_052',
        name: 'è¡€è‰²åå­—å†›æŠ¤æ‰‹',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_26.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'green',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            armor: 50,
            mastery: 10,
            blockRate: 2
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2
        }
    },
    EQ_053: {
        id: 'EQ_053',
        name: 'è¡€è‰²åå­—å†›æˆ˜é´',
        icon: "icons/wow/vanilla/armor/INV_Boots_02.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'blue',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            armor: 50,
            versatility: 10,
            blockRate: 3
        },
        growth: {
            hp: 2,
            armor: 2,
            versatility: 2,
            blockRate: 2
        }
    },
    EQ_054: {
        id: 'EQ_054',
        name: 'è¡€è‰²åå­—å†›è…•ç”²',
        icon: "icons/wow/vanilla/armor/INV_Bracer_16.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'blue',
        setId: 'scarlet_crusader',
        setName: 'è¡€è‰²åå­—å†›',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            armor: 50,
            mastery: 10,
            blockValue: 50
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockValue: 2
        }
    },
    EQ_055: {
        id: 'EQ_055',
        name: 'èµ«æ´›å¾·çš„è‚©é“ ',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_25.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            armor: 50,
            critRate: 5,
            haste: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            critRate: 2,
            haste: 2
        }
    },
    EQ_056: {
        id: 'EQ_056',
        name: 'åœ£ä½¿æŠ¤ç¬¦',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Amulet_01.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 800,
            mastery: 10,
            versatility: 10,
            spellPower: 300
        },
        growth: {
            hp: 2,
            mastery: 2,
            versatility: 2,
            spellPower: 2
        }
    },
    EQ_057: {
        id: 'EQ_057',
        name: 'ç ´åè€…',
        icon: "icons/wow/vanilla/weapons/INV_Axe_11.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 750,
            critRate: 20,
            versatility: 10,
            critDamage: 0.5
        },
        growth: {
            attack: 2,
            critRate: 2,
            versatility: 2,
            critDamage: 2
        },
        specialEffect: {
            type: 'proc_stat',
            trigger: 'turn_start',
            chance: 0.20,
            stats: { attack: 500 },
            scaleWithLevel: true
        }

    },

    EQ_058: {
        id: 'EQ_058',
        name: 'å…¬æ­£ä¹‹æ‰‹',
        icon: "icons/wow/vanilla/weapons/INV_Mace_14.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 800,
            spellPower: 650,
            mastery: 20,
            versatility: 10
        },
        growth: {
            hp: 2,
            spellPower: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_059: {
        id: 'EQ_059',
        name: 'è¡€è‰²æŒ‡æŒ¥å®˜ä¹‹ç›¾',
        icon: "icons/wow/vanilla/armor/INV_Shield_06.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1000,
            armor: 120,
            mastery: 20,
            blockRate: 20,
            blockValue: 300
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_060: {
        id: 'EQ_060',
        name: 'å¹»å½±æ³•æ–',
        icon: "icons/wow/vanilla/weapons/INV_Staff_13.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 750,
            critRate: 10,
            versatility: 20,
            haste: 20
        },
        growth: {
            spellPower: 2,
            critRate: 2,
            versatility: 2,
            haste: 2
        },
        specialEffect: {
            type: 'proc_stat',
            trigger: 'turn_start',
            chance: 0.20,
            stats: { spellPower: 500 },
            scaleWithLevel: true
        }
    },
    EQ_061: {
        id: 'EQ_061',
        name: 'é—å¿˜å…ˆçŸ¥å®ç ',
        icon: "icons/wow/vanilla/items/INV_Misc_Orb_02.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 500,
            mastery: 10,
            versatility: 10,
            haste: 10
        },
        growth: {
            spellPower: 2,
            mastery: 2,
            versatility: 2,
            haste: 2
        }
    },
    EQ_062: {
        id: 'EQ_062',
        name: 'æ­£ä¹‰ä¹‹æ‰‹',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Talisman_01.png",
        type: 'equipment',
        slot: 'trinket1',
        rarity: 'blue',

        level: 0,
        maxLevel: 100,

        baseStats: {
            attack: 350,
            haste: 10
        },
        growth: {
            attack: 2,
            haste: 2
        },

        specialEffect: {
            type: 'basic_attack_repeat',
            chance: 0.20
        }
    },
    EQ_063: {
        id: 'EQ_063',
        name: 'è¡€èš€ä¹‹åˆƒ',
        icon: "icons/wow/vanilla/weapons/INV_Weapon_ShortBlade_15.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',

        level: 0,
        maxLevel: 100,

        baseStats: {
            attack: 800,
            haste: 20,
            mastery: 20
        },
        growth: {
            attack: 2,
            haste: 2,
            mastery: 2
        },

        specialEffect: {
            type: 'basic_attack_repeat',
            chance: 0.20
        }
    },
    // ==================== æ²‰é»˜çš„ç¥åº™è£…å¤‡ ====================
    EQ_064: {
        id: 'EQ_064',
        name: 'æ„å¿—ä¹‹åŠ›',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Talisman_07.png",
        type: 'equipment',
        slot: 'trinket1',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1000,
            mastery: 10,
            blockRate: 5,
            blockValue: 300
        },
        growth: {
            hp: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_065: {
        id: 'EQ_065',
        name: 'è‡³é«˜å¾½è®°ä¹‹ç›¾',
        icon: "icons/wow/vanilla/armor/INV_Shield_15.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1200,
            armor: 150,
            blockRate: 25,
            blockValue: 400,
            mastery: 15
        },
        growth: {
            hp: 2,
            armor: 2,
            blockRate: 2,
            blockValue: 2,
            mastery: 2
        }
    },
    EQ_066: {
        id: 'EQ_066',
        name: 'æˆ˜å£«çš„æ‹¥æŠ±',
        icon: "icons/wow/vanilla/armor/INV_Chest_Chain_15.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setName: 'æ‹¥æŠ±å¥—è£…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1000,
            armor: 120,
            attack: 200,
            versatility: 10,
            critRate: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            attack: 2,
            versatility: 2,
            critRate: 2
        }
    },
    EQ_067: {
        id: 'EQ_067',
        name: 'é£è›‡çš„æ‹¥æŠ±',
        icon: "icons/wow/vanilla/armor/INV_Chest_Leather_09.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'embrace_set',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 800,
            armor: 80,
            spellPower: 300,
            haste: 15,
            critRate: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            spellPower: 2,
            haste: 2,
            critRate: 2
        }
    },
    EQ_068: {
        id: 'EQ_068',
        name: 'é˜¿å¡”è±é¢„è¨€è€…æ³•è¡£',
        icon: "icons/wow/vanilla/armor/INV_Chest_Cloth_43.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 600,
            spellPower: 400,
            mastery: 20
        },
        growth: {
            hp: 2,
            spellPower: 2,
            mastery: 20
        }
    },
    EQ_069: {
        id: 'EQ_069',
        name: 'é¾™ä¹‹å¬å”¤',
        icon: "icons/wow/vanilla/weapons/INV_Sword_39.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 800,
            versatility: 60
        },
        growth: {
            attack: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'map_slayer',
            bonusDamageVsMap: 0.1  // åœ°å›¾æˆ˜æ–—+10%ä¼¤å®³
        },
    },
    EQ_070: {
        id: 'EQ_070',
        name: 'ä¼Šå…°å°¼åº“æ–¯ä¹‹è§’',
        icon: "icons/wow/vanilla/armor/INV_Helmet_08.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1000,
            armor: 100,
            mastery: 20
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2
        }
    },
    EQ_071: {
        id: 'EQ_071',
        name: 'å·¨é¾™ä¹‹çœ¼',
        icon: "icons/wow/vanilla/items/INV_Misc_Eye_01.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 400,
            haste: 10
        },
        growth: {
            spellPower: 2,
            haste: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [1, 2],
            spellPowerBonus: 500
        }
    },
    EQ_072: {
        id: 'EQ_072',
        name: 'ä¼Šå…°å°¼åº“æ–¯çš„ç²¾å',
        icon: "icons/wow/vanilla/spells/Spell_Nature_AbolishMagic.png",
        type: 'equipment',
        slot: 'trinket1',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1500,
            mastery: 10,
            versatility: 30,
        },
        growth: {
            hp: 2,
            mastery: 2,
            versatility: 2,
        }
    },
    EQ_073: {
        id: 'EQ_073',
        name: 'å“ˆå¡çš„æ¯’ç‰™',
        icon: "icons/wow/vanilla/weapons/INV_Weapon_ShortBlade_25.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 600,
            haste: 25,
            mastery : 25,
        },
        growth: {
            spellPower: 2,
            haste: 2,
            mastery : 2,

        }
    },

    // ==================== é»‘çŸ³å¡”ä¸‹ï¼ˆ55çº§ï¼‰è£…å¤‡ ====================
    EQ_074: {
        id: 'EQ_074',
        name: 'å‹‡æ°”è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_34.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 900,
            armor: 120,
            mastery: 15,
            blockRate: 3,
            blockValue: 150
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_075: {
        id: 'EQ_075',
        name: 'è¿…å½±è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_03.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 300,
            hp: 450,
            armor: 70,
            critRate: 10,
            haste: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            haste: 2
        }
    },
    EQ_076: {
        id: 'EQ_076',
        name: 'è™”è¯šè…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_10.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 300,
            hp: 650,
            mastery: 15,
            versatility: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_077: {
        id: 'EQ_077',
        name: 'åšå­¦è€…è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_08.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 500,
            haste: 20,
            critRate: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            haste: 2,
            critRate: 2
        }
    },
    EQ_078: {
        id: 'EQ_078',
        name: 'å‹‡æ°”æŠ¤æ‰‹',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_26.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 850,
            armor: 110,
            mastery: 20,
            blockRate: 3,
            blockValue: 150
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_079: {
        id: 'EQ_079',
        name: 'è¿…å½±æ‰‹å¥—',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_24.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 350,
            hp: 450,
            armor: 70,
            critRate: 10,
            mastery: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            mastery: 2
        }
    },
    EQ_080: {
        id: 'EQ_080',
        name: 'è™”è¯šæ‰‹å¥—',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_14.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 500,
            hp: 650,
            mastery: 20,
            haste: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            haste: 2
        }
    },
    EQ_081: {
        id: 'EQ_081',
        name: 'åšå­¦è€…æ‰‹å¥—',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_17.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 600,
            hp: 500,
            haste: 20,
            mastery: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            haste: 2,
            mastery: 2
        }
    },
    EQ_082: {
        id: 'EQ_082',
        name: 'å–·æ¯’è€…',
        icon: "icons/wow/vanilla/weapons/INV_Wand_10.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 950,
            haste: 30,
            mastery: 25,
        },
        growth: {
            attack: 2,
            haste: 2,
            mastery: 2,
            critRate: 2
        }
    },
    EQ_083: {
        id: 'EQ_083',
        name: 'çº¢æœ¨ä¹‹ç¯',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_05.png",
        type: 'equipment',
        slot: 'ring2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1200,
            versatility: 20,
            mastery: 20
        },
        growth: {
            hp: 2,
            versatility: 2,
            mastery: 2
        }
    },
    EQ_084: {
        id: 'EQ_084',
        name: 'å“ˆé›·è‚¯çš„é¡¹åœˆ',
        icon: "icons/wow/vanilla/armor/INV_Belt_14.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1500,
            attack: 200,
            spellPower: 200,
            haste: 10,
            versatility: 10
        },
        growth: {
            hp: 2,
            attack: 2,
            spellPower: 2,
            haste: 2,
            versatility: 2
        }
    },
    EQ_085: {
        id: 'EQ_085',
        name: 'ç‡ƒæ£˜å®é’»',
        icon: "icons/wow/vanilla/items/ranjibaozuan.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 300,
            critRate: 10,
            mastery: 10
        },
        growth: {
            spellPower: 2,
            critRate: 2,
            mastery: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [1, 2],
            spellPowerBonus: 800
        }
    },
    EQ_086: {
        id: 'EQ_086',
        name: 'é»‘é¸­',
        icon: "icons/wow/vanilla/weapons/INV_Sword_13.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1050,
            critRate: 25,
            critDamage: 0.5,
            versatility: 20
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2,
            versatility: 2
        }
    },

    // ==================== é€šçµå­¦é™¢ï¼ˆ55çº§ï¼‰è£…å¤‡ ====================
    EQ_087: {
        id: 'EQ_087',
        name: 'ä¸Šå¤éª¨å¼“',
        icon: "icons/wow/vanilla/weapons/INV_Weapon_Bow_12.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1000,
            critRate: 20,
            haste: 20,
            mastery: 20
        },
        growth: {
            attack: 2,
            critRate: 2,
            haste: 2,
            mastery: 2
        }
    },
    EQ_088: {
        id: 'EQ_088',
        name: 'é™¢é•¿ä¹‹æ–',
        icon: "icons/wow/vanilla/weapons/INV_Staff_13.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 950,
            critRate: 25,
            mastery: 25,
            versatility: 20
        },
        growth: {
            spellPower: 2,
            critRate: 2,
            mastery: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [2, 3],
            spellPowerBonus: 800
        }
    },
    EQ_089: {
        id: 'EQ_089',
        name: 'å™¬éª¨é“é’ˆ',
        icon: "icons/wow/vanilla/weapons/INV_Wand_07.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 550,
            haste: 20,
            mastery: 20,
            critRate: 10
        },
        growth: {
            spellPower: 2,
            haste: 2,
            mastery: 2,
            critRate: 2
        }
    },
    EQ_090: {
        id: 'EQ_090',
        name: 'å‹‡æ°”å¤´ç›”',
        icon: "icons/wow/vanilla/armor/INV_Helmet_02.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1300,
            armor: 120,
            mastery: 10,
            blockRate: 4,
            blockValue: 150
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_091: {
        id: 'EQ_091',
        name: 'è™”è¯šå¤´å† ',
        icon: "icons/wow/vanilla/armor/INV_Crown_01.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 300,
            hp: 850,
            mastery: 10,
            versatility: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_092: {
        id: 'EQ_092',
        name: 'è¿…å½±ç½©å¸½',
        icon: "icons/wow/vanilla/armor/INV_Helmet_41.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 300,
            hp: 750,
            armor: 90,
            critRate: 10,
            haste: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            haste: 2
        }
    },
    EQ_093: {
        id: 'EQ_093',
        name: 'åšå­¦è€…å¤´å† ',
        icon: "icons/wow/vanilla/armor/INV_Crown_02.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 650,
            critRate: 10,
            haste: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            haste: 2
        }
    },
    EQ_094: {
        id: 'EQ_094',
        name: 'è«é‡Œè¥¿å¥¥çš„ç»Ÿå¾¡æŒ‡ç¯',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_16.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 700,
            mastery: 20,
            versatility: 20
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2
        }
    },

    // ==================== æ–¯å¦ç´¢å§†ï¼ˆ55çº§ï¼‰è£…å¤‡ ====================
    EQ_095: {
        id: 'EQ_095',
        name: 'ç‘æ–‡æˆ´å°”ä¹‹å‰‘',
        icon: "icons/wow/vanilla/weapons/INV_Sword_17.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1100,
            critRate: 30,
            critDamage: 0.6,
            versatility: 30
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2,
            versatility: 2
        },
        specialEffect: {
            // æ¯å›åˆ20%æ¦‚ç‡ï¼šæœ¬å›åˆæ”»å‡»å¼ºåº¦+1500
            //ï¼ˆé€šç”¨ç»“æ„ï¼štype=proc_stat, trigger=turn_startï¼‰
            type: 'proc_stat',
            trigger: 'turn_start',
            chance: 0.20,
            stats: { attack: 800 },
            scaleWithLevel: true
        }
    },
    EQ_096: {
        id: 'EQ_096',
        name: 'çŸ¥è¯†å®å…¸',
        icon: "icons/wow/vanilla/items/INV_Misc_Book_05.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 650,
            mastery: 25,
            haste: 20,
            versatility: 15
        },
        growth: {
            spellPower: 2,
            mastery: 2,
            haste: 2,
            versatility: 2
        }
    },
    EQ_097: {
        id: 'EQ_097',
        name: 'ç§˜æœ¯ä¹‹æ˜Ÿ',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Talisman_08.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 550,
            hp: 1500,
            haste: 20,
            critRate: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            haste: 2,
            critRate: 2
        }
    },
    EQ_098: {
        id: 'EQ_098',
        name: 'é»‘çˆµå£«æ–—ç¯·',
        icon: "icons/wow/vanilla/armor/INV_Misc_Cape_20.png",
        type: 'equipment',
        slot: 'cloak',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 900,
            armor: 120,
            versatility: 25,
            haste: 15,
            critRate: 10
        },
        growth: {
            hp: 2,
            armor: 2,
            versatility: 2,
            haste: 2,
            critRate: 2
        }
    },
    EQ_099: {
        id: 'EQ_099',
        name: 'å‹‡æ°”æŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_04.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1200,
            armor: 150,
            mastery: 10,
            blockRate: 4,
            blockValue: 150
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_100: {
        id: 'EQ_100',
        name: 'è¿…å½±æŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_02.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 250,
            hp: 700,
            armor: 90,
            critRate: 10,
            mastery: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            mastery: 2
        }
    },
    EQ_101: {
        id: 'EQ_101',
        name: 'è™”è¯šæŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_08.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 300,
            hp: 950,
            mastery: 15,
            haste: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            haste: 2
        }
    },
    EQ_102: {
        id: 'EQ_102',
        name: 'åšå­¦è€…æŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_06.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 850,
            critRate: 10,
            versatility: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            versatility: 2
        }
    },

    // ==================== é»‘çŸ³å¡”ä¸Šï¼ˆ60çº§ï¼‰è£…å¤‡ ====================
    EQ_103: {
        id: 'EQ_103',
        name: 'æ¶é­”ä¹‹å‡»',
        icon: "icons/wow/vanilla/weapons/INV_Weapon_ShortBlade_25.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1000,
            critRate: 20,
            critDamage: 0.5,
            mastery: 25,
            versatility: 20
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2,
            mastery: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'basic_attack_repeat',
            chance: 0.50
        }
    },
    EQ_104: {
        id: 'EQ_104',
        name: 'é›·å¾·åŒåˆƒ',
        icon: "icons/wow/vanilla/weapons/INV_Sword_40.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1300,
            critRate: 20,
            critDamage: 0.6,
            haste: 25,
            versatility: 20
        },
        growth: {
            attack: 2,
            critRate: 2,
            critDamage: 2,
            haste: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'basic_attack_repeat',
            chance: 0.40
        }
    },
    EQ_105: {
        id: 'EQ_105',
        name: 'çŸ³æ¥ ä¹‹ç¯',
        icon: "icons/wow/vanilla/items/INV_Misc_Root_02.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1300,
            versatility: 25,
            mastery: 25
        },
        growth: {
            hp: 2,
            versatility: 2,
            mastery: 2
        }
    },
    EQ_106: {
        id: 'EQ_106',
        name: 'ç—›è‹¦æŒ‡ç¯',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_16.png",
        type: 'equipment',
        slot: 'ring2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 900,
            attack: 250,
            spellPower: 250,
            critRate: 10,
            haste: 15
        },
        growth: {
            hp: 2,
            attack: 2,
            spellPower: 2,
            critRate: 2,
            haste: 2
        }
    },
    EQ_107: {
        id: 'EQ_107',
        name: 'é¾™äººä¹‹ç›¾',
        icon: "icons/wow/vanilla/armor/INV_Shield_20.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1600,
            armor: 200,
            mastery: 20,
            blockRate: 25,
            blockValue: 600
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_108: {
        id: 'EQ_108',
        name: 'é›·å¾·ä¹‹çœ¼',
        icon: "icons/wow/vanilla/armor/INV_Helmet_46.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 450,
            critRate: 10,
            mastery: 10
        },
        growth: {
            attack: 2,
            spellPower: 2,
            critRate: 2,
            mastery: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [0,1,2],
            attackBonus: 1000,
        }
    },
    EQ_109: {
        id: 'EQ_109',
        name: 'å‹‡æ°”èƒ¸ç”²',
        icon: "icons/wow/vanilla/armor/INV_Chest_Plate03.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1500,
            armor: 180,
            mastery: 10,
            blockRate: 4,
            blockValue: 250
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_110: {
        id: 'EQ_110',
        name: 'è¿…å½±å¤–å¥—',
        icon: "icons/wow/vanilla/armor/INV_Chest_Leather_07.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 350,
            hp: 900,
            armor: 100,
            critRate: 10,
            mastery: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            mastery: 2
        }
    },
    EQ_111: {
        id: 'EQ_111',
        name: 'è™”è¯šé•¿è¢',
        icon: "icons/wow/vanilla/armor/INV_Chest_Cloth_11.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 1200,
            mastery: 15,
            haste: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            haste: 2
        }
    },
    EQ_112: {
        id: 'EQ_112',
        name: 'åšå­¦è€…é•¿è¢',
        icon: "icons/wow/vanilla/armor/INV_Chest_Cloth_25.png",
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 1100,
            critRate: 10,
            mastery: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            mastery: 2
        }
    },

    // ==================== é»‘æš—é™¢é•¿åŠ ä¸ï¼ˆ60çº§ä¸–ç•Œé¦–é¢†ï¼‰æ–°å¢ï¼šT0 å¥—è£…æŠ¤è‚© ====================
    // è®¾è®¡è¯´æ˜ï¼šæ•´ä½“æ•°å€¼ç•¥é«˜äº 55 çº§å‰¯æœ¬æ‰è½çš„ T0 å¥—è£…æ•£ä»¶ï¼ˆè…°å¸¦/æ‰‹å¥—/å¤´ç›”/æŠ¤è…¿ï¼‰ï¼Œä½†ä¸è¶…è¿‡ 60 çº§èƒ¸ç”²å¼ºåº¦å¤ªå¤šã€‚
    EQ_113: {
        id: 'EQ_113',
        name: 'å‹‡æ°”è‚©ç”²',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_30.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1400,
            armor: 180,
            mastery: 15,
            blockRate: 4,
            blockValue: 280
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_114: {
        id: 'EQ_114',
        name: 'è¿…å½±æŠ¤è‚©',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_07.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 320,
            hp: 750,
            armor: 100,
            critRate: 10,
            versatility: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            versatility: 2
        }
    },
    EQ_115: {
        id: 'EQ_115',
        name: 'è™”è¯šè¡¬è‚©',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_09.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 300,
            hp: 1000,
            mastery: 15,
            versatility: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_116: {
        id: 'EQ_116',
        name: 'åšå­¦è€…è¡¬è‚©',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_23.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 350,
            hp: 950,
            critRate: 15,
            mastery: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            mastery: 2
        }
    },

    // ==================== ç‘æ–‡æˆ´å°”ç”·çˆµï¼ˆ60çº§ä¸–ç•Œé¦–é¢†ï¼‰æ–°å¢ï¼šT0 å¥—è£…æˆ˜é´/ä¾¿é‹ ====================
    // è®¾è®¡è¯´æ˜ï¼šæ•°å€¼å¤§å°å‚è€ƒ T0 æŠ¤è‚©ï¼ˆEQ_113~EQ_116ï¼‰ï¼Œå¹¶é€‚å½“è°ƒæ•´å‰¯å±æ€§ä»¥æ‹‰å¼€å·®å¼‚ã€‚
    EQ_117: {
        id: 'EQ_117',
        name: 'å‹‡æ°”æˆ˜é´',
        icon: "icons/wow/vanilla/armor/INV_Boots_Plate_03.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1350,
            armor: 190,
            mastery: 12,
            blockRate: 4,
            blockValue: 300
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        }
    },
    EQ_118: {
        id: 'EQ_118',
        name: 'è¿…å½±é•¿é´',
        icon: "icons/wow/vanilla/armor/INV_Boots_04.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 280,
            hp: 780,
            armor: 110,
            critRate: 10,
            mastery: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            mastery: 2
        }
    },
    EQ_119: {
        id: 'EQ_119',
        name: 'è™”è¯šè½¯é‹',
        icon: "icons/wow/vanilla/armor/INV_Boots_05.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 260,
            hp: 980,
            mastery: 15,
            haste: 10
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            haste: 2
        }
    },
    EQ_120: {
        id: 'EQ_120',
        name: 'åšå­¦è€…é•¿é´',
        icon: "icons/wow/vanilla/armor/INV_Boots_02.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 330,
            hp: 920,
            critRate: 10,
            haste: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            haste: 2
        }
    },

    // ==================== é›·å¾·Â·é»‘æ‰‹ï¼ˆ60çº§ä¸–ç•Œé¦–é¢†ï¼‰æ–°å¢ï¼šT0 å¥—è£…æŠ¤è…•/è£¹è…• ====================
    // è®¾è®¡è¯´æ˜ï¼šæ•°å€¼å¤§å°å‚è€ƒ T0 æŠ¤è‚©ï¼ˆEQ_113~EQ_116ï¼‰ï¼Œå¹¶é€‚å½“è°ƒæ•´å‰¯å±æ€§ä»¥æ‹‰å¼€å·®å¼‚ã€‚
    EQ_121: {
        id: 'EQ_121',
        name: 'å‹‡æ°”æŠ¤è…•',
        icon: "icons/wow/vanilla/armor/INV_Bracer_18.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'blue',
        setId: 'valor_set',
        setName: 'å‹‡æ°”',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1280,
            armor: 165,
            mastery: 10,
            blockValue: 250,
            magicResist: 40
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockValue: 2,
            magicResist: 2
        }
    },
    EQ_122: {
        id: 'EQ_122',
        name: 'è¿…å½±æŠ¤è…•',
        icon: "icons/wow/vanilla/armor/INV_Bracer_07.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'blue',
        setId: 'swiftshadow_set',
        setName: 'è¿…å½±',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 240,
            hp: 760,
            armor: 85,
            mastery: 10,
            haste: 15
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            mastery: 2,
            haste: 2
        }
    },
    EQ_123: {
        id: 'EQ_123',
        name: 'è™”è¯šæŠ¤è…•',
        icon: "icons/wow/vanilla/armor/INV_Belt_31.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'blue',
        setId: 'devout_set',
        setName: 'è™”è¯š',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 240,
            hp: 980,
            haste: 10,
            versatility: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            haste: 2,
            versatility: 2
        }
    },
    EQ_124: {
        id: 'EQ_124',
        name: 'åšå­¦è€…è…•è½®',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_23.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'blue',
        setId: 'scholar_set',
        setName: 'åšå­¦è€…',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 280,
            hp: 930,
            mastery: 10,
            versatility: 15
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2
        }
    },

    EQ_HOGGER_001: {
        id: 'EQ_HOGGER_001',
        name: 'éœæ ¼çš„æ¯›çš®æŠ«é£',
        icon: 'icons/wow/vanilla/armor/INV_Misc_Cape_10.png',
        type: 'equipment',
        slot: 'cloak',
        rarity: 'blue',
        setId: 'hogger_gather_set',
        setName: 'éœæ ¼çš„æˆ˜åˆ©å“',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 100,
            armor: 20,
            proficiency: 10  // é‡‡é›†ç†Ÿç»ƒ
        },
        growth: {
            hp: 2,
            armor: 2,
            proficiency: 2
        }
    },
    EQ_HOGGER_002: {
        id: 'EQ_HOGGER_002',
        name: 'éœæ ¼çš„ç ç‰™å¤´ç›”',
        icon: 'icons/wow/vanilla/armor/INV_Helmet_03.png',
        type: 'equipment',
        slot: 'head',
        rarity: 'blue',
        setId: 'hogger_gather_set',
        setName: 'éœæ ¼çš„æˆ˜åˆ©å“',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 150,
            armor: 30,
            precision: 10  // é‡‡é›†ç²¾ç»†
        },
        growth: {
            hp: 2,
            armor: 2,
            precision: 2
        }
    },
    EQ_HOGGER_003: {
        id: 'EQ_HOGGER_003',
        name: 'éœæ ¼çš„å…½çš®èƒ¸ç”²',
        icon: 'icons/wow/vanilla/armor/INV_Chest_Leather_01.png',
        type: 'equipment',
        slot: 'chest',
        rarity: 'blue',
        setId: 'hogger_gather_set',
        setName: 'éœæ ¼çš„æˆ˜åˆ©å“',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 200,
            armor: 40,
            perception: 10  // é‡‡é›†æ„ŸçŸ¥
        },
        growth: {
            hp: 2,
            armor: 2,
            perception: 2
        }
    },
    EQ_VANCLEEF_001: {
        id: 'EQ_VANCLEEF_001',
        name: 'æš´é£åŸå·¥å¤´çš„é“²å­',
        icon: 'icons/wow/vanilla/items/INV_Misc_Shovel_01.png',
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            proficiency: 20,
            precision: 20,
            perception: 20  // é‡‡é›†æ„ŸçŸ¥
        },
        growth: {
            proficiency: 2,
            precision: 2,
            perception: 2
        }
    },
    EQ_125: {
        id: 'EQ_125',
        name: 'ç¥ç§˜ç¥ç€åŠå ',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Necklace_11.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',

        setId: 'secret_set',
        setName: 'ç¥ç§˜å¥—è£…',

        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 1000,
            versatility: 15,
            proficiency: 20,
            precision: 20,
            perception: 20,
        },
        growth: {
            hp: 2,
            versatility: 2,
            proficiency: 2,
            precision: 2,
            perception: 2,
        }
    },
    EQ_126: {
        id: 'EQ_126',
        name: 'ç¥ç§˜è“å®çŸ³åŠå ',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Necklace_11.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',

        setId: 'secret_set',
        setName: 'ç¥ç§˜å¥—è£…',

        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 2000,
            versatility: 20,
            mastery:10,
            proficiency: 40,
            precision: 40,
            perception: 40,

        },
        growth: {
            hp: 2,
            versatility: 2,
            mastery:2,
            proficiency: 2,
            precision: 2,
            perception: 2,
        }
    },
    EQ_127: {
        id: 'EQ_127',
        name: 'ç¥ç§˜çº¢å®çŸ³åŠå ',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Necklace_11.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',

        setId: 'secret_set',
        setName: 'ç¥ç§˜å¥—è£…',

        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 4000,
            versatility: 25,
            mastery:15,
            proficiency: 80,
            precision: 80,
            perception: 80,

        },
        growth: {
            hp: 2,
            versatility: 2,
            mastery:2,
            proficiency: 2,
            precision: 2,
            perception: 2,
        }
    },
    EQ_128: {
        id: 'EQ_0128',
        name: 'ç¥ç§˜ç¥ç€æˆ’æŒ‡',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_12.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'blue',

        setId: 'secret_set',
        setName: 'ç¥ç§˜å¥—è£…',

        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 300,
            versatility: 15,
            proficiency: 20,
            precision: 20,
            perception: 20,
        },
        growth: {
            hp: 2,
            versatility: 2,
            proficiency: 2,
            precision: 2,
            perception: 2,
        }
    },
    EQ_129: {
        id: 'EQ_0129',
        name: 'ç¥ç§˜è“å®çŸ³æˆ’æŒ‡',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_12.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'blue',

        setId: 'secret_set',
        setName: 'ç¥ç§˜å¥—è£…',

        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            versatility: 20,
            mastery:10,
            proficiency: 40,
            precision: 40,
            perception: 40,
        },
        growth: {
            hp: 2,
            versatility: 2,
            mastery:2,
            proficiency: 2,
            precision: 2,
            perception: 2,
        }
    },
    EQ_130: {
        id: 'EQ_0130',
        name: 'ç¥ç§˜çº¢å®çŸ³æˆ’æŒ‡',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_12.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'blue',

        setId: 'secret_set',
        setName: 'ç¥ç§˜å¥—è£…',

        level: 1,
        maxLevel: 100,
        baseStats: {
            hp: 3000,
            versatility: 25,
            mastery:15,
            proficiency: 80,
            precision: 80,
            perception: 80,
        },
        growth: {
            hp: 2,
            versatility: 2,
            mastery:2,
            proficiency: 2,
            precision: 2,
            perception: 2,
        }
    },
    // ==================== ç¥–å°”æ ¼æ‹‰å¸ƒï¼ˆ60çº§ï¼‰è£…å¤‡ ====================
    EQ_131: {
        id: 'EQ_131',
        name: 'è¾›æ´›æ–¯è¯¸ç•Œçš„æ¯ç­è€…',
        icon: "icons/wow/vanilla/weapons/xinluosi.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1500,
            hp: 2800,
            haste: 30,
            mastery: 20,
            versatility: 20
        },
        growth: {
            attack: 2,
            hp: 2,
            haste: 2,
            mastery: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'proc_stat',
            trigger: 'turn_start',
            chance: 0.25,
            stats: { attack: 1500 },
            scaleWithLevel: true
        }
    },
    EQ_132: {
        id: 'EQ_132',
        name: 'è¡€é¢†ä¸»åº‡æŠ¤è€…',
        icon: "icons/wow/vanilla/weapons/xuelingzhu.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 900,
            hp: 5500,
            armor: 250,
            mastery: 25,
            blockValue: 500,
            versatility: 20
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            mastery: 2,
            blockValue: 2,
            versatility: 2
        }
    },
    EQ_133: {
        id: 'EQ_133',
        name: 'å¨…å°”ç½—çš„æ„å¿—',
        icon: "icons/wow/vanilla/weapons/yaerluodeyizhi.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 1200,
            hp: 3000,
            mastery: 25,
            haste: 25,
            versatility: 20
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            haste: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [2, 3],
            spellPowerBonus: 900
        }
    },
    EQ_134: {
        id: 'EQ_134',
        name: 'é‡‘åº¦çš„å¦–å™¨',
        icon: "icons/wow/vanilla/weapons/jindudeyaoqi.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 1250,
            hp:2800,
            critRate: 25,
            haste: 25,
            versatility: 20
        },
        growth: {
            spellPower: 2,
            hp:2,
            critRate: 2,
            haste: 2,
            versatility: 2
        }
    },
    EQ_135: {
        id: 'EQ_135',
        name: 'é‡‘åº¦çš„å„è¿è¢‹',
        icon: "icons/wow/vanilla/items/INV_Misc_Bag_10_Black.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 650,
            hp:2500,
            haste: 25,
            versatility: 25,
        },
        growth: {
            spellPower: 2,
            hp:2,
            haste: 2,
            versatility: 2
        }
    },
    EQ_136: {
        id: 'EQ_136',
        name: 'å“ˆå¡è±æˆ˜åˆƒ',
        icon: "icons/wow/vanilla/weapons/xinluosi.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 850,
            hp:2500,
            critRate: 20,
            mastery: 20,
            versatility: 15
        },
        growth: {
            attack: 2,
            hp:2,
            critRate: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_137: {
        id: 'EQ_137',
        name: 'åå™¬æŠ«é£',
        icon: "icons/wow/vanilla/armor/tunshipifeng.png",
        type: 'equipment',
        slot: 'cloak',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 320,
            hp: 3200,
            armor: 150,
            mastery: 20,
            versatility: 30,
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_138: {
        id: 'EQ_138',
        name: 'æ›¼å¤šåŸºå°”çš„å¾½è®°',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Talisman_01.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 350,
            hp: 2000,
            critRate: 10,
            mastery: 22,
            haste: 20
        },
        growth: {
            attack: 2,
            hp: 2,
            critRate: 2,
            mastery: 2,
            haste: 2
        }
    },

    // ==================== å®‰çªæ‹‰åºŸå¢Ÿï¼ˆ60çº§ï¼‰è£…å¤‡ ====================
    EQ_139: {
        id: 'EQ_139',
        name: 'æµæ²™æŠ¤ç¬¦',
        icon: "icons/wow/vanilla/armor/liushahufu.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 4200,
            armor: 220,
            mastery: 25,
            versatility: 25
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            versatility: 2
        },
        specialEffect: {
            name: 'æ²™å°˜æŠ¤ç›¾',
            type: 'proc_stat',
            trigger: 'turn_start',
            chance: 0.20,
            stats: { armor: 1500 },
            scaleWithLevel: true
        }
    },
    EQ_140: {
        id: 'EQ_140',
        name: 'æ‹‰è´¾å…‹æ–¯çš„å¾½è®°',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Talisman_13.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 3400,
            armor: 150,
            mastery: 20,
            blockValue: 400,
            versatility: 25
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockValue: 2,
            versatility: 2
        }
    },
    EQ_141: {
        id: 'EQ_141',
        name: 'ç‹‚æš´ä¸“æ³¨ä¹‹çˆª',
        icon: "icons/wow/vanilla/armor/kuangbaozhuanzhu.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 700,
            hp: 2800,
            mastery: 20,
            critRate: 20,
            versatility: 15,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery:2,
            critRate: 2,
            versatility: 2
        }
    },
    EQ_142: {
        id: 'EQ_142',
        name: 'æ²™æ¼ é£æš´æŠ«é£',
        icon: "icons/wow/vanilla/armor/INV_Misc_Cape_06.png",
        type: 'equipment',
        slot: 'cloak',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 360,
            hp: 3700,
            armor: 180,
            mastery: 22,
            versatility: 35
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            mastery: 2,
            versatility: 2
        }
    },
    EQ_143: {
        id: 'EQ_143',
        name: 'åºŸå¢Ÿæ³•æ–',
        icon: "icons/wow/vanilla/armor/feixufazhang.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 1350,
            hp: 3300,
            critRate: 25,
            mastery: 30,
            versatility: 20
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            mastery: 2,
            versatility: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [2, 3],
            spellPowerBonus: 1000
        }
    },
    EQ_144: {
        id: 'EQ_144',
        name: 'æµæ²™å é¥°',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Necklace_11.png",
        type: 'equipment',
        slot: 'neck',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 3000,
            attack: 450,
            spellPower: 450,
            haste: 25,
            versatility: 25
        },
        growth: {
            hp: 2,
            attack: 2,
            spellPower: 2,
            haste: 2,
            versatility: 2
        }
    },
    EQ_145: {
        id: 'EQ_145',
        name: 'å…¶æ‹‰å¸ç‹æŠ«é£',
        icon: "icons/wow/vanilla/armor/INV_Misc_Cape_20.png",
        type: 'equipment',
        slot: 'cloak',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 420,
            hp: 3800,
            critRate: 15,
            haste: 25,
            mastery: 25,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            haste: 2,
            mastery: 2,
        }
    },
    // ==================== ç†”ç«ä¹‹å¿ƒï¼ˆ60çº§ï¼‰è£…å¤‡ ====================
    // è®¾è®¡è¯´æ˜ï¼š
    // - ç”±äºæœ¬åŒºè£…å¤‡æ•°é‡è¾ƒå¤šï¼Œæ‰è½ç‡åœ¨ DROP_TABLES ä¸­æ•´ä½“ä¸‹è°ƒ
    // - å¼ºåº¦å®šä½ï¼šç›¸å¯¹ã€ç¥–å°”æ ¼æ‹‰å¸ƒ / å®‰çªæ‹‰åºŸå¢Ÿã€‘çº¦æå‡ï¼šç”Ÿå‘½å€¼ +30%ï¼Œå…¶ä½™å±æ€§ +15%ï¼ˆå·¦å³ï¼‰
    //
    // âœ… T1ï¼šåŠ›é‡ï¼ˆæˆ˜å£«ï¼‰
    EQ_146: {
        id: 'EQ_146',
        name: 'åŠ›é‡å¤´ç›”',
        icon: "icons/wow/vanilla/armor/INV_Helmet_09.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'purple',

        setId: 'might_set',
        setName: 'åŠ›é‡',

        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 5600,
            armor: 230,
            blockRate: 5,
            blockValue: 460,
            versatility: 12,
        },
        growth: {
            hp: 2,
            armor: 2,
            blockRate: 2,
            blockValue: 2,
            versatility: 2,
        }
    },
    EQ_147: {
        id: 'EQ_147',
        name: 'åŠ›é‡æŠ¤è…•',
        icon: "icons/wow/vanilla/armor/INV_Bracer_19.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'purple',

        setId: 'might_set',
        setName: 'åŠ›é‡',

        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 4200,
            armor: 200,
            blockRate: 4,
            blockValue: 380,
            versatility: 12,
        },
        growth: {
            hp: 2,
            armor: 2,
            blockRate: 2,
            blockValue: 2,
            versatility: 2,
        }
    },
    EQ_148: {
        id: 'EQ_148',
        name: 'åŠ›é‡è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_09.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'purple',

        setId: 'might_set',
        setName: 'åŠ›é‡',

        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 4200,
            armor: 210,
            mastery: 12,
            blockRate: 4,
            blockValue: 400,
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2,
        }
    },
    EQ_149: {
        id: 'EQ_149',
        name: 'åŠ›é‡é©¬é´',
        icon: "icons/wow/vanilla/armor/INV_Boots_Plate_04.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'purple',

        setId: 'might_set',
        setName: 'åŠ›é‡',

        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 5200,
            armor: 220,
            mastery: 12,
            blockRate: 4,
            blockValue: 420,
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2,
        }
    },

    // âœ… T1ï¼šå¤œå¹•æ€æ‰‹ï¼ˆç›—è´¼ï¼‰
    EQ_150: {
        id: 'EQ_150',
        name: 'å¤œå¹•æ€æ‰‹å¤´å·¾',
        icon: "icons/wow/vanilla/armor/INV_Helmet_41.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'purple',

        setId: 'nightslayer_set',
        setName: 'å¤œå¹•æ€æ‰‹',

        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 520,
            hp: 3800,
            armor: 180,
            critRate: 12,
            haste: 16,
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            haste: 2,
        }
    },
    EQ_151: {
        id: 'EQ_151',
        name: 'å¤œå¹•æ€æ‰‹æŠ¤è…•',
        icon: "icons/wow/vanilla/armor/INV_Bracer_02.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'purple',

        setId: 'nightslayer_set',
        setName: 'å¤œå¹•æ€æ‰‹',

        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 420,
            hp: 2800,
            armor: 150,
            critRate: 12,
            versatility: 16,
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            versatility: 2,
        }
    },
    EQ_152: {
        id: 'EQ_152',
        name: 'å¤œå¹•æ€æ‰‹è…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_23.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'purple',

        setId: 'nightslayer_set',
        setName: 'å¤œå¹•æ€æ‰‹',

        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 420,
            hp: 3000,
            armor: 160,
            haste: 12,
            mastery: 16,
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            haste: 2,
            mastery: 2,
        }
    },
    EQ_153: {
        id: 'EQ_153',
        name: 'å¤œå¹•æ€æ‰‹é•¿é´',
        icon: "icons/wow/vanilla/armor/INV_Boots_08.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'purple',

        setId: 'nightslayer_set',
        setName: 'å¤œå¹•æ€æ‰‹',

        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 450,
            hp: 3400,
            armor: 170,
            critRate: 12,
            mastery: 16,
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            mastery: 2,
        }
    },

    // âœ… T1ï¼šå¥¥æœ¯å¸ˆï¼ˆæ³•å¸ˆï¼‰
    EQ_154: {
        id: 'EQ_154',
        name: 'å¥¥æœ¯å¸ˆå¤´å† ',
        icon: "icons/wow/vanilla/armor/INV_Helmet_53.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'purple',

        setId: 'arcanist_set',
        setName: 'å¥¥æœ¯å¸ˆ',

        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 550,
            hp: 3600,
            critRate: 12,
            versatility: 16,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            mastery: 2,
            versatility: 2,
        }
    },
    EQ_155: {
        id: 'EQ_155',
        name: 'å¥¥æœ¯å¸ˆæŠ¤è…•',
        icon: "icons/wow/vanilla/armor/INV_Belt_29.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'purple',

        setId: 'arcanist_set',
        setName: 'å¥¥æœ¯å¸ˆ',

        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 400,
            hp: 2800,
            critRate: 12,
            versatility: 22,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            versatility: 2,
        }
    },
    EQ_156: {
        id: 'EQ_156',
        name: 'å¥¥æœ¯å¸ˆè…°å¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_30.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'purple',

        setId: 'arcanist_set',
        setName: 'å¥¥æœ¯å¸ˆ',

        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 400,
            hp: 2800,
            haste: 12,
            mastery: 16,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            haste: 2,
            critRate: 2,
            mastery: 2,
        }
    },
    EQ_157: {
        id: 'EQ_157',
        name: 'å¥¥æœ¯å¸ˆä¾¿é‹',
        icon: "icons/wow/vanilla/armor/INV_Boots_07.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'purple',

        setId: 'arcanist_set',
        setName: 'å¥¥æœ¯å¸ˆ',

        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 480,
            hp: 3400,
            critRate: 12,
            mastery: 16,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            haste: 2,
            critRate: 2,
            mastery: 2,
        }
    },

    // âœ… T1ï¼šé¢„è¨€ï¼ˆç‰§å¸ˆï¼‰
    EQ_158: {
        id: 'EQ_158',
        name: 'é¢„è¨€å¤´é¥°',
        icon: "icons/wow/vanilla/armor/INV_Helmet_34.png",
        type: 'equipment',
        slot: 'head',
        rarity: 'purple',

        setId: 'prophecy_set',
        setName: 'é¢„è¨€',

        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 500,
            hp: 3900,
            mastery: 12,
            versatility: 16,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2,
        }
    },
    EQ_159: {
        id: 'EQ_159',
        name: 'é¢„è¨€è‡‚ç”²',
        icon: "icons/wow/vanilla/armor/INV_Bracer_09.png",
        type: 'equipment',
        slot: 'wrist',
        rarity: 'purple',

        setId: 'prophecy_set',
        setName: 'é¢„è¨€',

        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 380,
            hp: 3400,
            mastery: 12,
            versatility: 16,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2,
            haste: 2,
        }
    },
    EQ_160: {
        id: 'EQ_160',
        name: 'é¢„è¨€æŸå¸¦',
        icon: "icons/wow/vanilla/armor/INV_Belt_22.png",
        type: 'equipment',
        slot: 'belt',
        rarity: 'purple',

        setId: 'prophecy_set',
        setName: 'é¢„è¨€',

        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 380,
            hp: 3400,
            versatility: 12,
            critRate: 16,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            versatility: 2,
            critRate: 2,
        }
    },
    EQ_161: {
        id: 'EQ_161',
        name: 'é¢„è¨€ä¹‹é´',
        icon: "icons/wow/vanilla/armor/INV_Boots_07.png",
        type: 'equipment',
        slot: 'feet',
        rarity: 'purple',

        setId: 'prophecy_set',
        setName: 'é¢„è¨€',

        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 430,
            hp: 3600,
            critRate: 12,
            versatility: 16,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            versatility: 2,
        }
    },

    // âœ… é¥°å“ï¼šç«ç„°ç¬¦å’’ï¼ˆé­”æŠ—é¥°å“ï¼‰
    EQ_162: {
        id: 'EQ_162',
        name: 'ç«ç„°ç¬¦å’’',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Talisman_09.png",
        type: 'equipment',
        slot: 'trinket1',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 5000,
            magicResist: 120,
            versatility: 10,
        },
        growth: {
            hp: 2,
            magicResist: 2,
            versatility: 2,
        },
        specialEffect: {
            type: 'proc_stat',
            trigger: 'turn_start',
            chance: 0.25,
            stats: { magicResist: 250 },
            scaleWithLevel: true
        }
    },

    // âœ… æˆ’æŒ‡ï¼šæ²‰é‡çš„é»‘é“æˆ’æŒ‡ï¼ˆå¦å…‹ï¼‰
    EQ_163: {
        id: 'EQ_163',
        name: 'æ²‰é‡çš„é»‘é“æˆ’æŒ‡',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_14.png",
        type: 'equipment',
        slot: 'ring2',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 4420,
            armor: 173,
            mastery: 23,
            blockValue: 460,
            versatility: 29,
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockValue: 2,
            versatility: 2,
        }
    },

    // âœ… æˆ’æŒ‡ï¼šæ³•æœ¯èƒ½é‡ä¹‹æˆ’ï¼ˆæ³•å¼ºï¼‰
    EQ_164: {
        id: 'EQ_164',
        name: 'æ³•æœ¯èƒ½é‡ä¹‹æˆ’',
        icon: "icons/wow/vanilla/armor/fashunengliang.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 520,
            hp: 3900,
            critRate: 10,
            haste: 22,
            mastery: 22,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            haste: 2,
            mastery: 2,
        }
    },

    // âœ… ç›¾ç‰Œï¼šé’»å­”è™«ä¹‹ç¢Ÿï¼ˆå¦å…‹ç›¾ç‰Œï¼‰
    EQ_165: {
        id: 'EQ_165',
        name: 'é’»å­”è™«ä¹‹ç¢Ÿ',
        icon: "icons/wow/vanilla/armor/INV_Shield_10.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 6200,
            armor: 360,
            mastery: 10,
            blockRate: 26,
            blockValue: 690,
            versatility: 12,
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2,
            versatility: 2,
        },
    },

    // âœ… æˆ’æŒ‡ï¼šè¿…å‡»æˆ’æŒ‡ï¼ˆæ”»å¼ºï¼‰
    EQ_166: {
        id: 'EQ_166',
        name: 'è¿…å‡»æˆ’æŒ‡',
        icon: "icons/wow/vanilla/armor/INV_Jewelry_Ring_07.png",
        type: 'equipment',
        slot: 'ring1',
        rarity: 'blue',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 520,
            hp: 3900,
            critRate: 10,
            haste: 22,
            mastery: 22,
        },
        growth: {
            attack: 2,
            hp: 2,
            critRate: 2,
            haste: 2,
            mastery: 2,
        }
    },

    // âœ… æ­¦å™¨ï¼šæ®‹å¿åˆ©åˆƒ
    EQ_167: {
        id: 'EQ_167',
        name: 'æ®‹å¿åˆ©åˆƒ',
        icon: "icons/wow/vanilla/weapons/INV_Sword_15.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1725,
            hp: 3640,
            critRate: 29,
            critDamage: 0.70,
            versatility: 40,
        },
        growth: {
            attack: 2,
            hp: 2,
            critRate: 2,
            critDamage: 2,
            versatility: 2,
        },
        specialEffect: {
            type: 'proc_stat',
            trigger: 'turn_start',
            chance: 0.20,
            stats: { attack: 1200, critRate: 20 },
            scaleWithLevel: true
        }
    },

    // âœ… ä¼ è¯´ï¼ˆæ©™ï¼‰ï¼šç¥ˆç¦
    EQ_168: {
        id: 'EQ_168',
        name: 'ç¥ˆç¦',
        icon: "icons/wow/vanilla/weapons/INV_Staff_30.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'orange',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 1600,
            hp: 4500,
            mastery: 20,
            versatility: 18,
            critRate: 10,
            haste: 20,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2,
            critRate: 2,
            haste: 2,
        },
        specialEffect: {
            type: 'proc_stat',
            trigger: 'turn_start',
            chance: 0.25,
            stats: { spellPower: 1500 },
            scaleWithLevel: true
        }
    },

    // âœ… æ­¦å™¨ï¼šç¢§ç©ºä¹‹æ­Œï¼ˆæ³•å¼ºæ­¦å™¨ï¼‰
    EQ_169: {
        id: 'EQ_169',
        name: 'ç¢§ç©ºä¹‹æ­Œ',
        icon: "icons/wow/vanilla/weapons/INV_Sword_39.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 1700,
            hp: 4000,
            critRate: 15,
            mastery: 30,
            versatility: 25,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            mastery: 2,
            versatility: 2,
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [0, 1, 2],
            spellPowerBonus: 1150
        }
    },

    // âœ… å‰¯æ‰‹ï¼šç†”ç«çŠ¬ç‰™ï¼ˆæ”»å¼ºå‰¯æ‰‹ï¼‰
    EQ_170: {
        id: 'EQ_170',
        name: 'ç†”ç«çŠ¬ç‰™',
        icon: "icons/wow/vanilla/weapons/INV_Weapon_ShortBlade_11.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 980,
            hp: 3250,
            critRate: 20,
            haste: 22,
            versatility: 15,
        },
        growth: {
            attack: 2,
            hp: 2,
            critRate: 2,
            haste: 2,
            versatility: 2,
        }
    },
    EQ_171: {
        id: 'EQ_171',
        name: 'ä¸çŸ­æš‚èƒ½é‡æŠ¤ç¬¦',
        icon: "icons/wow/vanilla/items/INV_Misc_StoneTablet_11.png",
        type: 'equipment',
        slot: 'trinket2',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 850
        },
        growth: {
            spellPower: 2
        },
        specialEffect: {
            type: 'skill_slot_buff',
            slots: [0,1,4,5],
            spellPowerBonus: 1800
        }
    },




    // ==================== Molten Coreï¼ˆç†”ç«ä¹‹å¿ƒï¼‰- åŠ å°”æ‰è½ï¼ˆæ‰‹å¥—/é€é£è€…éƒ¨ä»¶ï¼‰ ====================
    EQ_172: {
        id: 'EQ_172',
        name: 'åŠ›é‡æŠ¤æ‰‹',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_10.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 4200,
            armor: 210,
            blockRate: 4,
            blockValue: 400,
            versatility: 12
        },
        growth: {
            hp: 2,
            armor: 2,
            blockRate: 2,
            blockValue: 2,
            versatility: 2,
        },
        setId: 'might_set',
        setName: 'åŠ›é‡'
    },
    EQ_173: {
        id: 'EQ_173',
        name: 'å¤œå¹•æ€æ‰‹æ‰‹å¥—',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_21.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 420,
            hp: 3000,
            armor: 160,
            critRate: 12,
            haste: 16
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            haste: 2,
        },
        setId: 'nightslayer_set',
        setName: 'å¤œå¹•æ€æ‰‹'
    },
    EQ_174: {
        id: 'EQ_174',
        name: 'å¥¥æœ¯å¸ˆæ‰‹å¥—',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_14.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 420,
            hp: 3000,
            critRate: 12,
            haste: 16
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            haste: 2,
        },
        setId: 'arcanist_set',
        setName: 'å¥¥æœ¯å¸ˆ'
    },
    EQ_175: {
        id: 'EQ_175',
        name: 'é¢„è¨€æ‰‹å¥—',
        icon: "icons/wow/vanilla/armor/INV_Gauntlets_14.png",
        type: 'equipment',
        slot: 'hands',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 400,
            hp: 3400,
            mastery: 12,
            critRate: 16
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            critRate: 2,
        },
        setId: 'prophecy_set',
        setName: 'é¢„è¨€'
    },
    EQ_176: {
        id: 'EQ_176',
        name: 'é€é£è€…çš„ç¦é”¢ä¹‹é¢…ï¼ˆå³ï¼‰',
        icon: "icons/wow/vanilla/spells/Spell_Ice_Lament.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'orange',
        level: 0,
        maxLevel: 100,
        baseStats: {
            // æ— å±æ€§ï¼ˆç”¨äºåç»­åˆæˆ/æ”¶è—ç­‰ï¼‰
        },
        growth: {
            // æ— æˆé•¿
        },
    },
    // ==================== Molten Coreï¼ˆç†”ç«ä¹‹å¿ƒï¼‰- è¿¦é¡¿ç”·çˆµæ‰è½ï¼ˆæŠ¤è‚©/é€é£è€…éƒ¨ä»¶ï¼‰ ====================
    EQ_177: {
        id: 'EQ_177',
        name: 'åŠ›é‡è‚©é“ ',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_15.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 5200,
            armor: 220,
            mastery: 12,
            blockRate: 4,
            blockValue: 420
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2
        },
        setId: 'might_set',
        setName: 'åŠ›é‡'
    },
    EQ_178: {
        id: 'EQ_178',
        name: 'å¤œå¹•æ€æ‰‹æŠ¤è‚©',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_25.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 480,
            hp: 3600,
            armor: 170,
            critRate: 12,
            haste: 16
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            haste: 2
        },
        setId: 'nightslayer_set',
        setName: 'å¤œå¹•æ€æ‰‹'
    },
    EQ_179: {
        id: 'EQ_179',
        name: 'å¥¥æœ¯å¸ˆè¡¬è‚©',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_02.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 480,
            hp: 3400,
            critRate: 12,
            haste: 16
        },
        growth: {
            spellPower: 2,
            hp: 2,
            critRate: 2,
            haste: 2
        },
        setId: 'arcanist_set',
        setName: 'å¥¥æœ¯å¸ˆ'
    },
    EQ_180: {
        id: 'EQ_180',
        name: 'é¢„è¨€è¡¬è‚©',
        icon: "icons/wow/vanilla/armor/INV_Shoulder_02.png",
        type: 'equipment',
        slot: 'shoulder',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 450,
            hp: 3800,
            mastery: 12,
            critRate: 16
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            critRate: 2
        },
        setId: 'prophecy_set',
        setName: 'é¢„è¨€'
    },
    EQ_181: {
        id: 'EQ_181',
        name: 'é€é£è€…çš„ç¦é”¢ä¹‹é¢…ï¼ˆå·¦ï¼‰',
        icon: "icons/wow/vanilla/spells/Spell_Ice_Lament.png",
        type: 'equipment',
        slot: 'offHand',
        rarity: 'orange',
        level: 0,
        maxLevel: 100,
        baseStats: {
            // æ— å±æ€§ï¼ˆç”¨äºåç»­åˆæˆ/æ”¶è—ç­‰ï¼‰
        },
        growth: {
            // æ— æˆé•¿
        },
    },

    // ==================== Legendaryï¼ˆæ©™è‰²ï¼‰- é€é£è€…éƒ¨ä»¶åˆæˆï¼šé£å‰‘ ====================
    EQ_182: {
        id: 'EQ_182',
        name: 'é›·éœ†ä¹‹æ€’ï¼Œé€é£è€…çš„ç¥ç¦ä¹‹å‰‘',
        icon: "icons/wow/vanilla/weapons/INV_Sword_39.png",
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'orange',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 2500,
            hp: 6500,
            magicResist: 200,
            mastery: 25,
            versatility: 25,
            haste: 25,
        },
        growth: {
            attack: 2,
            hp: 2,
            magicResist: 2,
            mastery: 2,
            versatility: 2,
            haste: 2,
        },
        specialEffect: {
            type: 'thunderfury',
            name: 'é£æ€’é—ªç”µé“¾',
            trigger: 'turn_start',
            chance: 0.20,
            damageMult: 1.2,
            damageType: 'nature',
            selfDamageTakenMult: 0.8,
            selfBuffDuration: 2,
            damageReduction: 0.2,
        },
    },
    // ==================== Molten Coreï¼ˆç†”ç«ä¹‹å¿ƒï¼‰- ç„šåŒ–è€…å¤é›·æ›¼æ ¼æ‰è½ï¼ˆè…¿éƒ¨ï¼‰ ====================
    EQ_183: {
        id: 'EQ_183',
        name: 'åŠ›é‡è…¿é“ ',
        icon: "icons/wow/vanilla/armor/INV_Pants_04.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 6800,
            armor: 240,
            mastery: 12,
            blockRate: 5,
            blockValue: 500,
        },
        growth: {
            hp: 2,
            armor: 2,
            mastery: 2,
            blockRate: 2,
            blockValue: 2,
        },
        setId: 'might_set',
        setName: 'åŠ›é‡'
    },
    EQ_184: {
        id: 'EQ_184',
        name: 'å¤œå¹•æ€æ‰‹çŸ­è£¤',
        icon: "icons/wow/vanilla/armor/INV_Pants_06.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 520,
            hp: 4000,
            armor: 180,
            critRate: 12,
            mastery: 16,
        },
        growth: {
            attack: 2,
            hp: 2,
            armor: 2,
            critRate: 2,
            mastery: 2,
        },
        setId: 'nightslayer_set',
        setName: 'å¤œå¹•æ€æ‰‹'
    },
    EQ_185: {
        id: 'EQ_185',
        name: 'å¥¥æœ¯å¸ˆæŠ¤è…¿',
        icon: "icons/wow/vanilla/armor/INV_Pants_08.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 520,
            hp: 3800,
            haste: 12,
            versatility: 16,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            haste: 2,
            versatility: 2,
        },
        setId: 'arcanist_set',
        setName: 'å¥¥æœ¯å¸ˆ'
    },
    EQ_186: {
        id: 'EQ_186',
        name: 'é¢„è¨€çŸ­è£¤',
        icon: "icons/wow/vanilla/armor/INV_Pants_08.png",
        type: 'equipment',
        slot: 'legs',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            spellPower: 480,
            hp: 4200,
            mastery: 12,
            versatility: 16,
        },
        growth: {
            spellPower: 2,
            hp: 2,
            mastery: 2,
            versatility: 2,
        },
        setId: 'prophecy_set',
        setName: 'é¢„è¨€'
    },
    // ==================== Molten Coreï¼ˆç†”ç«ä¹‹å¿ƒï¼‰- ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯æ‰è½ï¼ˆèƒ¸ç”²ï¼‰ ====================
    EQ_187: {
      id: 'EQ_187',
      name: 'åŠ›é‡èƒ¸ç”²',
      icon: "icons/wow/vanilla/armor/INV_Chest_Plate16.png",
      type: 'equipment',
      slot: 'chest',
      rarity: 'purple',
      level: 0,
      maxLevel: 100,
      baseStats: {
        hp: 7200,
        armor: 260,
        blockRate: 5,
        blockValue: 540,
        versatility: 16,
      },
      growth: { hp: 2, armor: 2, blockRate: 2, blockValue: 2, versatility: 2 },
      setId: 'might_set',
      setName: 'åŠ›é‡'
    },
    EQ_188: {
      id: 'EQ_188',
      name: 'å¤œå¹•æ€æ‰‹èƒ¸ç”²',
      icon: "icons/wow/vanilla/armor/INV_Chest_Cloth_07.png",
      type: 'equipment',
      slot: 'chest',
      rarity: 'purple',
      level: 0,
      maxLevel: 100,
      baseStats: {
        attack: 560,
        hp: 4200,
        armor: 190,
        critRate: 12,
        mastery: 16,
      },
      growth: { attack: 2, hp: 2, armor: 2, critRate: 2, haste: 2, mastery: 2 },
      setId: 'nightslayer_set',
      setName: 'å¤œå¹•æ€æ‰‹'
    },
    EQ_189: {
      id: 'EQ_189',
      name: 'å¥¥æœ¯å¸ˆé•¿è¢',
      icon: "icons/wow/vanilla/armor/INV_Chest_Cloth_03.png",
      type: 'equipment',
      slot: 'chest',
      rarity: 'purple',
      level: 0,
      maxLevel: 100,
      baseStats: {
        spellPower: 560,
        hp: 4000,
        critRate: 12,
        mastery: 16,
      },
      growth: { spellPower: 2, hp: 2, critRate: 2, mastery: 2 },
      setId: 'arcanist_set',
      setName: 'å¥¥æœ¯å¸ˆ'
    },
    EQ_190: {
      id: 'EQ_190',
      name: 'é¢„è¨€æ³•è¢',
      icon: "icons/wow/vanilla/armor/INV_Chest_Cloth_03.png",
      type: 'equipment',
      slot: 'chest',
      rarity: 'purple',
      level: 0,
      maxLevel: 100,
      baseStats: {
        spellPower: 520,
        hp: 4600,
        mastery: 12,
        critRate: 16,
      },
      growth: { spellPower: 2, hp: 2, versatility: 2, critRate: 2 },
      setId: 'prophecy_set',
      setName: 'é¢„è¨€'
    },

    // ==================== Molten Coreï¼ˆç†”ç«ä¹‹å¿ƒï¼‰- æ‹‰æ ¼çº³ç½—æ–¯æ‰è½ ====================
    EQ_191: {
      id: 'EQ_191',
      name: 'æ„¤æ€’è…¿é“ ',
      icon: 'icons/wow/vanilla/armor/INV_Pants_04.png',
      type: 'equipment',
      slot: 'legs',
      rarity: 'purple',
      level: 1,
      maxLevel: 100,
      baseStats: { hp: 8000, armor: 270, mastery: 13, blockRate: 6, blockValue: 600 },
      growth: { hp: 2, armor: 2, mastery: 2, blockRate: 2, blockValue: 2 },
      setId: 'wrath_set',
      setName: 'æ„¤æ€’'
    },

    EQ_192: {
      id: 'EQ_192',
      name: 'è¡€ç‰™çŸ­è£¤',
      icon: 'icons/wow/vanilla/armor/INV_Pants_06.png',
      type: 'equipment',
      slot: 'legs',
      rarity: 'purple',
      level: 1,
      maxLevel: 100,
      baseStats: { attack: 650, hp: 4800, armor: 210, critRate: 14, mastery: 16 },
      growth: { attack: 2, hp: 2, armor: 2, critRate: 2, mastery: 2 },
      setId: 'bloodfang_set',
      setName: 'è¡€ç‰™'
    },

    EQ_193: {
      id: 'EQ_193',
      name: 'çµé£çŸ­è£¤',
      icon: 'icons/wow/vanilla/armor/INV_Pants_08.png',
      type: 'equipment',
      slot: 'legs',
      rarity: 'purple',
      level: 1,
      maxLevel: 100,
      baseStats: { spellPower: 650, hp: 4800, haste: 14, versatility: 16 },
      growth: { spellPower: 2, hp: 2, haste: 2, versatility: 2 },
      setId: 'netherwind_set',
      setName: 'çµé£'
    },

    EQ_194: {
      id: 'EQ_194',
      name: 'å“è¶ŠæŠ¤è…¿',
      icon: 'icons/wow/vanilla/armor/INV_Pants_09.png',
      type: 'equipment',
      slot: 'legs',
      rarity: 'purple',
      level: 1,
      maxLevel: 100,
      baseStats: { spellPower: 580, hp: 5300, mastery: 14, versatility: 16 },
      growth: { spellPower: 2, hp: 2, mastery: 2, versatility: 2 },
      setId: 'transcendence_set',
      setName: 'å“è¶Š'
    },

    EQ_195: {
      id: 'EQ_195',
      name: 'åŸƒå¤é›·äºšæŒ‡ç¯',
      icon: 'icons/wow/vanilla/armor/INV_Jewelry_Ring_15.png',
      type: 'equipment',
      slot: 'ring2',
      rarity: 'purple',
      level: 1,
      maxLevel: 100,
      baseStats: { attack: 620, hp: 4800, critRate: 14, haste: 22, mastery: 22 },
      growth: { attack: 2, hp: 2, critRate: 2, haste: 2, mastery: 2 }
    },

    EQ_196: {
      id: 'EQ_196',
      name: 'ç¯é›¾æŠ«é£',
      icon: 'icons/wow/vanilla/armor/INV_Misc_Cape_17.png',
      type: 'equipment',
      slot: 'cloak',
      rarity: 'purple',
      level: 1,
      maxLevel: 100,
      baseStats: { hp: 5200, armor: 180, magicResist: 260, versatility: 24 },
      growth: { hp: 2, armor: 2, magicResist: 2, versatility: 2 }
    },

    EQ_197: {
      id: 'EQ_197',
      name: 'ç«ç„°ä¹‹ç‹çš„é¡¹åœˆ',
      icon: 'icons/wow/vanilla/armor/INV_Jewelry_Amulet_05.png',
      type: 'equipment',
      slot: 'neck',
      rarity: 'purple',
      level: 1,
      maxLevel: 100,
      baseStats: { spellPower: 720, hp: 5500, critRate: 12, versatility: 20, mastery: 22 },
      growth: { spellPower: 2, hp: 2, critRate: 2, versatility: 2, mastery: 2 }
    },

    EQ_198: {
      id: 'EQ_198',
      name: 'è„Šéª¨æ”¶å‰²è€…',
      icon: 'icons/wow/vanilla/weapons/INV_Axe_09.png',
      type: 'equipment',
      slot: 'mainHand',
      rarity: 'purple',
      level: 1,
      maxLevel: 100,
      baseStats: { attack: 2250, hp: 4000, critRate: 20, critDamage: 0.8, versatility: 30 },
      growth: { attack: 2, hp: 2, critRate: 2, critDamage: 2, versatility: 2 },
      specialEffect: {
        type: 'map_slayer',
        bonusDamageVsMap: 0.40
      }
    },

    EQ_199: {
      id: 'EQ_199',
      name: 'è¨å¼—æ‹‰æ–¯æŒ‡ç¯',
      icon: 'icons/wow/vanilla/armor/safulasizhihuan.png',
      type: 'equipment',
      slot: 'ring2',
      rarity: 'purple',
      level: 1,
      maxLevel: 100,
      baseStats: { spellPower: 680, hp: 5200, critRate: 12, mastery: 22, versatility: 20 },
      growth: { spellPower: 2, hp: 2, critRate: 2, mastery: 2, versatility: 2 }
    },

    EQ_200: {
      id: 'EQ_200',
      name: 'å‰Šéª¨ä¹‹åˆƒ',
      icon: 'icons/wow/vanilla/weapons/INV_Sword_12.png',
      type: 'equipment',
      slot: 'mainHand',
      rarity: 'purple',
      level: 1,
      maxLevel: 100,
      baseStats: { attack: 2400, hp: 4800, critRate: 20, critDamage: 0.8, mastery: 30 },
      growth: { attack: 2, hp: 2, critRate: 2, critDamage: 2, mastery: 2 },
      specialEffect: {
        type: 'ignore_defense',
        pct: 0.50
      }
    },

    EQ_201: {
      id: 'EQ_201',
      name: 'è¨å¼—æ‹‰æ–¯ï¼Œç‚é­”æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ‰‹',
      icon: 'icons/wow/vanilla/weapons/safulasi.png',
      type: 'equipment',
      slot: 'mainHand',
      rarity: 'orange',
      level: 1,
      maxLevel: 100,
      baseStats: { attack: 2500, hp: 6000, magicResist: 250, critRate: 20, critDamage: 0.8, versatility: 30 },
      growth: { attack: 2, hp: 2, magicResist: 2, critRate: 2, critDamage: 2, versatility: 2 },
      specialEffects: [
        {
          type: 'proc_stat',
          name: 'è¨å¼—æ‹‰æ–¯ä¹‹åŠ›',
          trigger: 'turn_start',
          chance: 0.25,
          stats: { attack: 2000 },
          scaleWithLevel: true
        },
        {
          type: 'proc_damage',
          name: 'ç«ç„°ç®­',
          trigger: 'turn_start',
          chance: 0.25,
          school: 'fire',
          basedOn: 'attack',
          damageMult: 1.5,
          scaleWithLevel: true
        }
      ]
    },


};

//èµ¤è„Šå±±5ä»¶å›¾é‰´100çº§ç‚¹äº®æ•ˆæœ
const REDRIDGE_LV100_SET = ['EQ_014', 'EQ_015', 'EQ_016', 'EQ_017', 'EQ_018'];
// è´«ç˜ ä¹‹åœ°æ¯’è›‡çš„æ‹¥æŠ±6ä»¶è£…å¤‡å…¨éƒ¨è¾¾åˆ°è¿‡Lv.100 â†’ å…¨é˜Ÿçˆ†å‡»ç‡+5
const BARRENS_LV100_SET = ['EQ_019', 'EQ_020', 'EQ_021', 'EQ_022', 'EQ_023', 'EQ_024'];

//è†æ£˜è°·6ä»¶100çº§å›¾é‰´ç‚¹äº®æ•ˆæœ
const STRANGLETHORN_LV100_SET = ['EQ_027', 'EQ_028', 'EQ_029', 'EQ_030', 'EQ_031', 'EQ_032'];

// å‡„å‡‰ä¹‹åœ° 6 ä»¶è£…å¤‡å…¨éƒ¨è¾¾åˆ°è¿‡ Lv.100 â†’ å…¨é˜Ÿç²¾é€š +5
const DESOLACE_LV100_SET = ['EQ_035', 'EQ_036', 'EQ_037', 'EQ_038', 'EQ_039', 'EQ_040'];
// è¡€è‰²ä¿®é“é™¢ 13 ä»¶è£…å¤‡å…¨éƒ¨è¾¾åˆ°è¿‡ Lv.100 â†’ å…¨é˜Ÿæ”»å‡»å¼ºåº¦+200 æ³•æœ¯å¼ºåº¦+200
const SCARLET_MONASTERY_LV100_SET = [
    'EQ_049', 'EQ_050', 'EQ_051', 'EQ_052', 'EQ_053', 'EQ_054',
    'EQ_055', 'EQ_056', 'EQ_057', 'EQ_058', 'EQ_059', 'EQ_060', 'EQ_061'
];
// æ²‰æ²¡çš„ç¥åº™10ä»¶ 10å…¨èƒ½
const SUNKEN_TEMPLE_LV100_SET = ['EQ_064', 'EQ_065', 'EQ_066', 'EQ_067', 'EQ_068', 'EQ_069', 'EQ_070', 'EQ_071', 'EQ_072', 'EQ_073'];

// é»‘çŸ³å¡”ä¸‹14ä»¶ 10æš´å‡»
const LOWER_BLACKROCK_SPIRE_LV100_SET = ['EQ_074', 'EQ_075', 'EQ_076', 'EQ_077', 'EQ_078', 'EQ_069', 'EQ_079', 'EQ_080', 'EQ_081', 'EQ_082', 'EQ_083', 'EQ_084', 'EQ_085', 'EQ_086'];

// é€šçµå­¦é™¢8ä»¶ 10ç²¾é€š
const SCHOLOMANCE_LV100_SET = ['EQ_087', 'EQ_088', 'EQ_089', 'EQ_090', 'EQ_091', 'EQ_092', 'EQ_093', 'EQ_094'];

// æ–¯å¦ç´¢å§†8ä»¶ 10æ€¥é€Ÿ
const STRATHOLME_lv100_SET = ['EQ_095', 'EQ_096', 'EQ_097', 'EQ_098', 'EQ_099', 'EQ_100', 'EQ_101', 'EQ_102'];

// é»‘çŸ³å¡”ä¸Š10ä»¶ 500æ”»å‡»å¼ºåº¦/æ³•æœ¯å¼ºåº¦
const UPPER_BLACKROCK_SPIRE_LV100_SET = ['EQ_103', 'EQ_104', 'EQ_105', 'EQ_106', 'EQ_107', 'EQ_108', 'EQ_109', 'EQ_110', 'EQ_111', 'EQ_112'];

// ç¥–å°”æ ¼æ‹‰å¸ƒ 8 ä»¶è£…å¤‡å…¨éƒ¨è¾¾åˆ°è¿‡ Lv.100 â†’ æš´å‡»ä¼¤å®³ +20%
const ZUL_GURUB_LV100_SET = ['EQ_131', 'EQ_132', 'EQ_133', 'EQ_134', 'EQ_135', 'EQ_136', 'EQ_137', 'EQ_138'];

// å®‰çªæ‹‰åºŸå¢Ÿ 7 ä»¶è£…å¤‡å…¨éƒ¨è¾¾åˆ°è¿‡ Lv.100 â†’ å…¨é˜ŸæŠ¤ç”² +300ï¼Œé­”æ³•æŠ—æ€§ +100
const RUINS_OF_AHNQIRAJ_LV100_SET = ['EQ_139', 'EQ_140', 'EQ_141', 'EQ_142', 'EQ_143', 'EQ_144', 'EQ_145'];

// ç†”ç«ä¹‹å¿ƒï¼ˆåœ°å›¾æ‰è½ï¼‰26 ä»¶è£…å¤‡å…¨éƒ¨è¾¾åˆ°è¿‡ Lv.100 â†’ å…¨é˜Ÿæ”»å‡» +800ï¼Œæ³•å¼º +800ï¼Œé­”æ³•æŠ—æ€§ +200
const MOLTEN_CORE_LV100_SET = [
    'EQ_146', 'EQ_147', 'EQ_148', 'EQ_149',
    'EQ_150', 'EQ_151', 'EQ_152', 'EQ_153',
    'EQ_154', 'EQ_155', 'EQ_156', 'EQ_157',
    'EQ_158', 'EQ_159', 'EQ_160', 'EQ_161',
    'EQ_162', 'EQ_163', 'EQ_164', 'EQ_165',
    'EQ_166', 'EQ_167', 'EQ_168', 'EQ_169',
    'EQ_170', 'EQ_171'
];

// ==================== å›¾é‰´é›†é½æ•ˆæœé…ç½® ====================
const CODEX_SET_EFFECTS = [
    {
        id: 'redridge',
        name: 'èµ¤è„Šå±±',
        equipIds: REDRIDGE_LV100_SET,
        effect: 'å…¨é˜Ÿå…¨èƒ½ +5',
        color: '#4CAF50'
    },
    {
        id: 'barrens',
        name: 'è´«ç˜ ä¹‹åœ°',
        equipIds: BARRENS_LV100_SET,
        effect: 'å…¨é˜Ÿçˆ†å‡»ç‡ +5%',
        color: '#ff9800'
    },
    {
        id: 'stranglethorn',
        name: 'è†æ£˜è°·',
        equipIds: STRANGLETHORN_LV100_SET,
        effect: 'å…¨é˜Ÿæ€¥é€Ÿ +5',
        color: '#2196F3'
    },
    {
        id: 'desolace',
        name: 'å‡„å‡‰ä¹‹åœ°',
        equipIds: DESOLACE_LV100_SET,
        effect: 'å…¨é˜Ÿç²¾é€š +5',
        color: '#9C27B0'
    },
    {
        id: 'scarlet_monastery',
        name: 'è¡€è‰²ä¿®é“é™¢',
        equipIds: SCARLET_MONASTERY_LV100_SET,
        effect: 'å…¨é˜Ÿæ”»å‡» +200ï¼Œæ³•å¼º +200',
        color: '#f44336'
    },
    {
        id: 'susas',
        name: 'é­ç¬è€…è‹è¨æ–¯',
        equipIds: ['EQ_044'],
        effect: 'å…¨é˜Ÿå…¨èƒ½ +5ï¼Œæ€¥é€Ÿ +10ï¼Œç²¾é€š +10',
        color: '#ff8000'
    },
    {
        id: 'sunken_temple',
        name: 'æ²‰æ²¡çš„ç¥åº™',
        equipIds: SUNKEN_TEMPLE_LV100_SET,
        effect: 'å…¨é˜Ÿå…¨èƒ½ +10',
        color: '#00bcd4'
    },
    {
        id: 'lower_blackrock_spire',
        name: 'é»‘çŸ³å¡”ä¸‹',
        equipIds: LOWER_BLACKROCK_SPIRE_LV100_SET,
        effect: 'å…¨é˜Ÿæš´å‡» +10',
        color: '#ff9800'
    },
    {
        id: 'scholomance',
        name: 'é€šçµå­¦é™¢',
        equipIds: SCHOLOMANCE_LV100_SET,
        effect: 'å…¨é˜Ÿç²¾é€š +10',
        color: '#9C27B0'
    },
    {
        id: 'stratholme',
        name: 'æ–¯å¦ç´¢å§†',
        equipIds: STRATHOLME_lv100_SET,
        effect: 'å…¨é˜Ÿæ€¥é€Ÿ +10',
        color: '#2196F3'
    },
    {
        id: 'upper_blackrock_spire',
        name: 'é»‘çŸ³å¡”ä¸Š',
        equipIds: UPPER_BLACKROCK_SPIRE_LV100_SET,
        effect: 'å…¨é˜Ÿæ”»å‡» +500ï¼Œæ³•å¼º +500',
        color: '#f44336'
    },
    {
        id: 'zul_gurub',
        name: 'ç¥–å°”æ ¼æ‹‰å¸ƒ',
        equipIds: ZUL_GURUB_LV100_SET,
        effect: 'å…¨é˜Ÿæš´å‡»ä¼¤å®³ +20%',
        color: '#8bc34a'
    },
    {
        id: 'ruins_of_ahnqiraj',
        name: 'å®‰çªæ‹‰åºŸå¢Ÿ',
        equipIds: RUINS_OF_AHNQIRAJ_LV100_SET,
        effect: 'å…¨é˜ŸæŠ¤ç”² +300ï¼Œé­”æ³•æŠ—æ€§ +100',
        color: '#d4af37'
    },
    {
        id: 'molten_core',
        name: 'ç†”ç«ä¹‹å¿ƒ',
        equipIds: MOLTEN_CORE_LV100_SET,
        effect: 'å…¨é˜Ÿæ”»å‡» +800ï¼Œæ³•å¼º +800ï¼Œé­”æ³•æŠ—æ€§ +200',
        color: '#ff5722'
    }
];

// ==================== åéª‘å›¾é‰´ï¼ˆä¸å èƒŒåŒ…ï¼‰ ====================
// è¯´æ˜ï¼šåéª‘é€šè¿‡æ‰è½â€œç‚¹äº®å›¾é‰´â€ï¼Œä¸ä¼šè¿›å…¥é“å…·æ /èƒŒåŒ…ã€‚
// å›¾ç‰‡ URL é¢„ç•™ï¼šimageUrl å…ˆç•™ç©ºï¼Œåç»­å¡«å…¥å³å¯ã€‚
const MOUNT_CODEX = [
    {
        id: 'MOUNT_DEATHCHARGER',
        name: 'æ­»äº¡å†›é©¬',
        icon: 'ğŸ´',
        imageUrl: 'icons/wow/vanilla/rider/siwangjunma.png',
        source: 'å‡»æ€ã€ç‘æ–‡æˆ´å°”ç”·çˆµã€‘',
        bossId: 'baron_rivendare',
        dropChance: 0.01, // 1%
        // âœ… åéª‘åŠ æˆä½¿ç”¨â€œä¹˜ç®—å€ç‡â€ï¼ˆä¸å…¶å®ƒæ¥æºçš„åŠ æˆä¹˜ç®—å åŠ ï¼‰
        bonus: { expMult: 1.10 }, // å…¨å±€ï¼šç»éªŒè·å– x1.10
    },
    {
        id: 'MOUNT_TYRAELS_CHARGER',
        name: 'æ³°ç‘å°”çš„æˆ˜é©¬',
        icon: 'ğŸ',
        imageUrl: 'icons/wow/vanilla/rider/tairuier.png',
        source: 'æ—¶ç©ºå•†åŸ',
        // å•†åŸåéª‘ï¼šè´­ä¹°åç›´æ¥ç‚¹äº®å›¾é‰´ï¼ˆä¸è¿›èƒŒåŒ…ï¼‰ï¼Œæ— æ‰è½ç‡
        bonus: { goldMult: 1.20 }, // å…¨å±€ï¼šé‡‘å¸æ‰è½ x1.20
    },
    {
        id: 'MOUNT_RAZZASHI_RAPTOR',
        name: 'æ‹‰æ‰ä»€è¿…çŒ›é¾™',
        icon: 'ğŸ¦–',
        imageUrl: 'icons/wow/vanilla/rider/lazhashixunmenglong.png',
        source: 'ç¥–å°”æ ¼æ‹‰å¸ƒæ‰è½',
        zoneId: 'zul_gurub',
        dropChance: 0.0005, // 0.05%
        bonus: { goldMult: 1.10 }, // é‡‘å¸æ‰è½ x1.10
    },
    {
        id: 'MOUNT_SWIFT_ZULIAN_TIGER',
        name: 'è¿…æ·ç¥–åˆ©å®‰çŒ›è™',
        icon: 'ğŸ…',
        imageUrl: 'icons/wow/vanilla/rider/zulianmenghu.png',
        source: 'ç¥–å°”æ ¼æ‹‰å¸ƒæ‰è½',
        zoneId: 'zul_gurub',
        dropChance: 0.0005, // 0.05%
        bonus: { resourceMult: 1.10 }, // èµ„æºç”Ÿäº§é€Ÿåº¦ x1.10
    },
];

// ==================== æ—¶ç©ºå•†åŸï¼ˆä½¿ç”¨æ—¶ç©ºå¸ï¼‰ ====================
// è¯´æ˜ï¼šå•†åŸç‰©å“é€šå¸¸ä¸ä¼šè¿›å…¥èƒŒåŒ…ï¼›ä¾‹å¦‚â€œåéª‘â€ä¼šç›´æ¥ç‚¹äº®å›¾é‰´ï¼Œå¹¶æä¾›å…¨å±€åŠ æˆã€‚
const SPACETIME_SHOP_ITEMS = [
    {
        id: 'SHOP_MOUNT_TYRAELS_CHARGER',
        type: 'mount',
        name: 'æ³°ç‘å°”çš„æˆ˜é©¬',
        icon: 'ğŸ',
        imageUrl: 'icons/wow/vanilla/rider/tairuier.png',
        price: 5000,
        currencyKey: 'spacetimeCoin',
        currencyIcon: 'ğŸŒ€',
        mountId: 'MOUNT_TYRAELS_CHARGER',
        bonus: { goldMult: 1.20 }, // å…¨å±€ï¼šé‡‘å¸æ‰è½ +20%
        description: 'åœ£å…‰ç©¿è¶Šæ—¶ç©ºè€Œæ¥ã€‚è´­ä¹°åå°†ç›´æ¥ç‚¹äº®ã€åéª‘å›¾é‰´ã€‘ï¼Œå¹¶æ°¸ä¹…è·å¾—é‡‘å¸æ‰è½åŠ æˆã€‚',
        flavor: 'â€œå³ä¾¿ä¸–ç•Œç ´ç¢ï¼Œåœ£å…‰äº¦å°†ç…§è€€å‰è·¯ã€‚â€',
        rarity: 'legendary'
    },
];

// ==================== RARITY COLORS ====================
const RARITY_COLORS = {
    white: '#d9d9d9',
    green: '#1eff00',
    blue: '#0070dd',
    purple: '#a335ee',
    orange: '#ff8000',
    gold: '#ffd700'
};

const getRarityColor = (rarity) => {
    if (!rarity) return '#4a3c2a';
    return RARITY_COLORS[rarity] || '#4a3c2a';
};

// ==================== è®¡ç®—è§’è‰²é‡‡é›†å±æ€§ ====================
// ==================== è®¡ç®—è§’è‰²é‡‡é›†å±æ€§ï¼ˆå«è£…å¤‡åŠ æˆï¼‰ ====================
function calculateGatherStats(character) {
    const classData = CLASSES[character.classId];
    const baseGather = classData.baseGatherStats || { proficiency: 5, precision: 5, perception: 5 };

    // åŸºç¡€å€¼ + ç­‰çº§åŠ æˆ
    const levelBonus = Math.floor(character.level / 5);

    // è£…å¤‡åŠ æˆ
    let equipProficiency = 0;
    let equipPrecision = 0;
    let equipPerception = 0;

    Object.values(character.equipment || {}).forEach(item => {
        if (item && item.stats) {
            equipProficiency += item.stats.proficiency || 0;
            equipPrecision += item.stats.precision || 0;
            equipPerception += item.stats.perception || 0;
        }
    });

    // âœ… ç§æ—é‡‡é›†å±æ€§åŠ æˆï¼ˆä¾‹å¦‚ï¼šä¾å„’ã€ç†Ÿç¨”ã€‘ï¼‰
    const raceTrait = RACE_TRAITS?.[character.race];
    const gatherBonus = raceTrait?.gatherStatBonus || {};

    return {
        proficiency: baseGather.proficiency + levelBonus + equipProficiency + (gatherBonus.proficiency || 0),
        precision: baseGather.precision + levelBonus + equipPrecision + (gatherBonus.precision || 0),
        perception: baseGather.perception + levelBonus + equipPerception + (gatherBonus.perception || 0),
    };
}

// ==================== è®¡ç®—å»ºç­‘äº§å‡º ====================
function calculateBuildingProduction(building, workers, gameState) {
    if (!workers || workers.length === 0) return 0;

    const buildingData = RESOURCE_BUILDINGS[building];
    if (!buildingData) return 0;

    // ===== ç ”ç©¶åŠ æˆï¼ˆæŒ‰èµ„æºç±»å‹ç”Ÿæ•ˆï¼‰ =====
    // ä¾‹ï¼šä¼æœ¨ç²¾é€š(effect='wood') ä¼šæå‡ resourceType='wood' çš„äº§å‡º
    let researchBonus = 0;
    const resType = buildingData.resourceType;
    const researchLv = gameState?.research || {};
    Object.entries(researchLv).forEach(([rid, lv]) => {
        const r = RESEARCH?.[rid];
        if (r && r.effect === resType) {
            researchBonus += (r.bonus || 0) * (lv || 0);
        }
    });

    let totalProduction = 0;

    workers.forEach(charId => {
        const char = gameState.characters.find(c => c.id === charId);
        if (!char) return;

        const gatherStats = calculateGatherStats(char);
        const weights = buildingData.statWeights;

        // æ•ˆç‡è®¡ç®—ï¼šåŸºç¡€äº§é‡ * (1 + åŠ æƒå±æ€§/100)
        const weightedStat =
            gatherStats.proficiency * weights.proficiency +
            gatherStats.precision * weights.precision +
            gatherStats.perception * weights.perception;

        let efficiency = 1 + weightedStat / 10;

        // ===== æ–°å¢ï¼šå¥—è£…æ•ˆæœ gatherEfficiency =====
        const setBonuses = getSetBonusesForCharacter(char);
        for (const set of setBonuses) {
            for (const tier of set.activated) {
                if (tier.bonus?.gatherEfficiency) {
                    efficiency *= (1 + tier.bonus.gatherEfficiency);
                }
            }
        }

        // ç ”ç©¶æ•ˆç‡ï¼ˆä¼æœ¨/é‡‡çŸ¿/é‡‡é›†æ‰€/æŒ–æ¯›çš®ç­‰ï¼‰
        if (researchBonus > 0) {
            efficiency *= (1 + researchBonus);
        }

        const production = buildingData.baseProduction * efficiency;

        // ç²¾ç»†å±æ€§ï¼šæœ‰æ¦‚ç‡è·å¾—åŒå€äº§å‡º
        const doubleChance = gatherStats.precision / 200;
        const finalProduction = Math.random() < doubleChance ? production * 2 : production;

        totalProduction += finalProduction;
    });

    // âœ… æˆå°±ï¼šæ‰€æœ‰å»ºç­‘äº§é‡åŠ æˆï¼ˆå»ºè®¾è€…ç³»åˆ—ç­‰ï¼‰
    const achResourceBonus = getAchievementResourceBonus(gameState);
    const { resourceMult } = getMountMultipliers(gameState);
    return totalProduction * (1 + achResourceBonus) * (resourceMult || 1);
}

const ITEMS = {
    IT_001: {
        id: 'IT_001',
        name: 'ç ´çƒ‚çš„æ¯›çš®',
        type: 'junk',
        rarity: 'white',
        sellPrice: 200,
        icon: 'icons/wow/vanilla/items/INV_Banner_03.png'
    },
    IT_STV_001: {
        id: 'IT_STV_001',
        name: 'è†æ£˜è°·çš„é’å±±Â·ç¬¬ä¸€ç« ',
        type: 'junk',
        rarity: 'white',
        sellPrice: 5000
    },
    IT_STV_002: {
        id: 'IT_STV_002',
        name: 'è†æ£˜è°·çš„é’å±±Â·ç¬¬äºŒç« ',
        type: 'junk',
        rarity: 'white',
        sellPrice: 5000
    },
    IT_STV_003: {
        id: 'IT_STV_003',
        name: 'è†æ£˜è°·çš„é’å±±Â·ç¬¬ä¸‰ç« ',
        type: 'junk',
        rarity: 'white',
        sellPrice: 5000
    },
    IT_STV_004: {
        id: 'IT_STV_004',
        name: 'è†æ£˜è°·çš„é’å±±Â·ç¬¬å››ç« ',
        type: 'junk',
        rarity: 'white',
        sellPrice: 5000
    },
    // é»‘é¾™åŒ–èº«çš„è¯æ˜
    IT_BLACK_DRAGON_PROOF: {
        id: 'IT_BLACK_DRAGON_PROOF',
        name: 'é»‘é¾™åŒ–èº«çš„è¯æ˜',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Head_Dragon_01.png',
        description: 'ä½¿ç”¨åï¼Œæ­éœ²çœŸç›¸ï¼Œè§£é”éšè—Bossã€æ™®ç‘æ–¯æ‰˜å¥³å£«ã€‘'
    },
    // éœæ ¼çš„æ²¾è¡€å¾½ç« ï¼ˆéœæ ¼æ‰è½ï¼‰
    IT_HOGGER_BADGE: {
        id: 'IT_HOGGER_BADGE',
        name: 'éœæ ¼çš„æ²¾è¡€å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_ArmorKit_01.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€è‰¾å°”æ–‡æ£®æ—ï¼Œè¥¿éƒ¨è’é‡ï¼Œèµ¤è„Šå±±ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // è¡€è‰²åå­—å†›çš„å¾½ç« ï¼ˆè£‚é­‚è€…è¨å°”è¯ºæ–¯æ‰è½ï¼‰
    IT_SCARLET_CRUSADER_BADGE: {
        id: 'IT_SCARLET_CRUSADER_BADGE',
        name: 'è¡€è‰²åå­—å†›çš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_ArmorKit_10.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€è¡€è‰²ä¿®é“é™¢ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // è¿ªè²äºšå¾½ç« ï¼ˆèŒƒå…‹é‡Œå¤«æ‰è½ï¼‰
    IT_VANCLEEF_BADGE: {
        id: 'IT_VANCLEEF_BADGE',
        name: 'è¿ªè²äºšå¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/armor/INV_Jewelry_Talisman_05.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€è´«ç˜ ä¹‹åœ°ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // é»‘é¾™åŒ–èº«å¾½ç« ï¼ˆæ™®ç‘æ–¯æ‰˜æ‰è½ï¼‰
    IT_PRESTOR_BADGE: {
        id: 'IT_PRESTOR_BADGE',
        name: 'é»‘é¾™åŒ–èº«å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/armor/INV_Jewelry_Talisman_12.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€è†æ£˜è°·ï¼Œå¡”çº³åˆ©æ–¯ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // ç´¢ç‘æ£®å¤§å¸çš„å¾½ç« ï¼ˆè¾¾å°”æˆˆç´¢ç‘æ£®æ‰è½ï¼‰
    IT_THAURISSAN_BADGE: {
        id: 'IT_THAURISSAN_BADGE',
        name: 'ç´¢ç‘æ£®å¤§å¸çš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Rune_04.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€æ²‰æ²¡çš„ç¥åº™ï¼Œé»‘çŸ³æ·±æ¸Šã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    }
    ,

// åŠ ä¸çš„å¾½ç« ï¼ˆé»‘æš—é™¢é•¿åŠ ä¸æ‰è½ï¼‰
    IT_GANDLING_BADGE: {
        id: 'IT_GANDLING_BADGE',
        name: 'åŠ ä¸çš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Rune_08.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€é€šçµå­¦é™¢ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // ç‘æ–‡æˆ´å°”ç”·çˆµçš„å¾½ç« ï¼ˆç‘æ–‡æˆ´å°”ç”·çˆµæ‰è½ï¼‰
    IT_RIVENDARE_BADGE: {
        id: 'IT_RIVENDARE_BADGE',
        name: 'ç‘æ–‡æˆ´å°”ç”·çˆµçš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Rune_07.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€æ–¯å¦ç´¢å§†ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },
    // é›·å¾·é»‘æ‰‹çš„å¾½ç« ï¼ˆé›·å¾·é»‘æ‰‹æ‰è½ï¼‰
    IT_REND_BADGE: {
        id: 'IT_REND_BADGE',
        name: 'é›·å¾·é»‘æ‰‹çš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Rune_02.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€é»‘çŸ³å¡”ä¸Šã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },
    IT_HAKKAR_BADGE: {
        id: 'IT_HAKKAR_BADGE',
        name: 'å¤ºçµè€…çš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Idol_03.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€ç¥–å°”æ ¼æ‹‰å¸ƒã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },
    IT_OSSIRIAN_BADGE: {
        id: 'IT_OSSIRIAN_BADGE',
        name: 'æ— ç–¤è€…çš„å¾½ç« ',
        type: 'consumable',
        rarity: 'purple',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_StoneTablet_08.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€å®‰çªæ‹‰åºŸå¢Ÿã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰'
    },

    // ç«ç„°ä¹‹ç‹çš„å¾½ç« ï¼ˆæ‹‰æ ¼çº³ç½—æ–¯æ‰è½ï¼‰
    IT_RAGNAROS_BADGE: {
        id: 'IT_RAGNAROS_BADGE',
        name: 'ç«ç„°ä¹‹ç‹çš„å¾½ç« ',
        type: 'consumable',
        rarity: 'orange',
        canUse: true,
        sellPrice: 0,  // ä¸å¯å‡ºå”®
        icon: 'icons/wow/vanilla/items/INV_Misc_Rune_06.png',
        description: 'ä½¿ç”¨åé€‰æ‹©ä¸€ä»¶ã€ç†”ç«ä¹‹å¿ƒã€‘æˆ–ã€ç†”ç«ä¹‹å¿ƒBOSSã€‘æ‰è½è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ +2ï¼ˆæœ€é«˜100çº§ï¼‰ã€‚å¯ç”¨äºé£å‰‘/æ©™é”¤ç­‰ä¼ å¥‡è£…å¤‡ã€‚'
    }


};


const BUILDINGS = {
    house: { id: 'house', name: 'æ°‘å±…', cost: { gold: 100, wood: 50 }, production: { population: 2 }, consumption: {} },

};

function ItemIcon({ item, size = 28 }) {
    const src = item?.iconUrl || item?.icon;
    const isImg = typeof src === 'string' && (src.includes('/') || src.endsWith('.png'));

    if (isImg) {
        return (
            <img
                src={src}
                alt={item?.name || 'icon'}
                style={{ width: size, height: size, objectFit: 'contain', imageRendering: 'pixelated' }}
            />
        );
    }
    return <span style={{ fontSize: size }}>{src || 'ğŸ“¦'}</span>;
}

function SlotIcon({ slot, size = 28 }) {
    const info = EQUIPMENT_SLOTS?.[slot];
    // æ²¡æœ‰å›¾ç‰‡æ—¶å›é€€åˆ° emoji
    return <span style={{ fontSize: size }}>{info?.icon || "ğŸ“¦"}</span>;
}


const RESEARCH = {
    // æ¯çº§æå‡ 3%ï¼ˆ0.03ï¼‰
    lumber_mastery: {
        id: 'lumber_mastery',
        name: 'ä¼æœ¨ç²¾é€š',
        description: 'æå‡ä¼æœ¨æ•ˆç‡',
        baseCost: 500,
        effect: 'wood',
        bonus: 0.03,
    },
    mining_mastery: {
        id: 'mining_mastery',
        name: 'é‡‡çŸ¿ç²¾é€š',
        description: 'æå‡é‡‡çŸ¿æ•ˆç‡',
        baseCost: 500,
        effect: 'ironOre',
        bonus: 0.03,
    },

    // âœ… å‡»è´¥èŒƒå…‹é‡Œå¤«åè§£é”
    gathering_efficiency: {
        id: 'gathering_efficiency',
        name: 'é‡‡é›†ç²¾é€š',
        description: 'æå‡é‡‡é›†æ‰€é‡‡é›†è‰è¯çš„æ•ˆç‡ï¼ˆå‡»è´¥èŒƒå…‹é‡Œå¤«åè§£é”ï¼‰',
        baseCost: 1500,
        effect: 'herb',
        bonus: 0.03,
        unlockBoss: 'vancleef',
    },
    skinning_efficiency: {
        id: 'skinning_efficiency',
        name: 'æ•çŒç²¾é€š',
        description: 'æå‡çŒäººå°å±‹è·å–æ¯›çš®çš„æ•ˆç‡ï¼ˆå‡»è´¥èŒƒå…‹é‡Œå¤«åè§£é”ï¼‰',
        baseCost: 1500,
        effect: 'leather',
        bonus: 0.03,
        unlockBoss: 'vancleef',
    },

    // âœ… å‡»è´¥æ™®ç‘æ–¯æ‰˜å¥³å£«åè§£é”
    siphon_mastery: {
        id: 'siphon_mastery',
        name: 'æ±²é­”ç²¾é€š',
        description: 'æå‡é­”åŠ›ä¹‹æºæ±²å–é­”æ³•ç²¾åçš„æ•ˆç‡ï¼ˆå‡»è´¥æ™®ç‘æ–¯æ‰˜å¥³å£«åè§£é”ï¼‰',
        baseCost: 5000,
        effect: 'magicEssence',
        bonus: 0.03,
        unlockBoss: 'prestor_lady',
    },
    cast_iron_mastery: {
        id: 'cast_iron_mastery',
        name: 'é“¸é“ç²¾é€š',
        description: 'æå‡é“¸é€ å‚ç‚¼åˆ¶é“é”­çš„æ•ˆç‡ï¼ˆå‡»è´¥æ™®ç‘æ–¯æ‰˜å¥³å£«åè§£é”ï¼‰',
        baseCost: 5000,
        effect: 'ironIngot',
        bonus: 0.03,
        unlockBoss: 'prestor_lady',
    },
    // âœ… å‡»è´¥è£‚é­‚è€…è¨å°”è¯ºæ–¯åè§£é”
    alchemy_mastery: {
        id: 'alchemy_mastery',
        name: 'ç‚¼é‡‘ç²¾é€š',
        description: 'æå‡ç‚¼é‡‘æœ¯æ•ˆç‡ï¼ˆå‡»è´¥è£‚é­‚è€…è¨å°”è¯ºæ–¯åè§£é”ï¼‰',
        baseCost: 10000,
        effect: 'alchemyOil',
        bonus: 0.03,
        unlockBoss: 'thalnos',
    },
};

const ACHIEVEMENTS = {
    novice: { id: 'novice', name: 'åˆå‡ºèŒ…åº', description: 'è§’è‰²å‡çº§åˆ°10çº§', condition: (state) => state.characters.some(c => c.level >= 10), reward: { expBonus: 0.02 }, icon: 'âš”ï¸' },
    first_blood: { id: 'first_blood', name: 'åˆæˆ˜å‘Šæ·', description: 'å®Œæˆç¬¬ä¸€æ¬¡æˆ˜æ–—', condition: (state) => state.stats.battlesWon >= 1, reward: { goldBonus: 0.05 }, icon: 'ğŸ©¸' },
    tenli_po_sword_saint: {
        id: 'tenli_po_sword_saint',
        name: 'åé‡Œå¡å‰‘åœ£',
        description: 'åœ¨LV1åŒºåŸŸã€è‰¾å°”æ–‡æ£®æ—ã€‘å‡»æ€100000ä¸ªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        // è®¡æ•°æ¥æºï¼šstate.zoneKillCounts.elwynn_forestï¼ˆè·¨ä¸–ç´¯è®¡ï¼‰
        condition: (state) => (state.zoneKillCounts?.elwynn_forest || 0) >= 100000,
        // åœ°å›¾åŒºåŸŸæˆ˜æ–—ï¼šæ€»ä¼¤å®³ +5%
        reward: { mapDamageBonus: 0.05 },
        icon: 'ğŸ—¡ï¸'
    },

    // âœ… æ–°å¢ï¼šæŒç»­æˆ˜æ–—ç³»åˆ—ï¼ˆåœ°å›¾ç´¯è®¡å‡»æ€ï¼Œè·¨ä¸–ç´¯è®¡ï¼‰
    continuous_battle_1: {
        id: 'continuous_battle_1',
        name: 'æŒç»­æˆ˜æ–—â… ',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€1ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 10000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_2: {
        id: 'continuous_battle_2',
        name: 'æŒç»­æˆ˜æ–—â…¡',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€5ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 50000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_3: {
        id: 'continuous_battle_3',
        name: 'æŒç»­æˆ˜æ–—â…¢',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€10ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 100000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_4: {
        id: 'continuous_battle_4',
        name: 'æŒç»­æˆ˜æ–—â…£',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€50ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 500000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_5: {
        id: 'continuous_battle_5',
        name: 'æŒç»­æˆ˜æ–—â…¤',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€100ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 1000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_6: {
        id: 'continuous_battle_6',
        name: 'æŒç»­æˆ˜æ–—â…¥',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€500ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 5000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_7: {
        id: 'continuous_battle_7',
        name: 'æŒç»­æˆ˜æ–—â…¦',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€1000ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 10000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_8: {
        id: 'continuous_battle_8',
        name: 'æŒç»­æˆ˜æ–—â…§',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€5000ä¸‡åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 50000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_9: {
        id: 'continuous_battle_9',
        name: 'æŒç»­æˆ˜æ–—â…¨',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€1äº¿åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 100000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },
    continuous_battle_10: {
        id: 'continuous_battle_10',
        name: 'æŒç»­æˆ˜æ–—â…©',
        description: 'åœ¨åœ°å›¾ç´¯è®¡å‡»æ€5äº¿åªæ€ªç‰©ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalMapKills(state) >= 500000000,
        reward: { hpPct: 0.02 },
        icon: 'ğŸ”¥'
    },

    // âœ… æ–°å¢ï¼šé¦–é¢†æ€æ‰‹ç³»åˆ—ï¼ˆç´¯è®¡å‡»æ€ä»»æ„BOSSï¼Œè·¨ä¸–ç´¯è®¡ï¼‰
    boss_killer_1: {
        id: 'boss_killer_1',
        name: 'é¦–é¢†æ€æ‰‹â… ',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 10æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 10,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_2: {
        id: 'boss_killer_2',
        name: 'é¦–é¢†æ€æ‰‹â…¡',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 50æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 50,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_3: {
        id: 'boss_killer_3',
        name: 'é¦–é¢†æ€æ‰‹â…¢',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 100æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 100,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_4: {
        id: 'boss_killer_4',
        name: 'é¦–é¢†æ€æ‰‹â…£',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 500æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 500,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_5: {
        id: 'boss_killer_5',
        name: 'é¦–é¢†æ€æ‰‹â…¤',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 1000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 1000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_6: {
        id: 'boss_killer_6',
        name: 'é¦–é¢†æ€æ‰‹â…¥',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 5000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 5000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_7: {
        id: 'boss_killer_7',
        name: 'é¦–é¢†æ€æ‰‹â…¦',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 10000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 10000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_8: {
        id: 'boss_killer_8',
        name: 'é¦–é¢†æ€æ‰‹â…§',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 50000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 50000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_9: {
        id: 'boss_killer_9',
        name: 'é¦–é¢†æ€æ‰‹â…¨',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 100000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 100000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },
    boss_killer_10: {
        id: 'boss_killer_10',
        name: 'é¦–é¢†æ€æ‰‹â…©',
        description: 'ç´¯è®¡å‡»æ€ä»»æ„BOSS 500000æ¬¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿå‡ä¸ä¼šé‡ç½®è®¡æ•°ï¼‰',
        condition: (state) => getTotalWorldBossKills(state) >= 500000,
        reward: { versatility: 2 },
        icon: 'ğŸ‘‘'
    },


    collector: { id: 'collector', name: 'æ”¶è—å®¶', description: 'æ”¶é›†10ç§ä¸åŒç‰©å“', condition: (state) => state.codex.length >= 10, reward: { dropBonus: 0.1 }, icon: 'ğŸ“¦' },

    // âœ… å»ºè®¾è€…ç³»åˆ—ï¼šç´¯è®¡å»ºé€ å»ºç­‘æ•°é‡ï¼ˆå«æ—§å»ºç­‘ & åŠŸèƒ½å»ºç­‘ï¼‰
    builder_1: {
        id: 'builder_1',
        name: 'å»ºè®¾è€…â… ',
        description: 'ç´¯è®¡å»ºé€ 10åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 10,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_2: {
        id: 'builder_2',
        name: 'å»ºè®¾è€…â…¡',
        description: 'ç´¯è®¡å»ºé€ 50åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 50,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_3: {
        id: 'builder_3',
        name: 'å»ºè®¾è€…â…¢',
        description: 'ç´¯è®¡å»ºé€ 100åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 100,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_4: {
        id: 'builder_4',
        name: 'å»ºè®¾è€…â…£',
        description: 'ç´¯è®¡å»ºé€ 200åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 200,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_5: {
        id: 'builder_5',
        name: 'å»ºè®¾è€…â…¤',
        description: 'ç´¯è®¡å»ºé€ 500åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 500,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_6: {
        id: 'builder_6',
        name: 'å»ºè®¾è€…â…¥',
        description: 'ç´¯è®¡å»ºé€ 1000åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 1000,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_7: {
        id: 'builder_7',
        name: 'å»ºè®¾è€…â…¦',
        description: 'ç´¯è®¡å»ºé€ 2000åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 2000,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_8: {
        id: 'builder_8',
        name: 'å»ºè®¾è€…â…§',
        description: 'ç´¯è®¡å»ºé€ 5000åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 5000,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_9: {
        id: 'builder_9',
        name: 'å»ºè®¾è€…â…¨',
        description: 'ç´¯è®¡å»ºé€ 10000åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 10000,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    builder_10: {
        id: 'builder_10',
        name: 'å»ºè®¾è€…â…©',
        description: 'ç´¯è®¡å»ºé€ 20000åº§å»ºç­‘',
        condition: (state) => getTotalBuildingsBuilt(state) >= 20000,
        reward: { resourceBonus: 0.02 },
        icon: 'ğŸ—ï¸'
    },
    susas: {
        id: 'susas',
        name: 'é­ç¬è€…è‹è¨æ–¯',
        description: 'ç‚¹äº®ã€é­ç¬è€…è‹è¨æ–¯ã€‘Lv.100 å›¾é‰´',
        condition: (state) => Array.isArray(state.codexEquipLv100) && state.codexEquipLv100.includes('EQ_044'),
        reward: { dropBonus: 0.05 },
        icon: 'ğŸ´â€â˜ ï¸'
    },

    // âœ… æ–°å¢ï¼šé“å¿ƒæ¾„æ¾ˆç³»åˆ—ï¼ˆBOSSæŒ‘æˆ˜å»¶åå¤±è´¥ç´¯è®¡ï¼‰
    dao_xin_cheng_che_1: {
        id: 'dao_xin_cheng_che_1',
        name: 'é“å¿ƒæ¾„æ¾ˆâ… ',
        description: 'åœ¨BOSSæŒ‘æˆ˜ä¸­è¶…è¿‡4å›åˆåæˆ˜æ–—å¤±è´¥ç´¯è®¡è¾¾åˆ°100æ¬¡',
        condition: (state) => (state.stats?.bossLateRoundDefeats || 0) >= 100,
        reward: { bossHpPct: 0.05 },
        icon: 'ğŸ§˜'
    },
    dao_xin_cheng_che_2: {
        id: 'dao_xin_cheng_che_2',
        name: 'é“å¿ƒæ¾„æ¾ˆâ…¡',
        description: 'åœ¨BOSSæŒ‘æˆ˜ä¸­è¶…è¿‡4å›åˆåæˆ˜æ–—å¤±è´¥ç´¯è®¡è¾¾åˆ°1000æ¬¡',
        condition: (state) => (state.stats?.bossLateRoundDefeats || 0) >= 1000,
        reward: { bossHpPct: 0.05 },
        icon: 'ğŸ§˜'
    },

    // âœ… æ–°å¢ï¼šæˆ‘é‡ç”Ÿäº†ç³»åˆ—ï¼ˆç´¯è®¡é‡ç”Ÿæ¬¡æ•°ï¼‰
    reborn_1: {
        id: 'reborn_1',
        name: 'æˆ‘é‡ç”Ÿäº†â… ',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°10æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 10,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_2: {
        id: 'reborn_2',
        name: 'æˆ‘é‡ç”Ÿäº†â…¡',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°20æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 20,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_3: {
        id: 'reborn_3',
        name: 'æˆ‘é‡ç”Ÿäº†â…¢',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°50æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 50,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_4: {
        id: 'reborn_4',
        name: 'æˆ‘é‡ç”Ÿäº†â…£',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°100æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 100,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_5: {
        id: 'reborn_5',
        name: 'æˆ‘é‡ç”Ÿäº†â…¤',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°200æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 200,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_6: {
        id: 'reborn_6',
        name: 'æˆ‘é‡ç”Ÿäº†â…¥',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°500æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 500,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_7: {
        id: 'reborn_7',
        name: 'æˆ‘é‡ç”Ÿäº†â…¦',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°1000æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 1000,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_8: {
        id: 'reborn_8',
        name: 'æˆ‘é‡ç”Ÿäº†â…§',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°2000æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 2000,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_9: {
        id: 'reborn_9',
        name: 'æˆ‘é‡ç”Ÿäº†â…¨',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°5000æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 5000,
        reward: { goldBonus: 0.05 },
        icon: 'â™»ï¸'
    },
    reborn_10: {
        id: 'reborn_10',
        name: 'æˆ‘é‡ç”Ÿäº†â…©',
        description: 'ç´¯è®¡é‡ç”Ÿè¾¾åˆ°10000æ¬¡',
        condition: (state) => (state.rebirthCount || 0) >= 10000,
        reward: { goldBonus: 0.50 },
        icon: 'â™»ï¸'
    },

    // âœ… æ–°å¢ï¼šä½ä¿åˆé»‘äº†ç³»åˆ—ï¼ˆç´¯è®¡é¢†å–å®ä¼Ÿå®åº“å¥–åŠ±æ¬¡æ•°ï¼‰
    low_welfare_1: {
        id: 'low_welfare_1',
        name: 'ä½ä¿åˆé»‘äº†â… ',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±1æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 1,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_2: {
        id: 'low_welfare_2',
        name: 'ä½ä¿åˆé»‘äº†â…¡',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±5æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 5,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_3: {
        id: 'low_welfare_3',
        name: 'ä½ä¿åˆé»‘äº†â…¢',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±10æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 10,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_4: {
        id: 'low_welfare_4',
        name: 'ä½ä¿åˆé»‘äº†â…£',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±20æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 20,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_5: {
        id: 'low_welfare_5',
        name: 'ä½ä¿åˆé»‘äº†â…¤',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±50æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 50,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_6: {
        id: 'low_welfare_6',
        name: 'ä½ä¿åˆé»‘äº†â…¥',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±100æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 100,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_7: {
        id: 'low_welfare_7',
        name: 'ä½ä¿åˆé»‘äº†â…¦',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±200æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 200,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_8: {
        id: 'low_welfare_8',
        name: 'ä½ä¿åˆé»‘äº†â…§',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±500æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 500,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_9: {
        id: 'low_welfare_9',
        name: 'ä½ä¿åˆé»‘äº†â…¨',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±1000æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 1000,
        reward: { expBonus: 0.02 },
        icon: 'ğŸ¦'
    },
    low_welfare_10: {
        id: 'low_welfare_10',
        name: 'ä½ä¿åˆé»‘äº†â…©',
        description: 'ç´¯è®¡é€‰æ‹©å®ä¼Ÿå®åº“å¥–åŠ±2000æ¬¡',
        condition: (state) => (state.stats?.grandVaultPicks || 0) >= 2000,
        reward: { expBonus: 0.20 },
        icon: 'ğŸ¦'
    },
};

const WORLD_BOSSES = {
    hogger: { id: 'hogger', name: 'éœæ ¼',icon:'icons/wow/vanilla/boss/hogger.png', hp: 18000, attack: 150, defense: 70, rewards: { gold: 5000, exp: 5500 } },
    vancleef: { id: 'vancleef', name: 'è‰¾å¾·æ¸©Â·èŒƒå…‹é‡Œå¤«', icon: 'icons/wow/vanilla/boss/vancleef.png', hp: 140000, attack: 550, defense: 350, rewards: { gold: 25000, exp: 19800 }, unlockLevel: 30 },
    prestor_lady: {
        id: 'prestor_lady',
        name: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
        icon: 'icons/wow/vanilla/boss/prestor_lady.jpg', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 800000,
        attack: 1500,
        defense: 800,
        rewards: { gold: 100000, exp: 80000 },
        // ç‰¹æ®Šè§£é”æ¡ä»¶ï¼šéœ€è¦ä½¿ç”¨ã€é»‘é¾™åŒ–èº«çš„è¯æ˜ã€‘ç‰©å“
        unlockCondition: {
            requireItem: 'IT_BLACK_DRAGON_PROOF'
        }
    },
    thalnos: {
        id: 'thalnos',
        name: 'è£‚é­‚è€…è¨å°”è¯ºæ–¯',
        icon: 'icons/wow/vanilla/boss/thalnos.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 1000000,
        attack: 1800,
        defense: 750,
        rewards: { gold: 120000, exp: 95000 },
        unlockLevel: 50
    },

    // âœ… æ–°å¢ï¼š50çº§ä¸–ç•Œé¦–é¢† - è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸
    dagran_thaurissan: {
        id: 'dagran_thaurissan',
        name: 'è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸',
        icon: 'icons/wow/vanilla/boss/dagran_thaurissan.png',
        hp: 1500000,
        attack: 3000,
        defense: 1000,
        rewards: { gold: 300000, exp: 165000 },
        unlockLevel: 50
    },

// âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - é»‘æš—é™¢é•¿åŠ ä¸
    darkmaster_gandling: {
        id: 'darkmaster_gandling',
        name: 'é»‘æš—é™¢é•¿åŠ ä¸',
        icon: 'icons/wow/vanilla/boss/darkmaster_gandling.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 2800000,
        attack: 3600,
        defense: 1200,
        rewards: { gold: 450000, exp: 240000 },
        unlockLevel: 60
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - ç‘æ–‡æˆ´å°”ç”·çˆµï¼ˆæ–¯å¦ç´¢å§†ï¼‰
    baron_rivendare: {
        id: 'baron_rivendare',
        name: 'ç‘æ–‡æˆ´å°”ç”·çˆµ',
        icon: 'icons/wow/vanilla/boss/baron_rivendare.png',
        hp: 3400000,
        attack: 4000,
        defense: 1350,
        rewards: { gold: 550000, exp: 300000 },
        unlockLevel: 60
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - é›·å¾·Â·é»‘æ‰‹ï¼ˆé»‘çŸ³å¡”ä¸Šï¼‰
    rend_blackhand: {
        id: 'rend_blackhand',
        name: 'é›·å¾·Â·é»‘æ‰‹',
        icon: 'icons/wow/vanilla/boss/rend_blackhand.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 4000000,
        attack: 4000,
        defense: 1400,
        rewards: { gold: 580000, exp: 350000 },
        unlockLevel: 60
    },



    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - è¡€ç¥å“ˆå¡ï¼ˆç¥–å°”æ ¼æ‹‰å¸ƒï¼‰
    hakkar: {
        id: 'hakkar',
        name: 'è¡€ç¥å“ˆå¡',
        icon: 'icons/wow/vanilla/boss/hakkar.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 10000000,
        attack: 8000,
        defense: 3500,
        rewards: { gold: 1400000, exp: 900000 },
        unlockLevel: 60
    },
    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰ï¼ˆå®‰å…¶æ‹‰ï¼‰
    // è¯´æ˜ï¼šæœ¬ä½“é˜²å¾¡æé«˜ï¼ˆéœ€è¦å‡»æ€ã€æ±²èƒ½æ°´æ™¶ã€‘è§¦å‘çŸ­æš‚â€œç ´ç”²çª—å£â€ï¼‰
    ossirian: {
        id: 'ossirian',
        name: 'æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰',
        icon: 'icons/wow/vanilla/boss/ossirian.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 12000000,
        attack: 8500,
        defense: 800000,
        rewards: { gold: 1800000, exp: 1100000 },
        unlockLevel: 60
    },
    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - åŠ å°”ï¼ˆç†”ç«ä¹‹å¿ƒï¼‰
    garr: {
        id: 'garr',
        name: 'åŠ å°”',
        icon: 'icons/wow/vanilla/boss/garr.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 15000000,
        attack: 10800,
        defense: 10000,
        rewards: { gold: 2000000, exp: 1200000 },
        unlockLevel: 60
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - è¿¦é¡¿ç”·çˆµï¼ˆç†”ç«ä¹‹å¿ƒï¼‰
    baron_geddon: {
        id: 'baron_geddon',
        name: 'è¿¦é¡¿ç”·çˆµ',
        icon: 'icons/wow/vanilla/boss/jiadunnanjue.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 16000000,
        attack: 11200,
        defense: 12000,
        rewards: { gold: 2200000, exp: 1300000 },
        unlockLevel: 60
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - ç„šåŒ–è€…å¤é›·æ›¼æ ¼ï¼ˆç†”ç«ä¹‹å¿ƒï¼‰
    golemagg: {
        id: 'golemagg',
        name: 'ç„šåŒ–è€…å¤é›·æ›¼æ ¼',
        icon: 'icons/wow/vanilla/boss/golemagg.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 18000000,
        attack: 12800,
        defense: 13000,
        rewards: { gold: 2400000, exp: 1400000 },
        unlockLevel: 60
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ï¼ˆç†”ç«ä¹‹å¿ƒï¼‰
    majordomo_executus: {
        id: 'majordomo_executus',
        name: 'ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯',
        icon: 'icons/wow/vanilla/boss/guanlizhe.png', // éœ€è¦æ·»åŠ å¯¹åº”å›¾æ ‡
        hp: 20000000,
        attack: 12800,
        defense: 15000,
        rewards: { gold: 2600000, exp: 1500000 },
        unlockLevel: 60
    },

};

// ==================== å›¢é˜Ÿé¦–é¢†ï¼ˆRaid Bossï¼‰ ====================
// è¯´æ˜ï¼šå›¢é˜Ÿé¦–é¢†åœ¨ã€Œä¸–ç•Œé¦–é¢†ã€é¡µé¢ä¸­ä»¥ç‹¬ç«‹åŒºåŸŸå±•ç¤ºã€‚
// æœºåˆ¶å¤ç”¨ä¸–ç•Œé¦–é¢†ï¼ˆåŒä¸€å¥— Boss æˆ˜æ–—/ç»“ç®—/å†·å´ï¼‰ï¼Œä½†å‡†å¤‡ç•Œé¢æ”¯æŒ 5 äººé˜Ÿä¼ã€‚
// åç»­å¦‚éœ€æ›´å¤æ‚æŠ€èƒ½ï¼Œåªéœ€åœ¨ BOSS_DATA ä¸­è¡¥å……å¯¹åº” bossId çš„é…ç½®ä¸æˆ˜æ–—é€»è¾‘åˆ†æ”¯ã€‚
const TEAM_BOSSES = {
    ragnaros: {
        id: 'ragnaros',
        name: 'ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯',
        icon: 'icons/wow/vanilla/boss/ragnaros.png', // é¢„ç•™ï¼šè‡ªè¡Œè¡¥å›¾æ ‡
        hp: 30000000,
        attack: 18000,
        defense: 18000,
        rewards: { gold: 3200000, exp: 1800000 },
        unlockLevel: 60,
        partySize: 5, // âœ… å›¢é˜Ÿé¦–é¢†ï¼š5äºº
    },
};

// UI/é€»è¾‘å±‚é€šç”¨ï¼šè·å– Boss å…ƒä¿¡æ¯
function getBossMeta(bossId) {
    return TEAM_BOSSES?.[bossId] || WORLD_BOSSES?.[bossId] || null;
}

function isTeamBoss(bossId) {
    return !!TEAM_BOSSES?.[bossId];
}

function getBossPartySize(bossId) {
    const meta = getBossMeta(bossId);
    const n = Number(meta?.partySize);
    if (Number.isFinite(n) && n > 0) return Math.floor(n);
    return isTeamBoss(bossId) ? 5 : 3;
}

// è£…å¤‡æ§½ä½å®šä¹‰
const EQUIPMENT_SLOTS = {
    head: { name: 'å¤´éƒ¨', icon: 'â›‘ï¸' },
    neck: { name: 'é¡¹é“¾', icon: 'ğŸ“¿' },
    shoulder: { name: 'è‚©è†€', icon: 'ğŸ½' },
    cloak: { name: 'æŠ«é£', icon: 'ğŸ§¥' },
    chest: { name: 'èƒ¸ç”²', icon: 'ğŸ›¡ï¸' },
    wrist: { name: 'æ‰‹è…•', icon: 'âŒš' },
    hands: { name: 'æ‰‹å¥—', icon: 'ğŸ§¤' },
    belt: { name: 'è…°å¸¦', icon: 'ğŸ§·' },
    legs: { name: 'è…¿éƒ¨', icon: 'ğŸ‘–' },
    feet: { name: 'é‹å­', icon: 'ğŸ‘¢' },
    ring1: { name: 'æˆ’æŒ‡1', icon: 'ğŸ’' },
    ring2: { name: 'æˆ’æŒ‡2', icon: 'ğŸ’' },
    trinket1: { name: 'é¥°å“1', icon: 'âœ¨' },
    trinket2: { name: 'é¥°å“2', icon: 'âœ¨' },
    mainHand: { name: 'ä¸»æ‰‹', icon: 'âš”ï¸' },
    offHand: { name: 'å‰¯æ‰‹', icon: 'ğŸ›¡ï¸' }
};

const SET_BONUSES = {
    beginner_set: {
        name: 'åˆå¿ƒè€…å¥—è£…',
        tiers: [
            { count: 2, bonus: { expBonus: 0.20 } },
        ]
    },
    traveler_set: {
        name: 'æ—…è¡Œè€…å¥—è£…',
        tiers: [
            {
                count: 6,
                bonus: {
                    expBonus: 0.40
                }
            }
        ]
    },venom_embrace: {
        name: 'æ¯’è›‡çš„æ‹¥æŠ±',
        tiers: [
            { count: 3, bonus: { versatility: 10 } },
            { count: 6, bonus: { critRate: 10, critDamage: 0.30 } }  // 10%çˆ†å‡»ç‡ + 30%æš´å‡»ä¼¤å®³
        ]
    },scarlet_crusader: {
        name: 'è¡€è‰²åå­—å†›',
        tiers: [
            { count: 3, bonus: { armor: 100, blockValue: 50 } },
            { count: 6, bonus: { hp: 1000, blockRate: 5 } }
        ]
    },hogger_gather_set: {
        name: 'éœæ ¼çš„æˆ˜åˆ©å“',
        tiers: [
            { count: 3, bonus: { gatherEfficiency: 0.15 } }  // 3ä»¶å¥—é¢å¤–+15%é‡‡é›†æ•ˆç‡
        ]

    },
    valor_set: {
        name: 'å‹‡æ°”',
        tiers: [
            { count: 3, bonus: { hp: 500, armor: 80, mastery: 10 } },
            { count: 5, bonus: { blockRate: 5, blockValue: 300 } },
            { count: 8, bonus: { hp: 2000, attack:500 } }
        ]
    },
    swiftshadow_set: {
        name: 'è¿…å½±',
        tiers: [
            { count: 3, bonus: { attack: 200, haste: 10 } },
            { count: 5, bonus: { critRate: 10, critDamage: 0.30 } },
            { count: 8, bonus: { hp: 1000, versatility:20 } }
        ]
    },
    devout_set: {
        name: 'è™”è¯š',
        tiers: [
            { count: 3, bonus: { spellPower: 250, mastery: 10 } },
            { count: 5, bonus: { hp: 800, versatility: 15 } },
            { count: 8, bonus: { hp: 1500, spellPower:500 } }
        ]
    },
    scholar_set: {
        name: 'åšå­¦è€…',
        tiers: [
            { count: 3, bonus: { spellPower: 250, versatility: 10 } },
            { count: 5, bonus: { critRate: 10, mastery: 15 } },
            { count: 8, bonus: { hp: 1000, versatility:20 } }
        ]
    }
    ,
    // ==================== ç†”ç«ä¹‹å¿ƒ Â· T1 å¥—è£…ï¼ˆ4ä»¶å¥—ï¼‰ ====================
    might_set: {
        name: 'åŠ›é‡',
        tiers: [
            { count: 3, bonus: { hp: 800, armor: 120, mastery: 12 } },
            { count: 5, bonus: { blockRate: 6, blockValue: 360 } },
            { count: 8, bonus: { hp: 4000, attack:800 } },
        ]
    },
    nightslayer_set: {
        name: 'å¤œå¹•æ€æ‰‹',
        tiers: [
            { count: 3, bonus: { attack: 250, haste: 12 } },
            { count: 5, bonus: { critRate: 12, critDamage: 0.35 } },
            { count: 8, bonus: { hp: 2000, versatility:25 } },
        ]
    },
    arcanist_set: {
        name: 'å¥¥æœ¯å¸ˆ',
        tiers: [
            { count: 3, bonus: { spellPower: 300, haste: 12 } },
            { count: 5, bonus: { critRate: 12, mastery: 12} },
            { count: 8, bonus: { hp: 2000, versatility: 25 } },
        ]
    },
    prophecy_set: {
        name: 'é¢„è¨€',
        tiers: [
            { count: 3, bonus: { spellPower: 300, mastery: 12 } },
            { count: 5, bonus: { hp: 1200, versatility: 18 } },
            { count: 8, bonus: { hp: 2500, spellPower:800 } },
        ]
    }

};

// ==================== BOSS DATA ====================
const BOSS_DATA = {
    hogger: {
        id: 'hogger',
        name: 'éœæ ¼',
        maxHp: 18000,
        attack: 150,
        defense: 70,
        cycle: ['summon', 'strike', 'strike', 'strike'],
        summonCount: 2,
        heavyMultiplier: 2.5,
        minion: {
            name: 'è±ºç‹¼äººå°å¼Ÿ',
            maxHp: 300,
            attack: 75,
            defense: 20
        },
        rewards: {
            gold: 5000,
            exp: 5500,
            items: [
                { id: 'REBIRTH_INVITATION' },
                { id: 'EQ_HOGGER_001' , chance: 0.15 },  // æ–°å¢ï¼šéœæ ¼çš„æ¯›çš®æŠ«é£
                { id: 'EQ_HOGGER_002' , chance: 0.15 },  // æ–°å¢ï¼šéœæ ¼çš„ç ç‰™å¤´ç›”
                { id: 'EQ_HOGGER_003' , chance: 0.15 },   // æ–°å¢ï¼šéœæ ¼çš„å…½çš®èƒ¸ç”²
                { id: 'IT_HOGGER_BADGE', chance: 0.8 }
            ]
        }
    },
    vancleef: {
        id: 'vancleef',
        name: 'è‰¾å¾·æ¸©Â·èŒƒå…‹é‡Œå¤«',
        maxHp: 140000,
        attack: 550,
        defense: 350,
        // æŠ€èƒ½å¾ªç¯ï¼šè‡´æ­»æ‰“å‡» â†’ ç«ç‚®æ‰‹å‡†å¤‡ â†’ è‡´æ­»æ‰“å‡» â†’ ç™»ä¸Šç”²æ¿
        cycle: ['mortal_strike', 'summon_cannoneers', 'mortal_strike', 'board_the_deck'],
        // è‡´æ­»æ‰“å‡»ï¼š3å€æ”»å‡»
        mortalStrikeMultiplier: 3,
        // è‡´æ­»æ‰“å‡»debuffï¼šå‡ç–—50%æŒç»­2å›åˆ
        mortalStrikeDebuff: {
            healingReduction: 0.5,
            duration: 2
        },
        // ç«ç‚®æ‰‹é…ç½®
        minion: {
            name: 'è¿ªè²äºšç«ç‚®æ‰‹',
            maxHp: 600,
            attack: 0, // ç«ç‚®æ‰‹ä¸æ™®æ”»ï¼ŒåªAOE
            defense: 300,
            aoeDamageMultiplier: 0.7 // å¯¹å…¨é˜Ÿé€ æˆbossæ”»å‡»Ã—0.7çš„ä¼¤å®³
        },
        summonCount: 3,
        rewards: {
            gold: 25000,
            exp: 19800,
            items: [
                { id: 'IT_VANCLEEF_BADGE', chance: 0.8 },
                { id: 'EQ_VANCLEEF_001' , chance: 0.25 },
            ]
        }
    },
    prestor_lady: {
        id: 'prestor_lady',
        name: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
        maxHp: 800000,
        attack: 1500,
        defense: 800,
        // æŠ€èƒ½å¾ªç¯ï¼šè°æŠ¥ â†’ é»‘é¾™ä¹‹ç‚ â†’ å°–ç‰™ä¸åˆ©çˆª â†’ æ™®é€šæ”»å‡»
        cycle: ['espionage', 'black_dragon_flame', 'fangs_and_claws', 'normal_attack'],
        // è°æŠ¥ï¼šæ€»å…±10å€æ”»å‡»çš„æš—å½±ä¼¤å®³ï¼Œåˆ†æ•£ç«™ä½åªæ‰“å¦å…‹
        espionageDamageMultiplier: 10,
        // é»‘é¾™ä¹‹ç‚ï¼šæ¯å±‚DOT 0.2å€æ”»å‡»
        blackFlameDoTMultiplier: 0.2,
        // å°–ç‰™ä¸åˆ©çˆªï¼š3å€æ”»å‡» + æµè¡€DOT
        fangsMultiplier: 3,
        bleedDoTMultiplier: 0.8,
        bleedDuration: 3,
        rewards: {
            gold: 100000,
            exp: 80000,
            items: [
                // å¯ä»¥æ·»åŠ é»‘é¾™ä¸»é¢˜ç´«è£…æ‰è½
                { id: 'IT_PRESTOR_BADGE', chance: 0.8 }
            ]
        }
    },
    thalnos: {
        id: 'thalnos',
        name: 'è£‚é­‚è€…è¨å°”è¯ºæ–¯',
        maxHp: 1000000,
        attack: 1800,
        defense: 750,
        // æŠ€èƒ½å¾ªç¯ï¼šçµé­‚å¼ºé£ â†’ å •è½çš„åå­—å†› â†’ æ”¾é€çµé­‚ â†’ çµé­‚æ”¶å‰²è€…
        cycle: ['soul_storm', 'fallen_crusaders', 'banish_soul', 'soul_reaper'],

        // çµé­‚å¼ºé£ï¼šæ”»å‡»Ã—1.5ä¼¤å®³ + DOTï¼ˆæ¯å›åˆæ”»å‡»Ã—1.5ï¼ŒæŒç»­3å›åˆï¼‰
        soulStormMultiplier: 1.5,
        soulStormDoTMultiplier: 1.5,
        soulStormDoTDuration: 3,

        // æ”¾é€çµé­‚ï¼šæ”»å‡»Ã—4ä¼¤å®³ + ææƒ§3å›åˆ
        banishSoulMultiplier: 4,
        fearDuration: 2,

        // å •è½çš„åå­—å†›é…ç½®
        minion: {
            name: 'å •è½åå­—å†›',
            maxHp: 20000,
            attack: 1800, // ç­‰äºbossæ”»å‡»
            defense: 750
        },
        summonCount: 5,
        // çµé­‚æ”¶å‰²è€…ï¼š(åå­—å†›æ•°é‡+3) Ã— bossæ”»å‡» çš„æš—å½±ä¼¤å®³
        soulReaperBaseMultiplier: 1.5, // åŸºç¡€å€ç‡ï¼ˆæ— åå­—å†›æ—¶ï¼‰

        rewards: {
            gold: 130000,
            exp: 105000,
            items: [
                // âœ… è¨å°”è¯ºæ–¯ä¸“å±æ‰è½
                { id: 'IT_SCARLET_CRUSADER_BADGE', chance: 0.8 }
            ]
        }
    },

    // âœ… æ–°å¢ï¼šè¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸ï¼ˆç«ç„° / ç‰©ç†æ··åˆï¼‰
    dagran_thaurissan: {
        id: 'dagran_thaurissan',
        name: 'è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸',
        maxHp: 1500000,
        attack: 3000,
        defense: 1000,

        // æŠ€èƒ½å¾ªç¯ï¼šçƒˆç„°æ‰“å‡» â†’ ç†”å²©çˆ†è£‚ â†’ çƒˆç„°æ‰“å‡» â†’ æˆ˜æ–—æ€’å¼
        cycle: ['flame_strike', 'lava_burst', 'flame_strike', 'battle_shout'],

        // çƒˆç„°æ‰“å‡»ï¼šå¯¹å¦å…‹é€ æˆ 3Ã—ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—ï¼‰+ 3Ã—ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡ï¼‰
        flameStrikeFireMultiplier: 3,
        flameStrikePhysicalMultiplier: 5,

        // ç†”å²©çˆ†è£‚ï¼šéšæœºç›®æ ‡ 2Ã—ç«ç„°ä¼¤å®³ï¼Œå¹¶ç•™ä¸‹ç¼çƒ§DOTï¼ˆ1.5Ã—æ”»å‡»ï¼ŒæŒç»­3å›åˆï¼‰
        lavaBurstMultiplier: 2,
        burnDoTMultiplier: 1.5,
        burnDoTDuration: 3,

        // æˆ˜æ–—æ€’å¼ï¼šæœ¬åœºæˆ˜æ–—BOSSæ”»å‡» +10%ï¼Œå¯å åŠ 
        battleShoutAttackPct: 0.10,

        rewards: {
            gold: 300000,
            exp: 165000,
            items: [
                { id: 'IT_THAURISSAN_BADGE', chance: 0.8 }
            ]
        }
    },

// âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - é»‘æš—é™¢é•¿åŠ ä¸ï¼ˆé€šçµå­¦é™¢ï¼‰
    darkmaster_gandling: {
        id: 'darkmaster_gandling',
        name: 'é»‘æš—é™¢é•¿åŠ ä¸',
        maxHp: 2800000,
        attack: 3600,
        defense: 1200,

        // æŠ€èƒ½å¾ªç¯ï¼šæš—å½±ç®­ â†’ å¬å”¤äº¡çµå­¦å¾’ â†’ æš—å½±è¯…å’’ â†’ é»‘æš—é£æš´
        cycle: ['shadow_bolt', 'summon_apprentices', 'shadow_curse', 'dark_storm'],

        // æš—å½±ç®­ï¼šå¯¹å¦å…‹é€ æˆ 5 Ã— Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
        shadowBoltMultiplier: 5,

        // é»‘æš—é£æš´ï¼š3 Ã— Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ˆåˆ†æ•£ï¼šéšæœºå•ä½“ï¼›é›†ä¸­ï¼šå…¨ä½“ï¼‰
        darkStormMultiplier: 3,

        // æš—å½±è¯…å’’ï¼šç›®æ ‡é­”æ³•æŠ—æ€§é™ä½ 100ï¼ŒæŒç»­ 4 å›åˆï¼ˆå…è®¸ä¸ºè´Ÿï¼ŒæŒ‰ magicresist_k å…¬å¼å¢ä¼¤ï¼‰
        shadowCurseMagicResistDown: 100,
        shadowCurseDuration: 4,

        // äº¡çµå­¦å¾’ï¼šå¬å”¤ 2 ä¸ªï¼Œæ”»å‡»/é˜²å¾¡ä¸Bossç›¸åŒï¼Œè¡€é‡ 20ä¸‡ï¼›æ¯å›åˆéšæœºé‡Šæ”¾æš—å½±ç®­ï¼ˆ2 Ã— Bossæ”»å‡»ï¼‰
        summonCount: 2,
        minion: {
            name: 'äº¡çµå­¦å¾’',
            maxHp: 200000,
            attack: 3600,
            defense: 1200
        },
        minionShadowBoltMultiplier: 2,

        rewards: {
            gold: 450000,
            exp: 240000,
            items: [
                // âœ… æ–°å¢ï¼šT0 å¥—è£…æŠ¤è‚©ï¼ˆæ¯ä»¶ 20%ï¼‰
                { id: 'EQ_113', chance: 0.2 },  // å‹‡æ°”æŠ¤è‚©
                { id: 'EQ_114', chance: 0.2 },  // è¿…å½±æŠ¤è‚©
                { id: 'EQ_115', chance: 0.2 },  // è™”è¯šæŠ¤è‚©
                { id: 'EQ_116', chance: 0.2 },  // åšå­¦è€…æŠ¤è‚©
                { id: 'IT_GANDLING_BADGE', chance: 0.8 }
            ]
        }
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - ç‘æ–‡æˆ´å°”ç”·çˆµï¼ˆæ–¯å¦ç´¢å§†ï¼‰
    baron_rivendare: {
        id: 'baron_rivendare',
        name: 'ç‘æ–‡æˆ´å°”ç”·çˆµ',
        maxHp: 3400000,
        attack: 4000,
        defense: 1350,

        // æŠ€èƒ½å¾ªç¯ï¼šé¡ºåŠˆæ–© â†’ è‡´æ­»æ‰“å‡» â†’ å¬å”¤éª·é«…å¤§å†› â†’ æš—å½±éœ‡å‡»
        cycle: ['cleave', 'mortal_strike', 'summon_skeleton_army', 'shadow_shock'],

        // é¡ºåŠˆæ–©ï¼šåˆ†æ•£ç«™ä½æ‰“å¦å…‹ / é›†ä¸­ç«™ä½æ‰“å…¨ä½“ï¼ˆ5Ã—æ”»å‡»ï¼Œç‰©ç†ï¼Œå¯æ ¼æŒ¡/æŠ¤ç”²ï¼‰
        cleaveMultiplier: 5,

        // è‡´æ­»æ‰“å‡»ï¼š4Ã—æ”»å‡»ï¼ˆç‰©ç†ï¼‰+ å‡ç–—50% debuffï¼ˆå‚è€ƒèŒƒå…‹é‡Œå¤«ï¼‰
        mortalStrikeMultiplier: 4,
        mortalStrikeDebuff: {
            healingReduction: 0.5,
            duration: 2
        },

        // æš—å½±éœ‡å‡»ï¼š3Ã—æ”»å‡»æš—å½±ä¼¤å®³ + DOTï¼ˆæ¯å›åˆ1.5Ã—æ”»å‡»ï¼ŒæŒç»­3å›åˆï¼‰
        shadowShockMultiplier: 3,
        shadowShockDotMultiplier: 1.5,
        shadowShockDotDuration: 3,

        // å¬å”¤éª·é«…å¤§å†›ï¼šå¬å”¤5ä¸ªéª·é«…ï¼Œå¯¹å¦å…‹æŒ¥ç ï¼ˆ1.2Ã—æ”»å‡»ï¼Œç‰©ç†ï¼‰
        summonCount: 5,
        skeletonSlashMultiplier: 1.2,
        minion: {
            name: 'éª·é«…æˆ˜å£«',
            maxHp: 180000,
            attack: 4000,
            defense: 1100
        },

        rewards: {
            gold: 550000,
            exp: 300000,
            items: [
                // âœ… æ–°å¢ï¼šT0 å¥—è£…æˆ˜é´/ä¾¿é‹ï¼ˆæ¯ä»¶ 20%ï¼‰
                { id: 'EQ_117', chance: 0.2 },  // å‹‡æ°”æˆ˜é´
                { id: 'EQ_118', chance: 0.2 },  // è¿…å½±æˆ˜é´
                { id: 'EQ_119', chance: 0.2 },  // è™”è¯šä¾¿é‹
                { id: 'EQ_120', chance: 0.2 },  // åšå­¦è€…ä¾¿é‹
                { id: 'IT_RIVENDARE_BADGE', chance: 0.8 }
            ]
        }
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - é›·å¾·Â·é»‘æ‰‹ï¼ˆé»‘çŸ³å¡”ä¸Šï¼‰
    rend_blackhand: {
        id: 'rend_blackhand',
        name: 'é›·å¾·Â·é»‘æ‰‹',
        maxHp: 4000000,
        attack: 4000,
        defense: 1400,

        // æŠ€èƒ½å¾ªç¯ï¼šçƒˆç„°åæ¯ â†’ é¡ºåŠˆæ–© â†’ çƒˆç„°åæ¯ â†’ è·³è·ƒæ–©å‡»
        cycle: ['flame_breath', 'cleave', 'flame_breath', 'leap_slash'],

        // çƒˆç„°åæ¯ï¼šå¯¹å¦å…‹ 5Ã—æ”»å‡» ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡ï¼‰
        // å¹¶å¯¹å…¨é˜Ÿè¿½åŠ ä¸€æ¬¡â€œå¦å…‹å®é™…æ‰¿ä¼¤â€çš„ç«ç„°ä¼¤å®³ï¼ˆè®¡ç®—å„è‡ªé­”æŠ—ï¼‰
        flameBreathMultiplier: 5,

        // é¡ºåŠˆæ–©ï¼šåˆ†æ•£=æ‰“å¦å…‹ï¼›é›†ä¸­=æ‰“å…¨ä½“ï¼ˆ2.5Ã—æ”»å‡»ï¼Œç‰©ç†ï¼Œå¯æ ¼æŒ¡/æŠ¤ç”²ï¼‰
        cleaveMultiplier: 2.5,

        // è·³è·ƒæ–©å‡»ï¼šé›†ä¸­=æ‰“å¦å…‹ï¼›åˆ†æ•£=éšæœºéå¦å…‹ï¼ˆ5Ã—æ”»å‡»ï¼Œç‰©ç†ï¼Œå¯æ ¼æŒ¡/æŠ¤ç”²ï¼‰
        leapSlashMultiplier: 5,

        rewards: {
            gold: 580000,
            exp: 350000,
            items: [
                // âœ… æ–°å¢ï¼šT0 å¥—è£…æŠ¤è…•/è£¹è…•ï¼ˆæ¯ä»¶ 20%ï¼‰
                { id: 'EQ_121', chance: 0.2 },  // å‹‡æ°”æŠ¤è…•
                { id: 'EQ_122', chance: 0.2 },  // è¿…å½±æŠ¤è…•
                { id: 'EQ_123', chance: 0.2 },  // è™”è¯šè£¹è…•
                { id: 'EQ_124', chance: 0.2 },  // åšå­¦è€…è£¹è…•
                { id: 'IT_REND_BADGE', chance: 0.8 }
            ]
        }
    },
    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - è¡€ç¥å“ˆå¡ï¼ˆç¥–å°”æ ¼æ‹‰å¸ƒï¼‰
    hakkar: {
        id: 'hakkar',
        name: 'è¡€ç¥å“ˆå¡',
        maxHp: 10000000,
        attack: 8000,
        defense: 3500,

        // æŠ€èƒ½å¾ªç¯ï¼šå¬å”¤å“ˆå¡ä¹‹å­ â†’ è¡€æ¶²è™¹å¸ â†’ å •è½ä¹‹è¡€ â†’ è¡€æ¶²è™¹å¸
        cycle: ['summon_hakkar_sons', 'blood_siphon', 'corrupted_blood', 'blood_siphon'],

        // æŠ€èƒ½1ï¼šå¬å”¤å“ˆå¡ä¹‹å­
        summonCount: 2,
        minion: {
            name: 'å“ˆå¡ä¹‹å­',
            maxHp: 800000,
            attack: 8000,
            defense: 1200
        },
        acidMultiplier: 1.2,

        // å“ˆå¡ä¹‹å­æ­»äº¡ï¼šæ¯’æ€§ä¹‹è¡€ï¼ˆä¸­æ¯’DOTï¼‰
        // è¯´æ˜ï¼šæŒ‰â€œBOSSæ”»å‡»â€ç»“ç®—ï¼ˆ0.4Ã—BossAtkï¼‰ï¼ŒæŒç»­3å›åˆï¼Œä¸å¯å å±‚ï¼ˆåªåˆ·æ–°ï¼‰
        toxicBloodDotAtkCoeff: 0.4,
        toxicBloodDuration: 3,

        // æŠ€èƒ½2ï¼šè¡€æ¶²è™¹å¸
        bloodSiphonMultiplier: 3,
        bloodSiphonHealPctPerNonToxic: 0.05, // æœªä¸­æ¯’æ€§ä¹‹è¡€ï¼šæ¯äººå›å¤å“ˆå¡ 5% æœ€å¤§ç”Ÿå‘½
        bloodSiphonSelfDmgPctPerToxic: 0.01, // ä¸­æ¯’æ€§ä¹‹è¡€ï¼šæ¯äººåå™¬å“ˆå¡ 1% æœ€å¤§ç”Ÿå‘½

        // æŠ€èƒ½3ï¼šå •è½ä¹‹è¡€ï¼ˆä¸­æ¯’DOTï¼Œæš—å½±ä¼¤å®³ï¼Œå¯å å±‚åˆ°æˆ˜æ–—ç»“æŸï¼‰
        corruptedBloodDotMultiplier: 0.5,

        rewards: {
            gold: 1400000,
            exp: 900000,
            items: [
                { id: 'IT_HAKKAR_BADGE', chance: 0.8 }
            ]
        }
    },
    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰ï¼ˆå®‰å…¶æ‹‰ï¼‰
    ossirian: {
        id: 'ossirian',
        name: 'æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰',
        maxHp: 12000000,
        attack: 8500,
        defense: 800000,

        // è¢«åŠ¨ï¼šæ¯4å›åˆç”Ÿæˆæ±²èƒ½æ°´æ™¶ï¼ˆä¸Šé™1ï¼‰
        energyCrystalEvery: 4,
        defenseDownDefense: 8000,
        defenseDownDuration: 4,

        // æŠ€èƒ½å¾ªç¯ï¼šå¥¥æ–¯é‡Œå®‰ä¹‹åŠ› â†’ è·µè¸ â†’ ç»“èˆŒè¯…å’’ â†’ åŒ…å›´ä¹‹é£
        cycle: ['ossirian_strength', 'trample', 'tongue_curse', 'surrounding_winds'],

        // æŠ€èƒ½1ï¼šå¥¥æ–¯é‡Œå®‰ä¹‹åŠ›ï¼ˆ10Ã—æ”»å‡»ï¼Œç‰©ç†ï¼‰
        ossirianStrengthMultiplier: 10,

        // æŠ€èƒ½2ï¼šè·µè¸ï¼ˆ3Ã—æ”»å‡»ï¼Œè‡ªç„¶ï¼›åˆ†æ•£ç«™ä½é¢å¤–å‡»é£1å›åˆï¼‰
        trampleMultiplier: 3,
        knockupDuration: 1,

        // æŠ€èƒ½3ï¼šç»“èˆŒè¯…å’’ï¼ˆæ€¥é€Ÿ/æš´å‡»å½’é›¶ï¼ŒæŒç»­3å›åˆï¼‰
        tongueCurseDuration: 3,

        // æŠ€èƒ½4ï¼šåŒ…å›´ä¹‹é£ï¼ˆ3Ã—æ”»å‡»ï¼Œè‡ªç„¶ï¼›é›†ä¸­ç«™ä½æ”¹ä¸ºå…¨ä½“ï¼‰
        surroundingWindsMultiplier: 3,

        // æ±²èƒ½æ°´æ™¶ï¼ˆä¸æ”»å‡»ï¼‰
        minion: {
            name: 'æ±²èƒ½æ°´æ™¶',
            maxHp: 1000000,
            attack: 0,
            defense: 4000
        },

        rewards: {
            gold: 1800000,
            exp: 1100000,
            items: [
                { id: 'IT_OSSIRIAN_BADGE', chance: 0.8 }
            ]
        }
    },
    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - åŠ å°”ï¼ˆç†”ç«ä¹‹å¿ƒï¼‰
    garr: {
        id: 'garr',
        name: 'åŠ å°”',
        maxHp: 15000000,
        attack: 10800,
        defense: 10000,

        // æŠ€èƒ½å¾ªç¯ï¼šçƒˆç„°å†²å‡» â†’ å¬å”¤ç«å…ƒç´  â†’ çƒˆç„°é£æš´ â†’ ç«ç„°éœ‡å‡»
        cycle: ['flame_impact', 'summon_fire_elementals', 'flame_storm', 'fire_shock'],

        // æŠ€èƒ½1ï¼šçƒˆç„°å†²å‡»ï¼ˆéšæœºç›®æ ‡ 3Ã—ç«ç„°æ³•æœ¯ä¼¤å®³ï¼Œå¹¶ç•™ä¸‹ç¼çƒ§DOTï¼š1.5Ã—/å›åˆï¼ŒæŒç»­4å›åˆï¼‰
        flameImpactMultiplier: 3,
        flameImpactDotMultiplier: 1.5,
        flameImpactDotDuration: 4,

        // æŠ€èƒ½2ï¼šçƒˆç„°é£æš´ï¼ˆéšæœºç›®æ ‡ 3Ã—ï¼›é›†ä¸­ç«™ä½ï¼šå…¨ä½“ 3Ã—ï¼‰
        flameStormMultiplier: 3,

        // æŠ€èƒ½3ï¼šç«ç„°éœ‡å‡»ï¼ˆå…¨ä½“ 3Ã—ï¼›åˆ†æ•£ç«™ä½ï¼šå‡»é£å…¨ä½“1å›åˆï¼‰
        fireShockMultiplier: 3,
        knockupDuration: 1,

        // æŠ€èƒ½4ï¼šå¬å”¤ç«å…ƒç´ ï¼ˆ2ä¸ªï¼‰
        summonCount: 2,
        minion: {
            name: 'ç«å…ƒç´ ',
            maxHp: 1500000,
            attack: 10800,
            defense: 10000
        },
        scorchingPainMultiplier: 1.5,
        spellVulnerabilityPerStack: 0.02, // æ¯å±‚+2%æ³•æœ¯æ‰¿ä¼¤ï¼ˆæŒç»­åˆ°æˆ˜æ–—ç»“æŸï¼Œå¯å å±‚ï¼‰

        rewards: {
            gold: 2000000,
            exp: 1200000,
            items: [
                { id: 'EQ_172', chance: 0.1 },  // åŠ›é‡æŠ¤æ‰‹
                { id: 'EQ_173', chance: 0.1 },  // å¤œå¹•æ€æ‰‹æ‰‹å¥—
                { id: 'EQ_174', chance: 0.1 },  // å¥¥æœ¯å¸ˆæ‰‹å¥—
                { id: 'EQ_175', chance: 0.1 },  // é¢„è¨€æ‰‹å¥—
                { id: 'EQ_176', chance: 0.02 }  // é€é£è€…çš„ç¦é”¢ä¹‹é¢…ï¼ˆå³ï¼‰
            ]
        }
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - è¿¦é¡¿ç”·çˆµï¼ˆç†”ç«ä¹‹å¿ƒï¼‰
    baron_geddon: {
        id: 'baron_geddon',
        name: 'è¿¦é¡¿ç”·çˆµ',
        maxHp: 16000000,
        attack: 11200,
        defense: 12000,

        // æŠ€èƒ½å¾ªç¯ï¼šåœ°ç‹±çƒˆç„° â†’ çµé­‚ç‡ƒçƒ§ â†’ åœ°ç‹±çƒˆç„° â†’ æ´»ä½“ç‚¸å¼¹
        cycle: ['hellfire', 'soul_burn', 'hellfire', 'living_bomb'],

        // æŠ€èƒ½1ï¼šåœ°ç‹±çƒˆç„°ï¼ˆAOEç«ç„°æ³•æœ¯ä¼¤å®³ï¼Œè®¡ç®—é­”æŠ—ï¼‰
        // è¯´æ˜ï¼šåŸºç¡€0.5Ã—Bossæ”»å‡»ï¼›æ¯æ¬¡æ–½æ”¾ä¼šä½¿ä¸‹ä¸€æ¬¡åœ°ç‹±çƒˆç„°é¢å¤–+0.25Ã—Bossæ”»å‡»ï¼ˆå¯å åŠ åˆ°æˆ˜æ–—ç»“æŸï¼‰
        hellfireBaseMultiplier: 0.5,
        hellfireIncreaseMultiplier: 0.25,

        // æŠ€èƒ½2ï¼šçµé­‚ç‡ƒçƒ§ï¼ˆå•ä½“ç«ç„°æ³•æœ¯ä¼¤å®³ï¼Œè®¡ç®—é­”æŠ—ï¼‰
        soulBurnMultiplier: 8,

        // æŠ€èƒ½3ï¼šæ´»ä½“ç‚¸å¼¹ï¼ˆç«ç„°æ³•æœ¯ä¼¤å®³ï¼Œè®¡ç®—é­”æŠ—ï¼›å‡»é£2å›åˆï¼‰
        // åˆ†æ•£ç«™ä½ï¼šéšæœºå•ä½“ï¼›é›†ä¸­ç«™ä½ï¼šå…¨ä½“
        livingBombMultiplier: 4,
        livingBombKnockupDuration: 2,

        rewards: {
            gold: 2200000,
            exp: 1300000,
            items: [
                { id: 'EQ_177', chance: 0.1 },  // åŠ›é‡è‚©é“ 
                { id: 'EQ_178', chance: 0.1 },  // å¤œå¹•æ€æ‰‹æŠ¤è‚©
                { id: 'EQ_179', chance: 0.1 },  // å¥¥æœ¯å¸ˆè¡¬è‚©
                { id: 'EQ_180', chance: 0.1 },  // é¢„è¨€è¡¬è‚©
                { id: 'EQ_181', chance: 0.02 }  // é€é£è€…çš„ç¦é”¢ä¹‹é¢…ï¼ˆå·¦ï¼‰
            ]
        }
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - ç„šåŒ–è€…å¤é›·æ›¼æ ¼ï¼ˆç†”ç«ä¹‹å¿ƒï¼‰
    golemagg: {
        id: 'golemagg',
        name: 'ç„šåŒ–è€…å¤é›·æ›¼æ ¼',
        maxHp: 18000000,
        attack: 12800,
        defense: 13000,

        // æŠ€èƒ½å¾ªç¯ï¼šç†”å²©å–·æº… â†’ åœ°éœ‡æœ¯ â†’ ç‚çˆ†æœ¯ â†’ ç‹‚æ€’
        cycle: ['lava_splash', 'earthquake', 'pyroblast', 'fury'],

        // è¢«åŠ¨ï¼šå›ºæœ‰2åªç†”ç«æ¶çŠ¬ï¼ˆæ”»å‡»/é˜²å¾¡åŒBossï¼‰
        houndCount: 2,
        houndHp: 18000000,

        // ç†”ç«æ¶çŠ¬æ™®æ”»å€ç‡ï¼šå¸¸æ€1.2Ã—ï¼›Bossè¡€é‡â‰¤30%åç‹‚æš´ä¸º3Ã—
        houndNormalMultiplier: 1.2,
        houndEnrageMultiplier: 3,
        houndEnrageHpPct: 0.30,

        // æŠ€èƒ½1ï¼šç†”å²©å–·æº…ï¼ˆå¦å…‹ï¼Œ5Ã—æ³•æœ¯ä¼¤å®³ï¼Œå¹¶ä½¿å…¶æ‰¿å—æ‰€æœ‰ä¼¤å®³+5%å¯å å±‚åˆ°æˆ˜æ–—ç»“æŸï¼‰
        lavaSplashMultiplier: 5,
        lavaSplashVulnPerStack: 0.05,

        // æŠ€èƒ½2ï¼šåœ°éœ‡æœ¯ï¼ˆéšæœºç›®æ ‡3Ã—ï¼›é›†ä¸­ç«™ä½ï¼šå…¨ä½“3Ã—ï¼‰
        earthquakeMultiplier: 3,

        // æŠ€èƒ½3ï¼šç‚çˆ†æœ¯ï¼ˆéšæœºç›®æ ‡4Ã—ï¼Œå¹¶ç•™ä¸‹ä½™çƒ¬DOTï¼šæ¯å›åˆ1.5Ã—æŒç»­4å›åˆï¼‰
        pyroblastMultiplier: 4,
        emberDotMultiplier: 1.5,
        emberDotDuration: 4,

        // æŠ€èƒ½4ï¼šç‹‚æ€’ï¼ˆè‡ªèº«ä¸ç†”ç«æ¶çŠ¬é€ æˆçš„æ‰€æœ‰ä¼¤å®³+5%å¯å åŠ åˆ°æˆ˜æ–—ç»“æŸï¼‰
        furyPerStack: 0.05,

        minion: {
            name: 'ç†”ç«æ¶çŠ¬',
            maxHp: 1800000,
            attack: 12800,
            defense: 13000
        },

        rewards: {
            gold: 2400000,
            exp: 1400000,
            items: [
                { id: 'EQ_183', chance: 0.1 },  // åŠ›é‡è…¿é“ 
                { id: 'EQ_184', chance: 0.1 },  // å¤œå¹•æ€æ‰‹çŸ­è£¤
                { id: 'EQ_185', chance: 0.1 },  // å¥¥æœ¯å¸ˆæŠ¤è…¿
                { id: 'EQ_186', chance: 0.1 },  // é¢„è¨€çŸ­è£¤
                { id: 'EQ_171', chance: 0.02 }  // ä¸çŸ­æš‚èƒ½é‡æŠ¤ç¬¦
            ]
        }
    },

    // âœ… æ–°å¢ï¼š60çº§ä¸–ç•Œé¦–é¢† - ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ï¼ˆç†”ç«ä¹‹å¿ƒï¼‰
    majordomo_executus: {
        id: 'majordomo_executus',
        name: 'ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯',
        maxHp: 20000000,
        attack: 12800,
        defense: 15000,

        // æŠ€èƒ½å¾ªç¯ï¼šåç‰©ç†æŠ¤ç›¾ â†’ å¥¥çˆ†æœ¯ â†’ åé­”æ³•æŠ¤ç›¾ â†’ å¥¥çˆ†æœ¯
        cycle: ['anti_physical_shield', 'arcane_explosion', 'anti_magic_shield', 'arcane_explosion'],

        // è¢«åŠ¨ï¼šå›ºæœ‰2ä¸ªçƒˆç„°è¡Œè€…åŒ»å¸ˆï¼ˆæ¯å›åˆä¸ºå…¨ä½“å·±æ–¹å›å¤ 10Ã—Bossæ”»å‡»ï¼‰
        healerCount: 2,
        healerHp: 3000000,
        healerHealMultiplier: 10,
        healerName: 'çƒˆç„°è¡Œè€…åŒ»å¸ˆ',

        // è¢«åŠ¨ï¼šå›ºæœ‰2ä¸ªçƒˆç„°è¡Œè€…ç²¾è‹±ï¼ˆæ¯å›åˆå¯¹å…¨ä½“è§’è‰²é€ æˆ 1.5Ã—Bossæ”»å‡» çš„æ³•æœ¯ä¼¤å®³ï¼‰
        eliteCount: 2,
        eliteHp: 5000000,
        eliteAoEDamageMultiplier: 1.5,
        eliteName: 'çƒˆç„°è¡Œè€…ç²¾è‹±',

        // æŠ€èƒ½1ï¼šåç‰©ç†æŠ¤ç›¾ï¼ˆå…¨ä½“æ•Œæ–¹å•ä½å…ç–«ç‰©ç†ä¼¤å®³ï¼‰
        antiPhysicalDuration: 2,

        // æŠ€èƒ½2ï¼šå¥¥çˆ†æœ¯ï¼ˆå…¨ä½“æ³•æœ¯ä¼¤å®³ï¼Œè®¡ç®—é­”æŠ—ï¼‰
        arcaneExplosionMultiplier: 2,

        // æŠ€èƒ½3ï¼šåé­”æ³•æŠ¤ç›¾ï¼ˆå…¨ä½“æ•Œæ–¹å•ä½å…ç–«æ³•æœ¯ä¼¤å®³ï¼‰
        antiMagicDuration: 2,

        // UIé€šç”¨å°å¼Ÿé…ç½®ï¼ˆæœ¬Bosså®é™…å°å¼Ÿä¸ºä¸¤ç§ç±»å‹ï¼Œæˆ˜æ–—ä¸­ä»¥æ¯ä¸ªå°å¼Ÿå¯¹è±¡çš„ maxHp/displayName ä¸ºå‡†ï¼‰
        minion: {
            name: 'çƒˆç„°è¡Œè€…',
            maxHp: 5000000,
            attack: 12800,
            defense: 15000
        },

        rewards: {
            gold: 2600000,
            exp: 1500000,
            items: [
                { id: 'EQ_187', chance: 0.1 },  // åŠ›é‡èƒ¸ç”²
                { id: 'EQ_188', chance: 0.1 },  // å¤œå¹•æ€æ‰‹èƒ¸ç”²
                { id: 'EQ_189', chance: 0.1 },  // å¥¥æœ¯å¸ˆé•¿è¢
                { id: 'EQ_190', chance: 0.1 },  // é¢„è¨€æ³•è¢
            ]
        }
    },

    // âœ… æ–°å¢ï¼šå›¢é˜Ÿé¦–é¢† - ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯ï¼ˆ5äººï¼‰
    ragnaros: {
        id: 'ragnaros',
        name: 'ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯',
        maxHp: 30000000,
        attack: 18000,
        defense: 18000,

        // è¢«åŠ¨ï¼šè¨å¼—æ‹‰æ–¯ï¼Œç‚é­”æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ‰‹ â€”â€” æ¯å›åˆå¯¹å¦å…‹é€ æˆ 2.5Ã—BOSSæ”»å‡» çš„ç«ç„°ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
        sulfurasMultiplier: 2.5,

        // æŠ€èƒ½ï¼šæ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ€’ï¼ˆé»˜è®¤æ‰“å¦å…‹ï¼›é›†ä¸­ç«™ä½ï¼šæ‰“å…¨é˜Ÿï¼‰
        wrathMultiplier: 3,

        // æŠ€èƒ½ï¼šå…ƒç´ æ€’ç«ï¼ˆéšæœºç›®æ ‡ï¼›å¹¶æ–½åŠ ä½™çƒ¬DOTï¼‰
        elementalFuryMultiplier: 1.5,
        emberDotMultiplier: 1.5,
        emberDotDuration: 3,

        // æŠ€èƒ½ï¼šå²©æµ†å–·å‘ï¼ˆéšæœºç›®æ ‡ï¼‰
        magmaEruptionMultiplier: 3,

        // æŠ€èƒ½ï¼šè®©ç«ç„°å‡€åŒ–ä¸€åˆ‡ï¼ˆå¤šæ®µçƒ­æµªAOEï¼‰
        purifyMultiplier: 1.2,
        purifyWaves: 3,

        // æŠ€èƒ½ï¼šä¸‹æ½œï¼ˆå…ç–«ä¼¤å®³ï¼Œå¬å”¤ç«ç„°ä¹‹å­ï¼‰
        submergeDuration: 3,
        sonCount: 4,
        sonHp: 6000000,
        sonBurnTargets: 2,
        sonBurnMultiplier: 1.2,

        minion: {
            name: 'ç«ç„°ä¹‹å­',
            maxHp: 6000000,
            attack: 18000,
            defense: 18000,
        },

        // æŠ€èƒ½å¾ªç¯ï¼š
        // æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ€’ â†’ å…ƒç´ æ€’ç« â†’ å²©æµ†å–·å‘ â†’ è®©ç«ç„°å‡€åŒ–ä¸€åˆ‡ â†’ ä¸‹æ½œ â†’ å…ƒç´ æ€’ç« â†’ å²©æµ†å–·å‘ â†’ è®©ç«ç„°å‡€åŒ–ä¸€åˆ‡ â†’ å¾ªç¯
        cycle: [
            'ragnaros_wrath',
            'elemental_fury',
            'magma_eruption',
            'purify_all',
            'submerge',
            'elemental_fury',
            'magma_eruption',
            'purify_all',
        ],

        rewards: {
            gold: 3200000,
            exp: 1800000,
            items: [
                { id: 'IT_RAGNAROS_BADGE', chance: 0.8 },
                { id: 'EQ_191', chance: 0.10 },
                { id: 'EQ_192', chance: 0.10 },
                { id: 'EQ_193', chance: 0.10 },
                { id: 'EQ_194', chance: 0.10 },
                { id: 'EQ_195', chance: 0.10 },
                { id: 'EQ_196', chance: 0.10 },
                { id: 'EQ_197', chance: 0.10 },
                { id: 'EQ_198', chance: 0.10 },
                { id: 'EQ_199', chance: 0.10 },
                { id: 'EQ_200', chance: 0.10 },
                { id: 'EQ_201', chance: 0.02 }
            ]
        }
    },

};

// ==================== ç¾ç»Šåç§°æ˜ å°„ ====================
const BOND_NAMES = {
    baoernai: 'åŒ…äºŒå¥¶',
    jianyue: 'ç®€çº¦è€Œä¸ç®€å•'
};

// ==================== UTILS ====================
function formatItemStatValue(stat, valueRaw) {
    const v = Number(valueRaw) || 0;

    const percentStats = new Set(['critRate', 'blockRate']);

    if (percentStats.has(stat)) {
        return `${(v).toFixed(1)}%`;
    }

    if (stat === 'critDamage') {
        return v <= 1
            ? `${Math.floor(v * 100)}%`
            : `${Math.floor(v)}`;
    }

    return `${Math.floor(v)}`;
}


function mergeEquipments(eqA, eqB) {
    // ==================== ç‰¹æ®Šé…æ–¹ï¼šé€é£è€…å·¦å³é¢…åˆæˆé£å‰‘ ====================
    // è§„åˆ™ï¼šEQ_176ï¼ˆå³ï¼‰ + EQ_181ï¼ˆå·¦ï¼‰ => EQ_182ï¼ˆé›·éœ†ä¹‹æ€’ï¼Œé€é£è€…çš„ç¥ç¦ä¹‹å‰‘ï¼‰
    const isThunderfuryRecipe = (a, b) => {
        const ida = a?.id;
        const idb = b?.id;
        return (ida === 'EQ_176' && idb === 'EQ_181') || (ida === 'EQ_181' && idb === 'EQ_176');
    };

    if (isThunderfuryRecipe(eqA, eqB)) {
        const forged = createEquipmentInstance('EQ_182');
        return forged || null;
    }

    if (eqA.id !== eqB.id) return null;

    const getLevel = (eq) => (eq?.currentLevel ?? eq?.level ?? 0);

    const levelA = getLevel(eqA);
    const levelB = getLevel(eqB);

    // âœ… Lv100 è¿›é˜¶åˆæˆï¼ˆæ‹–åŠ¨åˆæˆï¼‰
    // è§„åˆ™ï¼š
    // - EQ_003 ç¥ç§˜æ£®æ—åŠå  Lv100 + ä»»æ„ç­‰çº§ EQ_003 â†’ EQ_125 ç¥ç§˜ç¥ç€åŠå 
    // - EQ_125 ç¥ç§˜ç¥ç€åŠå  Lv100 + ä»»æ„ç­‰çº§ EQ_125 â†’ EQ_126 ç¥ç§˜è“å®çŸ³åŠå 
    // - EQ_126 ç¥ç§˜è“å®çŸ³åŠå  Lv100 + ä»»æ„ç­‰çº§ EQ_126 â†’ EQ_127 ç¥ç§˜çº¢å®çŸ³åŠå 
    const POST_NECLACE_LV100_EVOLVE = {
        EQ_003: 'EQ_125',
        EQ_125: 'EQ_126',
        EQ_126: 'EQ_127',
    };
    const POST_RING_LV100_EVOLVE = {
        EQ_004: 'EQ_128',
        EQ_128: 'EQ_129',
        EQ_129: 'EQ_130',
    };

    const nextNeckId = POST_NECLACE_LV100_EVOLVE[eqA.id];
    if (nextNeckId && Math.max(levelA, levelB) >= 100) {
        const evolved = createEquipmentInstance(nextNeckId);
        return evolved || null;
    }

    const nextRingId = POST_RING_LV100_EVOLVE[eqA.id];
    if (nextRingId && Math.max(levelA, levelB) >= 100) {
        const evolved = createEquipmentInstance(nextRingId);
        return evolved || null;
    }

    const newLevel = Math.min(100, levelA + levelB + 1);

    return {
        ...eqA,
        currentLevel: newLevel,
        stats: scaleStats(eqA.baseStats, eqA.growth, newLevel)
    };
}



function getEquipmentTemplate(templateId) {
    // å¸¸è§„æ‰è½è£…å¤‡ï¼šFIXED_EQUIPMENTS
    // ä»»åŠ¡/å‰§æƒ…å¥–åŠ±è£…å¤‡ï¼šQUEST_REWARD_EQUIPMENTS
    return FIXED_EQUIPMENTS?.[templateId] || QUEST_REWARD_EQUIPMENTS?.[templateId];
}

function createEquipmentInstance(templateId) {
    const tpl = getEquipmentTemplate(templateId);

    if (!tpl) {
        console.error(`[createEquipmentInstance] è£…å¤‡æ¨¡æ¿ä¸å­˜åœ¨: ${templateId}`);
        return null;
    }

    const level = Number.isFinite(Number(tpl.level)) ? Number(tpl.level) : 0;

    return {
        ...tpl,
        instanceId: `eq_${Date.now()}_${Math.random()}`,
        qualityColor: getRarityColor(tpl.rarity),
        currentLevel: level,
        stats: scaleStats(tpl.baseStats || {}, tpl.growth || {}, level)
    };
}

function getSetBonusesForCharacter(character) {
    // character.equipment: { weapon, armor, ... } æ¯ä¸ª slot å¯èƒ½æ˜¯ null æˆ–è£…å¤‡å®ä¾‹
    const eqList = Object.values(character.equipment || {}).filter(Boolean);
    if (eqList.length === 0) return [];

    // ç»Ÿè®¡å¥—è£… id / åç§°ï¼ˆæ ¹æ®ä½ è£…å¤‡æ•°æ®ç»“æ„æ”¹å­—æ®µåï¼‰
    // è¿™é‡Œä¼˜å…ˆç”¨ setId / setNameï¼Œå¦‚æœä½ æ˜¯ç”¨ tpl.set å°±æ”¹ä¸€ä¸‹
    const countBySet = new Map(); // setId -> { setId, setName, count }
    for (const eq of eqList) {
        const setId = eq.setId || eq.set || null;
        const setName = eq.setName || eq.set || eq.setId || null;
        if (!setId) continue;

        const prev = countBySet.get(setId) || { setId, setName, count: 0 };
        prev.count += 1;
        countBySet.set(setId, prev);
    }

    // ä½ çš„å¥—è£…è§„åˆ™è¡¨ï¼šSET_BONUSESï¼ˆä½ å¯ä»¥è‡ªå·±å®šä¹‰ï¼‰
    // ä¾‹ï¼š
    // const SET_BONUSES = {
    //   wolf: { name:'ç‹¼ç‹', tiers:[ {count:2, bonus:{atkPct:0.1}}, {count:4, bonus:{hpPct:0.15}} ] }
    // }
    if (typeof SET_BONUSES === 'undefined') return []; // å…¼å®¹ä½ ç›®å‰è¿˜æ²¡åŠ  set è¡¨

    const active = [];
    for (const { setId, setName, count } of countBySet.values()) {
        const def = SET_BONUSES[setId];
        if (!def) continue;

        // æ‰¾åˆ°å·²æ¿€æ´»çš„ tier
        const tiers = Array.isArray(def.tiers) ? def.tiers : [];
        const activated = tiers.filter(t => count >= t.count);

        if (activated.length > 0) {
            active.push({
                setId,
                name: def.name || setName || setId,
                count,
                activated,
            });
        }
    }

    // å›ºå®šæ’åºï¼šæ¿€æ´»å¤šçš„åœ¨å‰
    active.sort((a, b) => (b.activated.length - a.activated.length) || (b.count - a.count));
    return active;
}

function formatBonusText(bonusObj) {
    const entries = Object.entries(bonusObj || {});
    if (entries.length === 0) return '';

    const nameMap = {
        atkPct: 'æ”»å‡»',
        hpPct: 'ç”Ÿå‘½',
        bossHpPct: 'BOSSæˆ˜æ–—ç”Ÿå‘½',
        expBonus: 'ç»éªŒå€¼å¢å¹…',
        goldBonus: 'é‡‘å¸å¢å¹…',
        dropBonus: 'æ‰è½å¢å¹…',
        resourceBonus: 'æ‰€æœ‰å»ºç­‘äº§é‡',
        mapDamageBonus: 'åœ°å›¾æˆ˜æ–—ä¼¤å®³',
        versatility: 'å…¨èƒ½',
        expMult: 'ç»éªŒè·å–',
        goldMult: 'é‡‘å¸æ‰è½',
        resourceMult: 'èµ„æºç”Ÿäº§é€Ÿåº¦',
    };

    return entries.map(([k, v]) => {
        if (typeof v === 'number') {
            // âœ… â€œä¹˜ç®—å€ç‡â€å­—æ®µï¼šæ˜¾ç¤ºä¸º +X%
            if (k.endsWith('Mult')) {
                const pct = Math.round((v - 1) * 100);
                const sign = pct >= 0 ? '+' : '';
                return `${nameMap[k] || k} ${sign}${pct}%`;
            }

            // æ˜ç¡®æŒ‰ç™¾åˆ†æ¯”å±•ç¤ºçš„å­—æ®µ
            if (k.endsWith('Pct') || k === 'expBonus' || k === 'goldBonus' || k === 'dropBonus' || k === 'resourceBonus' || k === 'mapDamageBonus') {
                return `${nameMap[k] || k} +${Math.round(v * 100)}%`;
            }

            return `${nameMap[k] || k} +${v}`;
        }
        return `${nameMap[k] || k} +${String(v)}`;
    }).join('ï¼Œ');
}



function formatStatForDisplay(stat, value) {
    if (stat === 'critRate' || stat === 'blockRate' || stat === 'expBonus') {
        return `${Math.floor(value * 100)}%`;
    }
    return Math.floor(value);
}

// åœ°å›¾ç´¯è®¡å‡»æ€æ•°ï¼ˆè·¨åŒºåŸŸç´¯è®¡ï¼‰ï¼šç”¨äºæˆå°±ã€æŒç»­æˆ˜æ–—â… ~â…©ã€‘ç­‰
function getTotalMapKills(state) {
    const counts = (state?.zoneKillCounts && typeof state.zoneKillCounts === 'object' && !Array.isArray(state.zoneKillCounts))
        ? state.zoneKillCounts
        : {};

    return Object.values(counts).reduce((sum, v) => sum + (Math.max(0, Math.floor(Number(v) || 0))), 0);
}

// ä¸»åŸç´¯è®¡å»ºç­‘å»ºé€ æ•°ï¼šç”¨äºæˆå°±ã€å»ºè®¾è€…â… ~â…©ã€‘ç­‰
// è¯´æ˜ï¼šå…¼å®¹æ—§ç³»ç»Ÿï¼ˆstate.buildingsï¼‰ä¸æ–°ç³»ç»Ÿï¼ˆstate.functionalBuildingsï¼‰
function getTotalBuildingsBuilt(state) {
    const buildings = (state?.buildings && typeof state.buildings === 'object' && !Array.isArray(state.buildings))
        ? state.buildings
        : {};
    const functional = (state?.functionalBuildings && typeof state.functionalBuildings === 'object' && !Array.isArray(state.functionalBuildings))
        ? state.functionalBuildings
        : {};

    const sumObj = (obj) => Object.values(obj).reduce((sum, v) => sum + Math.max(0, Math.floor(Number(v) || 0)), 0);
    return sumObj(buildings) + sumObj(functional);
}

// ä¸–ç•Œé¦–é¢†ç´¯è®¡å‡»æ€æ•°ï¼ˆè·¨ä¸–ç´¯è®¡ï¼‰ï¼šç”¨äºæˆå°±ã€é¦–é¢†æ€æ‰‹â… ~â…©ã€‘ç­‰
function getTotalWorldBossKills(state) {
    const counts = (state?.worldBossKillCounts && typeof state.worldBossKillCounts === 'object' && !Array.isArray(state.worldBossKillCounts))
        ? state.worldBossKillCounts
        : {};

    return Object.values(counts).reduce((sum, v) => sum + Math.max(0, Math.floor(Number(v) || 0)), 0);
}


// âœ… æˆå°±ï¼šå…¨é˜Ÿç”Ÿå‘½ç™¾åˆ†æ¯”åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
function getAchievementHpPctBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.hpPct) {
            bonus += Number(a.reward.hpPct) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.02 = +2%
}

// âœ… æˆå°±ï¼šä»…BOSSæˆ˜æ–—ç”Ÿå‘½ç™¾åˆ†æ¯”åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
// è¯´æ˜ï¼šåªåœ¨ BOSS æˆ˜æ–—åˆå§‹åŒ–æ—¶åº”ç”¨ï¼ˆè§ START_BOSS_COMBATï¼‰
function getAchievementBossHpPctBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.bossHpPct) {
            bonus += Number(a.reward.bossHpPct) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.05 = +5%
}

// âœ… æˆå°±ï¼šå…¨é˜Ÿç»éªŒè·å–åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
function getAchievementExpBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.expBonus) {
            bonus += Number(a.reward.expBonus) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.02 = +2%
}

// âœ… æˆå°±ï¼šé‡‘å¸è·å–åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
function getAchievementGoldBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.goldBonus) {
            bonus += Number(a.reward.goldBonus) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.05 = +5%
}

// âœ… æ€»é‡‘å¸è·å–åŠ æˆï¼šæˆå°±é‡‘å¸å¢å¹… + è½®å›é‡‘å¸å¢å¹…ï¼ˆåŠ æ³•å åŠ ï¼‰
function getTotalGoldBonus(state) {
    const ach = Number(getAchievementGoldBonus(state)) || 0;
    const rebirth = Number(state?.rebirthBonuses?.gold) || 0;
    return Math.max(0, ach + rebirth);
}

// ==================== åéª‘å›¾é‰´ï¼šä¹˜ç®—å€ç‡ ====================
// è§„åˆ™ï¼šå·²ç‚¹äº®åéª‘æä¾›å€ç‡åŠ æˆï¼Œå¤šä¸ªåéª‘ä¹‹é—´ç›¸äº’ä¹˜ç®—ã€‚
// ä¸åŸæœ‰â€œåŠ æ³•â€çš„æˆå°±/è½®å›/è®­ç»ƒç­‰ä¸å†²çªï¼šæœ€ç»ˆ = base * (1 + additiveBonus) * mountMult
function getMountMultipliers(state) {
    const codexMounts = Array.isArray(state?.codexMounts) ? state.codexMounts : [];
    const mountSet = new Set(codexMounts);

    let expMult = 1;
    let goldMult = 1;
    let resourceMult = 1;

    (Array.isArray(MOUNT_CODEX) ? MOUNT_CODEX : []).forEach(m => {
        if (!m?.id) return;
        if (!mountSet.has(m.id)) return;
        const b = m.bonus || {};
        if (typeof b.expMult === 'number' && b.expMult > 0) expMult *= b.expMult;
        if (typeof b.goldMult === 'number' && b.goldMult > 0) goldMult *= b.goldMult;
        if (typeof b.resourceMult === 'number' && b.resourceMult > 0) resourceMult *= b.resourceMult;
    });

    return { expMult, goldMult, resourceMult };
}

// åŸºç¡€é‡‘å¸ baseGoldï¼Œåº”ç”¨é‡‘å¸è·å–åŠ æˆï¼šeffective = floor(baseGold * (1 + bonus))
function getEffectiveGoldGain(baseGold, state) {
    const base = Number(baseGold) || 0;
    if (base <= 0) return 0;
    const bonus = getTotalGoldBonus(state);
    const { goldMult } = getMountMultipliers(state);
    const additive = (!Number.isFinite(bonus) || bonus <= 0) ? 1 : (1 + bonus);
    return Math.floor(base * additive * (goldMult || 1));
}


function getAchievementDropBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.dropBonus) {
            bonus += a.reward.dropBonus;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.05 = +5%
}

// âœ… åŠŸèƒ½å»ºç­‘ï¼šå¯»é¾™ä¼šæ‰è½åŠ æˆï¼ˆæ¯çº§+5%ï¼Œ20çº§=+100%ï¼‰
function getDragonSeekersGuildDropBonus(state) {
    const level = Math.max(0, Math.floor(Number(state?.functionalBuildings?.dragon_seekers_guild) || 0));
    // æ¯çº§ +5% æ‰è½æ¦‚ç‡ï¼ˆçº¿æ€§ï¼‰ï¼Œæœ€å¤š +100%
    return Math.min(1, level * 0.05);
}

// âœ… æ€»æ‰è½åŠ æˆï¼šæˆå°±æ‰è½å¢å¹… + å¯»é¾™ä¼šæ‰è½å¢å¹…
// è§„åˆ™ï¼šå°†å„æ¥æºçš„â€œæ‰è½å¢å¹…â€å…ˆçº¿æ€§ç›¸åŠ ï¼Œå†ä½œç”¨åˆ°åŸºç¡€æ¦‚ç‡ï¼šeffective = base * (1 + bonus)ï¼Œæœ€åå°é¡¶ 100%
function getTotalDropBonus(state) {
    const ach = Number(getAchievementDropBonus(state)) || 0;
    const guild = Number(getDragonSeekersGuildDropBonus(state)) || 0;
    return Math.max(0, ach + guild);
}

// åŸºç¡€æ¦‚ç‡ baseChanceï¼ˆ0~1ï¼‰ï¼Œåº”ç”¨æ‰è½åŠ æˆå¹¶å°é¡¶ 1
function getEffectiveDropChance(baseChance, state) {
    const base = Math.max(0, Math.min(1, Number(baseChance) || 0));
    if (base <= 0) return 0;
    const bonus = getTotalDropBonus(state);
    return Math.min(1, base * (1 + bonus));
}

// âœ… æˆå°±ï¼šå»ºç­‘äº§é‡åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
function getAchievementResourceBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.resourceBonus) {
            bonus += Number(a.reward.resourceBonus) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.02 = +2%
}

// âœ… æˆå°±ï¼šåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
// æ³¨æ„ï¼šä¸è£…å¤‡ç‰¹æ•ˆï¼ˆå¦‚ map_slayerï¼‰çš„åŠ æˆå°†åœ¨æˆ˜æ–—è®¡ç®—å¤„â€œä¹˜ç®—â€ï¼ˆè§ getMapDamageDealtMultï¼‰
function getAchievementMapDamageBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.mapDamageBonus) {
            bonus += Number(a.reward.mapDamageBonus) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 0.05 = +5%
}

// âœ… æˆå°±ï¼šå…¨é˜Ÿå…¨èƒ½åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
function getAchievementVersatilityBonus(state) {
    const unlocked = state?.achievements || {};
    let bonus = 0;
    Object.values(ACHIEVEMENTS).forEach(a => {
        if (unlocked[a.id] && a.reward?.versatility) {
            bonus += Number(a.reward.versatility) || 0;
        }
    });
    return bonus; // ä¾‹å¦‚ 2 è¡¨ç¤º +2 å…¨èƒ½
}


function getAchievementMapDamageDealtMult(state) {
    const bonus = getAchievementMapDamageBonus(state);
    if (!Number.isFinite(bonus) || bonus <= 0) return 1;
    return 1 + bonus;
}

function addEquipmentIdToCodex(state, equipmentId) {
    if (!equipmentId) return state;
    const current = Array.isArray(state.codex) ? state.codex : [];
    if (current.includes(equipmentId)) return state;
    return { ...state, codex: [...current, equipmentId] };
}

function addEquipmentIdToLv100Codex(state, equipmentId) {
    if (!equipmentId) return state;
    const cur = Array.isArray(state.codexEquipLv100) ? state.codexEquipLv100 : [];
    if (cur.includes(equipmentId)) return state;
    return { ...state, codexEquipLv100: [...cur, equipmentId] };
}


function addJunkIdToCodex(state, junkId) {
    if (!junkId) return state;
    const current = Array.isArray(state.codexJunk) ? state.codexJunk : [];
    if (current.includes(junkId)) return state;
    return { ...state, codexJunk: [...current, junkId] };
}

function addMountIdToCodex(state, mountId) {
    if (!mountId) return state;
    const current = Array.isArray(state.codexMounts) ? state.codexMounts : [];
    if (current.includes(mountId)) return state;
    return { ...state, codexMounts: [...current, mountId] };
}

/**
 * å°è¯•ä»æŸä¸ªä¸–ç•Œé¦–é¢†è§£é”åéª‘ï¼ˆä¸è¿›èƒŒåŒ…ï¼Œåªç‚¹äº®å›¾é‰´ï¼‰
 * @param {object} state
 * @param {string} bossId
 * @param {(text: string) => void} onLog
 * @returns {{ state: object, unlocked: object|null }}
 */
function tryUnlockMountFromBoss(state, bossId, onLog) {
    try {
        if (!bossId) return { state, unlocked: null };

        const mounts = Array.isArray(MOUNT_CODEX) ? MOUNT_CODEX : [];
        const mount = mounts.find(m => m?.bossId === bossId);
        if (!mount?.id) return { state, unlocked: null };

        const cur = Array.isArray(state?.codexMounts) ? state.codexMounts : [];
        if (cur.includes(mount.id)) return { state, unlocked: null };

        const chance = Number(mount.dropChance) || 0;
        if (chance <= 0) return { state, unlocked: null };

        if (Math.random() >= chance) return { state, unlocked: null };

        let next = addMountIdToCodex(state, mount.id);

        // âœ… ç«‹å³é‡ç®—å…¨é˜Ÿå±æ€§ï¼Œè®©å…¨å±€åŠ æˆç«‹åˆ»ç”Ÿæ•ˆ
        if (next && next.characters) {
            next = { ...next, characters: recalcPartyStats(next, next.characters) };
        }

        if (typeof onLog === 'function') {
            const bonusText = mount?.bonus ? formatBonusText(mount.bonus) : '';
            const bonusTip = bonusText ? `ï¼ˆå…¨å±€åŠ æˆï¼š${bonusText}ï¼‰` : '';
            onLog(`ğŸ‰ è·å¾—åéª‘ã€${mount.name}ã€‘ï¼å·²ç‚¹äº®åéª‘å›¾é‰´${bonusTip}`);
        }

        return { state: next, unlocked: mount };
    } catch (e) {
        console.error('tryUnlockMountFromBoss error:', e);
        return { state, unlocked: null };
    }
}

function learnNewSkills(character) {
    const classData = CLASSES[character.classId];
    const learned = new Set(character.skills || []);

    // âœ… ç§æ—é¢å¤–æŠ€èƒ½ï¼šéšæ—¶ç¡®ä¿æ‹¥æœ‰ï¼ˆç”¨äºæ—§è§’è‰²è¡¥é½ / æ–°å¢ç§æ—è¢«åŠ¨ï¼‰
    const raceExtraSkills = RACE_TRAITS?.[character.race]?.extraSkills || [];
    raceExtraSkills.forEach(sid => {
        if (sid) learned.add(sid);
    });

    classData.skills.forEach(({ level, skillId }) => {
        if (character.level >= level && !learned.has(skillId)) {
            learned.add(skillId);
        }
    });

    return Array.from(learned);
}

// è®¡ç®—â€œå…¨é˜Ÿå…‰ç¯â€å€ç‡ï¼šåªè¦é˜Ÿé‡Œæœ‰äººç‚¹äº†ï¼Œå°±å…¨é˜Ÿåƒåˆ°
function getPartyAuraMultipliers(characters) {
    let hpMul = 1;
    let spellPowerMul = 1;

    (characters || []).forEach(c => {
        const t = c.talents || {};
        // 30çº§ï¼šçœŸè¨€æœ¯è€ï¼ˆå…¨é˜ŸHP+10%ï¼‰
        if (t[30] === 'pwt') hpMul *= 1.10;

        // 30çº§ï¼šç¥åœ£å¯è¿ªï¼ˆå…¨é˜Ÿæ³•å¼º+5%ï¼‰
        if (t[30] === 'holy_enlight') spellPowerMul *= 1.05;

        // å†°éœœæ³•å¸ˆ40çº§ï¼šå¥¥æœ¯æ™ºæ…§ï¼ˆå…¨é˜Ÿæ³•å¼º+10%ï¼‰
        if (t[40] === 'arcane_intellect') spellPowerMul *= 1.10;
    });

    return { hpMul, spellPowerMul };
}

// ç”¨åŒä¸€å¥—å…‰ç¯å€ç‡ï¼Œé‡ç®—å…¨é˜Ÿ statsï¼ˆå…³é”®ï¼šå…‰ç¯è¦å…¨é˜Ÿä¸€èµ·é‡ç®—ï¼‰
function recalcPartyStats(gameState,characters) {
    const auras = getPartyAuraMultipliers(characters);
    return (characters || []).map(c => {
        const next = { ...c };
        next.stats = calculateTotalStats(next, auras, gameState);
        return next;
    });
}


// è®¡ç®—è§’è‰²æ€»å±æ€§ï¼ˆåŸºç¡€+è£…å¤‡ï¼‰
function calculateTotalStats(character, partyAuras = { hpMul: 1, spellPowerMul: 1 }, gameState) {
    const classData = CLASSES[character.classId];

    // å…ˆç®— max
    let totalStats = {
        hp: classData.baseStats.hp + (character.level - 1) * 10,
        mp: classData.baseStats.mp + (character.level - 1) * 5,
        attack: classData.baseStats.attack + (character.level - 1) * 2,
        spellPower: classData.baseStats.spellPower + (character.level - 1) * 2,
        armor: classData.baseStats.armor + (character.level - 1) * 3,
        magicResist: classData.baseStats.magicResist + (character.level - 1) * 1,
        blockValue: classData.baseStats.blockValue || 0,

        haste: 0,
        critRate: 5,
        critDamage: 2.0,
        mastery: 0,
        versatility: 0,
        blockRate: 0,
        expBonus: 0,

        // å¤©èµ‹/çŠ¶æ€ç”¨ï¼šå—åˆ°ä¼¤å®³ä¹˜åŒºï¼ˆ1=ä¸å˜ï¼Œ0.8=å‡ä¼¤20%ï¼‰
        damageTakenMult: 1
    };

    // ==================== RACE (PASSIVE) ====================
    // ç§æ—è¢«åŠ¨ï¼šç›´æ¥åŠ åˆ°é¢æ¿å±æ€§é‡Œï¼Œåç»­ç²¾é€š/å¤©èµ‹/è£…å¤‡ç­‰ä¼šä¸€èµ·ç»“ç®—
    const raceTrait = RACE_TRAITS?.[character.race];
    if (raceTrait?.statBonus) {
        for (const [k, v] of Object.entries(raceTrait.statBonus)) {
            totalStats[k] = (totalStats[k] || 0) + v;
        }
    }

// âœ… æ—¶é—´æ®µå±æ€§åŠ æˆï¼ˆä¾‹å¦‚ï¼šæš—å¤œç²¾çµã€ç²¾çµç²¾é­„ã€‘ï¼‰
// çº¦å®šï¼šdayStart(å«)~nightStart(ä¸å«) ä¸ºâ€œç™½å¤©â€ï¼Œå…¶ä½™ä¸ºâ€œå¤œæ™šâ€
    if (raceTrait?.timeBasedStatBonus) {
        const cfg = raceTrait.timeBasedStatBonus || {};
        const dayStart = Number.isFinite(Number(cfg.dayStart)) ? Number(cfg.dayStart) : 6;
        const nightStart = Number.isFinite(Number(cfg.nightStart)) ? Number(cfg.nightStart) : 18;

        const hour = new Date().getHours();
        const isDay = dayStart < nightStart
            ? (hour >= dayStart && hour < nightStart)
            : (hour >= dayStart || hour < nightStart);

        const bonus = (isDay ? cfg.dayBonus : cfg.nightBonus) || {};
        if (bonus && typeof bonus === 'object') {
            for (const [k, v] of Object.entries(bonus)) {
                totalStats[k] = (totalStats[k] || 0) + (Number(v) || 0);
            }
        }
    }


    // å¥—è£…åŠ æˆï¼ˆexpBonus / goldBonus / dropBonus ç­‰ï¼‰
    const setBonuses = getSetBonusesForCharacter(character);
    for (const set of setBonuses) {
        for (const tier of set.activated) {
            for (const [k, v] of Object.entries(tier.bonus || {})) {
                totalStats[k] = (totalStats[k] || 0) + v;
            }
        }
    }

    // é‡ç”Ÿå…¨å±€åŠ æˆ
    totalStats.expBonus = (totalStats.expBonus || 0) + (gameState?.rebirthBonuses?.exp || 0);

    // âœ… åŠŸèƒ½å»ºç­‘ï¼šè®­ç»ƒå‡äººç»éªŒåŠ æˆï¼ˆæ¯åº§ +1%ï¼‰
    const trainingCount = Math.max(0, Math.floor(Number(gameState?.functionalBuildings?.training_dummy) || 0));
    if (trainingCount > 0) {
        totalStats.expBonus = (totalStats.expBonus || 0) + trainingCount * 0.01;
    }

    // âœ… æˆå°±ï¼šç»éªŒè·å–åŠ æˆï¼ˆè·¨æˆå°±åŠ æ³•å åŠ ï¼‰
    const achExpBonus = getAchievementExpBonus(gameState);
    if (Number.isFinite(achExpBonus) && achExpBonus !== 0) {
        totalStats.expBonus = (totalStats.expBonus || 0) + achExpBonus;
    }

    // ==================== åéª‘å›¾é‰´åŠ æˆï¼ˆå…¨é˜Ÿæ°¸ä¹…ï¼‰ ====================
    // è§„åˆ™ï¼šå·²ç‚¹äº®çš„åéª‘ä¼šæä¾›å…¨å±€åŠ æˆï¼ˆä¾‹å¦‚ï¼š10%ç»éªŒåŠ æˆï¼‰ã€‚
    const codexMounts = Array.isArray(gameState?.codexMounts) ? gameState.codexMounts : [];
    if (codexMounts.length > 0) {
        const mountSet = new Set(codexMounts);
        (Array.isArray(MOUNT_CODEX) ? MOUNT_CODEX : []).forEach(m => {
            if (!m || !m.id) return;
            if (!mountSet.has(m.id)) return;
            const bonus = m.bonus || {};
            for (const [k, v] of Object.entries(bonus)) {
                // âœ… åéª‘â€œä¹˜ç®—å€ç‡â€ç”± getMountMultipliers ç»Ÿä¸€å¤„ç†ï¼Œä¸å†™è¿›é¢æ¿åŠ æ³•ç»Ÿè®¡
                if (k.endsWith('Mult')) continue;
                totalStats[k] = (totalStats[k] || 0) + (Number(v) || 0);
            }
        });
    }

    // ==================== å›¾é‰´ Lv.100 é›†é½åŠ æˆï¼ˆå…¨é˜Ÿæ°¸ä¹…ï¼‰ ====================
    const codexLv100 = Array.isArray(gameState?.codexEquipLv100) ? gameState.codexEquipLv100 : [];
    const codexLv100Set = new Set(codexLv100);

    if (codexLv100Set.size) {
        const addBonus = (bonus = {}) => {
            for (const [k, v] of Object.entries(bonus)) {
                totalStats[k] = (totalStats[k] || 0) + v;
            }
        };

        const codexBonusRules = [
            { ids: REDRIDGE_LV100_SET, bonus: { versatility: 5 } }, // èµ¤è„Šå±±ï¼šå…¨é˜Ÿå…¨èƒ½ +5
            { ids: BARRENS_LV100_SET, bonus: { critRate: 5 } }, // è´«ç˜ ä¹‹åœ°ï¼šå…¨é˜Ÿæš´å‡»ç‡ +5
            { ids: STRANGLETHORN_LV100_SET, bonus: { haste: 5 } }, // è†æ£˜è°·ï¼šå…¨é˜Ÿæ€¥é€Ÿ +5
            { ids: DESOLACE_LV100_SET, bonus: { mastery: 5 } }, // å‡„å‡‰ä¹‹åœ°ï¼šå…¨é˜Ÿç²¾é€š +5
            { ids: SCARLET_MONASTERY_LV100_SET, bonus: { attack: 200, spellPower: 200 } }, // è¡€è‰²ä¿®é“é™¢ï¼šå…¨é˜Ÿæ”»å‡» +200ï¼Œæ³•å¼º +200
            { ids: ['EQ_044'], bonus: { versatility: 5, haste: 10, mastery: 10 } }, // é­ç¬è€…è‹è¨æ–¯ï¼šå…¨èƒ½ +5ï¼Œæ€¥é€Ÿ +10ï¼Œç²¾é€š +10
            { ids: SUNKEN_TEMPLE_LV100_SET, bonus: { versatility: 10 } }, // æ²‰æ²¡çš„ç¥åº™ï¼šå…¨é˜Ÿå…¨èƒ½ +10
            { ids: LOWER_BLACKROCK_SPIRE_LV100_SET, bonus: { critRate: 10 } }, // é»‘çŸ³å¡”ä¸‹ï¼šå…¨é˜Ÿæš´å‡» +10
            { ids: SCHOLOMANCE_LV100_SET, bonus: { mastery: 10 } }, // é€šçµå­¦é™¢ï¼šå…¨é˜Ÿç²¾é€š +10
            { ids: STRATHOLME_lv100_SET, bonus: { haste: 10 } }, // æ–¯å¦ç´¢å§†ï¼šå…¨é˜Ÿæ€¥é€Ÿ +10
            { ids: UPPER_BLACKROCK_SPIRE_LV100_SET, bonus: { attack: 500, spellPower: 500 } }, // é»‘çŸ³å¡”ä¸Šï¼šå…¨é˜Ÿæ”»å‡» +500ï¼Œæ³•å¼º +500
            { ids: ZUL_GURUB_LV100_SET, bonus: { critDamage: 0.20 } }, // ç¥–å°”æ ¼æ‹‰å¸ƒï¼šæš´å‡»ä¼¤å®³ +20%
            { ids: RUINS_OF_AHNQIRAJ_LV100_SET, bonus: { armor: 300, magicResist: 100 } }, // å®‰çªæ‹‰åºŸå¢Ÿï¼šå…¨é˜ŸæŠ¤ç”² +300ï¼Œé­”æ³•æŠ—æ€§ +100
            { ids: MOLTEN_CORE_LV100_SET, bonus: { attack: 800, spellPower: 800, magicResist: 200 } }, // ç†”ç«ä¹‹å¿ƒï¼šå…¨é˜Ÿæ”»å‡» +1000ï¼Œæ³•å¼º +1000ï¼Œé­”æ³•æŠ—æ€§ +200

        ];

        for (const rule of codexBonusRules) {
            if (rule.ids.every(id => codexLv100Set.has(id))) {
                addBonus(rule.bonus);
            }
        }
    }

    // ç®€çº¦è€Œä¸ç®€å•ç¾ç»Šï¼šå•ä¸€èŒä¸šé˜Ÿä¼æ™®é€šæ”»å‡»ä¼¤å®³æé«˜150%
    if (gameState?.rebirthBonds?.includes('jianyue')) {
        const allSameClass =
            (gameState?.characters?.length || 0) > 0 &&
            gameState.characters.every(c => c.classId === gameState.characters[0].classId);

        if (allSameClass) {
            totalStats.basicAttackMultiplier = (totalStats.basicAttackMultiplier || 1) * 2.5;
        }
    }

    Object.values(character.equipment || {}).forEach(item => {
        if (item && item.stats) {
            Object.entries(item.stats).forEach(([stat, value]) => {
                totalStats[stat] = (totalStats[stat] || 0) + value;
            });

        }
    });

    // ==================== TALENTS (PASSIVE) ====================
    // ä»…å¤„ç†â€œæ°¸ä¹…/æˆ˜æ–—ä¸­å§‹ç»ˆç”Ÿæ•ˆâ€çš„è¢«åŠ¨ï¼šå¦‚æŠ¤ç”²+100ã€å§¿æ€ç­‰ã€‚
    // æˆ˜æ–—å†…â€œå å±‚â€ç±»å¤©èµ‹ï¼ˆè´¨æœ´/æ ¼æŒ¡å¤§å¸ˆï¼‰åœ¨æˆ˜æ–—ç³»ç»Ÿé‡Œå¤„ç†ã€‚
    const t = character.talents || {};
    if (character.classId === 'protection_warrior') {
        // 10çº§ï¼šå ç”²è¿‡ - æŠ¤ç”² +100ï¼ˆæˆ˜æ–—ä¸­ç”Ÿæ•ˆï¼›æ­¤æ¸¸æˆåªæœ‰æˆ˜æ–—ç”¨æŠ¤ç”²ï¼Œæ‰€ä»¥ç›´æ¥åŠ åˆ°æ€»æŠ¤ç”²ï¼‰
        if (t[10] === 'armor_up') {
            totalStats.armor = (totalStats.armor || 0) + 100;
        }

        // 20çº§ï¼šå§¿æ€ä¸‰é€‰ä¸€
        if (t[20] === 'defense_stance') {
            totalStats.damageTakenMult = (totalStats.damageTakenMult || 1) * 0.8; // å—åˆ°ä¼¤å®³ -20%
        } else if (t[20] === 'battle_stance') {
            totalStats.attack = (totalStats.attack || 0) * 1.10; // æ”»å‡»å¼ºåº¦ +10%
        } else if (t[20] === 'berserk_stance') {
            totalStats.critRate = (totalStats.critRate || 0) + 8;      // æš´å‡» +8%
            totalStats.critDamage = (totalStats.critDamage || 2.0) + 0.20; // æš´å‡»ä¼¤å®³ +20%ï¼ˆä»¥å€ç‡åŠ æˆï¼‰
        }
    }

    // ==================== ç‹‚å¾’ç›—è´¼ï¼šå¸¸é©»è¢«åŠ¨å¤©èµ‹ ====================
    if (character.classId === 'outlaw_rogue') {
        // 50çº§ï¼šé£˜å¿½ä¸å®š - å—åˆ°ä¼¤å®³é™ä½20%
        if (t[50] === 'erratic') {
            totalStats.damageTakenMult = (totalStats.damageTakenMult || 1) * 0.8;
        }
    }

    // ==================== ç²¾é€šï¼šç²¾ç¡®æ ¼æŒ¡ ====================
    if (character.classId === 'protection_warrior') {
        const mastery = totalStats.mastery || 0;

        const masteryBonusPct = (10 + mastery / 4) / 100;

        // åªæ”¾å¤§â€œåŸå§‹æ ¼æŒ¡ç‡ / åŸå§‹æ ¼æŒ¡å€¼â€
        //totalStats.blockRate += totalStats.blockRate * masteryBonusPct;
        totalStats.blockValue += totalStats.blockValue * masteryBonusPct;
    }

    // ==================== æˆ’å¾‹ç‰§å¸ˆç²¾é€šï¼šæ•‘èµï¼ˆ1çº§è¢«åŠ¨ï¼‰ ====================
    if (character.classId === 'discipline_priest') {
        const mastery = Number(totalStats.mastery) || 0;

        // åŸºç¡€æ•‘èµ 20% + ç²¾é€š/10 %
        const atonementRate =
            0.20 + (mastery / 10) / 100;

        totalStats.atonement = {
            healingRate: atonementRate
        };

        // ï¼ˆæ ·ä¾‹ï¼‰50çº§å¤©èµ‹ï¼šç¥åœ£åŒ–èº« - æ³•æœ¯å¼ºåº¦æé«˜20%
        if (t[50] === 'holy_avatar') {
            totalStats.spellPower = (totalStats.spellPower || 0) * 1.2;
        }
    }

    // ==================== å†°éœœæ³•å¸ˆç²¾é€šï¼šæ·±å†¬ä¹‹å¯’ï¼ˆ1çº§è¢«åŠ¨ï¼‰ ====================
    if (character.classId === 'frost_mage') {
        const mastery = Number(totalStats.mastery) || 0;
        // åŸºç¡€ 120% + ç²¾é€š/2 %
        const iceLanceBaseMultiplier =
            1.20 + (mastery / 2) / 100;

        totalStats.iceLanceBaseMultiplier = iceLanceBaseMultiplier;
    }


    // ==================== æˆå°±ï¼šå…¨é˜Ÿå…¨èƒ½åŠ æˆï¼ˆå¦‚ã€é¦–é¢†æ€æ‰‹â… ~â…©ã€‘ï¼‰ ====================
    const achVersatilityBonus = getAchievementVersatilityBonus(gameState);
    if (Number.isFinite(achVersatilityBonus) && achVersatilityBonus !== 0) {
        totalStats.versatility = (Number(totalStats.versatility) || 0) + achVersatilityBonus;
    }


    // ==================== ç§æ—ï¼šç”Ÿå‘½å€¼ç™¾åˆ†æ¯”åŠ æˆï¼ˆä¾‹å¦‚ï¼šç‰›å¤´äººã€ç‰›å¤´ç²¾é­„ã€‘ï¼‰ ====================
    // è§„åˆ™ï¼šä½œä¸ºä¹˜åŒºä½œç”¨åœ¨æœ€ç»ˆ hp ä¸Šï¼ˆä¸æˆå°±/å…‰ç¯å¯å åŠ ï¼‰
    const raceHpPctBonus = Number(raceTrait?.hpPctBonus) || 0;
    if (Number.isFinite(raceHpPctBonus) && raceHpPctBonus !== 0) {
        totalStats.hp = (Number(totalStats.hp) || 0) * (1 + raceHpPctBonus);
    }

// ==================== æˆå°±ï¼šå…¨é˜Ÿç”Ÿå‘½ç™¾åˆ†æ¯”åŠ æˆï¼ˆå¦‚ã€æŒç»­æˆ˜æ–—â… ~â…©ã€‘ï¼‰ ====================
    // è§„åˆ™ï¼šhpPct ä¸ºåŠ æ³•å åŠ ï¼Œç„¶åä½œä¸ºä¹˜åŒºä½œç”¨åœ¨æœ€ç»ˆ hp ä¸Š
    const achHpPctBonus = getAchievementHpPctBonus(gameState);
    if (Number.isFinite(achHpPctBonus) && achHpPctBonus > 0) {
        totalStats.hp = (Number(totalStats.hp) || 0) * (1 + achHpPctBonus);
    }

    totalStats.maxHp = Math.floor((totalStats.hp || 0) * (partyAuras.hpMul || 1));
    totalStats.maxMp = totalStats.mp;

    // âœ… å…³é”®ï¼šä¿ç•™æ—§çš„ currentHp/currentMpï¼Œä¸è¦ç›´æ¥é‡ç½®ä¸ºæ»¡
    const prevHp = character.stats?.currentHp ?? totalStats.maxHp;
    const prevMp = character.stats?.currentMp ?? totalStats.maxMp;

    totalStats.currentHp = Math.min(totalStats.maxHp, Math.max(0, prevHp));
    totalStats.currentMp = Math.min(totalStats.maxMp, Math.max(0, prevMp));
    totalStats.spellPower = Math.floor((totalStats.spellPower || 0) * (partyAuras.spellPowerMul || 1));

    return totalStats;
}

function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
}

/**
 * æŒ‰ level(0~100) å°† baseStats ç¼©æ”¾åˆ° baseStats * growth
 * - level = 0   => baseStats
 * - level = 100 => baseStats * growth
 * - ä¸­é—´çº¿æ€§æ’å€¼ï¼šbase * (1 + (level/100) * (growth - 1))
 */
function scaleStats(baseStats = {}, growth = {}, level = 0) {
    const lv = clamp(Number(level) || 0, 0, 100);
    const t = lv / 100;

    const scaled = {};

    for (const [stat, baseValRaw] of Object.entries(baseStats)) {
        const baseVal = Number(baseValRaw) || 0;

        const g = Number(growth?.[stat]);
        const growthMul = Number.isFinite(g) ? g : 1;

        const mul = 1 + t * (growthMul - 1);
        scaled[stat] = baseVal * mul; // âœ… ä¿ç•™å°æ•°
    }

    return scaled;
}

// ==================== TRINKET: æŠ€èƒ½æ å¼ºåŒ–ï¼ˆç¬¬1/ç¬¬4æ ¼ç­‰ï¼‰ ====================
// çº¦å®šï¼šspecialEffect.type === 'skill_slot_buff'
// specialEffect.slots: [0..7]ï¼ˆ0=ç¬¬ä¸€æ ¼ï¼‰
// specialEffect.attackBonus / spellPowerBonusï¼šåœ¨è¯¥æŠ€èƒ½æ ¼é‡Šæ”¾æŠ€èƒ½æ—¶ï¼Œä¸´æ—¶åŠ åˆ°è§’è‰²è®¡ç®—ç”¨é¢æ¿
// ä¸è£…å¤‡æ•°å€¼ä¸€è‡´ï¼šæ»¡çº§(100)è§†ä¸º*2ï¼Œå› æ­¤è¿™é‡Œä¹Ÿåšçº¿æ€§ç¼©æ”¾ï¼šmul = 1 + level/100
function getSkillSlotBuffBonus(character, slotIndex) {
    const idx = Number(slotIndex);
    if (!Number.isFinite(idx)) return { attackBonus: 0, spellPowerBonus: 0 };

    const eqList = Object.values(character?.equipment || {}).filter(Boolean);
    if (eqList.length === 0) return { attackBonus: 0, spellPowerBonus: 0 };

    let attackBonus = 0;
    let spellPowerBonus = 0;

    for (const eq of eqList) {
        const effects = getEquipmentSpecialEffectList(eq);
        if (effects.length === 0) continue;

        for (const se of effects) {
            if (!se || se.type !== 'skill_slot_buff') continue;

            const slots = Array.isArray(se.slots) ? se.slots : [];
            if (!slots.includes(idx)) continue;

            // çº¿æ€§ç¼©æ”¾ï¼šlv0=1x, lv100=2x
            const lv = clamp(Number(eq.currentLevel ?? eq.level) || 0, 0, 100);
            const mul = 1 + (lv / 100);

            attackBonus += (Number(se.attackBonus) || 0) * mul;
            spellPowerBonus += (Number(se.spellPowerBonus) || 0) * mul;
        }
    }

    return {
        attackBonus: Math.floor(attackBonus),
        spellPowerBonus: Math.floor(spellPowerBonus)
    };
}


// ==================== RACE: æŠ€èƒ½æ ¼å±æ€§åŠ æˆï¼ˆå‰Næ ¼ç­‰ï¼‰ ====================
// çº¦å®šï¼šRACE_TRAITS[race].firstNSlotStatBonus = { n: 4, stats: { haste: 20 } }
// è¿”å›ï¼š{ haste: 20 } è¿™ç±»â€œåŠ æ³•å±æ€§â€
function getRacialSkillSlotStatBonus(character, slotIndex) {
    const idx = Number(slotIndex);
    if (!Number.isFinite(idx)) return {};

    const raceTrait = RACE_TRAITS?.[character?.race];
    const cfg = raceTrait?.firstNSlotStatBonus;
    if (!cfg || typeof cfg !== 'object') return {};

    const n = Math.max(0, Math.floor(Number(cfg.n) || 0));
    if (n <= 0 || idx >= n) return {};

    const stats = (cfg.stats && typeof cfg.stats === 'object')
        ? cfg.stats
        : ((cfg.bonus && typeof cfg.bonus === 'object') ? cfg.bonus : {});

    const out = {};
    Object.entries(stats || {}).forEach(([k, v]) => {
        const num = Number(v);
        if (Number.isFinite(num) && num !== 0) {
            out[k] = (out[k] || 0) + num;
        }
    });

    return out;
}

// æ£€æŸ¥è§’è‰²æ˜¯å¦æœ‰æ™®æ”»é‡å¤ç‰¹æ•ˆï¼Œè¿”å›è§¦å‘æ¦‚ç‡
function getBasicAttackRepeatChance(character) {
    const eqList = Object.values(character?.equipment || {}).filter(Boolean);
    for (const eq of eqList) {
        const effects = getEquipmentSpecialEffectList(eq);
        if (effects.length === 0) continue;

        for (const se of effects) {
            if (se && se.type === 'basic_attack_repeat') {
                return se.chance || 0;
            }
        }
    }
    return 0;
}

// ==================== è£…å¤‡ç‰¹æ•ˆï¼šåœ°å›¾å± æˆ®ï¼ˆåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼‰ ====================
// æ•°æ®çº¦å®šï¼š
// specialEffect: {
//   type: 'map_slayer',
//   bonusDamageVsMap: 0.25  // åœ°å›¾æˆ˜æ–—+25%ä¼¤å®³
// }
// è¯´æ˜ï¼š
// - ä»…åœ¨ã€Œåœ°å›¾æˆ˜æ–—ã€(stepCombatRounds) ç”Ÿæ•ˆ
// - æ”¯æŒæœªæ¥å‡ºç°å¤šä»¶åŒç±»ç‰¹æ•ˆæ—¶å åŠ ï¼ˆåŠ æ³•å åŠ ï¼‰
function getMapSlayerDamageDealtMult(character) {
    const eqList = Object.values(character?.equipment || {}).filter(Boolean);
    if (eqList.length === 0) return 1;

    let bonus = 0;
    for (const eq of eqList) {
        const effects = getEquipmentSpecialEffectList(eq);
        if (effects.length === 0) continue;
        for (const se of effects) {
            if (!se || se.type !== 'map_slayer') continue;
            bonus += Number(se.bonusDamageVsMap) || 0;
        }
    }

    // é˜²å¾¡æ€§ï¼šé¿å…å‡ºç°è´Ÿå€¼æˆ– NaN
    if (!Number.isFinite(bonus) || bonus <= 0) return 1;

    return 1 + bonus;
}

// âœ… åœ°å›¾æˆ˜æ–—æ€»ä¼¤å®³å€ç‡
// - è£…å¤‡ç‰¹æ•ˆï¼ˆmap_slayerï¼‰å†…éƒ¨ï¼šåŠ æ³•å åŠ  => 1 + Î£bonus
// - æˆå°±ï¼ˆmapDamageBonusï¼‰å†…éƒ¨ï¼šåŠ æ³•å åŠ  => 1 + Î£bonus
// - ä¸¤è€…ä¹‹é—´ï¼šä¹˜ç®—ï¼ˆç”¨æˆ·éœ€æ±‚ï¼šæˆå°±åœ°å›¾ä¼¤å®³ ä¸ è£…å¤‡ç‰¹æ•ˆä¼¤å®³ ä¹˜ç®—ï¼‰
function getMapDamageDealtMult(character, gameState) {
    const equipMult = getMapSlayerDamageDealtMult(character);
    const achMult = getAchievementMapDamageDealtMult(gameState);

    const m1 = (Number.isFinite(equipMult) && equipMult > 0) ? equipMult : 1;
    const m2 = (Number.isFinite(achMult) && achMult > 0) ? achMult : 1;
    return m1 * m2;
}

// ==================== è£…å¤‡ç‰¹æ•ˆï¼šé€šç”¨ã€Œæ¦‚ç‡è§¦å‘å±æ€§å¢ç›Šã€æ¡†æ¶ ====================
// ç›®æ ‡ï¼šæ”¯æŒç±»ä¼¼â€œæ¯å›åˆXX%æ¦‚ç‡è·å¾—XXXXå±æ€§ï¼ˆä»…æœ¬å›åˆç”Ÿæ•ˆï¼‰â€çš„ç‰¹æ•ˆï¼Œå¹¶ä¾¿äºåç»­æ‰©å±•æ›´å¤šè§¦å‘æ—¶æœºã€‚
//
// æ•°æ®çº¦å®šï¼ˆç¤ºä¾‹ï¼‰ï¼š
// specialEffect: {
//   type: 'proc_stat',
//   trigger: 'turn_start',         // è§¦å‘æ—¶æœºï¼ˆç›®å‰å®ç°ï¼šturn_startï¼‰
//   chance: 0.20,                  // 0~1
//   stats: { attack: 1500 },       // ä»»æ„å±æ€§é”®ï¼ˆattack / spellPower / critRate ...ï¼‰
//   scaleWithLevel: false          // å¯é€‰ï¼šæ˜¯å¦æŒ‰è£…å¤‡ç­‰çº§ç¼©æ”¾ï¼ˆlv0=1x, lv100=2xï¼‰
// }
//
// ä¹Ÿæ”¯æŒæœªæ¥åœ¨è£…å¤‡ä¸Šæ–°å¢ï¼šspecialEffects: []ï¼ˆå¤šæ¡ç‰¹æ•ˆï¼‰

const STAT_LABELS = {
    hp: 'ç”Ÿå‘½å€¼',
    mp: 'æ³•åŠ›å€¼',
    attack: 'æ”»å‡»å¼ºåº¦',
    spellPower: 'æ³•æœ¯å¼ºåº¦',
    armor: 'æŠ¤ç”²',
    magicResist: 'é­”æ³•æŠ—æ€§',
    haste: 'æ€¥é€Ÿ',
    critRate: 'æš´å‡»ç‡',
    critDamage: 'æš´å‡»ä¼¤å®³',
    mastery: 'ç²¾é€š',
    versatility: 'å…¨èƒ½',
    blockRate: 'æ ¼æŒ¡ç‡',
    blockValue: 'æ ¼æŒ¡å€¼',
    proficiency: 'ç†Ÿç»ƒ',
    precision: 'ç²¾ç»†',
    perception: 'æ„ŸçŸ¥',
};

function getEquipmentSpecialEffectList(eq) {
    const list = [];
    if (Array.isArray(eq?.specialEffects)) list.push(...eq.specialEffects);
    if (eq?.specialEffect) list.push(eq.specialEffect);
    return list.filter(Boolean);
}

function formatProcStatBonusText(bonus = {}) {
    const entries = Object.entries(bonus).filter(([, v]) => Number(v) !== 0);
    if (entries.length === 0) return '';

    return entries.map(([stat, valueRaw]) => {
        const name = STAT_LABELS[stat] || stat;
        const v = Number(valueRaw) || 0;

        // ä¸è£…å¤‡é¢æ¿ä¸€è‡´çš„å±•ç¤ºä¹ æƒ¯
        if (stat === 'critRate' || stat === 'blockRate') {
            return `${name} +${v.toFixed(1)}%`;
        }
        if (stat === 'critDamage') {
            return v <= 1 ? `${name} +${Math.floor(v * 100)}%` : `${name} +${Math.floor(v)}`;
        }
        return `${name} +${Math.floor(v)}`;
    }).join('ï¼Œ');
}

/**
 * é€šç”¨ï¼šæ·éª°è§¦å‘ã€Œproc_statã€ç±»å‹çš„è£…å¤‡ç‰¹æ•ˆï¼ˆè¿”å›æœ¬å›åˆåº”ä¸´æ—¶åŠ åˆ°é¢æ¿çš„å±æ€§ï¼‰
 * @param character è§’è‰²å¯¹è±¡ï¼ˆéœ€å« equipmentï¼‰
 * @param trigger   è§¦å‘ç‚¹ï¼ˆä¾‹å¦‚ï¼š'turn_start'ï¼‰
 * @returns {{ bonus: Object, triggered: Array<{label: string, bonus: Object, chance: number}> }}
 */
function rollProcStatEffects(character, trigger) {
    const eqList = Object.values(character?.equipment || {}).filter(Boolean);
    const totalBonus = {};
    const triggered = [];

    for (const eq of eqList) {
        const effects = getEquipmentSpecialEffectList(eq);
        if (effects.length === 0) continue;

        for (const se of effects) {
            if (!se || se.type !== 'proc_stat') continue;
            if (se.trigger !== trigger) continue;

            const chance = Math.max(0, Math.min(1, Number(se.chance) || 0));
            if (chance <= 0) continue;

            if (Math.random() >= chance) continue;

            const stats = se.stats && typeof se.stats === 'object' ? se.stats : {};

            // å¯é€‰ï¼šæŒ‰è£…å¤‡ç­‰çº§ç¼©æ”¾ï¼ˆä¸è£…å¤‡å±æ€§ä¸€è‡´ï¼šlv0=1x, lv100=2xï¼‰
            const lv = clamp(Number(eq.currentLevel ?? eq.level) || 0, 0, 100);
            const mul = se.scaleWithLevel ? (1 + (lv / 100)) : 1;

            const applied = {};
            for (const [stat, valRaw] of Object.entries(stats)) {
                const baseVal = Number(valRaw) || 0;
                if (!Number.isFinite(baseVal) || baseVal === 0) continue;

                const add = baseVal * mul;
                applied[stat] = (applied[stat] || 0) + add;
                totalBonus[stat] = (totalBonus[stat] || 0) + add;
            }

            // è¾“å‡ºç»™æ—¥å¿—ç”¨ï¼šä¼˜å…ˆç”¨ç‰¹æ•ˆè‡ªå®šä¹‰åï¼Œå…¶æ¬¡è£…å¤‡å
            const label = se.name || eq.name || 'è£…å¤‡ç‰¹æ•ˆ';
            triggered.push({ label, bonus: applied, chance });
        }
    }

    // ç»Ÿä¸€å‘ä¸‹å–æ•´ï¼Œé¿å…å°æ•°æ±¡æŸ“
    for (const k of Object.keys(totalBonus)) {
        totalBonus[k] = Math.floor(Number(totalBonus[k]) || 0);
    }
    triggered.forEach(t => {
        for (const k of Object.keys(t.bonus || {})) {
            t.bonus[k] = Math.floor(Number(t.bonus[k]) || 0);
        }
    });

    return { bonus: totalBonus, triggered };
}



// ==================== è£…å¤‡ç‰¹æ•ˆï¼šæ— è§†é˜²å¾¡ï¼ˆç©¿ç”²ï¼‰ ====================
// specialEffect: { type: 'ignore_defense', pct: 0.5 }
// è¯´æ˜ï¼šå¯¹ç›®æ ‡é€ æˆçš„æ‰€æœ‰â€œæ‰£é˜²å¾¡â€ä¼¤å®³ï¼Œç›®æ ‡é˜²å¾¡æŒ‰ (1 - pct) è®¡ç®—ï¼ˆæœ€å¤šæ— è§†90%ï¼‰
function getIgnoreDefensePct(character) {
    try {
        const eqList = Object.values(character?.equipment || {}).filter(Boolean);
        let pct = 0;

        eqList.forEach(eq => {
            const effects = getEquipmentSpecialEffectList(eq);
            effects.forEach(se => {
                if (!se || se.type !== 'ignore_defense') return;
                const v = Number(se.pct ?? se.ignorePct ?? se.value);
                if (Number.isFinite(v) && v > 0) pct += v;
            });
        });

        return clamp(pct, 0, 0.9);
    } catch {
        return 0;
    }
}

function getEffectiveTargetDefense(attacker, targetDefenseRaw) {
    const base = Math.max(0, Math.floor(Number(targetDefenseRaw) || 0));
    const pct = getIgnoreDefensePct(attacker);
    if (!Number.isFinite(pct) || pct <= 0) return base;
    return Math.max(0, Math.floor(base * (1 - pct)));
}

// ==================== è£…å¤‡ç‰¹æ•ˆï¼šæ¦‚ç‡è§¦å‘ä¼¤å®³ï¼ˆé€šç”¨ï¼‰ ====================
// specialEffect: {
//   type: 'proc_damage',
//   name: 'ç«ç„°ç®­',
//   trigger: 'turn_start',
//   chance: 0.25,
//   school: 'fire',
//   basedOn: 'attack' | 'spellPower',
//   damageMult: 1.5,   // ä¼¤å®³ = åŸºç¡€å±æ€§ * damageMult
//   damageFlat: 0,     // é¢å¤–å›ºå®šä¼¤å®³ï¼ˆå¯é€‰ï¼‰
//   scaleWithLevel: true
// }
function rollProcDamageEffects(character, trigger = 'turn_start') {
    const eqList = Object.values(character?.equipment || {}).filter(Boolean);

    const triggered = [];

    eqList.forEach(eq => {
        const effects = getEquipmentSpecialEffectList(eq);
        effects.forEach(se => {
            if (!se || se.type !== 'proc_damage') return;
            if (se.trigger && se.trigger !== trigger) return;

            const chance = Number(se.chance) || 0;
            if (chance <= 0) return;

            if (Math.random() > chance) return;

            const basedOn = (se.basedOn === 'spellPower') ? 'spellPower' : 'attack';
            const basis = Number(character?.stats?.[basedOn]) || 0;

            const lv = Number(eq?.currentLevel ?? eq?.level ?? 0) || 0;
            const lvMult = se.scaleWithLevel ? (1 + lv / 100) : 1;

            const mult = Number(se.damageMult) || 0;
            const flat = Number(se.damageFlat) || 0;

            let rawDamage = 0;
            if (mult !== 0) rawDamage += basis * mult;
            rawDamage += flat;
            rawDamage = Math.floor(rawDamage * lvMult);

            triggered.push({
                label: se.name || se.label || 'è§¦å‘ä¼¤å®³',
                school: se.school || 'physical',
                basedOn,
                rawDamage,
                chance
            });
        });
    });

    return triggered;
}

// å°å·¥å…·ï¼šä¼¤å®³å­¦æ´¾ä¸­æ–‡
function getSchoolCn(school) {
    const s = String(school || '').toLowerCase();
    const map = {
        physical: 'ç‰©ç†',
        fire: 'ç«ç„°',
        frost: 'å†°éœœ',
        arcane: 'å¥¥æœ¯',
        nature: 'è‡ªç„¶',
        shadow: 'æš—å½±',
        holy: 'ç¥åœ£'
    };
    return map[s] || 'ä¼¤å®³';
}

// ==================== è£…å¤‡ç‰¹æ•ˆï¼šé£å‰‘ï¼ˆé›·éœ†ä¹‹æ€’ï¼‰é—ªç”µé“¾ ====================
// æ•°æ®çº¦å®šï¼šspecialEffect.type === 'thunderfury'
// è§¦å‘ï¼šturn_startï¼Œchance=0.20
// æ•ˆæœï¼šå¯¹æ‰€æœ‰æ•Œäººé€ æˆ damageMult * æ”»å‡»å¼ºåº¦ çš„è‡ªç„¶ä¼¤å®³ï¼›å¹¶è·å¾—æ‰¿ä¼¤é™ä½ selfDamageTakenMultï¼ˆå¦‚0.8ï¼‰æŒç»­ selfBuffDuration å›åˆ
function rollThunderfuryEffect(character, trigger) {
    const eqList = Object.values(character?.equipment || {}).filter(Boolean);
    for (const eq of eqList) {
        const effects = getEquipmentSpecialEffectList(eq);
        if (effects.length === 0) continue;

        for (const se of effects) {
            if (!se || se.type !== 'thunderfury') continue;
            if ((se.trigger || 'turn_start') !== trigger) continue;

            const chance = Math.max(0, Math.min(1, Number(se.chance) || 0));
            if (chance <= 0) continue;
            if (Math.random() >= chance) continue;

            return {
                label: se.name || eq.name || 'é›·éœ†ä¹‹æ€’',
                damageMult: Number(se.damageMult) || 1.2,
                selfDamageTakenMult: Number(se.selfDamageTakenMult) || 0.8,
                selfBuffDuration: Math.max(1, Math.floor(Number(se.selfBuffDuration) || 2)),
            };
        }
    }
    return null;
}

// ==================== BOSSæˆ˜æ–—ä¸€æ­¥æ¨è¿›å‡½æ•° ====================
function stepBossCombat(state) {
    if (!state.bossCombat) return state;

    let combat = { ...state.bossCombat };
    combat.logs = combat.logs || [];
    let logs = [...combat.logs];

    const bossBase = BOSS_DATA[combat.bossId];
    if (!bossBase) return state;

    // ç»Ÿä¸€ç¡®ä¿å­˜åœ¨ bossBuffsï¼ˆç”¨äºå„Bossçš„è¢«åŠ¨/è®¡æ—¶å™¨ï¼‰
    combat.bossBuffs = combat.bossBuffs || {};

    // æœ¬å›åˆå¼€å§‹æ—¶çš„"é˜²å¾¡è¦†ç›–"æŒç»­æ—¶é—´ï¼Œç”¨äºå›åˆæœ«é€’å‡ï¼ˆé¿å…åˆšè§¦å‘å°±è¢«æ‰£1å›åˆï¼‰
    const bossDefenseOverrideRemainingStart = Number(combat.bossDefenseOverrideRemaining || 0);

    // ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ï¼šæŠ¤ç›¾åœ¨æœ¬å›åˆå¼€å§‹æ—¶çš„å‰©ä½™å›åˆæ•°ï¼ˆç”¨äºå›åˆæœ«é€’å‡ï¼‰
    const executusPhysicalShieldStart = Number(combat.bossBuffs.executusPhysicalShield || 0);
    const executusMagicShieldStart = Number(combat.bossBuffs.executusMagicShield || 0);

    // ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯ï¼šä¸‹æ½œå…ç–«åœ¨æœ¬å›åˆå¼€å§‹æ—¶çš„å‰©ä½™å›åˆæ•°ï¼ˆç”¨äºå›åˆæœ«é€’å‡ï¼‰
    const ragnarosSubmergeStart = Number(combat.bossBuffs.ragnarosSubmergeTurns || 0);
    const isRagnarosSubmergedThisRound = (combat.bossId === 'ragnaros' && ragnarosSubmergeStart > 0);

    combat.round += 1;
    // âœ… æ·»åŠ è¾…åŠ©å‡½æ•°ï¼Œåˆ›å»ºå¸¦å›åˆæ•°çš„æ—¥å¿—å¯¹è±¡
    const currentRound = combat.round;
    const addLog = (text, type = 'normal') => {
        logs.push({ round: currentRound, text, type });
    };

    // ä»¥æˆ˜æ–—å†…çŠ¶æ€ä¸ºå‡†ï¼Œè®¡ç®—æœ¬å›åˆæœ‰æ•ˆBossæ•°æ®ï¼ˆé¿å…ç›´æ¥ä¿®æ”¹ BOSS_DATA å…¨å±€å¯¹è±¡ï¼‰
    let boss = { ...bossBase };

    // é˜²å¾¡è¦†ç›–ï¼šä¾‹å¦‚æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰çš„â€œç ´ç”²çª—å£â€
    if (Number.isFinite(combat.bossDefenseOverride) && (combat.bossDefenseOverrideRemaining || 0) > 0) {
        boss.defense = combat.bossDefenseOverride;
    }

    // æ•‘èµï¼ˆbuffï¼‰å¯èƒ½å¸¦æ¥çš„é¢å¤–å‡ä¼¤ï¼ˆä¾‹å¦‚ï¼šæˆ’å¾‹ç‰§60çº§å¤©èµ‹ã€ä»æ…ˆã€‘ï¼‰
    // çº¦å®šï¼šåœ¨ stats.atonement ä¸ŠæŒ‚ damageTakenMultï¼ˆå¦‚ 0.95ï¼‰ï¼Œå¹¶åœ¨ä¸€åˆ‡æ‰¿ä¼¤ç»“ç®—æ—¶ä¹˜å…¥ã€‚
    const getAtonementDamageTakenMult = (playerState) => {
        const v = playerState?.char?.stats?.atonement?.damageTakenMult;
        return (typeof v === 'number' && Number.isFinite(v) && v > 0) ? v : 1;
    };


    // ==================== æ³•æœ¯æ˜“ä¼¤ï¼ˆç«å…ƒç´ ï¼šç¼çƒ­ä¹‹ç—›ï¼‰ ====================
    // æ¯å±‚ä½¿ç›®æ ‡å—åˆ°çš„â€œæ³•æœ¯/éç‰©ç†â€ä¼¤å®³ +2%ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸï¼Œå¯å å±‚
    // çº¦å®šï¼šplayerState.debuffs.spellVulnerability = { stacks: n, pctPerStack: 0.02 }
    const getSpellVulnerabilityMult = (playerState) => {
        const stacks = Math.max(0, Math.floor(Number(playerState?.debuffs?.spellVulnerability?.stacks) || 0));
        const pct = Number(playerState?.debuffs?.spellVulnerability?.pctPerStack);
        const per = (Number.isFinite(pct) ? pct : 0.02);
        if (stacks <= 0 || !Number.isFinite(per) || per <= 0) return 1;
        return 1 + stacks * per;
    };

    // é€šç”¨ï¼šæ³•æœ¯ä¼¤å®³ï¼ˆé­”æŠ—ï¼‰ç»“ç®—ï¼ˆå¹¶å¥—ç”¨ï¼šå—ä¼¤å‡å…/å…¨èƒ½/æŒ«å¿—æ€’å¼/æ•‘èµ/æ³•æœ¯æ˜“ä¼¤ï¼‰
    const calcMagicDamage = (playerState, rawDamage, magicResistOverride = null) => {
        const mr = (magicResistOverride !== null && magicResistOverride !== undefined)
            ? (Number(magicResistOverride) || 0)
            : (playerState?.char?.stats?.magicResist || 0);

        const resistReduction = getMagicResistDamageReduction(mr);
        let damage = Math.floor((rawDamage || 0) * (1 - resistReduction));

        const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;

        let buffTakenMult = 1;
        if (playerState?.buffs) {
            playerState.buffs.forEach(b => {
                if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
            });
        }

        const demoralizingShoutMult = combat.bossDebuffs?.demoralizingShout?.damageMult ?? 1;
        const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
        const atonementTakenMult = getAtonementDamageTakenMult(playerState);
        const spellVulnMult = getSpellVulnerabilityMult(playerState);

        damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * demoralizingShoutMult * versTakenMult * spellVulnMult));

        return { damage, resistReduction, magicResist: mr, spellVulnMult };
    };

    // ==================== ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ï¼šæŠ¤ç›¾å…ç–«ï¼ˆåç‰©ç† / åé­”æ³•ï¼‰ ====================
    // çº¦å®šï¼š
    // - school æœªæä¾› => é»˜è®¤è§†ä¸º physical
    // - school === 'physical' => ç‰©ç†
    // - å…¶å®ƒ => æ³•æœ¯/éç‰©ç†
    const isMagicSchool = (school) => {
        if (!school) return false;
        return school !== 'physical';
    };

    const getExecutusShieldInfo = (school) => {
        if (combat.bossId !== 'majordomo_executus') return { immune: false, shieldName: '' };

        const isMagic = isMagicSchool(school);
        const phys = Number(combat.bossBuffs.executusPhysicalShield || 0);
        const mag = Number(combat.bossBuffs.executusMagicShield || 0);

        if (isMagic && mag > 0) return { immune: true, shieldName: 'åé­”æ³•æŠ¤ç›¾' };
        if (!isMagic && phys > 0) return { immune: true, shieldName: 'åç‰©ç†æŠ¤ç›¾' };
        return { immune: false, shieldName: '' };
    };


    const triggerAtonementHeal = (source, damageDone) => {
        if (!source || damageDone <= 0) return;

        // åªå…è®¸æˆ’å¾‹ç‰§å¸ˆçš„ä¼¤å®³è§¦å‘æ•‘èµï¼ˆå¦åˆ™ç°åœ¨ä¼šå˜æˆâ€œå…¨é˜Ÿå¸è¡€â€ï¼‰
        if (source.char?.classId !== 'discipline_priest') return;

        combat.playerStates.forEach(ps => {
            if (!ps || ps.currentHp <= 0) return;
            if (!ps.char?.stats?.atonement) return;

            // æ¯ä¸ªç›®æ ‡è‡ªå·±çš„å‡ç–—ï¼ˆè‡´æ­»æ‰“å‡»ï¼‰åº”å½“å„ç®—å„çš„
            let healingMult = 1;
            if (ps.debuffs?.mortalStrike) {
                healingMult = 1 - (ps.debuffs.mortalStrike.healingReduction || 0);
            }

            const rate = ps.char.stats.atonement.healingRate ?? 0.20;
            const heal = Math.floor(damageDone * rate * healingMult);

            const maxHp = ps.char.stats.maxHp || 0;
            const actualHeal = Math.min(heal, maxHp - ps.currentHp);

            ps.currentHp += actualHeal;
            ps.char.stats.currentHp = ps.currentHp; // è®©UIä¹ŸåŒæ­¥

            let healLog = `å› ä¸ºæ•‘èµæ¢å¤ ${actualHeal} ç‚¹ç”Ÿå‘½`;
            if (healingMult < 1) {
                healLog += `ï¼ˆå—åˆ°è‡´æ­»æ‰“å‡»å‡ç–—${Math.round((1 - healingMult) * 100)}%ï¼‰`;
            }
            addLog(healLog);
        });
    };


    // ===== æŠ¤ç›¾å¸æ”¶ä¼¤å®³è¾…åŠ©å‡½æ•° =====
    const applyShieldAbsorb = (playerState, damage, logs, currentRound) => {
        if (!playerState.buffs || damage <= 0) {
            return { finalDamage: damage, absorbed: 0 };
        }

        // æ‰¾åˆ°æœ‰æ•ˆçš„æŠ¤ç›¾buff
        const shieldBuff = playerState.buffs.find(b =>
            b.type && b.amount > 0 && ['ice_barrier', 'holy_barrier'].includes(b.type)
        );

        if (!shieldBuff) {
            return { finalDamage: damage, absorbed: 0 };
        }

        // è®¡ç®—å¸æ”¶é‡
        const absorbed = Math.min(shieldBuff.amount, damage);
        shieldBuff.amount -= absorbed;
        const finalDamage = damage - absorbed;

        // æŠ¤ç›¾å—å‡»è§¦å‘æ•ˆæœï¼ˆå¯’å†°æŠ¤ä½“ï¼š25%æ¦‚ç‡è·å¾—å¯’å†°æŒ‡ï¼‰
        if (shieldBuff.onHitEffect?.type === 'generate_finger') {
            if (playerState.char.classId === 'frost_mage' && Math.random() < shieldBuff.onHitEffect.chance) {
                playerState.fingersOfFrost = (playerState.fingersOfFrost || 0) + 1;
                addLog(`ã€${shieldBuff.name}ã€‘è§¦å‘ï¼š${playerState.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${playerState.fingersOfFrost}å±‚`);
            }
        }

        // æŠ¤ç›¾ç ´ç¢
        if (shieldBuff.amount <= 0) {
            addLog(`${playerState.char.name} çš„ã€${shieldBuff.name}ã€‘æŠ¤ç›¾ç ´ç¢ï¼`);
            const idx = playerState.buffs.findIndex(b => b.type === shieldBuff.type);
            if (idx !== -1) {
                playerState.buffs.splice(idx, 1);
            }
        }

        return { finalDamage, absorbed };
    };

    // ==================== ç§æ—ï¼šçŸ®äººã€çŸ³åƒå½¢æ€ã€‘ ====================
    // æ•ˆæœï¼šæˆ˜æ–—ä¸­é¦–æ¬¡å—åˆ°ã€è¯…å’’ã€‘ä¸ã€ä¸­æ¯’ã€‘æ•ˆæœæ—¶å…ç–«ï¼ˆæ¯ç§å„ 1 æ¬¡ï¼‰ã€‚
    // è¯´æ˜ï¼šè¿™é‡Œåªåšâ€œåˆ¤å®š+æ¶ˆè€—æ¬¡æ•°+å†™æ—¥å¿—â€ï¼Œå…·ä½“æ•ˆæœçš„åº”ç”¨ç‚¹ï¼ˆdebuff/dotï¼‰éœ€è¦è°ƒç”¨å®ƒã€‚
    const ensureRacialFlags = (ps) => {
        if (!ps || typeof ps !== 'object') return {};
        if (!ps.racialFlags || typeof ps.racialFlags !== 'object') ps.racialFlags = {};
        if (ps.racialFlags.stoneformCurseUsed === undefined) ps.racialFlags.stoneformCurseUsed = false;
        if (ps.racialFlags.stoneformPoisonUsed === undefined) ps.racialFlags.stoneformPoisonUsed = false;
        if (ps.racialFlags.undeadWillUsed === undefined) ps.racialFlags.undeadWillUsed = false;
        return ps.racialFlags;
    };

    const tryFirstDebuffImmunity = (ps, kind, idx = null, sourceName = '') => {
        if (!ps || ps.currentHp <= 0) return false;

        const raceTrait = RACE_TRAITS?.[ps?.char?.race];
        const enabled = !!raceTrait?.firstDebuffImmunity?.[kind];
        if (!enabled) return false;

        const flags = ensureRacialFlags(ps);
        const flagKey = kind === 'curse'
            ? 'stoneformCurseUsed'
            : (kind === 'poison' ? 'stoneformPoisonUsed' : null);
        if (!flagKey) return false;
        if (flags[flagKey]) return false;

        // æ¶ˆè€—æ¬¡æ•°
        flags[flagKey] = true;

        const kindText = kind === 'curse' ? 'è¯…å’’' : (kind === 'poison' ? 'ä¸­æ¯’' : kind);
        const posText = (Number.isFinite(Number(idx)) && idx !== null) ? `ä½ç½®${Number(idx) + 1} ` : '';
        const srcText = sourceName ? `ï¼ˆ${sourceName}ï¼‰` : '';
        addLog(`ã€çŸ³åƒå½¢æ€ã€‘è§¦å‘ï¼š${posText}${ps.char?.name || ''} å…ç–«äº†æœ¬åœºæˆ˜æ–—çš„é¦–æ¬¡${kindText}æ•ˆæœ${srcText}`);
        return true;
    };

    // ==================== ç§æ—ï¼šäº¡çµã€äº¡çµæ„å¿—ã€‘ ====================
    // æ•ˆæœï¼šBossæˆ˜æ–—ä¸­å…ç–«å—åˆ°çš„ç¬¬ä¸€æ¬¡ææƒ§æ•ˆæœï¼ˆæ¯åœºBossæˆ˜ 1 æ¬¡ï¼‰
    const tryFirstFearImmunity = (ps, idx = null, sourceName = '') => {
        if (!ps || ps.currentHp <= 0) return false;

        const raceTrait = RACE_TRAITS?.[ps?.char?.race];
        const enabled = !!raceTrait?.firstFearImmunity;
        if (!enabled) return false;

        const flags = ensureRacialFlags(ps);
        if (flags.undeadWillUsed) return false;

        // æ¶ˆè€—æ¬¡æ•°
        flags.undeadWillUsed = true;

        const posText = (Number.isFinite(Number(idx)) && idx !== null) ? `ä½ç½®${Number(idx) + 1} ` : '';
        const srcText = sourceName ? `ï¼ˆ${sourceName}ï¼‰` : '';
        addLog(`ã€äº¡çµæ„å¿—ã€‘è§¦å‘ï¼š${posText}${ps.char?.name || ''} å…ç–«äº†æœ¬åœºBossæˆ˜çš„é¦–æ¬¡ã€ææƒ§ã€‘æ•ˆæœ${srcText}`);
        return true;
    };

    // ==================== ç©å®¶é˜¶æ®µ ====================

    // ç©å®¶å›åˆç»“æŸæ—¶çš„ buff/debuff ç»“ç®—ï¼ˆç”¨äºâ€œææƒ§â€ç­‰è·³è¿‡è¡ŒåŠ¨çš„æƒ…å†µï¼‰
    const tickPlayerDurations = (p, i) => {
        // buff duration å‡å°‘
        if (p.buffs && p.buffs.length > 0) {
            p.buffs = p.buffs
                .map(b => {
                    if (b.justApplied) {
                        // åˆšåŠ ä¸Šçš„ buffï¼Œæœ¬æ¬¡ä¸æ‰£æ—¶é—´ï¼Œåªæ¸…æ ‡è®°
                        delete b.justApplied;
                    } else if (b.duration !== undefined) {
                        b.duration -= 1;
                    }
                    return b;
                })
                .filter(b => {
                    // æŠ¤ç›¾ï¼šæŒç»­æ—¶é—´åˆ°æœŸæˆ–å¸æ”¶é‡è€—å°½éƒ½ç§»é™¤
                    if (b.type && ['ice_barrier', 'holy_barrier'].includes(b.type)) {
                        if ((b.duration ?? 999) <= 0 || (b.amount ?? 0) <= 0) {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€${b.name}ã€‘æŠ¤ç›¾æ¶ˆå¤±`);
                            return false;
                        }
                        return true;
                    }
                    return (b.duration ?? 999) > 0;
                });
        }

        // debuff duration å‡å°‘ï¼ˆè‡´æ­»æ‰“å‡»å‡ç–—/ææƒ§ç­‰ï¼‰
        if (p.debuffs) {
            Object.keys(p.debuffs).forEach(key => {
                if (p.debuffs[key]?.duration !== undefined) {
                    p.debuffs[key].duration -= 1;
                    if (p.debuffs[key].duration <= 0) {
                        delete p.debuffs[key];

                        // âœ… ä¸åŒdebuffæ˜¾ç¤ºä¸åŒæ¶ˆå¤±æ–‡æ¡ˆ
                        if (key === 'mortalStrike') {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€è‡´æ­»æ‰“å‡»ã€‘å‡ç–—æ•ˆæœæ¶ˆå¤±`);
                        } else if (key === 'fear') {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€ææƒ§ã€‘æ•ˆæœæ¶ˆå¤±`);
                        } else if (key === 'knockup') {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€å‡»é£ã€‘æ•ˆæœæ¶ˆå¤±`);
                        } else if (key === 'shadowCurse') {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€æš—å½±è¯…å’’ã€‘æ•ˆæœæ¶ˆå¤±`);
                        } else if (key === 'tongueCurse') {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€ç»“èˆŒè¯…å’’ã€‘æ•ˆæœæ¶ˆå¤±`);
                        } else {
                            addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€${key}ã€‘æ•ˆæœæ¶ˆå¤±`);
                        }
                    }
                }
            });
        }
        // æ•‘èµ duration å‡å°‘ï¼ˆä»…å½“å¸¦ duration æ—¶æ‰é€’å‡ï¼›ç²¾é€šè¢«åŠ¨/å¸¸é©»æ•‘èµä¸å—å½±å“ï¼‰
        if (p.char?.stats?.atonement && p.char.stats.atonement.duration !== undefined) {
            p.char.stats.atonement.duration -= 1;
            if (p.char.stats.atonement.duration <= 0) {
                delete p.char.stats.atonement;
                addLog(`ä½ç½®${i + 1} ${p.char.name} çš„ã€æ•‘èµã€‘æ•ˆæœç»“æŸ`);
            }
        }

    };

    // ==================== æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰ï¼šè¢«åŠ¨ï¼ˆæ°´æ™¶ç”Ÿæˆ / å‡»æ¯è§¦å‘ç ´ç”²çª—å£ï¼‰ ====================
    // è®¾è®¡ï¼šæ¯ 4 å›åˆç”Ÿæˆ 1 ä¸ªã€æ±²èƒ½æ°´æ™¶ã€‘ï¼ˆä¸Šé™ 1ï¼‰
    //      æ°´æ™¶è¢«å‡»æ¯åï¼ŒBoss é˜²å¾¡é™ä¸º 8000ï¼ŒæŒç»­ 4 å›åˆ
    const maybeSummonOssirianCrystal = () => {
        if (combat.bossId !== 'ossirian') return;

        combat.minions = Array.isArray(combat.minions) ? combat.minions : [];

        const every = Math.max(1, Math.floor(Number(boss.energyCrystalEvery || 4)));
        const hasAliveCrystal = combat.minions.some(m => (m?.hp ?? 0) > 0 && m.isEnergyCrystal);

        if (!hasAliveCrystal && (combat.round % every === 0)) {
            const hp = Math.floor(Number(boss.minion?.maxHp || 1000000));
            const def = Math.floor(Number(boss.minion?.defense || 4000));

            combat.minions.push({
                hp,
                maxHp: hp,
                attack: Math.floor(Number(boss.minion?.attack || 0)),
                defense: def,
                isEnergyCrystal: true,
                deathProcessed: false,
                immune: false,
                dots: []
            });

            addLog(`ã€${boss.name}ã€‘ç”Ÿæˆäº†ã€${boss.minion?.name || 'æ±²èƒ½æ°´æ™¶'}ã€‘ï¼šHP ${hp.toLocaleString()}ï¼Œé˜²å¾¡ ${def.toLocaleString()}`);
        }
    };

    const processOssirianCrystalDeaths = () => {
        if (combat.bossId !== 'ossirian') return;
        combat.minions = Array.isArray(combat.minions) ? combat.minions : [];

        const deadCrystals = combat.minions.filter(m => (m?.hp ?? 0) <= 0 && m.isEnergyCrystal && !m.deathProcessed);
        if (deadCrystals.length <= 0) return;

        deadCrystals.forEach(m => { m.deathProcessed = true; });

        const newDef = Math.floor(Number(boss.defenseDownDefense || 8000));
        const dur = Math.max(1, Math.floor(Number(boss.defenseDownDuration || 4)));

        combat.bossDefenseOverride = newDef;
        combat.bossDefenseOverrideRemaining = dur;
        boss.defense = newDef; // âœ… è®©åŒå›åˆåç»­è§’è‰²ä¹Ÿèƒ½ç«‹åˆ»äº«å—åˆ°ç ´ç”²çª—å£

        addLog(`ã€${boss.name}ã€‘çš„ã€${boss.minion?.name || 'æ±²èƒ½æ°´æ™¶'}ã€‘è¢«å‡»æ¯ï¼é˜²å¾¡é™ä¸º ${newDef.toLocaleString()}ï¼ŒæŒç»­ ${dur} å›åˆ`);
    };

    // å›åˆå¼€å§‹ï¼šå…ˆç”Ÿæˆæ°´æ™¶ï¼ˆè‹¥åˆ°å›åˆæ•°ï¼‰ï¼Œè®©ç©å®¶æœ¬å›åˆå°±èƒ½æ‰“åˆ°
    if (combat.bossId === 'ossirian') {
        maybeSummonOssirianCrystal();
        // å…œåº•ï¼šå¦‚æœä¸Šå›åˆæœ«æ°´æ™¶åˆšæ­»ä½†è¿˜æ²¡å¤„ç†ï¼ˆä¾‹å¦‚DOTï¼‰ï¼Œè¿™é‡Œå…ˆå¤„ç†ä¸€æ¬¡
        processOssirianCrystalDeaths();
    }

    // ==================== ç„šåŒ–è€…å¤é›·æ›¼æ ¼ï¼šè¢«åŠ¨ï¼ˆå›ºæœ‰ç†”ç«æ¶çŠ¬ï¼‰ ====================
    // è¯´æ˜ï¼šå¼€åœºè‡ªå¸¦2åªç†”ç«æ¶çŠ¬ï¼ˆæ”»å‡»/é˜²å¾¡åŒBossï¼‰ï¼›
    //      å½“Bossç”Ÿå‘½å€¼é™è‡³30%ä»¥ä¸‹æ—¶ï¼Œç†”ç«æ¶çŠ¬è¿›å…¥ç‹‚æš´ï¼ˆåœ¨å°å¼Ÿè¡ŒåŠ¨é˜¶æ®µç”Ÿæ•ˆï¼‰ã€‚
    if (combat.bossId === 'golemagg') {
        combat.bossBuffs = combat.bossBuffs || {};
        combat.minions = Array.isArray(combat.minions) ? combat.minions : [];

        // åˆå§‹åŒ–ç‹‚æ€’å±‚æ•°
        if (!Number.isFinite(Number(combat.bossBuffs.furyStacks))) {
            combat.bossBuffs.furyStacks = 0;
        }

        // é¦–æ¬¡è¿›å…¥æˆ˜æ–—ï¼šç”Ÿæˆç†”ç«æ¶çŠ¬ï¼ˆä¸ä¼šåœ¨æ­»äº¡åè‡ªåŠ¨é‡ç”Ÿï¼‰
        if (!combat.bossBuffs.golemaggHoundsSpawned) {
            const count = Math.max(0, Math.floor(Number(boss.houndCount || 2)));
            const hp = Math.floor(Number(boss.houndHp || boss.minion?.maxHp || 1800000));
            const atk = Math.floor(Number(boss.attack || 0));
            const def = Math.floor(Number(boss.defense || 0));

            for (let k = 0; k < count; k++) {
                combat.minions.push({
                    hp,
                    maxHp: hp,
                    attack: atk,
                    defense: def,
                    isMoltenHound: true,
                    immune: false,
                    dots: []
                });
            }

            combat.bossBuffs.golemaggHoundsSpawned = true;
            combat.bossBuffs.houndsEnraged = false;

            const minionName = boss.minion?.name || 'ç†”ç«æ¶çŠ¬';
            if (count > 0) {
                addLog(`ã€${boss.name}ã€‘è¢«åŠ¨ï¼šå›ºæœ‰ ${count} åªã€${minionName}ã€‘ç™»åœºï¼`, 'warning');
            }
        }
    }

    // ==================== ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ï¼šè¢«åŠ¨ï¼ˆå›ºæœ‰çƒˆç„°è¡Œè€…åŒ»å¸ˆ/ç²¾è‹±ï¼‰ ====================
    // è¢«åŠ¨ï¼š
    // - å›ºæœ‰2ä¸ªã€çƒˆç„°è¡Œè€…åŒ»å¸ˆã€‘ï¼ˆHP 3,000,000ï¼‰
    // - å›ºæœ‰2ä¸ªã€çƒˆç„°è¡Œè€…ç²¾è‹±ã€‘ï¼ˆHP 5,000,000ï¼‰
    // è¡ŒåŠ¨é€»è¾‘åœ¨â€œå°å¼Ÿè¡ŒåŠ¨é˜¶æ®µâ€å¤„ç†ã€‚
    if (combat.bossId === 'majordomo_executus') {
        combat.bossBuffs = combat.bossBuffs || {};
        combat.minions = Array.isArray(combat.minions) ? combat.minions : [];

        // åˆå§‹åŒ–æŠ¤ç›¾å‰©ä½™å›åˆ
        if (!Number.isFinite(Number(combat.bossBuffs.executusPhysicalShield))) {
            combat.bossBuffs.executusPhysicalShield = 0;
        }
        if (!Number.isFinite(Number(combat.bossBuffs.executusMagicShield))) {
            combat.bossBuffs.executusMagicShield = 0;
        }

        // å¼€åœºç”Ÿæˆéšä»ï¼ˆä¸ä¼šè‡ªåŠ¨é‡ç”Ÿï¼‰
        if (!combat.bossBuffs.executusAddsSpawned) {
            const healerCount = Math.max(0, Math.floor(Number(boss.healerCount || 2)));
            const eliteCount = Math.max(0, Math.floor(Number(boss.eliteCount || 2)));

            const healerHp = Math.floor(Number(boss.healerHp || 3000000));
            const eliteHp = Math.floor(Number(boss.eliteHp || 5000000));

            const atk = Math.floor(Number(boss.attack || 0));
            const def = Math.floor(Number(boss.defense || 0));

            const healerName = boss.healerName || 'çƒˆç„°è¡Œè€…åŒ»å¸ˆ';
            const eliteName = boss.eliteName || 'çƒˆç„°è¡Œè€…ç²¾è‹±';

            for (let k = 0; k < healerCount; k++) {
                combat.minions.push({
                    hp: healerHp,
                    maxHp: healerHp,
                    attack: atk,
                    defense: def,
                    isFlamewakerHealer: true,
                    isFlamewakerElite: false,
                    displayName: `${healerName}${k + 1}`,
                    immune: false,
                    dots: []
                });
            }

            for (let k = 0; k < eliteCount; k++) {
                combat.minions.push({
                    hp: eliteHp,
                    maxHp: eliteHp,
                    attack: atk,
                    defense: def,
                    isFlamewakerHealer: false,
                    isFlamewakerElite: true,
                    displayName: `${eliteName}${k + 1}`,
                    immune: false,
                    dots: []
                });
            }

            combat.bossBuffs.executusAddsSpawned = true;

            if (healerCount + eliteCount > 0) {
                addLog(`ã€${boss.name}ã€‘è¢«åŠ¨ï¼šå›ºæœ‰ ${healerCount} ä¸ªã€${healerName}ã€‘ä¸ ${eliteCount} ä¸ªã€${eliteName}ã€‘ç™»åœºï¼`, 'warning');
            }
        }
    }

    for (let i = 0; i < combat.playerStates.length; i++) {
        const p = combat.playerStates[i];
        if (p.currentHp <= 0) continue;

        // ===== 50çº§å¤©èµ‹ï¼šå¹»æƒ³æ›²ï¼ˆæ¯å›åˆè·å¾—1å±‚ï¼Œå½±å“ä¸‹ä¸€ä¸ªç¥åœ£æ–°æ˜Ÿï¼‰ =====
        if (p.char?.classId === 'discipline_priest' && p.char?.talents?.[50] === 'fantasia') {
            p.fantasiaStacks = (p.fantasiaStacks || 0) + 1;
            addLog(`ã€å¹»æƒ³æ›²ã€‘ä½ç½®${i + 1} ${p.char.name} è·å¾—1å±‚ï¼ˆå½“å‰${p.fantasiaStacks}å±‚ï¼‰`);
        }

        // ==================== å›åˆå¼€å§‹ï¼šæŒç»­æ€§buffæ•ˆæœï¼ˆç›—è´¼ç­‰ï¼‰ ====================
        // 1) çŒ©çº¢ä¹‹ç“¶ï¼šæ¯å›åˆå›å¤æœ€å¤§ç”Ÿå‘½å€¼ä¸€å®šæ¯”ä¾‹
        // 2) å†²åŠ¨ï¼šæ¯å›åˆè·å¾—è¿å‡»ç‚¹
        p.comboPoints = Number.isFinite(p.comboPoints) ? p.comboPoints : 0;
        if (Array.isArray(p.buffs) && p.buffs.length > 0) {
            p.buffs.forEach(b => {
                // æ¯å›åˆæ²»ç–—
                if (b && typeof b.healPctPerTurn === 'number' && b.healPctPerTurn > 0) {
                    const maxHp = Number(p.char?.stats?.maxHp) || 0;
                    const baseHeal = Math.floor(maxHp * b.healPctPerTurn);

                    // è‡´æ­»æ‰“å‡»ï¼šå‡ç–—
                    let healingMult = 1;
                    if (p.debuffs?.mortalStrike) {
                        healingMult = 1 - (p.debuffs.mortalStrike.healingReduction || 0);
                    }
                    const actualHeal = Math.max(0, Math.floor(baseHeal * healingMult));
                    if (actualHeal > 0 && p.currentHp > 0) {
                        const before = p.currentHp;
                        p.currentHp = Math.min(maxHp, p.currentHp + actualHeal);
                        const realHeal = p.currentHp - before;
                        if (realHeal > 0) {
                            let healText = `ã€${b.name || 'æŒç»­æ²»ç–—'}ã€‘ä½ç½®${i + 1} ${p.char.name} å›å¤ ${realHeal} ç‚¹ç”Ÿå‘½`;
                            if (healingMult < 1) {
                                healText += `ï¼ˆå—åˆ°è‡´æ­»æ‰“å‡»å‡ç–—${Math.round((1 - healingMult) * 100)}%ï¼‰`;
                            }
                            addLog(healText);
                        }
                    }
                }

                // æ¯å›åˆè·å¾—è¿å‡»ç‚¹
                if (b && Number.isFinite(Number(b.comboPerTurn)) && Number(b.comboPerTurn) > 0) {
                    const gain = Math.max(0, Math.floor(Number(b.comboPerTurn)));
                    if (gain > 0) {
                        const maxCombo = getMaxComboPointsForChar(p.char);
                        const before = p.comboPoints;
                        p.comboPoints = Math.min(maxCombo, p.comboPoints + gain);
                        const realGain = p.comboPoints - before;
                        if (realGain > 0) {
                            addLog(`ã€${b.name || 'å¢ç›Š'}ã€‘ä½ç½®${i + 1} ${p.char.name} è·å¾— ${realGain} æ˜Ÿï¼ˆå½“å‰${p.comboPoints}æ˜Ÿï¼‰`);
                        }
                    }
                }
            });
        }

        // ==================== ææƒ§ï¼šè·³è¿‡æœ¬å›åˆè¡ŒåŠ¨ ====================
        // è¯´æ˜ï¼šæ¯æ¬¡ stepBossCombat è§†ä¸ºâ€œ1å›åˆâ€ï¼Œææƒ§æœŸé—´è¯¥è§’è‰²ä¸é‡Šæ”¾æŠ€èƒ½ï¼›
        // ä½†ä»ç„¶ä¼šæ¶ˆè€—æœ¬å›åˆï¼ˆæŠ€èƒ½è½®è½¬ç»§ç»­å‰è¿›ï¼‰ï¼Œå¹¶æ­£å¸¸ç»“ç®— buff/debuff æŒç»­æ—¶é—´ã€‚
        if (p.debuffs?.fear?.duration > 0) {
            // ä»ç„¶æ¨è¿›æŠ€èƒ½è½®è½¬ï¼ˆè¡¨ç¤ºè¿™ä¸€å›åˆè¢«æµªè´¹ï¼‰
            if (Array.isArray(p.validSkills) && p.validSkills.length > 0) {
                p.skillIndex = (p.skillIndex || 0) + 1;
            }

            addLog(`ä½ç½®${i + 1} ${p.char.name} å› ã€ææƒ§ã€‘æ— æ³•è¡ŒåŠ¨ï¼ˆå‰©ä½™${p.debuffs.fear.duration}å›åˆï¼‰`, 'debuff');
            tickPlayerDurations(p, i);
            continue;
        }

        // ==================== å‡»é£ï¼šè·³è¿‡æœ¬å›åˆè¡ŒåŠ¨ ====================
        // è¯´æ˜ï¼šä¸ææƒ§ç±»ä¼¼ï¼Œä½†ä¸èµ°äº¡çµæ„å¿—ç­‰"ææƒ§å…ç–«"é€»è¾‘ã€‚
        if (p.debuffs?.knockup?.duration > 0) {
            // ä»ç„¶æ¨è¿›æŠ€èƒ½è½®è½¬ï¼ˆè¡¨ç¤ºè¿™ä¸€å›åˆè¢«æµªè´¹ï¼‰
            if (Array.isArray(p.validSkills) && p.validSkills.length > 0) {
                p.skillIndex = (p.skillIndex || 0) + 1;
            }

            addLog(`ä½ç½®${i + 1} ${p.char.name} å› ã€å‡»é£ã€‘æ— æ³•è¡ŒåŠ¨ï¼ˆå‰©ä½™${p.debuffs.knockup.duration}å›åˆï¼‰`, 'debuff');
            tickPlayerDurations(p, i);
            continue;
        }

        // é˜²å¾¡ï¼šæç«¯æƒ…å†µä¸‹æ²¡æœ‰æŠ€èƒ½è¡¨
        if (!Array.isArray(p.validSkills) || p.validSkills.length === 0) {
            addLog(`ä½ç½®${i + 1} ${p.char.name} æ²¡æœ‰å¯ç”¨æŠ€èƒ½ï¼Œè·³è¿‡è¡ŒåŠ¨`, 'warning');
            tickPlayerDurations(p, i);
            continue;
        }

        const slotIndex = p.skillIndex % p.validSkills.length;
        let skillId = p.validSkills[p.skillIndex % p.validSkills.length];
        p.skillIndex += 1;
        let skill = SKILLS[skillId];

        // ===== æ–°å¢ï¼šå¤„ç†æ¡ä»¶æŠ€èƒ½ =====
        if (skill && skill.type === 'conditional') {
            const condition = skill.condition;
            let conditionMet = false;

            if (condition.type === 'has_buff') {
                if (condition.buffName === 'fingersOfFrost') {
                    conditionMet = (p.fingersOfFrost || 0) >= (condition.minStacks || 1);
                }
            }

            const actualSkillId = conditionMet ? skill.skillIfTrue : skill.skillIfFalse;
            skillId = actualSkillId;
            skill = SKILLS[actualSkillId];

            addLog(`ã€æ™ºèƒ½æŠ€èƒ½ã€‘${p.char.name}ï¼š${conditionMet ? 'æœ‰å¯’å†°æŒ‡â†’å†°æªæœ¯' : 'æ— å¯’å†°æŒ‡â†’å¯’å†°ç®­'}`);
        }
        // ===== æ¡ä»¶æŠ€èƒ½å¤„ç†ç»“æŸ =====

        if (!skill) {
            tickPlayerDurations(p, i);
            continue;
        }

        // ==================== è£…å¤‡ç‰¹æ•ˆï¼šå›åˆå¼€å§‹æ¦‚ç‡å±æ€§å¢ç›Šï¼ˆä»…æœ¬å›åˆï¼‰ ====================
        const { bonus: turnProcBonus, triggered: turnProcTriggered } = rollProcStatEffects(p.char, 'turn_start');
        if (turnProcTriggered.length > 0) {
            turnProcTriggered.forEach(tp => {
                const t = formatProcStatBonusText(tp.bonus);
                if (t) addLog(`ã€${tp.label}ã€‘è§¦å‘ï¼š${t}ï¼ˆæœ¬å›åˆï¼‰`);
            });
        }

        // ==================== è£…å¤‡ç‰¹æ•ˆï¼šé›·éœ†ä¹‹æ€’ï¼ˆé£å‰‘ï¼‰ ====================
        // å›åˆå¼€å§‹20%æ¦‚ç‡ï¼šå¯¹æ‰€æœ‰æ•Œäººé€ æˆ1.2å€æ”»å‡»çš„è‡ªç„¶ä¼¤å®³ï¼›å¹¶è·å¾—æ‰¿ä¼¤-20%æŒç»­2å›åˆ
        const thunderfury = rollThunderfuryEffect(p.char, 'turn_start');
        if (thunderfury) {
            const atk = Number(p.char?.stats?.attack) || 0;
            const raw = Math.floor(atk * (Number(thunderfury.damageMult) || 1.2));
            const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';

            // ä¼¤å®³ï¼šBoss
            if ((combat.bossHp ?? 0) > 0 && !isRagnarosSubmergedThisRound) {
                const shieldInfo = getExecutusShieldInfo('nature');
                if (shieldInfo.immune) {
                    addLog(`ã€${thunderfury.label}ã€‘é—ªç”µé“¾è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«`, 'warning');
                } else {
                const defEff = getEffectiveTargetDefense(p.char, (boss.defense || 0));
                const actual = Math.max(1, Math.floor(raw - defEff));
                combat.bossHp -= actual;
                addLog(`ã€${thunderfury.label}ã€‘é—ªç”µé“¾å‘½ä¸­ ${boss.name}ï¼šé€ æˆ ${actual} è‡ªç„¶ä¼¤å®³`);
                }
            }

            // ä¼¤å®³ï¼šæ‰€æœ‰å­˜æ´»ä¸”éå…ç–«çš„å°å¼Ÿ
            if (Array.isArray(combat.minions) && combat.minions.length > 0) {
                combat.minions.forEach((m, mi) => {
                    if (!m || (m.hp ?? 0) <= 0) return;
                    if (m.immune) {
                        addLog(`ã€${thunderfury.label}ã€‘é—ªç”µé“¾è¢« ${minionName} å…ç–«`, 'warning');
                        return;
                    }

                    const shieldInfo = getExecutusShieldInfo('nature');
                    if (shieldInfo.immune) {
                        addLog(`ã€${thunderfury.label}ã€‘é—ªç”µé“¾è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«`, 'warning');
                        return;
                    }
                    const defRaw = m.defense ?? boss.minion?.defense ?? boss.cannoneer?.defense ?? 0;
                    const defEff = getEffectiveTargetDefense(p.char, defRaw);
                    const actual = Math.max(1, Math.floor(raw - defEff));
                    combat.minions[mi].hp -= actual;
                    addLog(`ã€${thunderfury.label}ã€‘é—ªç”µé“¾å‘½ä¸­ ${minionName}ï¼šé€ æˆ ${actual} è‡ªç„¶ä¼¤å®³`);
                });
            }

            // è‡ªèº«æ‰¿ä¼¤é™ä½Buffï¼ˆåˆ·æ–°ï¼‰
            const buffType = 'thunderfury_guard';
            const dur = Math.max(1, Math.floor(thunderfury.selfBuffDuration || 2));
            const dtm = Number(thunderfury.selfDamageTakenMult) || 0.8;
            const existingIdx = (p.buffs || []).findIndex(b => b?.type === buffType);
            if (existingIdx === -1) {
                p.buffs.push({
                    type: buffType,
                    name: 'é›·éœ†å®ˆæŠ¤',
                    damageTakenMult: dtm,
                    duration: dur,
                    justApplied: true,
                });
            } else {
                p.buffs[existingIdx] = {
                    ...p.buffs[existingIdx],
                    name: 'é›·éœ†å®ˆæŠ¤',
                    damageTakenMult: dtm,
                    duration: dur,
                    justApplied: true,
                };
            }
            addLog(`ã€é›·éœ†å®ˆæŠ¤ã€‘${p.char.name} å—åˆ°çš„æ‰€æœ‰ä¼¤å®³é™ä½ ${Math.round((1 - dtm) * 100)}%ï¼ˆæŒç»­${dur}å›åˆï¼‰`, 'buff');
        }

                // ==================== è£…å¤‡ç‰¹æ•ˆï¼šæ¦‚ç‡è§¦å‘ä¼¤å®³ï¼ˆä¾‹å¦‚ï¼šè¨å¼—æ‹‰æ–¯Â·ç«ç„°ç®­ï¼‰ ====================
        const procDamages = rollProcDamageEffects(p.char, 'turn_start');
        if (procDamages.length > 0) {
            procDamages.forEach(pd => {
                const school = pd.school || 'physical';

                // é€‰ç›®æ ‡ï¼šé»˜è®¤æ‰“ Bossï¼›è‹¥ Boss ä¸‹æ½œ/ä¸ä¼˜å…ˆBoss æˆ– Bosså·²æ­»äº¡ï¼Œåˆ™æ‰“è¡€é‡æœ€ä½ä¸”æœªå…ç–«çš„å°å¼Ÿ
                let tType = 'boss';
                let tIndex = -1;

                const attackableMinions = (combat.minions || [])
                    .map((m, idx) => ({ idx, hp: Number(m?.hp) || 0, immune: !!m?.immune }))
                    .filter(x => x.hp > 0 && !x.immune);

                if (((isRagnarosSubmergedThisRound && attackableMinions.length > 0) ||
                    (!combat.strategy?.priorityBoss && attackableMinions.length > 0) ||
                    ((combat.bossHp ?? 0) <= 0 && attackableMinions.length > 0))) {
                    attackableMinions.sort((a, b) => a.hp - b.hp);
                    tType = 'minion';
                    tIndex = attackableMinions[0].idx;
                }

                // ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯æŠ¤ç›¾åˆ¤å®šï¼ˆç«ç„°/æš—å½±/è‡ªç„¶ ç­‰è§†ä¸ºâ€œåé­”æ³•æŠ¤ç›¾â€ï¼‰
                const shieldInfo = getExecutusShieldInfo(school);
                if (shieldInfo.immune) {
                    if (tType === 'boss') {
                        addLog(`ã€${pd.label}ã€‘ä¼¤å®³è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${boss.name}ï¼‰`, 'warning');
                    } else {
                        const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                        addLog(`ã€${pd.label}ã€‘ä¼¤å®³è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${minionName}${tIndex + 1}ï¼‰`, 'warning');
                    }
                    return;
                }

                // Boss ç›®æ ‡
                if (tType === 'boss') {
                    if ((combat.bossHp ?? 0) <= 0) return;

                    if (isRagnarosSubmergedThisRound) {
                        addLog(`ã€${pd.label}ã€‘ä¼¤å®³è¢«ã€ä¸‹æ½œã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${boss.name}ï¼‰`, 'warning');
                        return;
                    }

                    const defRaw = Number(boss.defense) || 0;
                    const def = getEffectiveTargetDefense(p.char, defRaw);
                    const actual = Math.max(1, Math.floor((Number(pd.rawDamage) || 0) - def));
                    combat.bossHp -= actual;
                    addLog(`ã€${pd.label}ã€‘å‘½ä¸­ ${boss.name}ï¼šé€ æˆ ${actual} ${getSchoolCn(school)}ä¼¤å®³`);
                }

                // å°å¼Ÿç›®æ ‡
                if (tType === 'minion' && tIndex >= 0 && combat.minions?.[tIndex]) {
                    const m = combat.minions[tIndex];
                    if ((m?.hp ?? 0) <= 0 || m.immune) return;

                    const defRaw = Number(m?.defense) || Number(boss.minion?.defense) || Number(boss.cannoneer?.defense) || 0;
                    const def = getEffectiveTargetDefense(p.char, defRaw);
                    const actual = Math.max(1, Math.floor((Number(pd.rawDamage) || 0) - def));

                    m.hp -= actual;

                    const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                    addLog(`ã€${pd.label}ã€‘å‘½ä¸­ ${minionName}${tIndex + 1}ï¼šé€ æˆ ${actual} ${getSchoolCn(school)}ä¼¤å®³`);
                }
            });
        }

// é¥°å“/è£…å¤‡ç‰¹æ•ˆï¼šæŠ€èƒ½æ å¼ºåŒ–
        const slotBuff = getSkillSlotBuffBonus(p.char, slotIndex);
        // ç§æ—ï¼šæŠ€èƒ½æ ¼å±æ€§åŠ æˆï¼ˆä¾‹å¦‚ï¼šå·¨é­”ã€ç‹‚æš´ã€‘å‰4æ ¼æ€¥é€Ÿ+20ï¼‰
        const racialSlotBonus = getRacialSkillSlotStatBonus(p.char, slotIndex);


        // è®¡ç®—æœ¬å›åˆç”¨äºæŠ€èƒ½ç»“ç®—çš„é¢æ¿ï¼ˆä¸ä¼šå†™å›è§’è‰²æœ¬ä½“ï¼‰
        const calcStats = {
            ...p.char.stats,
            attack: (p.char.stats.attack || 0) + (p.talentBuffs?.attackFlat || 0) + (slotBuff.attackBonus || 0),
            blockValue: (p.char.stats.blockValue || 0) + (p.talentBuffs?.blockValueFlat || 0),
            spellPower: (p.char.stats.spellPower || 0) + (p.talentBuffs?.spellPowerFlat || 0) + (slotBuff.spellPowerBonus || 0)
        };

        // ç§æ—ï¼šæŠ€èƒ½æ ¼å±æ€§åŠ æˆï¼ˆåŠ æ³•å åŠ ï¼‰
        Object.entries(racialSlotBonus || {}).forEach(([stat, add]) => {
            calcStats[stat] = (calcStats[stat] || 0) + (Number(add) || 0);
        });

        // å åŠ æœ¬å›åˆè§¦å‘çš„ä¸´æ—¶å±æ€§
        Object.entries(turnProcBonus || {}).forEach(([stat, add]) => {
            calcStats[stat] = (calcStats[stat] || 0) + (Number(add) || 0);
        });

        // Buffï¼šé¢æ¿å±æ€§åŠ æˆï¼ˆå¦‚åˆ‡å‰²/å†²åŠ¨/æ­£ä¸­çœ‰å¿ƒ/å†°å†·è¡€è„‰/äº‰åˆ†å¤ºç§’ç­‰ï¼‰
        if (Array.isArray(p.buffs) && p.buffs.length > 0) {
            p.buffs.forEach(b => {
                if (!b) return;
                if (Number.isFinite(Number(b.hasteBonus)) && Number(b.hasteBonus) !== 0) {
                    calcStats.haste = (calcStats.haste || 0) + (Number(b.hasteBonus) || 0);
                }
                if (Number.isFinite(Number(b.critRateBonus)) && Number(b.critRateBonus) !== 0) {
                    calcStats.critRate = (calcStats.critRate || 0) + (Number(b.critRateBonus) || 0);
                }
                // âœ… æš´å‡»ä¼¤å®³åŠ æˆï¼ˆä¾‹å¦‚ï¼šç‹‚å¾’ç›—è´¼30çº§å¤©èµ‹ã€åˆ€é”‹å†²åˆºã€‘ï¼‰
                if (Number.isFinite(Number(b.critDamageBonus)) && Number(b.critDamageBonus) !== 0) {
                    calcStats.critDamage = (calcStats.critDamage || 2.0) + (Number(b.critDamageBonus) || 0);
                }
                if (Number.isFinite(Number(b.masteryBonus)) && Number(b.masteryBonus) !== 0) {
                    calcStats.mastery = (calcStats.mastery || 0) + (Number(b.masteryBonus) || 0);
                }
                if (Number.isFinite(Number(b.versatilityBonus)) && Number(b.versatilityBonus) !== 0) {
                    calcStats.versatility = (calcStats.versatility || 0) + (Number(b.versatilityBonus) || 0);
                }
                if (Number.isFinite(Number(b.attackBonus)) && Number(b.attackBonus) !== 0) {
                    calcStats.attack = (calcStats.attack || 0) + (Number(b.attackBonus) || 0);
                }
                if (Number.isFinite(Number(b.spellPowerBonus)) && Number(b.spellPowerBonus) !== 0) {
                    calcStats.spellPower = (calcStats.spellPower || 0) + (Number(b.spellPowerBonus) || 0);
                }
            });
        }

        // ==================== Boss Debuffï¼šç»“èˆŒè¯…å’’ï¼ˆæ€¥é€Ÿ/æš´å‡»å½’é›¶ï¼‰ ====================
        if (p.debuffs?.tongueCurse?.duration > 0) {
            calcStats.haste = 0;
            calcStats.critRate = 0;
        }

        // ==================== ç‹‚å¾’ç›—è´¼40çº§å¤©èµ‹ï¼šå†·è¡€ ====================
        // æ•ˆæœï¼šç¬¬1æ ¼æŠ€èƒ½æš´å‡»ç‡+100%ï¼Œæš´å‡»ä¼¤å®³+50%
        if (p.char?.classId === 'outlaw_rogue' && p.char?.talents?.[40] === 'cold_blood' && slotIndex === 0) {
            calcStats.critRate = (Number(calcStats.critRate) || 0) + 100;
            calcStats.critDamage = (Number(calcStats.critDamage) || 2.0) + 0.5;
        }

        const charForCalc = {
            ...p.char,
            stats: calcStats
        };

        // combatContext
        const icyVeinsBuff = p.buffs?.some(b => b.type === 'icy_veins');
        const blizzardActive = combat.bossDots?.some(d => d.name === 'å†°é£æš´' && d.sourcePlayerId === p.char.id) ||
            combat.minions?.some(m => m.dots?.some(d => d.name === 'å†°é£æš´' && d.sourcePlayerId === p.char.id));

        // å¯è¢«AOEå‘½ä¸­çš„æ•Œäººæ•°ï¼ˆç”¨äºç‹‚å¾’ç›—è´¼20çº§å¤©èµ‹ç­‰ï¼‰
        const enemyCount = (() => {
            let cnt = 0;
            if ((combat.bossHp ?? 0) > 0 && !isRagnarosSubmergedThisRound) cnt += 1;
            if (Array.isArray(combat.minions) && combat.minions.length > 0) {
                combat.minions.forEach(m => {
                    if (!m) return;
                    if ((m.hp ?? 0) > 0 && !m.immune) cnt += 1;
                });
            }
            return cnt;
        })();

        const combatContext = {
            fortuneMisfortuneStacks: p.fortuneMisfortuneStacks || 0,
            fantasiaStacks: p.fantasiaStacks || 0,
            icyVeinsBuff,
            blizzardActive,
            fingersOfFrost: p.fingersOfFrost || 0,
            comboPoints: p.comboPoints || 0,
            enemyCount
        };
        const result = skill.calculate(charForCalc, combatContext);

        // ç›®æ ‡é€‰æ‹©é€»è¾‘ - æ£€æŸ¥ç«ç‚®æ‰‹æ˜¯å¦å…ç–«
        let targetType = 'boss';
        let targetIndex = -1;

        // æ£€æŸ¥æ˜¯å¦æœ‰å¯æ”»å‡»çš„å°å¼Ÿï¼ˆæ’é™¤å…ç–«çŠ¶æ€çš„ç«ç‚®æ‰‹ï¼‰
        const attackableMinions = combat.minions
            .map((m, idx) => ({ idx, hp: m.hp, immune: m.immune }))
            .filter(m => m.hp > 0 && !m.immune);

        if (((isRagnarosSubmergedThisRound && attackableMinions.length > 0) || (!combat.strategy.priorityBoss && attackableMinions.length > 0))) {
            attackableMinions.sort((a, b) => a.hp - b.hp);
            targetIndex = attackableMinions[0].idx;
            targetType = 'minion';
        }

        // buffä¼¤å®³åŠ æˆ
        let buffDamageDealtMult = 1;
        if (p.buffs) {
            p.buffs.forEach(b => {
                if (b.damageDealtMult) {
                    buffDamageDealtMult *= b.damageDealtMult;
                }
            });
        }

        // ==================== ç‹‚å¾’ç›—è´¼60çº§å¤©èµ‹ï¼šæ€¥ä¸å¯è€ ====================
        // å†²åŠ¨æœŸé—´ï¼šæ ¹æ®å½“å‰è¿å‡»ç‚¹(æ˜Ÿ)æé«˜æ€»ä¼¤å®³ï¼ˆæ¯æ˜Ÿ+3%ï¼‰
        let impatientBonusPct = 0;
        let impatientCombo = 0;
        if (p.char?.classId === 'outlaw_rogue' && p.char?.talents?.[60] === 'impatient') {
            const hasAR = Array.isArray(p.buffs) && p.buffs.some(b => b?.type === 'adrenaline_rush' && (b.duration ?? 0) > 0);
            if (hasAR) {
                const cp = Math.max(0, Math.floor(Number(p.comboPoints) || 0));
                if (cp > 0) {
                    impatientCombo = cp;
                    impatientBonusPct = cp * 3;
                    buffDamageDealtMult *= (1 + cp * 0.03);
                }
            }
        }

        // ==================== ç›—è´¼ï¼šå‰‘åˆƒä¹±èˆï¼ˆå¤åˆ¶ä¼¤å®³ï¼‰ ====================
        const hasBladeFlurry = Array.isArray(p.buffs) && p.buffs.some(b => b?.type === 'blade_flurry' && (b.duration ?? 1) > 0);
        const getBladeFlurryCopyRatio = () => {
            // åŸºç¡€50%ï¼Œç²¾é€šæé«˜ï¼ˆç²¾é€š/10ï¼‰%
            const mastery = Number(charForCalc?.stats?.mastery) || 0;
            return 0.5 + (mastery / 1000);
        };

        const applyBladeFlurryCleave = (baseDamage, sourceLabel = '') => {
            if (!hasBladeFlurry) return;
            if (!Number.isFinite(baseDamage) || baseDamage <= 0) return;

            const ratio = getBladeFlurryCopyRatio();
            if (!Number.isFinite(ratio) || ratio <= 0) return;

            const cleaveBase = Math.floor(baseDamage * ratio);
            if (cleaveBase <= 0) return;

            const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';

            // å¤åˆ¶ä¼¤å®³é»˜è®¤æŒ‰â€œç‰©ç†â€å¤„ç†ï¼ˆå¯è¢«ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ã€åç‰©ç†æŠ¤ç›¾ã€‘å…ç–«ï¼‰
            const shieldInfo = getExecutusShieldInfo('physical');

            // ä¸»ç›®æ ‡æ˜¯å°å¼Ÿ -> é¢å¤–æ‰“Boss
            if (targetType !== 'boss' && combat.bossHp > 0 && !isRagnarosSubmergedThisRound) {
                if (shieldInfo.immune) {
                    addLog(`ã€å‰‘åˆƒä¹±èˆã€‘é¢å¤–ä¼¤å®³è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼`, 'warning');
                } else {
                const bossDefRaw = Number(boss.defense) || 0;
                const bossDef = getEffectiveTargetDefense(p.char, bossDefRaw);
                const cleaveToBoss = Math.max(1, cleaveBase - bossDef);
                combat.bossHp -= cleaveToBoss;
                addLog(`ã€å‰‘åˆƒä¹±èˆã€‘${p.char.name} çš„${sourceLabel} é¢å¤–å¯¹ ${boss.name} é€ æˆ ${cleaveToBoss} ä¼¤å®³`);
                }
            }

            // é¢å¤–æ‰“æ‰€æœ‰éä¸»ç›®æ ‡çš„å°å¼Ÿ
            if (Array.isArray(combat.minions) && combat.minions.length > 0) {
                combat.minions.forEach((m, idx) => {
                    if (!m || m.hp <= 0) return;
                    if (targetType === 'minion' && idx === targetIndex) return;

                    // å…ç–«
                    if (m.immune) {
                        addLog(`ã€å‰‘åˆƒä¹±èˆã€‘é¢å¤–ä¼¤å®³è¢« ç«ç‚®æ‰‹${idx + 1}ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                        return;
                    }

                    if (shieldInfo.immune) {
                        addLog(`ã€å‰‘åˆƒä¹±èˆã€‘é¢å¤–ä¼¤å®³è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼`, 'warning');
                        return;
                    }

                    const defRaw = Number(m.defense) || Number(boss.minion?.defense) || Number(boss.cannoneer?.defense) || 0;
                    const def = getEffectiveTargetDefense(p.char, defRaw);
                    const cleaveToMinion = Math.max(1, cleaveBase - def);
                    m.hp -= cleaveToMinion;
                    addLog(`ã€å‰‘åˆƒä¹±èˆã€‘${p.char.name} çš„${sourceLabel} é¢å¤–å¯¹ ${minionName}${idx + 1} é€ æˆ ${cleaveToMinion} ä¼¤å®³`);
                });
            }
        };

        // ==================== ç‹‚å¾’ç›—è´¼30çº§å¤©èµ‹ï¼šæ‚è€æ‰“å‡» ====================
        // æ•ˆæœï¼šæ™®é€šæ”»å‡»/å½±è¢­ å åŠ ã€æ‚è€ã€‘ï¼ˆå…¨èƒ½+2ï¼Œæœ€å¤š25å±‚ï¼Œæœ¬åœºæˆ˜æ–—ï¼‰
        const procJugglingStrikes = (triggerSkillId) => {
            if (p.char?.classId !== 'outlaw_rogue') return;
            if (p.char?.talents?.[30] !== 'juggling_strikes') return;
            if (!['basic_attack', 'shadowstrike', 'sinister_strike'].includes(triggerSkillId)) return;

            p.buffs = Array.isArray(p.buffs) ? p.buffs : [];
            const maxStacks = 25;
            const perStack = 2;

            const idx = p.buffs.findIndex(b => b?.type === 'juggling');
            if (idx === -1) {
                p.buffs.push({
                    type: 'juggling',
                    name: 'æ‚è€',
                    stacks: 1,
                    versatilityBonus: perStack,
                    duration: 999,
                    justApplied: true,
                });
                addLog(`ã€æ‚è€æ‰“å‡»ã€‘${p.char.name} è·å¾—1å±‚ã€æ‚è€ã€‘ï¼ˆ1/${maxStacks}ï¼Œå…¨èƒ½+${perStack}ï¼‰`);
                return;
            }

            const old = p.buffs[idx];
            const curStacks = Math.max(0, Math.floor(Number(old.stacks) || 0));
            if (curStacks >= maxStacks) return;

            const nextStacks = Math.min(maxStacks, curStacks + 1);
            p.buffs[idx] = {
                ...old,
                stacks: nextStacks,
                versatilityBonus: nextStacks * perStack,
                duration: 999,
                justApplied: true,
            };
            addLog(`ã€æ‚è€æ‰“å‡»ã€‘${p.char.name} è·å¾—1å±‚ã€æ‚è€ã€‘ï¼ˆ${nextStacks}/${maxStacks}ï¼Œå…¨èƒ½+${nextStacks * perStack}ï¼‰`);
        };

        // æ™®é€šæ”»å‡»æ‰§è¡Œå‡½æ•°
        const executeBasicAttackDamage = (isRepeat = false, repeatSource = '') => {
            const basicSkill = SKILLS['basic_attack'];
            const basicResult = basicSkill.calculate(charForCalc, combatContext);

            if (basicResult.damage) {
                let damage = basicResult.damage * buffDamageDealtMult;
                const targetDefenseRaw = targetType === 'boss' ? boss.defense : (boss.minion?.defense || boss.cannoneer?.defense || 0);
                const targetDefense = getEffectiveTargetDefense(p.char, targetDefenseRaw);
                const actualDamage = Math.max(1, Math.floor(damage - targetDefense));

                // ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯ï¼šä¸‹æ½œ - Bosså…ç–«æ‰€æœ‰ä¼¤å®³
                if (targetType === 'boss' && isRagnarosSubmergedThisRound) {
                    addLog(`ä½ç½®${i + 1} ${p.char.name} çš„æ”»å‡»è¢«ã€ä¸‹æ½œã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${boss.name}ï¼‰`, 'warning');
                    return 0;
                }

                // ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ï¼šåç‰©ç†æŠ¤ç›¾ï¼ˆå…ç–«ç‰©ç†ä¼¤å®³ï¼‰
                {
                    const shieldInfo = getExecutusShieldInfo('physical');
                    if (shieldInfo.immune) {
                        const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                        addLog(`ä½ç½®${i + 1} ${p.char.name} çš„æ”»å‡»è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${targetType === 'boss' ? boss.name : minionName}ï¼‰`, 'warning');
                        return 0;
                    }
                }

                if (targetType === 'boss') {
                    combat.bossHp -= actualDamage;
                } else {
                    // æ£€æŸ¥å…ç–«
                    if (combat.minions[targetIndex]?.immune) {
                        addLog(`ä½ç½®${i + 1} ${p.char.name} çš„æ”»å‡»è¢«ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                        return 0;
                    }
                    combat.minions[targetIndex].hp -= actualDamage;
                }

                const repeatText = isRepeat ? `(${repeatSource || 'è¿å‡»'})` : '';
                const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                addLog(`ä½ç½®${i + 1} ${p.char.name} ä½¿ç”¨ æ™®é€šæ”»å‡»${repeatText} å¯¹ ${targetType === 'boss' ? boss.name : minionName} é€ æˆ ${actualDamage} ä¼¤å®³${basicResult.isCrit ? 'ï¼ˆæš´å‡»ï¼‰' : ''}`);

                // ==================== ç‹‚å¾’ç›—è´¼40çº§å¤©èµ‹ï¼šæ·±é‚ƒè¯¡è®¡ ====================
                // æ•ˆæœï¼šæ™®é€šæ”»å‡»æš´å‡»æœ‰50%æ¦‚ç‡è·å¾—1é¢—æ˜Ÿ
                if (p.char?.classId === 'outlaw_rogue' && p.char?.talents?.[40] === 'deep_stratagem' && basicResult.isCrit) {
                    if (Math.random() < 0.5) {
                        const maxCombo = getMaxComboPointsForChar(p.char);
                        const before = p.comboPoints;
                        p.comboPoints = Math.min(maxCombo, (Number(p.comboPoints) || 0) + 1);
                        const realGain = p.comboPoints - before;
                        if (realGain > 0) {
                            addLog(`ã€æ·±é‚ƒè¯¡è®¡ã€‘è§¦å‘ï¼š${p.char.name} æ™®é€šæ”»å‡»${repeatText}æš´å‡»è·å¾—1æ˜Ÿï¼ˆå½“å‰${p.comboPoints}æ˜Ÿï¼‰`);
                        }
                    }
                }


                if (basicResult.holySwordDamage && basicResult.holySwordDamage > 0) {
                    const holySwordActualDamage = Math.max(1, Math.floor(basicResult.holySwordDamage));

                    if (targetType === 'boss') {
                        combat.bossHp -= holySwordActualDamage;
                    } else if (!combat.minions[targetIndex]?.immune) {
                        combat.minions[targetIndex].hp -= holySwordActualDamage;
                    }

                    addLog(`ã€åœ£å‰‘ã€‘è§¦å‘ï¼š${p.char.name} é¢å¤–é€ æˆ ${holySwordActualDamage} ç‚¹çœŸå®ä¼¤å®³`);
                }

                // å‰‘åˆƒä¹±èˆï¼šå¤åˆ¶ä¼¤å®³ï¼ˆæ™®é€šæ”»å‡»ä¹Ÿè§¦å‘ï¼‰
                applyBladeFlurryCleave(Math.floor(damage), `æ™®é€šæ”»å‡»${repeatText}`);

                // âœ… ç‹‚å¾’ç›—è´¼30çº§å¤©èµ‹ï¼šæ‚è€æ‰“å‡»ï¼ˆé‡å¤æ™®æ”»åŒæ ·å å±‚ï¼‰
                procJugglingStrikes('basic_attack');

                return actualDamage;
            }
            return 0;
        };

        // AOEä¼¤å®³å¤„ç†
        if (result.aoeDamage) {
            if (impatientBonusPct > 0) {
                addLog(`ã€æ€¥ä¸å¯è€ã€‘å†²åŠ¨æœŸé—´å½“å‰${impatientCombo}æ˜Ÿï¼Œæœ¬æ¬¡ã€${skill.name}ã€‘ä¼¤å®³æé«˜${impatientBonusPct}%`);
            }
            let damage = result.aoeDamage * buffDamageDealtMult;

            // ç‹‚å¾’ç›—è´¼20çº§å¤©èµ‹ï¼šç´¢å‘½å¼ºèƒ½ - æ¶ˆè€—æ˜Ÿçš„æŠ€èƒ½æ¯æ¶ˆè€—1æ˜Ÿï¼Œæœ€ç»ˆä¼¤å®³+5%
            if (p.char?.classId === 'outlaw_rogue' && p.char?.talents?.[20] === 'fatal_empowerment' && result.consumeComboPoints) {
                const spent = (result.consumeComboPoints === 'all')
                    ? (p.comboPoints || 0)
                    : Math.min((p.comboPoints || 0), Math.max(0, Math.floor(Number(result.consumeComboPoints) || 0)));
                if (spent > 0) {
                    damage *= (1 + spent * 0.05);
                    addLog(`ã€ç´¢å‘½å¼ºèƒ½ã€‘${p.char.name} æ¶ˆè€—${spent}æ˜Ÿï¼Œæœ¬æ¬¡ã€${skill.name}ã€‘ä¼¤å®³æé«˜${spent * 5}%`);
                }
            }

            const skillName = skill.name || 'æŠ€èƒ½';

            // å¯¹ Boss é€ æˆä¼¤å®³
            if (combat.bossHp > 0 && !isRagnarosSubmergedThisRound) {
                const shieldInfo = getExecutusShieldInfo(result.school);
                if (shieldInfo.immune) {
                    addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skillName}è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${boss.name}ï¼‰`, 'warning');
                } else {
                    combat.bossHp -= damage;
                    addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skillName}å¯¹ ${boss.name} é€ æˆ ${Math.floor(damage)} ä¼¤å®³${result.isCrit ? 'ï¼ˆæš´å‡»ï¼ï¼‰' : ''}`);

                    // æ•‘èµæœºåˆ¶
                    if (p.char.stats.atonement) {
                        triggerAtonementHeal(p, damage);
                    }

                    if (result.isCrit && result.dotOnCrit) {
                        combat.bossDots = combat.bossDots || [];
                        combat.bossDots.push({ ...result.dotOnCrit, sourcePlayerId: p.char.id });
                        addLog(`â†’ ${boss.name} è·å¾—ã€é‡ä¼¤ã€‘ï¼Œå°†æŒç»­å—åˆ° DOT ä¼¤å®³`);
                    }

                    if (result.generateFingerOnHit && p.char.classId === 'frost_mage') {
                        p.fingersOfFrost = (p.fingersOfFrost || 0) + 1;
                        addLog(`ã€å†°å·çªè¿›ã€‘è§¦å‘ï¼š${p.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${p.fingersOfFrost}å±‚`);
                    }

                    if (p.char.talents?.[30] === 'demoralizing_shout') {
                        if (!combat.bossDebuffs?.demoralizingShout) {
                            combat.bossDebuffs = combat.bossDebuffs || {};
                            combat.bossDebuffs.demoralizingShout = { damageMult: 0.8 };
                            addLog(`ã€æŒ«å¿—æ€’å¼ã€‘è§¦å‘ï¼šæ‰€æœ‰æ•Œäººé€ æˆçš„ä¼¤å®³é™ä½20%`);
                        }
                    }
                }
            }

            // å¯¹æ‰€æœ‰å°å¼Ÿé€ æˆä¼¤å®³ï¼ˆæ£€æŸ¥å…ç–«ï¼‰
            combat.minions.forEach((m, idx) => {
                if (m.hp <= 0) return;

                // æ£€æŸ¥å…ç–«çŠ¶æ€
                if (m.immune) {
                    addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skillName}è¢« ç«ç‚®æ‰‹${idx + 1}ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                    return;
                }

                const shieldInfo = getExecutusShieldInfo(result.school);
                if (shieldInfo.immune) {
                    addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skillName}è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${(m.displayName || `${(boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ')}${idx + 1}`)}ï¼‰`, 'warning');
                    return;
                }

                m.hp -= damage;
                const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skillName}å¯¹ ${minionName}${idx + 1} é€ æˆ ${Math.floor(damage)} ä¼¤å®³${result.isCrit ? 'ï¼ˆæš´å‡»ï¼ï¼‰' : ''}`);

                // æ•‘èµæœºåˆ¶
                if (p.char.stats.atonement) {
                    triggerAtonementHeal(p, damage);
                }

                if (result.isCrit && result.dotOnCrit) {
                    m.dots = m.dots || [];
                    m.dots.push({ ...result.dotOnCrit, sourcePlayerId: p.char.id });
                    addLog(`â†’ ${minionName}${idx + 1} è·å¾—ã€é‡ä¼¤ã€‘ï¼Œå°†æŒç»­å—åˆ° DOT ä¼¤å®³`);
                }

                if (result.generateFingerOnHit && p.char.classId === 'frost_mage') {
                    p.fingersOfFrost = (p.fingersOfFrost || 0) + 1;
                    addLog(`ã€å†°å·çªè¿›ã€‘è§¦å‘ï¼š${p.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${p.fingersOfFrost}å±‚`);
                }
            });

            // å±±ä¸˜ä¹‹ç‹å¤©èµ‹å¤„ç†
            if (p.char.talents?.[30] === 'mountain_king' && Math.random() < 0.5) {
                const extraResult = skill.calculate(charForCalc);
                const extraDamage = extraResult.aoeDamage * buffDamageDealtMult;

                addLog(`ã€å±±ä¸˜ä¹‹ç‹ã€‘è§¦å‘ï¼šé›·éœ†ä¸€å‡»å†æ¬¡é‡Šæ”¾ï¼`);

                if (combat.bossHp > 0 && !isRagnarosSubmergedThisRound) {
                    const shieldInfo = getExecutusShieldInfo(extraResult.school);
                    if (shieldInfo.immune) {
                        addLog(`é›·éœ†ä¸€å‡»(å±±ä¸˜ä¹‹ç‹)è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${boss.name}ï¼‰`, 'warning');
                    } else {
                        combat.bossHp -= extraDamage;
                        addLog(`ä½ç½®${i + 1} ${p.char.name} çš„é›·éœ†ä¸€å‡»(å±±ä¸˜ä¹‹ç‹)å¯¹ ${boss.name} é€ æˆ ${Math.floor(extraDamage)} ä¼¤å®³${extraResult.isCrit ? 'ï¼ˆæš´å‡»ï¼ï¼‰' : ''}`);

                        if (extraResult.isCrit && extraResult.dotOnCrit) {
                            combat.bossDots = combat.bossDots || [];
                            combat.bossDots.push({ ...extraResult.dotOnCrit, sourcePlayerId: p.char.id });
                            addLog(`â†’ ${boss.name} è·å¾—ã€é‡ä¼¤ã€‘`);
                        }
                    }
                }

                combat.minions.forEach((m, idx) => {
                    if (m.hp <= 0) return;
                    if (m.immune) {
                        addLog(`é›·éœ†ä¸€å‡»(å±±ä¸˜ä¹‹ç‹)è¢« ç«ç‚®æ‰‹${idx + 1}ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                        return;
                    }

                    const shieldInfo = getExecutusShieldInfo(extraResult.school);
                    if (shieldInfo.immune) {
                        addLog(`é›·éœ†ä¸€å‡»(å±±ä¸˜ä¹‹ç‹)è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${(m.displayName || `${(boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ')}${idx + 1}`)}ï¼‰`, 'warning');
                        return;
                    }
                    m.hp -= extraDamage;
                    const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                    addLog(`ä½ç½®${i + 1} ${p.char.name} çš„é›·éœ†ä¸€å‡»(å±±ä¸˜ä¹‹ç‹)å¯¹ ${minionName}${idx + 1} é€ æˆ ${Math.floor(extraDamage)} ä¼¤å®³${extraResult.isCrit ? 'ï¼ˆæš´å‡»ï¼ï¼‰' : ''}`);

                    if (extraResult.isCrit && extraResult.dotOnCrit) {
                        m.dots = m.dots || [];
                        m.dots.push({ ...extraResult.dotOnCrit, sourcePlayerId: p.char.id });
                    }
                });
            }
        }
        // å•ä½“ä¼¤å®³å¤„ç†
        else if (result.damage) {
            if (impatientBonusPct > 0) {
                addLog(`ã€æ€¥ä¸å¯è€ã€‘å†²åŠ¨æœŸé—´å½“å‰${impatientCombo}æ˜Ÿï¼Œæœ¬æ¬¡ã€${skill.name}ã€‘ä¼¤å®³æé«˜${impatientBonusPct}%`);
            }
            let damage = result.damage;

            // ç‹‚å¾’ç›—è´¼20çº§å¤©èµ‹ï¼šç´¢å‘½å¼ºèƒ½ - æ¶ˆè€—æ˜Ÿçš„æŠ€èƒ½æ¯æ¶ˆè€—1æ˜Ÿï¼Œæœ€ç»ˆä¼¤å®³+5%
            if (p.char?.classId === 'outlaw_rogue' && p.char?.talents?.[20] === 'fatal_empowerment' && result.consumeComboPoints) {
                const spent = (result.consumeComboPoints === 'all')
                    ? (p.comboPoints || 0)
                    : Math.min((p.comboPoints || 0), Math.max(0, Math.floor(Number(result.consumeComboPoints) || 0)));
                if (spent > 0) {
                    damage *= (1 + spent * 0.05);
                    addLog(`ã€ç´¢å‘½å¼ºèƒ½ã€‘${p.char.name} æ¶ˆè€—${spent}æ˜Ÿï¼Œæœ¬æ¬¡ã€${skill.name}ã€‘ä¼¤å®³æé«˜${spent * 5}%`);
                }
            }

            // å¤©èµ‹åŠ æˆ
            if (p.char.talents?.[10] === 'shadow_amp' && result.school === 'shadow') {
                damage *= 1.2;
            }
            if (p.char.talents?.[20] === 'dark_side' && skillId === 'mind_blast') {
                damage *= 1.8;
            }
            damage *= buffDamageDealtMult;

            // æ³•æœ¯æ˜“ä¼¤
            const isSpellSchool = (result.school === 'holy' || result.school === 'shadow');
            let takenMult = 1;
            if (isSpellSchool) {
                const vuln = combat.bossDebuffs?.spell_vuln;
                if (vuln) takenMult *= (vuln.mult ?? 1);
            }
            damage = Math.floor(damage * takenMult);

            const targetDefenseRaw = targetType === 'boss' ? boss.defense : (boss.minion?.defense || boss.cannoneer?.defense || 0);
            const targetDefense = getEffectiveTargetDefense(p.char, targetDefenseRaw);

            // æ£€æŸ¥ç›®æ ‡æ˜¯å¦å…ç–«
            const shieldInfo = getExecutusShieldInfo(result.school);
            const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
            const targetLabel = (targetType === 'boss')
                ? boss.name
                : (combat.minions[targetIndex]?.displayName || `${minionName}${targetIndex + 1}`);

            if (targetType === 'boss' && isRagnarosSubmergedThisRound) {
                addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skill.name}è¢«ã€ä¸‹æ½œã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${targetLabel}ï¼‰`, 'warning');
            } else if (shieldInfo.immune) {
                addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skill.name}è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${targetLabel}ï¼‰`, 'warning');
            } else if (targetType === 'minion' && combat.minions[targetIndex]?.immune) {
                addLog(`ä½ç½®${i + 1} ${p.char.name} çš„${skill.name}è¢«ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
            } else {
                const actualDamage = Math.max(1, damage - targetDefense);

                if (targetType === 'boss') {
                    combat.bossHp -= actualDamage;
                } else {
                    combat.minions[targetIndex].hp -= actualDamage;
                }

                addLog(`ä½ç½®${i + 1} ${p.char.name} ä½¿ç”¨ ${skill.name} å¯¹ ${targetLabel} é€ æˆ ${actualDamage} ä¼¤å®³${result.isCrit ? 'ï¼ˆæš´å‡»ï¼‰' : ''}`);

                // å‰‘åˆƒä¹±èˆï¼šå¤åˆ¶ä¼¤å®³ï¼ˆæ™®é€šæ”»å‡»/åˆºéª¨/ä¼å‡»/æ­£ä¸­çœ‰å¿ƒï¼‰
                if (['basic_attack', 'eviscerate', 'ambush', 'between_the_eyes'].includes(skillId)) {
                    applyBladeFlurryCleave(damage, skill.name);
                }

                // æ•‘èµæœºåˆ¶
                if (p.char.stats.atonement) {
                    triggerAtonementHeal(p, actualDamage);
                }

                // é­ç¬è€…è‹è¨æ–¯ç‰¹æ•ˆ
                if (skillId === 'basic_attack') {
                    // ==================== ç‹‚å¾’ç›—è´¼40çº§å¤©èµ‹ï¼šæ·±é‚ƒè¯¡è®¡ ====================
                    // æ•ˆæœï¼šæ™®é€šæ”»å‡»æš´å‡»æœ‰50%æ¦‚ç‡è·å¾—1é¢—æ˜Ÿ
                    if (p.char?.classId === 'outlaw_rogue' && p.char?.talents?.[40] === 'deep_stratagem' && result.isCrit) {
                        if (Math.random() < 0.5) {
                            const maxCombo = getMaxComboPointsForChar(p.char);
                            const before = p.comboPoints;
                            p.comboPoints = Math.min(maxCombo, (Number(p.comboPoints) || 0) + 1);
                            const realGain = p.comboPoints - before;
                            if (realGain > 0) {
                                addLog(`ã€æ·±é‚ƒè¯¡è®¡ã€‘è§¦å‘ï¼š${p.char.name} æ™®é€šæ”»å‡»æš´å‡»è·å¾—1æ˜Ÿï¼ˆå½“å‰${p.comboPoints}æ˜Ÿï¼‰`);
                            }
                        }
                    }

                    // ==================== ç‹‚å¾’ç›—è´¼60çº§å¤©èµ‹ï¼šèƒ†å¤§å¦„ä¸º ====================
                    // æ™®æ”»è¿å‡»æ¦‚ç‡ +10%ï¼›è¿å‡»è§¦å‘æ—¶è·å¾—ç²¾é€šï¼ˆå¯å åŠ ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸï¼‰
                    const equipRepeatChance = getBasicAttackRepeatChance(p.char);
                    const talentRepeatBonus =
                        (p.char?.classId === 'outlaw_rogue' && p.char?.talents?.[60] === 'reckless_bravery')
                            ? 0.10
                            : 0;

                    const repeatChance = Math.min(1, Math.max(0, (Number(equipRepeatChance) || 0) + talentRepeatBonus));
                    if (repeatChance > 0) {
                        const roll = Math.random();
                        if (roll < repeatChance) {
                            const procLabel = (talentRepeatBonus > 0 && roll >= (Number(equipRepeatChance) || 0))
                                ? 'èƒ†å¤§å¦„ä¸º'
                                : 'é­ç¬è€…è‹è¨æ–¯';
                            addLog(`ã€${procLabel}ã€‘è§¦å‘ï¼šå†æ¬¡å‘åŠ¨æ™®é€šæ”»å‡»ï¼`);

                            // è¿å‡»è§¦å‘ï¼šè·å¾—ç²¾é€šï¼ˆä»…å½“ç‚¹äº†èƒ†å¤§å¦„ä¸ºï¼‰
                            if (talentRepeatBonus > 0) {
                                const perStack = 20;
                                const maxDuration = 999;

                                p.buffs = Array.isArray(p.buffs) ? p.buffs : [];
                                const idx = p.buffs.findIndex(b => b?.type === 'reckless_bravery_mastery');
                                if (idx === -1) {
                                    p.buffs.push({
                                        type: 'reckless_bravery_mastery',
                                        name: 'èƒ†å¤§å¦„ä¸º',
                                        stacks: 1,
                                        masteryBonus: perStack,
                                        duration: maxDuration,
                                        justApplied: true,
                                    });
                                    addLog(`ã€èƒ†å¤§å¦„ä¸ºã€‘${p.char.name} è·å¾—${perStack}ç²¾é€šï¼ˆ1å±‚ï¼Œæ€»ç²¾é€š+${perStack}ï¼‰`);
                                } else {
                                    const old = p.buffs[idx];
                                    const curStacks = Math.max(0, Math.floor(Number(old.stacks) || 0));
                                    const nextStacks = curStacks + 1;
                                    p.buffs[idx] = {
                                        ...old,
                                        stacks: nextStacks,
                                        masteryBonus: nextStacks * perStack,
                                        duration: maxDuration,
                                        justApplied: true,
                                    };
                                    addLog(`ã€èƒ†å¤§å¦„ä¸ºã€‘${p.char.name} è·å¾—${perStack}ç²¾é€šï¼ˆ${nextStacks}å±‚ï¼Œæ€»ç²¾é€š+${nextStacks * perStack}ï¼‰`);
                                }
                            }

                            executeBasicAttackDamage(true, procLabel);
                        }
                    }
                }
            }
        }

        // ==================== ç‹‚å¾’ç›—è´¼30çº§å¤©èµ‹ï¼šè—é”‹å¯»æ—¶ ====================
        // æ•ˆæœï¼šä¼å‡»æœ‰80%æ¦‚ç‡å†æ¬¡å‘åŠ¨ï¼Œæ¯ä¸ªæŠ€èƒ½æ ¼ä»…åˆ¤å®šä¸€æ¬¡ã€‚
        if (skillId === 'ambush' && p.char?.classId === 'outlaw_rogue' && p.char?.talents?.[30] === 'hidden_edge_time') {
            p.talentFlags = p.talentFlags || {};
            p.talentFlags.hiddenEdgeTime = p.talentFlags.hiddenEdgeTime || { checkedSlots: {} };
            const checkedSlots = p.talentFlags.hiddenEdgeTime.checkedSlots || {};
            p.talentFlags.hiddenEdgeTime.checkedSlots = checkedSlots;

            // æ¯ä¸ªæŠ€èƒ½æ ¼ä»…åˆ¤å®šä¸€æ¬¡ï¼ˆæ— è®ºæˆè´¥ï¼‰
            if (!checkedSlots[slotIndex]) {
                checkedSlots[slotIndex] = true;

                if (Math.random() < 0.8) {
                    addLog(`ã€è—é”‹å¯»æ—¶ã€‘è§¦å‘ï¼š${p.char.name} çš„ã€ä¼å‡»ã€‘å†æ¬¡å‘åŠ¨ï¼`);

                    const extraSkill = SKILLS['ambush'];
                    const extraResult = extraSkill.calculate(charForCalc, combatContext);

                    if (extraResult?.damage) {
                        let extraDamage = extraResult.damage;

                        // ä¸å•ä½“ä¼¤å®³é€šç”¨é€»è¾‘ä¿æŒä¸€è‡´ï¼ˆbuff/æ˜“ä¼¤/æ¶ˆè€—æ˜ŸåŠ æˆç­‰ï¼‰
                        if (p.char?.classId === 'outlaw_rogue' && p.char?.talents?.[20] === 'fatal_empowerment' && extraResult.consumeComboPoints) {
                            const spent = (extraResult.consumeComboPoints === 'all')
                                ? (p.comboPoints || 0)
                                : Math.min((p.comboPoints || 0), Math.max(0, Math.floor(Number(extraResult.consumeComboPoints) || 0)));
                            if (spent > 0) {
                                extraDamage *= (1 + spent * 0.05);
                                addLog(`ã€ç´¢å‘½å¼ºèƒ½ã€‘${p.char.name} æ¶ˆè€—${spent}æ˜Ÿï¼Œæœ¬æ¬¡ã€ä¼å‡»(è—é”‹å¯»æ—¶)ã€‘ä¼¤å®³æé«˜${spent * 5}%`);
                            }
                        }

                        if (p.char.talents?.[10] === 'shadow_amp' && extraResult.school === 'shadow') {
                            extraDamage *= 1.2;
                        }
                        extraDamage *= buffDamageDealtMult;

                        const isSpellSchoolExtra = (extraResult.school === 'holy' || extraResult.school === 'shadow');
                        let takenMultExtra = 1;
                        if (isSpellSchoolExtra) {
                            const vuln = combat.bossDebuffs?.spell_vuln;
                            if (vuln) takenMultExtra *= (vuln.mult ?? 1);
                        }
                        extraDamage = Math.floor(extraDamage * takenMultExtra);

                        const targetDef = targetType === 'boss'
                            ? (boss.defense || 0)
                            : (boss.minion?.defense || boss.cannoneer?.defense || 0);

                        const shieldInfo = getExecutusShieldInfo(extraResult.school);
                        const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                        const targetLabel = (targetType === 'boss')
                            ? boss.name
                            : (combat.minions[targetIndex]?.displayName || `${minionName}${targetIndex + 1}`);

                        if (targetType === 'boss' && isRagnarosSubmergedThisRound) {
                            addLog(`â†’ é¢å¤–ä¼å‡»è¢«ã€ä¸‹æ½œã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${targetLabel}ï¼‰`, 'warning');
                        } else if (shieldInfo.immune) {
                            addLog(`â†’ é¢å¤–ä¼å‡»è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${targetLabel}ï¼‰`, 'warning');
                        } else if (targetType === 'minion' && combat.minions[targetIndex]?.immune) {
                            addLog(`â†’ é¢å¤–ä¼å‡»è¢«ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                        } else {
                            const extraActual = Math.max(1, extraDamage - targetDef);
                            if (targetType === 'boss') {
                                combat.bossHp -= extraActual;
                            } else {
                                combat.minions[targetIndex].hp -= extraActual;
                            }

                            addLog(`â†’ ${p.char.name} çš„ä¼å‡»(è—é”‹å¯»æ—¶)å¯¹ ${targetLabel} é€ æˆ ${extraActual} ä¼¤å®³${extraResult.isCrit ? 'ï¼ˆæš´å‡»ï¼‰' : ''}`);

                            // å‰‘åˆƒä¹±èˆï¼šå¤åˆ¶ä¼¤å®³ï¼ˆä¼å‡»åŒæ ·è§¦å‘ï¼‰
                            applyBladeFlurryCleave(extraDamage, `${skill.name}(è—é”‹å¯»æ—¶)`);
                        }
                    }

                    // âœ… é¢å¤–ä¼å‡»ä¹Ÿäº§ç”Ÿè¿å‡»ç‚¹ï¼ˆæ˜Ÿï¼‰
                    if (extraResult?.generateComboPoints) {
                        const gain = Math.max(0, Math.floor(Number(extraResult.generateComboPoints) || 0));
                        if (gain > 0) {
                            const maxCombo = getMaxComboPointsForChar(p.char);
                            const before = p.comboPoints;
                            p.comboPoints = Math.min(maxCombo, p.comboPoints + gain);
                            const realGain = p.comboPoints - before;
                            if (realGain > 0) {
                                addLog(`ã€è¿å‡»ç‚¹ã€‘${p.char.name} å› ã€è—é”‹å¯»æ—¶ã€‘é¢å¤–è·å¾— ${realGain} æ˜Ÿï¼ˆå½“å‰${p.comboPoints}æ˜Ÿï¼‰`);
                            }
                        }
                    }
                } else {
                    addLog(`ã€è—é”‹å¯»æ—¶ã€‘æœªè§¦å‘ï¼š${p.char.name} çš„ã€ä¼å‡»ã€‘æ²¡æœ‰å†æ¬¡å‘åŠ¨`);
                }
            }
        }

        // æ²»ç–—å¤„ç† - éœ€è¦è€ƒè™‘å‡ç–—debuff
        if (result.healAll) {
            let heal = Math.floor(result.healAll);
            combat.playerStates.forEach(ps => {
                if (ps.currentHp > 0) {
                    // æ£€æŸ¥å‡ç–—debuff
                    let healingMult = 1;
                    if (ps.debuffs?.mortalStrike) {
                        healingMult = 1 - (ps.debuffs.mortalStrike.healingReduction || 0);
                    }
                    const actualHeal = Math.floor(heal * healingMult);
                    const newHp = Math.min(ps.char.stats.maxHp, ps.currentHp + actualHeal);
                    ps.currentHp = newHp;
                    ps.char.stats.currentHp = newHp;
                }
            });
            addLog(`ä½ç½®${i + 1} ${p.char.name} å…¨é˜Ÿæ²»ç–— ${heal}`);
        }

        // æ•‘èµå¤„ç†ï¼ˆapplyAtonementï¼‰
        if (result.applyAtonement) {
            const dur = Number(result.applyAtonement.duration) || 2;

            // âœ… æ•‘èµæ²»ç–—æ¯”ä¾‹åº”å½“æŒ‰â€œæ–½æ³•è€…ï¼ˆæˆ’å¾‹ç‰§å¸ˆï¼‰â€çš„ç²¾é€šæ¥è®¡ç®—
            // æ—§é€»è¾‘ï¼šæ¯ä¸ªç›®æ ‡ä½¿ç”¨è‡ªå·±çš„ atonement.healingRateï¼ˆéç‰§å¸ˆé»˜è®¤ 20%ï¼‰
            // æ–°é€»è¾‘ï¼šå…¨é˜Ÿç»Ÿä¸€ä½¿ç”¨æ–½æ³•è€…çš„æ•‘èµæ¯”ä¾‹ï¼ˆå³ï¼šåŸºç¡€ 20% + ç‰§å¸ˆç²¾é€šåŠ æˆï¼‰
            const casterExistingRate = p.char?.stats?.atonement?.healingRate;
            const casterMastery = Number(p.char?.stats?.mastery) || 0;

            // ä¸è§’è‰²è¢«åŠ¨â€œç²¾é€šï¼šæ•‘èµâ€çš„è®¡ç®—ä¿æŒä¸€è‡´
            // ï¼ˆè‹¥è§’è‰² stats.atonement å·²ç»æœ‰ healingRateï¼Œå°±ç›´æ¥å¤ç”¨ï¼Œé¿å…å…¬å¼å˜æ›´æ—¶ä¸¤å¤„ä¸ä¸€è‡´ï¼‰
            const casterHealingRate = (typeof casterExistingRate === 'number')
                ? casterExistingRate
                : (0.20 + (casterMastery / 10) / 100);

            // âœ… 60çº§å¤©èµ‹ï¼šä»æ…ˆ - æ•‘èµé¢å¤–æä¾›5%å‡ä¼¤ï¼ˆä¹˜ç®—ï¼‰
            const benevolence = (p.char?.classId === 'discipline_priest' && p.char?.talents?.[60] === 'benevolence');

            combat.playerStates.forEach(ps => {
                if (ps.currentHp > 0) {
                    ps.char.stats.atonement = {
                        healingRate: casterHealingRate,
                        duration: dur,
                        ...(benevolence ? { damageTakenMult: 0.95 } : {})
                    };
                }
            });

            addLog(
                `ä½ç½®${i + 1} ${p.char.name} ä¸ºå…¨é˜Ÿæ–½åŠ ã€æ•‘èµã€‘ï¼ŒæŒç»­ ${dur} å›åˆ` +
                (benevolence ? 'ï¼ˆä»æ…ˆï¼šé¢å¤–5%å‡ä¼¤ï¼‰' : '')
            );
        }

        // è‹¦ä¿®æŠ€èƒ½å¤„ç† - éœ€è¦è€ƒè™‘å‡ç–—debuff
        if (result.penanceHeal) {
            const frontPlayer = combat.playerStates.find(ps => ps.currentHp > 0);
            if (frontPlayer) {
                const fortuneStacks = p.fortuneMisfortuneStacks || 0;
                let healAmount = result.penanceHeal;

                // æ£€æŸ¥å‡ç–—debuff
                let healingMult = 1;
                if (frontPlayer.debuffs?.mortalStrike) {
                    healingMult = 1 - (frontPlayer.debuffs.mortalStrike.healingReduction || 0);
                }
                healAmount = Math.floor(healAmount * healingMult);

                const newHp = Math.min(frontPlayer.char.stats.maxHp, frontPlayer.currentHp + healAmount);
                const actualHeal = newHp - frontPlayer.currentHp;
                frontPlayer.currentHp = newHp;

                let healText = `ä½ç½®${i + 1} ${p.char.name} è‹¦ä¿®æ²»ç–— ${frontPlayer.char.name} ${actualHeal}`;
                if (fortuneStacks > 0 && p.char.talents?.[40] === 'fortune_misfortune') {
                    healText += `ï¼ˆç¥¸ç¦ç›¸ä¾ ${fortuneStacks} å±‚åŠ æˆï¼‰`;
                }
                if (healingMult < 1) {
                    healText += `ï¼ˆå—åˆ°è‡´æ­»æ‰“å‡»å‡ç–—${Math.round((1 - healingMult) * 100)}%ï¼‰`;
                }
                addLog(healText);

                // ==================== æˆ’å¾‹ç‰§å¸ˆ60çº§å¤©èµ‹ï¼šç—›è‹¦å‹åˆ¶ ====================
                // è‹¦ä¿®ä½¿å½“å‰ç›®æ ‡è·å¾—30%å‡ä¼¤ï¼ˆbuffä¹˜ç®—ï¼‰ï¼ŒæŒç»­2å›åˆ
                if (p.char?.classId === 'discipline_priest' && p.char?.talents?.[60] === 'pain_suppression') {
                    const duration = 2;
                    const damageTakenMult = 0.7; // -30% æ‰¿ä¼¤ï¼ˆä¹˜ç®—ï¼‰

                    frontPlayer.buffs = Array.isArray(frontPlayer.buffs) ? frontPlayer.buffs : [];
                    const idx = frontPlayer.buffs.findIndex(b => b?.type === 'pain_suppression');

                    // ä»…å½“ç›®æ ‡å°±æ˜¯æ–½æ³•è€…æœ¬äººæ—¶ï¼Œæ‰éœ€è¦ justAppliedï¼ˆå¦åˆ™ä¼šç™½èµš1å›åˆï¼‰
                    const extra = (frontPlayer === p) ? { justApplied: true } : {};

                    if (idx === -1) {
                        frontPlayer.buffs.push({
                            type: 'pain_suppression',
                            name: 'ç—›è‹¦å‹åˆ¶',
                            damageTakenMult,
                            duration,
                            ...extra,
                        });
                    } else {
                        frontPlayer.buffs[idx] = {
                            ...frontPlayer.buffs[idx],
                            type: 'pain_suppression',
                            name: 'ç—›è‹¦å‹åˆ¶',
                            damageTakenMult,
                            duration,
                            ...extra,
                        };
                    }

                    addLog(`ã€ç—›è‹¦å‹åˆ¶ã€‘${p.char.name} çš„è‹¦ä¿®ä½¿ ${frontPlayer.char.name} å—åˆ°ä¼¤å®³é™ä½30%ï¼ŒæŒç»­${duration}å›åˆ`);
                }

                // ç»ˆæè‹¦ä¿®ä¼¤å®³
                if (result.penanceDamage) {
                    const targetDefenseRaw = targetType === 'boss' ? boss.defense : (boss.minion?.defense || boss.cannoneer?.defense || 0);
                const targetDefense = getEffectiveTargetDefense(p.char, targetDefenseRaw);

                    // ç»ˆæè‹¦ä¿®è§†ä¸ºâ€œæ³•æœ¯â€ï¼ˆholyï¼‰ï¼Œå¯èƒ½è¢«ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ã€åé­”æ³•æŠ¤ç›¾ã€‘å…ç–«
                    const shieldInfo = getExecutusShieldInfo('holy');
                    const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                    const targetLabel = (targetType === 'boss')
                        ? boss.name
                        : (combat.minions[targetIndex]?.displayName || `${minionName}${targetIndex + 1}`);

                    if (shieldInfo.immune) {
                        addLog(`ã€ç»ˆæè‹¦ä¿®ã€‘è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${targetLabel}ï¼‰`, 'warning');
                    } else if (targetType === 'minion' && combat.minions[targetIndex]?.immune) {
                        addLog(`ã€ç»ˆæè‹¦ä¿®ã€‘è¢«ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                    } else {
                        const actualDamage = Math.max(1, Math.floor(result.penanceDamage * buffDamageDealtMult - targetDefense));

                        if (targetType === 'boss') {
                            combat.bossHp -= actualDamage;
                        } else if (targetIndex >= 0) {
                            combat.minions[targetIndex].hp -= actualDamage;
                        } else {
                            combat.bossHp -= actualDamage;
                        }

                        addLog(`ä½ç½®${i + 1} ${p.char.name}ã€ç»ˆæè‹¦ä¿®ã€‘é€ æˆ ${actualDamage} ä¼¤å®³${result.penanceDamageIsCrit ? 'ï¼ˆæš´å‡»ï¼‰' : ''}`);

                        // æ•‘èµæœºåˆ¶
                        if (p.char.stats.atonement) {
                            triggerAtonementHeal(p, actualDamage);
                        }
                    }
                }

                // äº‰åˆ†å¤ºç§’
                if (result.applyHasteBuff) {
                    p.buffs = p.buffs || [];
                    p.buffs.push({
                        type: 'haste',
                        hasteBonus: result.applyHasteBuff.hasteBonus,
                        duration: result.applyHasteBuff.duration
                        ,justApplied:true});
                    addLog(`ã€äº‰åˆ†å¤ºç§’ã€‘è§¦å‘ï¼š${p.char.name} æ€¥é€Ÿ+${result.applyHasteBuff.hasteBonus}%ï¼ŒæŒç»­${result.applyHasteBuff.duration}å›åˆ`);
                }

                if (result.clearFortuneStacks) {
                    p.fortuneMisfortuneStacks = 0;
                }
            }
        }

        // DOTå¤„ç†
        if (result.dot) {
            if (result.dot.name === 'å†°é£æš´') {
                if (targetType === 'boss' && !isRagnarosSubmergedThisRound) {
                    combat.bossDots = combat.bossDots || [];
                    combat.bossDots.push({ ...result.dot, sourcePlayerId: p.char.id });
                    addLog(`ä½ç½®${i + 1} ${p.char.name} å¯¹ ${boss.name} æ–½æ”¾ã€å†°é£æš´ã€‘ï¼ŒæŒç»­${result.dot.duration}å›åˆ`);
                } else if (targetType === 'boss' && isRagnarosSubmergedThisRound) {
                    addLog(`å†°é£æš´è¢«ã€ä¸‹æ½œã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${boss.name}ï¼‰`, 'warning');
                } else if (targetIndex >= 0 && !combat.minions[targetIndex]?.immune) {
                    combat.minions[targetIndex].dots = combat.minions[targetIndex].dots || [];
                    combat.minions[targetIndex].dots.push({ ...result.dot, sourcePlayerId: p.char.id });
                    addLog(`ä½ç½®${i + 1} ${p.char.name} å¯¹ ç«ç‚®æ‰‹${targetIndex + 1} æ–½æ”¾å†°é£æš´ï¼`);
                } else if (targetIndex >= 0 && combat.minions[targetIndex]?.immune) {
                    addLog(`å†°é£æš´è¢« ç«ç‚®æ‰‹${targetIndex + 1}ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                }
            }else{
                const dotObj = { ...result.dot, name: result.dot.name || skill.name, sourcePlayerId: p.char.id };
                if (targetType === 'boss') {
                    if (isRagnarosSubmergedThisRound) {
                        addLog(`â†’ ${boss.name}å¤„äºã€ä¸‹æ½œã€‘çŠ¶æ€ï¼Œæœªèƒ½æ–½åŠ ã€${dotObj.name}ã€‘`, 'warning');
                    } else {
                        combat.bossDots = combat.bossDots || [];
                        combat.bossDots.push(dotObj);
                    }
                } else if (targetType === 'minion' && !combat.minions[targetIndex]?.immune) {
                    combat.minions[targetIndex].dots = combat.minions[targetIndex].dots || [];
                    combat.minions[targetIndex].dots.push(dotObj);
                }
            }

        }

        // AOE DOTï¼ˆå¯’å†°å®ç ï¼‰
        if (result.aoeDot) {
            if (combat.bossHp > 0 && !isRagnarosSubmergedThisRound) {
                combat.bossDots = combat.bossDots || [];
                combat.bossDots.push({ ...result.aoeDot, sourcePlayerId: p.char.id });
                addLog(`ä½ç½®${i + 1} ${p.char.name} å¯¹ ${boss.name} æ–½æ”¾ã€${result.aoeDot.name}ã€‘ï¼ŒæŒç»­${result.aoeDot.duration}å›åˆ`);
            }
            combat.minions.forEach((m, idx) => {
                if (m.hp <= 0) return;
                if (m.immune) {
                    addLog(`ã€${result.aoeDot.name}ã€‘è¢« ç«ç‚®æ‰‹${idx + 1}ã€ç™»ä¸Šç”²æ¿ã€‘å…ç–«ï¼`);
                    return;
                }
                m.dots = m.dots || [];
                m.dots.push({ ...result.aoeDot, sourcePlayerId: p.char.id });
                addLog(`ä½ç½®${i + 1} ${p.char.name} å¯¹ ç«ç‚®æ‰‹${idx + 1} æ–½æ”¾ã€${result.aoeDot.name}ã€‘ï¼ŒæŒç»­${result.aoeDot.duration}å›åˆ`);
            });
        }

        // buffå¤„ç†
        if (result.buff) {
            p.buffs = p.buffs || [];
            p.buffs.push({ ...result.buff, justApplied: true });

            if (result.buff.damageTakenMult) {
                const damageReduction = Math.round((1 - result.buff.damageTakenMult) * 100);
                let buffText = `ä½ç½®${i + 1} ${p.char.name} å¼€å¯ç›¾å¢™ï¼Œå—åˆ°ä¼¤å®³é™ä½${damageReduction}%ï¼ˆæŒç»­${result.buff.duration}å›åˆï¼‰`;
                if (result.buff.damageDealtMult && result.buff.damageDealtMult > 1) {
                    const damageIncrease = Math.round((result.buff.damageDealtMult - 1) * 100);
                    buffText += `ï¼Œé€ æˆä¼¤å®³æé«˜${damageIncrease}%`;
                }

                // 60çº§å¤©èµ‹ï¼šæ³°å¦å£å’ - ç›¾å¢™æœŸé—´é¢æ¿å±æ€§åŠ æˆ
                if (Number.isFinite(Number(result.buff.masteryBonus)) && Number(result.buff.masteryBonus) !== 0) {
                    buffText += `ï¼Œç²¾é€š+${result.buff.masteryBonus}`;
                }
                if (Number.isFinite(Number(result.buff.versatilityBonus)) && Number(result.buff.versatilityBonus) !== 0) {
                    buffText += `ï¼Œå…¨èƒ½+${result.buff.versatilityBonus}`;
                }

                addLog(buffText);
            }

            if (result.buff.type === 'icy_veins') {
                addLog(`ä½ç½®${i + 1} ${p.char.name} å¼€å¯ã€å†°å†·è¡€è„‰ã€‘ï¼šå†°éœœä¼¤å®³+50%ï¼Œæ€¥é€Ÿ+50%ï¼ŒæŒç»­${result.buff.duration}å›åˆ`);
            }

            // ç‹‚å¾’ç›—è´¼buff
            if (result.buff.type === 'blade_flurry') {
                addLog(`ä½ç½®${i + 1} ${p.char.name} å¼€å¯ã€å‰‘åˆƒä¹±èˆã€‘ï¼šåç»­æ™®æ”»/åˆºéª¨/ä¼å‡»/æ­£ä¸­çœ‰å¿ƒå°†è§¦å‘å¤åˆ¶ä¼¤å®³ï¼ˆæŒç»­æœ¬åœºæˆ˜æ–—ï¼‰`);
            }
            if (result.buff.type === 'slice_and_dice') {
                const vBonus = result.buff.versatilityBonus || 0;
                addLog(`ä½ç½®${i + 1} ${p.char.name} å¼€å¯ã€åˆ‡å‰²ã€‘ï¼šæ€¥é€Ÿ+${result.buff.hasteBonus || 0}` + (vBonus ? `ï¼Œå…¨èƒ½+${vBonus}` : '') + `ï¼ŒæŒç»­${result.buff.duration}å›åˆ`);
            }
            if (result.buff.type === 'between_the_eyes') {
                addLog(`ä½ç½®${i + 1} ${p.char.name} è·å¾—ã€æ­£ä¸­çœ‰å¿ƒã€‘ï¼šæš´å‡»ç‡+${result.buff.critRateBonus || 0}%ï¼ŒæŒç»­${result.buff.duration}å›åˆ`);
            }
            if (result.buff.type === 'adrenaline_rush') {
                addLog(`ä½ç½®${i + 1} ${p.char.name} å¼€å¯ã€å†²åŠ¨ã€‘ï¼šæ€¥é€Ÿ+${result.buff.hasteBonus || 0}ï¼Œæ¯å›åˆ+${result.buff.comboPerTurn || 0}æ˜Ÿï¼ŒæŒç»­${result.buff.duration}å›åˆ`);
            }
            if (result.buff.type === 'crimson_vial') {
                addLog(`ä½ç½®${i + 1} ${p.char.name} ä½¿ç”¨ã€çŒ©çº¢ä¹‹ç“¶ã€‘ï¼šæ¯å›åˆå›å¤${Math.round((result.buff.healPctPerTurn || 0) * 100)}%æœ€å¤§ç”Ÿå‘½å€¼ï¼ŒæŒç»­${result.buff.duration}å›åˆ`);
            }
        }

        // ===== æŠ¤ç›¾æŠ€èƒ½å¤„ç† =====
        if (result.shield) {
            // ç¥åœ£éšœå£ï¼šå¯¹å…¨é˜Ÿæ–½åŠ æŠ¤ç›¾ï¼›å…¶ä»–æŠ¤ç›¾é»˜è®¤åªç»™è‡ªå·±
            combat.playerStates.forEach((ps, j) => {
                if (result.shield.type !== 'holy_barrier' && j !== i) return;
                if (ps.currentHp <= 0) return;

                ps.buffs = ps.buffs || [];

                // æ£€æŸ¥æ˜¯å¦å·²æœ‰åŒç±»å‹æŠ¤ç›¾
                const existingIdx = ps.buffs.findIndex(b => b.type === result.shield.type);
                if (existingIdx !== -1) {
                    const oldShield = ps.buffs[existingIdx];
                    ps.buffs[existingIdx] = {
                        ...result.shield,
                        amount: Math.max(oldShield.amount, result.shield.amount)
                    };
                    addLog(`ä½ç½®${j + 1} ${ps.char.name} åˆ·æ–°ã€${result.shield.name}ã€‘æŠ¤ç›¾ï¼Œå¸æ”¶é‡ï¼š${ps.buffs[existingIdx].amount}`);
                } else {
                    ps.buffs.push({ ...result.shield });
                    addLog(`ä½ç½®${j + 1} ${ps.char.name} è·å¾—ã€${result.shield.name}ã€‘æŠ¤ç›¾ï¼Œå¯å¸æ”¶ ${result.shield.amount} ç‚¹ä¼¤å®³`);
                }
            });
        }

        // å¤©èµ‹è§¦å‘
        if (skillId === 'basic_attack' && p.char.talents?.[10] === 'plain') {
            p.talentBuffs.attackFlat = (p.talentBuffs.attackFlat || 0) + 5;
            addLog(`ã€è´¨æœ´ã€‘è§¦å‘ï¼šæ”»å‡»+5`);
        }

        // ==================== ç‹‚å¾’ç›—è´¼30çº§å¤©èµ‹ ====================
        // æ‚è€æ‰“å‡»ï¼šæ™®é€šæ”»å‡»/å½±è¢­å å±‚å…¨èƒ½ï¼ˆæœ¬åœºæˆ˜æ–—ï¼‰
        procJugglingStrikes(skillId);

        // åˆ€é”‹å†²åˆºï¼šä¼å‡»åè·å¾—æš´å‡»ä¼¤å®³+50%ï¼ˆæŒç»­4å›åˆï¼‰
        if (skillId === 'ambush' && p.char?.classId === 'outlaw_rogue' && p.char?.talents?.[30] === 'blade_dash') {
            const duration = 4;
            const bonus = 0.5;
            p.buffs = Array.isArray(p.buffs) ? p.buffs : [];
            const idx = p.buffs.findIndex(b => b?.type === 'blade_dash');
            if (idx === -1) {
                p.buffs.push({
                    type: 'blade_dash',
                    name: 'åˆ€é”‹å†²åˆº',
                    duration,
                    critDamageBonus: bonus,
                    justApplied: true,
                });
            } else {
                p.buffs[idx] = {
                    ...p.buffs[idx],
                    duration,
                    critDamageBonus: bonus,
                    justApplied: true,
                };
            }
            addLog(`ã€åˆ€é”‹å†²åˆºã€‘è§¦å‘ï¼š${p.char.name} æš´å‡»ä¼¤å®³+50%ï¼ŒæŒç»­${duration}å›åˆ`);
        }

        if ((skillId === 'smite' || skillId === 'mind_blast') && p.char.talents?.[40] === 'fortune_misfortune') {
            p.fortuneMisfortuneStacks = (p.fortuneMisfortuneStacks || 0) + 1;
            addLog(`ã€ç¥¸ç¦ç›¸ä¾ã€‘${p.char.name} å±‚æ•°+1ï¼Œå½“å‰${p.fortuneMisfortuneStacks}å±‚`);
        }

        // å†°éœœæ³•å¸ˆå¤©èµ‹
        if (skillId === 'frostbolt' && result.triggerFrostboltTalents) {
            if (p.char.talents?.[10] === 'lingering_cold') {
                p.talentBuffs = p.talentBuffs || {};
                p.talentBuffs.spellPowerFlat = (p.talentBuffs.spellPowerFlat || 0) + 5;
                addLog(`ã€å»¶ç»µå¯’å†·ã€‘è§¦å‘ï¼š${p.char.name} æ³•æœ¯å¼ºåº¦+5`);
            }

            if (p.char.talents?.[20] === 'fingers_of_frost' && Math.random() < 0.5) {
                p.fingersOfFrost = (p.fingersOfFrost || 0) + 1;
                addLog(`ã€å¯’å†°æŒ‡ã€‘è§¦å‘ï¼š${p.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${p.fingersOfFrost}å±‚`);
            }

            if (p.char.talents?.[20] === 'cold_wisdom' || p.char.talents?.[30] === 'cold_intuition') {
                const triggerChance = p.char.talents?.[30] === 'cold_intuition' ? 0.4 : 0.25;
                if (Math.random() < triggerChance) {
                    const blizzardSkill = SKILLS['blizzard'];
                    const blizzardResult = blizzardSkill.calculate(charForCalc, combatContext);

                    if (targetType === 'boss') {
                        combat.bossDots = combat.bossDots || [];
                        combat.bossDots.push({ ...blizzardResult.dot, sourcePlayerId: p.char.id });
                        addLog(`ã€å†°å†·æ™ºæ…§ã€‘è§¦å‘ï¼š${p.char.name} é¢å¤–å¯¹ ${boss.name} æ–½æ”¾å†°é£æš´ï¼`);
                    } else if (targetIndex >= 0 && !combat.minions[targetIndex]?.immune) {
                        combat.minions[targetIndex].dots = combat.minions[targetIndex].dots || [];
                        combat.minions[targetIndex].dots.push({ ...blizzardResult.dot, sourcePlayerId: p.char.id });
                        addLog(`ã€å†°å†·æ™ºæ…§ã€‘è§¦å‘ï¼š${p.char.name} é¢å¤–å¯¹ ç«ç‚®æ‰‹${targetIndex + 1} æ–½æ”¾å†°é£æš´ï¼`);
                    }
                }
            }
        }

        if (skillId === 'ice_lance' && result.consumeFingersOfFrost) {
            p.fingersOfFrost = Math.max(0, (p.fingersOfFrost || 0) - 1);
            addLog(`ã€å¯’å†°æŒ‡ã€‘æ¶ˆè€—1å±‚ï¼Œ${p.char.name} å‰©ä½™${p.fingersOfFrost}å±‚`);
        }

        // ===== 50çº§å¤©èµ‹ï¼šå¹»æƒ³æ›² - ç¥åœ£æ–°æ˜Ÿæ–½æ”¾åæ¸…ç©ºå±‚æ•° =====
        if (result.clearFantasiaStacks) {
            const used = Number(result.fantasiaStacksUsed) || (p.fantasiaStacks || 0);
            p.fantasiaStacks = 0;
            addLog(`ã€å¹»æƒ³æ›²ã€‘${p.char.name} æ¶ˆè€—${used}å±‚ï¼Œå¼ºåŒ–æœ¬æ¬¡ç¥åœ£æ–°æ˜Ÿåæ¸…ç©ºå±‚æ•°`);
        }

        // ==================== ç›—è´¼ï¼šè¿å‡»ç‚¹ï¼ˆæ˜Ÿï¼‰ç»“ç®— ====================
        // è¯´æ˜ï¼šæŠ€èƒ½çš„ calculate å¯è¿”å›ï¼š
        // - generateComboPoints: number
        // - consumeComboPoints: 'all' | number
        p.comboPoints = Number.isFinite(p.comboPoints) ? p.comboPoints : 0;
        if (result.consumeComboPoints) {
            const spent = result.consumeComboPoints === 'all'
                ? p.comboPoints
                : Math.min(p.comboPoints, Math.max(0, Math.floor(Number(result.consumeComboPoints) || 0)));
            if (spent > 0) {
                p.comboPoints = Math.max(0, p.comboPoints - spent);
                addLog(`ã€è¿å‡»ç‚¹ã€‘${p.char.name} æ¶ˆè€— ${spent} æ˜Ÿï¼ˆå½“å‰${p.comboPoints}æ˜Ÿï¼‰`);

                // ç‹‚å¾’ç›—è´¼20çº§å¤©èµ‹ï¼šæ— æƒ… - æ¯æ¶ˆè€—1æ˜Ÿï¼Œ20%æ¦‚ç‡è¿”è¿˜1æ˜Ÿ
                if (p.char?.classId === 'outlaw_rogue' && p.char?.talents?.[20] === 'ruthless') {
                    let refunded = 0;
                    for (let k = 0; k < spent; k++) {
                        if (Math.random() < 0.2) refunded += 1;
                    }
                    if (refunded > 0) {
                        const maxCombo = getMaxComboPointsForChar(p.char);
                        const beforeRefund = p.comboPoints;
                        p.comboPoints = Math.min(maxCombo, p.comboPoints + refunded);
                        const realRefund = p.comboPoints - beforeRefund;
                        if (realRefund > 0) {
                            addLog(`ã€æ— æƒ…ã€‘${p.char.name} è¿”è¿˜ ${realRefund} æ˜Ÿï¼ˆå½“å‰${p.comboPoints}æ˜Ÿï¼‰`);
                        }
                    }
                }
            }
        }
        if (result.generateComboPoints) {
            const gain = Math.max(0, Math.floor(Number(result.generateComboPoints) || 0));
            if (gain > 0) {
                const maxCombo = getMaxComboPointsForChar(p.char);
                const before = p.comboPoints;
                p.comboPoints = Math.min(maxCombo, p.comboPoints + gain);
                const realGain = p.comboPoints - before;
                if (realGain > 0) {
                    addLog(`ã€è¿å‡»ç‚¹ã€‘${p.char.name} è·å¾— ${realGain} æ˜Ÿï¼ˆå½“å‰${p.comboPoints}æ˜Ÿï¼‰`);
                }
            }
        }

        // æœ¬è§’è‰²è¡ŒåŠ¨ç»“æŸï¼šç»“ç®—æŒç»­æ—¶é—´
        tickPlayerDurations(p, i);

        // æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰ï¼šè‹¥æœ¬å›åˆå‡»æ¯ã€æ±²èƒ½æ°´æ™¶ã€‘ï¼Œç«‹åˆ»è§¦å‘ç ´ç”²çª—å£ï¼ˆè®©åç»­è§’è‰²åŒå›åˆå—ç›Šï¼‰
        processOssirianCrystalDeaths();
    }

    // ç¾ç»Šæ•ˆæœ
    if (state.rebirthBonds?.includes('baoernai')) {
        const priests = combat.playerStates.filter(p => p.char.classId === 'discipline_priest' && p.currentHp > 0).length;
        const warriors = combat.playerStates.filter(p => p.char.classId === 'protection_warrior' && p.currentHp > 0).length;
        if (warriors === 1 && priests === 2) {
            const warrior = combat.playerStates.find(p => p.char.classId === 'protection_warrior' && p.currentHp > 0);
            if (warrior) {
                const blockValue = (warrior.char.stats.blockValue || 0) + (warrior.talentBuffs?.blockValueFlat || 0);
                const aoeDamage = Math.floor(blockValue * 0.8);
                if (aoeDamage > 0) {
                    const shieldInfo = getExecutusShieldInfo('physical');
                    if (shieldInfo.immune) {
                        addLog(`ã€åŒ…äºŒå¥¶ç¾ç»Šã€‘é¢å¤–ä¼¤å®³è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«`, 'warning');
                    } else {
                        if (!isRagnarosSubmergedThisRound) {
                            combat.bossHp -= aoeDamage;
                        }
                        combat.minions.forEach(m => {
                            if (m.hp > 0 && !m.immune) {
                                m.hp -= aoeDamage;
                            }
                        });
                        addLog(`ã€åŒ…äºŒå¥¶ç¾ç»Šã€‘é˜²æŠ¤æˆ˜å£«å¯¹æ‰€æœ‰æ•Œäººé€ æˆ ${aoeDamage} é¢å¤–ä¼¤å®³ï¼ˆåŸºäºæ ¼æŒ¡å€¼ï¼‰`);
                    }
                }
            }
        }
    }

    // ==================== æˆ’å¾‹ç‰§å¸ˆ30çº§å¤©èµ‹ï¼šæš—å½±é­” ====================
    // æ•ˆæœï¼šæ¯å›åˆé€ æˆ 0.3 å€æ³•æœ¯å¼ºåº¦çš„æš—å½±ä¼¤å®³
    // è¯´æ˜ï¼šä½œä¸ºè¢«åŠ¨å›åˆä¼¤å®³ï¼Œåœ¨ç©å®¶é˜¶æ®µç»“æŸåç»Ÿä¸€ç»“ç®—ä¸€æ¬¡ï¼ˆå³ä½¿è¢«ææƒ§ä¹Ÿä¼šç”Ÿæ•ˆï¼‰ã€‚
    if (Array.isArray(combat.playerStates) && combat.playerStates.length > 0) {
        combat.playerStates.forEach((p, pIdx) => {
            if (!p || p.currentHp <= 0) return;
            if (p.char?.classId !== 'discipline_priest') return;
            if (p.char?.talents?.[30] !== 'shadowfiend') return;

            // é€‰æ‹©ç›®æ ‡ï¼šé»˜è®¤æ‰“ Bossï¼›è‹¥ç­–ç•¥ä¸ä¼˜å…ˆBossï¼Œåˆ™æ‰“è¡€é‡æœ€ä½ä¸”æœªå…ç–«çš„å°å¼Ÿ
            let targetType = 'boss';
            let targetIndex = -1;

            const attackableMinions = (combat.minions || [])
                .map((m, idx) => ({ idx, hp: Number(m?.hp) || 0, immune: !!m?.immune }))
                .filter(x => x.hp > 0 && !x.immune);

            if (((isRagnarosSubmergedThisRound && attackableMinions.length > 0) || (!combat.strategy?.priorityBoss && attackableMinions.length > 0)) && (combat.bossHp ?? 0) > 0) {
                attackableMinions.sort((a, b) => a.hp - b.hp);
                targetType = 'minion';
                targetIndex = attackableMinions[0].idx;
            }

            // è®¡ç®—ä¼¤å®³ï¼šé»˜è®¤ 0.6 * æ³•å¼ºï¼›60çº§å¤©èµ‹ã€å‚¬å¿ƒé­”ã€‘= 1.2 * æ³•å¼ºï¼ˆç‚¹äº†30çº§æš—å½±é­”æ‰ä¼šè¿›åˆ°è¿™é‡Œï¼‰
            const sfCoeff = (p.char?.talents?.[60] === 'mindbender') ? 1.2 : 0.6;
            let dmg = ((p.char?.stats?.spellPower || 0) + (p.talentBuffs?.spellPowerFlat || 0)) * sfCoeff;

            // 10çº§å¤©èµ‹ï¼šæš—å½±å¢å¹…ï¼ˆæš—å½±ä¼¤å®³ +20%ï¼‰
            if (p.char?.talents?.[10] === 'shadow_amp') {
                dmg *= 1.2;
            }

            // æ€¥é€Ÿï¼šä½œä¸º DOT ç±»å›åˆä¼¤å®³ï¼ŒåŒæ ·äº«å—â€œæ€¥é€Ÿ*2%â€çš„ä¼¤å®³åŠ æˆ
            dmg *= (1 + (((p.char?.stats?.haste) || 0) * 0.02));

            // ï¼ˆç›®å‰ boss æˆ˜æœªå¹¿æ³›æ–½åŠ  spell_vulnï¼Œä½†è¿™é‡Œä»æ”¯æŒï¼‰
            const vuln = combat.bossDebuffs?.spell_vuln;
            if (vuln?.mult) {
                dmg *= vuln.mult;
            }

            const isCrit = Math.random() < ((p.char?.stats?.critRate || 0) / 100);
            if (isCrit) {
                dmg *= (p.char?.stats?.critDamage || 2);
            }

            dmg = Math.floor(dmg);

            if (targetType === 'boss') {
                if ((combat.bossHp ?? 0) <= 0) return;

                if (isRagnarosSubmergedThisRound) {
                    addLog(`ã€æš—å½±é­”ã€‘ä¼¤å®³è¢«ã€ä¸‹æ½œã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${boss.name}ï¼‰`, 'warning');
                    return;
                }

                const shieldInfo = getExecutusShieldInfo('shadow');
                if (shieldInfo.immune) {
                    addLog(`ã€æš—å½±é­”ã€‘ä¼¤å®³è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${boss.name}ï¼‰`, 'warning');
                    return;
                }

                const defRaw = Number(boss?.defense) || 0;
                const def = getEffectiveTargetDefense(p.char, defRaw);
                const actual = Math.max(1, dmg - def);
                combat.bossHp -= actual;
                addLog(`ã€æš—å½±é­”ã€‘ä½ç½®${pIdx + 1} ${p.char.name} å¯¹ ${boss.name} é€ æˆ ${actual} æš—å½±ä¼¤å®³${isCrit ? 'ã€æš´å‡»ã€‘' : ''}`);

                // æ•‘èµï¼ˆç”±è¯¥æˆ’å¾‹ç‰§å¸ˆçš„ä¼¤å®³è§¦å‘ï¼‰
                if (p.char?.stats?.atonement) {
                    triggerAtonementHeal(p, actual);
                }
            } else if (targetType === 'minion' && targetIndex >= 0 && combat.minions?.[targetIndex]) {
                const m = combat.minions[targetIndex];
                if ((m?.hp ?? 0) <= 0 || m?.immune) return;

                const shieldInfo = getExecutusShieldInfo('shadow');
                if (shieldInfo.immune) {
                    const minionName = boss?.minion?.name || boss?.cannoneer?.name || 'å°å¼Ÿ';
                    const targetLabel = m?.displayName || `${minionName}${targetIndex + 1}`;
                    addLog(`ã€æš—å½±é­”ã€‘ä¼¤å®³è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${targetLabel}ï¼‰`, 'warning');
                    return;
                }

                const defRaw = Number(m?.defense) || Number(boss?.minion?.defense) || Number(boss?.cannoneer?.defense) || 0;
                const def = getEffectiveTargetDefense(p.char, defRaw);
                const actual = Math.max(1, dmg - def);
                m.hp -= actual;

                const minionName = boss?.minion?.name || boss?.cannoneer?.name || 'å°å¼Ÿ';
                addLog(`ã€æš—å½±é­”ã€‘ä½ç½®${pIdx + 1} ${p.char.name} å¯¹ ${minionName}${targetIndex + 1} é€ æˆ ${actual} æš—å½±ä¼¤å®³${isCrit ? 'ã€æš´å‡»ã€‘' : ''}`);

                if (p.char?.stats?.atonement) {
                    triggerAtonementHeal(p, actual);
                }
            }
        });
    }

    // DOT ç»“ç®—
    if (combat.bossDots) {
        combat.bossDots = combat.bossDots.filter(dot => {
            const dotName = dot.name || 'é‡ä¼¤';

            // ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯ï¼šä¸‹æ½œ - Bosså…ç–«æ‰€æœ‰ä¼¤å®³ï¼ˆDOTä¸é€ æˆä¼¤å®³ï¼Œä½†ä»æ¶ˆè€—æŒç»­æ—¶é—´ï¼‰
            if (isRagnarosSubmergedThisRound) {
                addLog(`ã€${dotName}ã€‘è¢«ã€ä¸‹æ½œã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${boss.name}ï¼Œå‰©ä½™${dot.duration - 1}å›åˆï¼‰`, 'warning');
                dot.duration -= 1;
                return dot.duration > 0;
            }

            // ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ï¼šæŠ¤ç›¾å…ç–«ä¼šä½¿ DOT ä¸é€ æˆä¼¤å®³ï¼ˆä½†ä»æ¶ˆè€—æŒç»­æ—¶é—´ï¼‰
            const shieldInfo = getExecutusShieldInfo(dot.school);
            if (shieldInfo.immune) {
                addLog(`ã€${dotName}ã€‘è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${boss.name}ï¼Œå‰©ä½™${dot.duration - 1}å›åˆï¼‰`, 'warning');
                dot.duration -= 1;
                return dot.duration > 0;
            }

            const dmg = Math.max(1, Math.floor(dot.damagePerTurn));
            combat.bossHp -= dmg;

            addLog(`ã€${dotName}ã€‘å¯¹ ${boss.name} é€ æˆ ${dmg} DOT ä¼¤å®³ï¼ˆå‰©ä½™${dot.duration - 1}å›åˆï¼‰`);

            if (dot.sourcePlayerId) {
                const sourcePlayer = combat.playerStates.find(p => p.char.id === dot.sourcePlayerId);
                if (sourcePlayer && sourcePlayer.char.talents?.[30] === 'brutal_momentum' && sourcePlayer.currentHp > 0) {
                    const healAmount = Math.floor(dmg * 1.5);
                    const maxHp = sourcePlayer.char.stats.maxHp || 0;
                    const actualHeal = Math.min(healAmount, maxHp - sourcePlayer.currentHp);
                    if (actualHeal > 0) {
                        sourcePlayer.currentHp += actualHeal;
                        addLog(`ã€æ®‹æš´åŠ¨åŠ›ã€‘è§¦å‘ï¼š${sourcePlayer.char.name} æ²»ç–— ${actualHeal} ç‚¹ç”Ÿå‘½`);
                    }
                }

                if (dot.canGenerateFinger && sourcePlayer && sourcePlayer.char.talents?.[30] === 'orb_mastery') {
                    if (Math.random() < 0.25) {
                        sourcePlayer.fingersOfFrost = (sourcePlayer.fingersOfFrost || 0) + 1;
                        addLog(`ã€å®ç ç²¾é€šã€‘è§¦å‘ï¼š${sourcePlayer.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${sourcePlayer.fingersOfFrost}å±‚`);
                    }
                }

                if (sourcePlayer.char.stats.atonement) {
                    triggerAtonementHeal(sourcePlayer, dmg);
                }
            }

            dot.duration -= 1;
            return dot.duration > 0;
        });
    }

    // å°å¼ŸDOTç»“ç®—
    combat.minions = combat.minions.map((m, idx) => {
        if (m.hp <= 0) return m;
        if (m.dots && m.dots.length > 0) {
            m.dots = m.dots.filter(dot => {
                // å…ç–«çŠ¶æ€ä¸‹DOTä¸é€ æˆä¼¤å®³
                if (m.immune) {
                    dot.duration -= 1;
                    return dot.duration > 0;
                }

                const dotName = dot.name || 'é‡ä¼¤';
                const minionName = boss.minion?.name || boss.cannoneer?.name || 'å°å¼Ÿ';
                const targetLabel = m.displayName || `${minionName}${idx + 1}`;

                // ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ï¼šæŠ¤ç›¾å…ç–«ä¼šä½¿ DOT ä¸é€ æˆä¼¤å®³ï¼ˆä½†ä»æ¶ˆè€—æŒç»­æ—¶é—´ï¼‰
                const shieldInfo = getExecutusShieldInfo(dot.school);
                if (shieldInfo.immune) {
                    addLog(`ã€${dotName}ã€‘è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${targetLabel}ï¼Œå‰©ä½™${dot.duration - 1}å›åˆï¼‰`, 'warning');
                    dot.duration -= 1;
                    return dot.duration > 0;
                }

                const dmg = Math.max(1, Math.floor(dot.damagePerTurn));
                m.hp -= dmg;

                addLog(`ã€${dotName}ã€‘å¯¹ ${targetLabel} é€ æˆ ${dmg} DOT ä¼¤å®³ï¼ˆå‰©ä½™${dot.duration - 1}å›åˆï¼‰`);

                if (dot.sourcePlayerId) {
                    const sourcePlayer = combat.playerStates.find(p => p.char.id === dot.sourcePlayerId);
                    if (sourcePlayer && sourcePlayer.char.talents?.[30] === 'brutal_momentum' && sourcePlayer.currentHp > 0) {
                        const healAmount = Math.floor(dmg * 1.5);
                        const maxHp = sourcePlayer.char.stats.maxHp || 0;
                        const actualHeal = Math.min(healAmount, maxHp - sourcePlayer.currentHp);
                        if (actualHeal > 0) {
                            sourcePlayer.currentHp += actualHeal;
                            addLog(`ã€æ®‹æš´åŠ¨åŠ›ã€‘è§¦å‘ï¼š${sourcePlayer.char.name} æ²»ç–— ${actualHeal} ç‚¹ç”Ÿå‘½`);
                        }
                    }

                    if (dot.canGenerateFinger && sourcePlayer && sourcePlayer.char.talents?.[30] === 'orb_mastery') {
                        if (Math.random() < 0.25) {
                            sourcePlayer.fingersOfFrost = (sourcePlayer.fingersOfFrost || 0) + 1;
                            addLog(`ã€å®ç ç²¾é€šã€‘è§¦å‘ï¼š${sourcePlayer.char.name} è·å¾—1å±‚å¯’å†°æŒ‡ï¼Œå½“å‰${sourcePlayer.fingersOfFrost}å±‚`);
                        }
                    }
                }

                dot.duration -= 1;
                return dot.duration > 0;
            });
        }
        return m;
    });

    // ==================== Bossé˜¶æ®µ ====================
    const pickAlivePlayerIndex = () => {
        for (let idx = 0; idx < combat.playerStates.length; idx++) {
            const p = combat.playerStates[idx];
            if ((p.currentHp ?? 0) > 0) return idx;
        }
        return -1;
    };

    const getBuffBlockRate = (playerState) => {
        const buffs = Array.isArray(playerState?.buffs) ? playerState.buffs : [];
        return buffs.reduce((sum, b) => sum + (b?.blockRate || 0), 0);
    };

    const calcMitigatedAndBlockedDamage = (playerState, rawDamage, isHeavy = false) => {
        const armor = playerState?.char?.stats?.armor || 0;
        const dr = getArmorDamageReduction(armor);
        let dmg = applyPhysicalMitigation(rawDamage, armor);

        // ===== 50çº§å¤©èµ‹ï¼šæ ¼æŒ¡çªç ´ =====
        let baseBlockRate = playerState?.char?.stats?.blockRate || 0;
        const buffBlockRate = getBuffBlockRate(playerState);
        let totalBlockRate = baseBlockRate + buffBlockRate;
        let blockBreakthroughBonusValue = 0;

        if (playerState?.char?.talents?.[50] === 'block_breakthrough' && totalBlockRate > 95) {
            const excessBlockRate = totalBlockRate - 95;
            blockBreakthroughBonusValue = Math.floor(
                (playerState?.char?.stats?.blockValue || 0) * (excessBlockRate / 100)
            );
            totalBlockRate = 95;
        }

        const blockChance = Math.max(0, Math.min(0.95, totalBlockRate / 100));

        let blockedAmount = 0;
        if (Math.random() < blockChance) {
            const blockValue = Math.floor(
                (playerState?.char?.stats?.blockValue || 0) +
                (playerState?.talentBuffs?.blockValueFlat || 0) +
                blockBreakthroughBonusValue
            );
            blockedAmount = Math.min(Math.max(0, dmg - 1), Math.max(0, blockValue));
            dmg = Math.max(1, dmg - blockedAmount);
        }

        // ===== ON_BLOCK å¤©èµ‹è§¦å‘ï¼ˆBOSSæˆ˜ï¼‰ =====
        if (blockedAmount > 0) {
            // 10çº§å¤©èµ‹ï¼šæ ¼æŒ¡å¤§å¸ˆ - æœ¬åœºæˆ˜æ–—æ ¼æŒ¡å€¼ +10
            if (playerState?.char?.talents?.[10] === 'block_master') {
                playerState.talentBuffs = playerState.talentBuffs || {};
                playerState.talentBuffs.blockValueFlat = (playerState.talentBuffs.blockValueFlat || 0) + 10;
                addLog(`ã€æ ¼æŒ¡å¤§å¸ˆã€‘è§¦å‘ï¼š${playerState.char.name} æ ¼æŒ¡å€¼ +10ï¼ˆæœ¬åœºæˆ˜æ–—ï¼‰`);
            }

            // 60çº§å¤©èµ‹ï¼šç›¾åˆºåå‡» - åå‡»BOSS
            if (playerState?.char?.talents?.[60] === 'shield_spikes') {
                const spikeDmg = Math.floor(blockedAmount);
                if (spikeDmg > 0 && (combat.bossHp ?? 0) > 0) {
                    const shieldInfo = getExecutusShieldInfo('physical');
                    if (shieldInfo.immune) {
                        addLog(`ã€ç›¾åˆºåå‡»ã€‘è¢«ã€${shieldInfo.shieldName}ã€‘å…ç–«ï¼ˆç›®æ ‡ï¼š${boss.name}ï¼‰`, 'warning');
                    } else {
                        combat.bossHp -= spikeDmg;
                        addLog(`ã€ç›¾åˆºåå‡»ã€‘è§¦å‘ï¼š${playerState.char.name} åå‡» ${boss.name} é€ æˆ ${spikeDmg} ç‚¹çœŸå®ä¼¤å®³`);
                    }
                }
            }
        }

        const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
        let buffTakenMult = 1;
        if (playerState.buffs) {
            playerState.buffs.forEach(b => {
                if (b.damageTakenMult) {
                    buffTakenMult *= b.damageTakenMult;
                }
            });
            playerState.buffs = playerState.buffs.filter(b => (b.duration ?? 999) > 0);
        }

        const finalTakenMult = takenMult * buffTakenMult * getAtonementDamageTakenMult(playerState);
        const demoralizingShoutMult = combat.bossDebuffs?.demoralizingShout?.damageMult ?? 1;
        const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
        dmg = Math.max(1, Math.floor(dmg * finalTakenMult * demoralizingShoutMult * versTakenMult));

        return { damage: dmg, dr, blockedAmount, isHeavy };
    };

    // Boss è¡ŒåŠ¨
    const bossAction = boss.cycle[(combat.round - 1) % boss.cycle.length];


    // ==================== å“ˆå¡ï¼šå“ˆå¡ä¹‹å­æ­»äº¡è§¦å‘ã€æ¯’æ€§ä¹‹è¡€ã€‘ ====================
    // æ”¾åœ¨Bossè¡ŒåŠ¨å‰ç»“ç®—ï¼Œç¡®ä¿æœ¬å›åˆã€è¡€æ¶²è™¹å¸ã€‘èƒ½æ­£ç¡®è¯»å–â€œæ˜¯å¦ä¸­æ¯’æ€§ä¹‹è¡€â€
    if (combat.bossId === 'hakkar') {
        const deadSons = (combat.minions || []).filter(m => (m?.hp ?? 0) <= 0 && m.isHakkarSon && !m.deathProcessed);
        if (deadSons.length > 0) {
            // æ ‡è®°å·²å¤„ç†ï¼Œé¿å…é‡å¤è§¦å‘
            deadSons.forEach(m => { m.deathProcessed = true; });

            const deadCount = deadSons.length;
            addLog(`ã€${boss.name}ã€‘çš„ã€å“ˆå¡ä¹‹å­ã€‘æ­»äº¡ï¼ˆ${deadCount}ä¸ªï¼‰ï¼Œæ‰€æœ‰è§’è‰²è·å¾—ã€æ¯’æ€§ä¹‹è¡€ã€‘ï¼ˆä¸å¯å å±‚ï¼Œåªåˆ·æ–°ï¼‰ï¼`);

            combat.playerStates.forEach((ps, pIdx) => {
                if (!ps || ps.currentHp <= 0) return;

                // âœ… çŸ®äººï¼šçŸ³åƒå½¢æ€ - é¦–æ¬¡ä¸­æ¯’å…ç–«ï¼ˆè¿™é‡Œå¿…é¡»æå‰åˆ¤å®šï¼Œå¦åˆ™ä¼šå½±å“ã€è¡€æ¶²è™¹å¸ã€‘è®¡æ•°ï¼‰
                if (tryFirstDebuffImmunity(ps, 'poison', pIdx, 'æ¯’æ€§ä¹‹è¡€')) {
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å…ç–«äº†ã€æ¯’æ€§ä¹‹è¡€ã€‘`, 'debuff');
                    return;
                }

                ps.dots = ps.dots || [];
                const coeff = boss.toxicBloodDotAtkCoeff ?? 0.4;
                const duration = boss.toxicBloodDuration ?? 3;

                // æŒ‰â€œBOSSæ”»å‡»â€ç»“ç®—
                const basePerTurn = Math.floor((boss.attack || 0) * coeff);

                const existing = ps.dots.find(d => d && d.name === 'æ¯’æ€§ä¹‹è¡€');
                if (existing) {
                    // ä¸å¯å å±‚ï¼šåªåˆ·æ–°æŒç»­æ—¶é—´ä¸æ¯å›åˆä¼¤å®³
                    existing.stacks = 1;
                    existing.duration = duration; // åˆ·æ–°æŒç»­æ—¶é—´
                    existing.type = 'poison';
                    existing.isPoison = true;
                    existing.school = 'nature';

                    const perTurn = Math.max(1, Math.floor(basePerTurn));
                    existing.damagePerTurn = perTurn;

                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} çš„ã€æ¯’æ€§ä¹‹è¡€ã€‘åˆ·æ–°ï¼ˆæ¯å›åˆ${perTurn}è‡ªç„¶ä¼¤å®³ï¼ŒæŒç»­${duration}å›åˆï¼Œä¸å¯å å±‚ï¼‰`, 'debuff');
                } else {
                    const perTurn = Math.max(1, Math.floor(basePerTurn));
                    ps.dots.push({
                        name: 'æ¯’æ€§ä¹‹è¡€',
                        type: 'poison',
                        isPoison: true,
                        school: 'nature',
                        stacks: 1,
                        damagePerTurn: perTurn,
                        duration: duration
                    });
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} è·å¾—ã€æ¯’æ€§ä¹‹è¡€ã€‘ï¼ˆæ¯å›åˆ${perTurn}è‡ªç„¶ä¼¤å®³ï¼ŒæŒç»­${duration}å›åˆï¼Œä¸å¯å å±‚ï¼‰`, 'debuff');
                }
            });
        }
    }

    // ==================== èŒƒå…‹é‡Œå¤«ç‰¹æ®ŠæŠ€èƒ½å¤„ç† ====================
    if (combat.bossId === 'vancleef') {
        // è‡´æ­»æ‰“å‡»
        if (bossAction === 'mortal_strike') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.mortalStrikeMultiplier || 3));
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);

                // åœ¨è‡´æ­»æ‰“å‡»æ‰£è¡€å‰æ·»åŠ æŠ¤ç›¾å¤„ç†
                const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';

                // æ–½åŠ å‡ç–—debuff
                target.debuffs = target.debuffs || {};
                target.debuffs.mortalStrike = {
                    healingReduction: boss.mortalStrikeDebuff.healingReduction,
                    duration: boss.mortalStrikeDebuff.duration
                };

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€è‡´æ­»æ‰“å‡»ã€‘å¯¹ ä½ç½®${tIdx + 1} é€ æˆ ${shieldResult.finalDamage} ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                addLog(`â†’ ä½ç½®${tIdx + 1} å—åˆ°ã€è‡´æ­»æ‰“å‡»ã€‘ï¼šå—åˆ°æ²»ç–—æ•ˆæœé™ä½50%ï¼ŒæŒç»­2å›åˆ`);
            }
        }
        // ç«ç‚®æ‰‹å‡†å¤‡
        else if (bossAction === 'summon_cannoneers') {
            const aliveMinions = (combat.minions || []).filter(m => (m.hp ?? 0) > 0);
            const need = Math.max(0, (boss.summonCount || 3) - aliveMinions.length);

            for (let i = 0; i < need; i++) {
                combat.minions.push({
                    hp: boss.minion.maxHp,
                    maxHp: boss.minion.maxHp,
                    attack: boss.minion.attack,
                    defense: boss.minion.defense,
                    isCannoneer: true,
                    immune: false,
                    dots: []
                });
            }

            if (need > 0) {
                addLog(`ã€${boss.name}ã€‘å¤§å–Šï¼š"ç«ç‚®æ‰‹å‡†å¤‡ï¼" å¬å”¤äº† ${need} ä¸ª${boss.minion.name}`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å¬å”¤ç«ç‚®æ‰‹ï¼Œä½†åœºä¸Šç«ç‚®æ‰‹å·²æ»¡`);
            }
        }
        // ç™»ä¸Šç”²æ¿
        else if (bossAction === 'board_the_deck') {
            const aliveMinions = combat.minions.filter(m => m.hp > 0 && m.isCannoneer);
            if (aliveMinions.length > 0) {
                combat.minions.forEach(m => {
                    if (m.hp > 0 && m.isCannoneer) {
                        m.immune = true;
                    }
                });
                addLog(`ã€${boss.name}ã€‘å¤§å–Šï¼š"ç™»ä¸Šç”²æ¿ï¼" æ‰€æœ‰ç«ç‚®æ‰‹è·å¾—å…ç–«ä¼¤å®³æ•ˆæœï¼`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å‘½ä»¤ç«ç‚®æ‰‹ç™»ä¸Šç”²æ¿ï¼Œä½†åœºä¸Šæ²¡æœ‰ç«ç‚®æ‰‹`);
            }
        }
    }
    // ==================== æ™®ç‘æ–¯æ‰˜å¥³å£«æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'prestor_lady') {
        // è°æŠ¥ï¼šå¯¹å½“å‰ç›®æ ‡å’Œå‘¨å›´é˜Ÿå‹é€ æˆæ€»å…±bossæ”»å‡»åŠ›Ã—10çš„æš—å½±ä¼¤å®³
        // é›†ä¸­ç«™ä½ï¼šä¼¤å®³ç”±æ‰€æœ‰å­˜æ´»è§’è‰²åˆ†æ‹…
        // åˆ†æ•£ç«™ä½ï¼šåªæ‰“1å·ä½å¦å…‹
        if (bossAction === 'espionage') {
            const totalDamage = Math.floor((boss.attack || 0) * (boss.espionageDamageMultiplier || 10));
            const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);

            if (alivePlayers.length === 0) {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è°æŠ¥ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            } else if (combat.strategy.stance === 'dispersed') {
                // åˆ†æ•£ç«™ä½ï¼šåªæ‰“1å·ä½
                const tIdx = pickAlivePlayerIndex();
                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    // æš—å½±ä¼¤å®³ï¼Œä½¿ç”¨é­”æ³•æŠ—æ€§å‡å…
                    const magicResist = target.char?.stats?.magicResist || 0;
                    const resistReduction = getMagicResistDamageReduction(magicResist); // ç»Ÿä¸€çš„é­”æŠ—å…¬å¼ï¼ˆè§ magicresist_kï¼‰
                    let damage = Math.floor(totalDamage * (1 - resistReduction));

                    // åº”ç”¨å—ä¼¤å‡å…
                    const takenMult = target.char?.stats?.damageTakenMult ?? 1;
                    let buffTakenMult = 1;
                    if (target.buffs) {
                        target.buffs.forEach(b => {
                            if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                        });
                    }
                    const versTakenMult = getVersatilityDamageTakenMult(target.char?.stats?.versatility);
                    const atonementTakenMult = getAtonementDamageTakenMult(target);

                    damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * versTakenMult));

                    // è°æŠ¥ä¹Ÿè¦ç»è¿‡æŠ¤ç›¾
                    const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è°æŠ¥ã€‘ï¼ˆåˆ†æ•£ç«™ä½ï¼‰å¯¹ ä½ç½®${tIdx + 1} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³${shieldText}`);
                }
            } else {
                // é›†ä¸­ç«™ä½ï¼šä¼¤å®³åˆ†æ‘Šç»™æ‰€æœ‰å­˜æ´»è§’è‰²
                const damagePerPlayer = Math.floor(totalDamage / alivePlayers.length);

                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è°æŠ¥ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰ï¼Œ${alivePlayers.length}åè§’è‰²åˆ†æ‘Šä¼¤å®³`);

                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;

                    const magicResist = ps.char?.stats?.magicResist || 0;
                    const resistReduction = getMagicResistDamageReduction(magicResist);
                    let damage = Math.floor(damagePerPlayer * (1 - resistReduction));

                    const takenMult = ps.char?.stats?.damageTakenMult ?? 1;
                    let buffTakenMult = 1;
                    if (ps.buffs) {
                        ps.buffs.forEach(b => {
                            if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                        });
                    }
                    const versTakenMult = getVersatilityDamageTakenMult(ps.char?.stats?.versatility);
                    const atonementTakenMult = getAtonementDamageTakenMult(ps);

                    damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * versTakenMult));

                    // è°æŠ¥ä¹Ÿè¦ç»è¿‡æŠ¤ç›¾
                    const shieldResult = applyShieldAbsorb(ps, damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è°æŠ¥ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰å¯¹ ä½ç½®${pIdx + 1} ${ps.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³${shieldText}`);
                });
            }
        }
        // é»‘é¾™ä¹‹ç‚ï¼šå¯¹æ‰€æœ‰è§’è‰²æ–½åŠ 1å±‚é»‘é¾™ä¹‹ç‚DOT
        else if (bossAction === 'black_dragon_flame') {
            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é»‘é¾™ä¹‹ç‚ã€‘ï¼Œæ‰€æœ‰è§’è‰²è·å¾—1å±‚é»‘é¾™ä¹‹ç‚ï¼`);

            combat.playerStates.forEach((ps, pIdx) => {
                if (ps.currentHp <= 0) return;

                // åˆå§‹åŒ–ç©å®¶DOTæ•°ç»„
                ps.dots = ps.dots || [];

                // æ£€æŸ¥æ˜¯å¦å·²æœ‰é»‘é¾™ä¹‹ç‚DOTï¼Œå¦‚æœæœ‰åˆ™å åŠ å±‚æ•°
                const existingFlame = ps.dots.find(d => d.name === 'é»‘é¾™ä¹‹ç‚');
                if (existingFlame) {
                    existingFlame.stacks = (existingFlame.stacks || 1) + 1;
                    existingFlame.damagePerTurn = Math.floor(
                        (boss.attack || 0) * (boss.blackFlameDoTMultiplier || 0.2) * existingFlame.stacks
                    );
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} çš„é»‘é¾™ä¹‹ç‚å åŠ è‡³ ${existingFlame.stacks} å±‚`);
                } else {
                    ps.dots.push({
                        name: 'é»‘é¾™ä¹‹ç‚',
                        type: 'dot',
                        school: 'shadow',
                        stacks: 1,
                        damagePerTurn: Math.floor((boss.attack || 0) * (boss.blackFlameDoTMultiplier || 0.2)),
                        duration: 999, // æŒç»­æ•´åœºæˆ˜æ–—
                        isPermanent: true
                    });
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} è·å¾—é»‘é¾™ä¹‹ç‚ï¼ˆ1å±‚ï¼‰`);
                }
            });
        }
        // å°–ç‰™ä¸åˆ©çˆªï¼šå¯¹1å·ä½é€ æˆ3å€æ”»å‡»ä¼¤å®³ + æµè¡€DOT
        else if (bossAction === 'fangs_and_claws') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.fangsMultiplier || 3));
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);

                target.currentHp -= damage;

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€å°–ç‰™ä¸åˆ©çˆªã€‘å¯¹ ä½ç½®${tIdx + 1} é€ æˆ ${damage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}ï¼‰`);

                // æ–½åŠ æµè¡€DOT
                target.dots = target.dots || [];
                const bleedDamage = Math.floor((boss.attack || 0) * (boss.bleedDoTMultiplier || 0.8));

                // æ£€æŸ¥æ˜¯å¦å·²æœ‰æµè¡€DOTï¼Œå¦‚æœæœ‰åˆ™åˆ·æ–°æŒç»­æ—¶é—´
                const existingBleed = target.dots.find(d => d.name === 'æ’•è£‚ä¼¤å£');
                if (existingBleed) {
                    existingBleed.duration = boss.bleedDuration || 3;
                    addLog(`â†’ ä½ç½®${tIdx + 1} çš„ã€æ’•è£‚ä¼¤å£ã€‘æŒç»­æ—¶é—´åˆ·æ–°`);
                } else {
                    target.dots.push({
                        name: 'æ’•è£‚ä¼¤å£',
                        type: 'dot',
                        school: 'physical',
                        damagePerTurn: bleedDamage,
                        duration: boss.bleedDuration || 3
                    });
                    addLog(`â†’ ä½ç½®${tIdx + 1} è·å¾—ã€æ’•è£‚ä¼¤å£ã€‘ï¼šæ¯å›åˆ ${bleedDamage} ç‚¹æµè¡€ä¼¤å®³ï¼ŒæŒç»­ ${boss.bleedDuration || 3} å›åˆ`);
                }
            }
        }
        // æ™®é€šæ”»å‡»
        else if (bossAction === 'normal_attack') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor(boss.attack || 0);
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, false);

                target.currentHp -= damage;

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                addLog(`ã€${boss.name}ã€‘æ™®é€šæ”»å‡» ä½ç½®${tIdx + 1} é€ æˆ ${damage} ç‚¹ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}ï¼‰`);
            }
        }
    }
    // ==================== éœæ ¼æŠ€èƒ½å¤„ç†ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰ ====================
    else if (combat.bossId === 'hogger') {
        if (bossAction === 'summon') {
            const aliveMinions = (combat.minions || []).filter(m => (m.hp ?? 0) > 0);
            const need = Math.max(0, (boss.summonCount || 0) - aliveMinions.length);

            for (let i = 0; i < need; i++) {
                combat.minions.push({
                    hp: boss.minion.maxHp,
                    maxHp: boss.minion.maxHp,
                    attack: boss.minion.attack,
                    defense: boss.minion.defense,
                });
            }

            if (need > 0) {
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€å¬å”¤ã€‘å‘¼å«äº† ${need} ä¸ª${boss.minion.name}`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å¬å”¤ï¼Œä½†åœºä¸Šå°å¼Ÿå·²æ»¡`);
            }
        }

        if (bossAction === 'strike') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.heavyMultiplier || 1));
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);

                target.currentHp -= damage;

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€é‡å‡»ã€‘å¯¹ ä½ç½®${tIdx + 1} é€ æˆ ${damage} ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}ï¼‰`);
            }
        }
    }// ==================== è£‚é­‚è€…è¨å°”è¯ºæ–¯æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'thalnos') {
        // çµé­‚å¼ºé£ï¼šå¯¹éšæœºç›®æ ‡ï¼ˆåˆ†æ•£ï¼‰æˆ–æ‰€æœ‰ç›®æ ‡ï¼ˆé›†ä¸­ï¼‰é€ æˆä¼¤å®³+DOT
        if (bossAction === 'soul_storm') {
            const baseDamage = Math.floor((boss.attack || 0) * (boss.soulStormMultiplier || 1.5));
            const dotDamage = Math.floor((boss.attack || 0) * (boss.soulStormDoTMultiplier || 1.5));
            const dotDuration = boss.soulStormDoTDuration || 3;

            if (combat.strategy.stance === 'dispersed') {
                // åˆ†æ•£ç«™ä½ï¼šåªæ‰“éšæœºä¸€ä¸ªç›®æ ‡
                const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
                if (alivePlayers.length > 0) {
                    const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                    const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);

                    if (tIdx >= 0) {
                        const target = combat.playerStates[tIdx];
                        const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, baseDamage, false);

                        // æŠ¤ç›¾å¸æ”¶
                        const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                        target.currentHp -= shieldResult.finalDamage;

                        const drPct = Math.round(dr * 100);
                        const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                        const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                        addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çµé­‚å¼ºé£ã€‘ï¼ˆåˆ†æ•£ç«™ä½ï¼‰å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);

                        // æ–½åŠ DOT
                        target.dots = target.dots || [];
                        target.dots.push({
                            name: 'çµé­‚å¼ºé£',
                            type: 'dot',
                            school: 'shadow',
                            damagePerTurn: dotDamage,
                            duration: dotDuration
                        });
                        addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} è·å¾—ã€çµé­‚å¼ºé£ã€‘ï¼šæ¯å›åˆ ${dotDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ŒæŒç»­ ${dotDuration} å›åˆ`);
                    }
                }
            } else {
                // é›†ä¸­ç«™ä½ï¼šå¯¹æ‰€æœ‰å­˜æ´»è§’è‰²é€ æˆä¼¤å®³+DOT
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çµé­‚å¼ºé£ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰ï¼Œæ‰€æœ‰è§’è‰²å—åˆ°ä¼¤å®³ï¼`);

                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;

                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(ps, baseDamage, false);

                    // æŠ¤ç›¾å¸æ”¶
                    const shieldResult = applyShieldAbsorb(ps, damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);

                    // æ–½åŠ DOT
                    ps.dots = ps.dots || [];
                    ps.dots.push({
                        name: 'çµé­‚å¼ºé£',
                        type: 'dot',
                        school: 'shadow',
                        damagePerTurn: dotDamage,
                        duration: dotDuration
                    });
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} è·å¾—ã€çµé­‚å¼ºé£ã€‘DOT`);
                });
            }
        }
        // å •è½çš„åå­—å†›ï¼šå¬å”¤5ä¸ªåå­—å†›
        else if (bossAction === 'fallen_crusaders') {
            const aliveMinions = (combat.minions || []).filter(m => (m.hp ?? 0) > 0);
            const need = Math.max(0, (boss.summonCount || 5) - aliveMinions.length);

            for (let i = 0; i < need; i++) {
                combat.minions.push({
                    hp: boss.minion.maxHp,
                    maxHp: boss.minion.maxHp,
                    attack: boss.attack, // æ”»å‡»ç­‰äºbossæ”»å‡»
                    defense: boss.minion.defense,
                    isCrusader: true,
                    dots: []
                });
            }

            if (need > 0) {
                addLog(`ã€${boss.name}ã€‘å¬å”¤äº† ${need} ä¸ª${boss.minion.name}ï¼`);
                addLog(`â†’ åå­—å†›å±æ€§ï¼šHP ${boss.minion.maxHp}ï¼Œæ”»å‡» ${boss.attack}`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å¬å”¤åå­—å†›ï¼Œä½†åœºä¸Šåå­—å†›å·²æ»¡`);
            }
        }
        // æ”¾é€çµé­‚ï¼šå¯¹éšæœºç›®æ ‡é€ æˆé«˜é¢ä¼¤å®³+ææƒ§
        else if (bossAction === 'banish_soul') {
            const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
            if (alivePlayers.length > 0) {
                // éšæœºé€‰æ‹©ä¸€ä¸ªç›®æ ‡
                const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);

                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    const raw = Math.floor((boss.attack || 0) * (boss.banishSoulMultiplier || 4));
                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);

                    // æŠ¤ç›¾å¸æ”¶
                    const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æ”¾é€çµé­‚ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);

                    // æ–½åŠ ææƒ§debuffï¼ˆäº¡çµï¼šé¦–æ¬¡ææƒ§å…ç–«ï¼‰
                    if (!tryFirstFearImmunity(target, tIdx, 'æ”¾é€çµé­‚')) {
                        target.debuffs = target.debuffs || {};
                        target.debuffs.fear = {
                            duration: boss.fearDuration || 3
                        };
                        addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} é™·å…¥ã€ææƒ§ã€‘ï¼æ— æ³•è¡ŒåŠ¨ ${boss.fearDuration || 3} å›åˆ`);
                    }
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æ”¾é€çµé­‚ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }
        // çµé­‚æ”¶å‰²è€…ï¼šå¯¹æ‰€æœ‰ç›®æ ‡é€ æˆ(åå­—å†›æ•°é‡*2+3)Ã—æ”»å‡»çš„æš—å½±ä¼¤å®³
        else if (bossAction === 'soul_reaper') {
            const aliveCrusaders = (combat.minions || []).filter(m => m.hp > 0 && m.isCrusader).length;
            const multiplier = aliveCrusaders + (boss.soulReaperBaseMultiplier || 3);
            const totalDamage = Math.floor((boss.attack || 0) * multiplier);

            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çµé­‚æ”¶å‰²è€…ã€‘ï¼å½“å‰åå­—å†›æ•°é‡ï¼š${aliveCrusaders}ï¼Œä¼¤å®³å€ç‡ï¼š${multiplier}å€`);

            combat.playerStates.forEach((ps, pIdx) => {
                if (ps.currentHp <= 0) return;

                // æš—å½±ä¼¤å®³ï¼Œä½¿ç”¨é­”æ³•æŠ—æ€§å‡å…
                const magicResist = ps.char?.stats?.magicResist || 0;
                const resistReduction = getMagicResistDamageReduction(magicResist);
                let damage = Math.floor(totalDamage * (1 - resistReduction));

                // åº”ç”¨å—ä¼¤å‡å…
                const takenMult = ps.char?.stats?.damageTakenMult ?? 1;
                let buffTakenMult = 1;
                if (ps.buffs) {
                    ps.buffs.forEach(b => {
                        if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                    });
                }
                const versTakenMult = getVersatilityDamageTakenMult(ps.char?.stats?.versatility);
                const atonementTakenMult = getAtonementDamageTakenMult(ps);

                damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * versTakenMult));

                // æŠ¤ç›¾å¸æ”¶
                const shieldResult = applyShieldAbsorb(ps, damage, logs, currentRound);
                ps.currentHp -= shieldResult.finalDamage;

                const resistPct = Math.round(resistReduction * 100);
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resistPct}%${shieldText}ï¼‰`);
            });
        }
    }

    // ==================== è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'dagran_thaurissan') {
        // æœ¬Bosséœ€è¦åœ¨æˆ˜æ–—ä¸­è®°å½•â€œæˆ˜æ–—æ€’å¼â€å å±‚
        combat.bossBuffs = combat.bossBuffs || {};
        combat.bossBuffs.battleShoutStacks = combat.bossBuffs.battleShoutStacks || 0;

        const shoutPct = Number(boss.battleShoutAttackPct ?? 0.10);
        const getEffectiveAttack = () => {
            const stacks = combat.bossBuffs.battleShoutStacks || 0;
            return Math.floor((boss.attack || 0) * (1 + stacks * shoutPct));
        };

        // ç«ç„°ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆå¹¶å¥—ç”¨ä¼¤å®³å‡å…/å…¨èƒ½ï¼‰
        const calcFireDamage = (playerState, rawDamage) => {
            const magicResist = playerState?.char?.stats?.magicResist || 0;
            const resistReduction = getMagicResistDamageReduction(magicResist);
            let damage = Math.floor((rawDamage || 0) * (1 - resistReduction));

            // åº”ç”¨å—ä¼¤å‡å…
            const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (playerState?.buffs) {
                playerState.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }
            const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
            const atonementTakenMult = getAtonementDamageTakenMult(playerState);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * versTakenMult));

            return { damage, resistReduction };
        };

        // çƒˆç„°æ‰“å‡»ï¼šå¯¹å½“å‰å¦å…‹é€ æˆ 3Ã—ç«ç„°ä¼¤å®³ + 3Ã—ç‰©ç†ä¼¤å®³ï¼ˆå¯æ ¼æŒ¡ï¼‰
        if (bossAction === 'flame_strike') {
            const tIdx = pickAlivePlayerIndex(); // 1å·ä½ï¼ˆå¦å…‹ä½ï¼‰
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const atk = getEffectiveAttack();

                // â‘  ç«ç„°ä¼¤å®³
                const rawFire = Math.floor(atk * (boss.flameStrikeFireMultiplier || 3));
                const fireRes = calcFireDamage(target, rawFire);
                const shieldResultFire = applyShieldAbsorb(target, fireRes.damage, logs, currentRound);
                target.currentHp -= shieldResultFire.finalDamage;

                const fireResPct = Math.round(fireRes.resistReduction * 100);
                const fireShieldText = shieldResultFire.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResultFire.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çƒˆç„°æ‰“å‡»ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResultFire.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${fireResPct}%${fireShieldText}ï¼‰`);

                // â‘¡ ç‰©ç†ä¼¤å®³ï¼ˆå¯æ ¼æŒ¡ï¼‰
                if (target.currentHp > 0) {
                    const rawPhys = Math.floor(atk * (boss.flameStrikePhysicalMultiplier || 3));
                    const { damage: physDmg, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, rawPhys, true);

                    const shieldResultPhys = applyShieldAbsorb(target, physDmg, logs, currentRound);
                    target.currentHp -= shieldResultPhys.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResultPhys.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResultPhys.absorbed}` : '';
                    addLog(`â†’ åŒæ—¶é€ æˆ ${shieldResultPhys.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çƒˆç„°æ‰“å‡»ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

        // ç†”å²©çˆ†è£‚ï¼šå¯¹éšæœºç›®æ ‡é€ æˆ 3Ã—ç«ç„°ä¼¤å®³ï¼Œå¹¶ç•™ä¸‹ç¼çƒ§DOTï¼ˆ1.5Ã—æ”»å‡»ï¼ŒæŒç»­3å›åˆï¼‰
        else if (bossAction === 'lava_burst') {
            const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
            if (alivePlayers.length > 0) {
                const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);

                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    const atk = getEffectiveAttack();

                    const raw = Math.floor(atk * (boss.lavaBurstMultiplier || 3));
                    const fireRes = calcFireDamage(target, raw);

                    const shieldResult = applyShieldAbsorb(target, fireRes.damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const fireResPct = Math.round(fireRes.resistReduction * 100);
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ç†”å²©çˆ†è£‚ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${fireResPct}%${shieldText}ï¼‰`);

                    // æ–½åŠ ç¼çƒ§DOT
                    const dotDamage = Math.floor(atk * (boss.burnDoTMultiplier || 1.5));
                    const dotDuration = boss.burnDoTDuration || 3;

                    target.dots = target.dots || [];
                    const existing = target.dots.find(d => d.name === 'ç¼çƒ§');
                    if (existing) {
                        existing.damagePerTurn = dotDamage;
                        existing.duration = dotDuration;
                        existing.school = 'fire';
                        addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} çš„ã€ç¼çƒ§ã€‘æŒç»­æ—¶é—´åˆ·æ–°ï¼ˆæ¯å›åˆ ${dotDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ŒæŒç»­ ${dotDuration} å›åˆï¼‰`);
                    } else {
                        target.dots.push({
                            name: 'ç¼çƒ§',
                            type: 'dot',
                            school: 'fire',
                            damagePerTurn: dotDamage,
                            duration: dotDuration
                        });
                        addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} è·å¾—ã€ç¼çƒ§ã€‘ï¼šæ¯å›åˆ ${dotDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ŒæŒç»­ ${dotDuration} å›åˆ`);
                    }
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ç†”å²©çˆ†è£‚ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

        // æˆ˜æ–—æ€’å¼ï¼šæ”»å‡» +10%ï¼Œå¯å åŠ ï¼ŒæŒç»­æ•´åœºæˆ˜æ–—
        else if (bossAction === 'battle_shout') {
            combat.bossBuffs.battleShoutStacks += 1;
            const stacks = combat.bossBuffs.battleShoutStacks;
            const totalPct = Math.round(stacks * shoutPct * 100);
            const curAtk = getEffectiveAttack();
            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æˆ˜æ–—æ€’å¼ã€‘ï¼šæ”»å‡»æé«˜ +${Math.round(shoutPct * 100)}%ï¼ˆå½“å‰${stacks}å±‚ï¼Œæ€»æå‡${totalPct}%ï¼‰ï¼Œå½“å‰æ”»å‡» ${curAtk}`);
        }
    }


    // ==================== é»‘æš—é™¢é•¿åŠ ä¸æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'darkmaster_gandling') {
        // æš—å½±ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆè€ƒè™‘ã€æš—å½±è¯…å’’ã€‘é­”æŠ—é™ä½ï¼‰
        const getEffectiveMagicResist = (playerState) => {
            const base = playerState?.char?.stats?.magicResist || 0;
            const curseDelta = playerState?.debuffs?.shadowCurse?.magicResistDelta || 0;
            return base + curseDelta;
        };

        const calcShadowDamage = (playerState, rawDamage) => {
            const magicResist = getEffectiveMagicResist(playerState);
            const resistReduction = getMagicResistDamageReduction(magicResist);
            let damage = Math.floor((rawDamage || 0) * (1 - resistReduction));

            // åº”ç”¨å—ä¼¤å‡å…
            const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (playerState?.buffs) {
                playerState.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }
            const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
            const atonementTakenMult = getAtonementDamageTakenMult(playerState);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * versTakenMult));

            return { damage, resistReduction, magicResist };
        };

        // æš—å½±ç®­ï¼šå¯¹å¦å…‹é€ æˆ5å€æ”»å‡»çš„æš—å½±ä¼¤å®³
        if (bossAction === 'shadow_bolt') {
            const tIdx = pickAlivePlayerIndex(); // 1å·ä½ï¼ˆå¦å…‹ä½ï¼‰
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.shadowBoltMultiplier || 5));
                const shadowRes = calcShadowDamage(target, raw);

                const shieldResult = applyShieldAbsorb(target, shadowRes.damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(shadowRes.resistReduction * 100);
                const mrText = Number(shadowRes.magicResist) < 0 ? `ï¼ˆæœ‰æ•ˆé­”æŠ— ${Math.floor(shadowRes.magicResist)}ï¼‰` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æš—å½±ç®­ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æš—å½±ç®­ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }
        // å¬å”¤äº¡çµå­¦å¾’
        else if (bossAction === 'summon_apprentices') {
            const aliveMinions = (combat.minions || []).filter(m => (m.hp ?? 0) > 0 && m.isApprentice);
            const need = Math.max(0, (boss.summonCount || 2) - aliveMinions.length);

            for (let i = 0; i < need; i++) {
                combat.minions.push({
                    hp: boss.minion.maxHp,
                    maxHp: boss.minion.maxHp,
                    attack: boss.attack,
                    defense: boss.defense,
                    isApprentice: true,
                    dots: []
                });
            }

            if (need > 0) {
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€å¬å”¤äº¡çµå­¦å¾’ã€‘å¬å”¤äº† ${need} ä¸ª${boss.minion.name}ï¼`);
                addLog(`â†’ ${boss.minion.name} å±æ€§ï¼šHP ${boss.minion.maxHp}ï¼Œæ”»å‡»/é˜²å¾¡ = Bossï¼›æ¯å›åˆéšæœºé‡Šæ”¾ã€æš—å½±ç®­ã€‘ï¼ˆ2Ã—Bossæ”»å‡»ï¼‰`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å¬å”¤äº¡çµå­¦å¾’ï¼Œä½†åœºä¸Šäº¡çµå­¦å¾’å·²æ»¡`);
            }
        }
        // æš—å½±è¯…å’’ï¼šéšæœºç›®æ ‡ï¼Œé­”æŠ— -100ï¼ŒæŒç»­4å›åˆ
        else if (bossAction === 'shadow_curse') {
            const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
            if (alivePlayers.length > 0) {
                const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);

                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    target.debuffs = target.debuffs || {};

                    const duration = boss.shadowCurseDuration || 4;
                    const delta = -Math.abs(Number(boss.shadowCurseMagicResistDown || 100));

                    // âœ… çŸ®äººï¼šçŸ³åƒå½¢æ€ - æœ¬åœºé¦–æ¬¡è¯…å’’å…ç–«
                    if (tryFirstDebuffImmunity(target, 'curse', tIdx, 'æš—å½±è¯…å’’')) {
                        addLog(`â†’ ã€æš—å½±è¯…å’’ã€‘è¢«å…ç–«ï¼Œæœªäº§ç”Ÿæ•ˆæœ`, 'debuff');
                    } else {
                        target.debuffs.shadowCurse = {
                            type: 'curse',
                            magicResistDelta: delta,
                            duration
                        };

                        addLog(`ã€${boss.name}ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} æ–½æ”¾ã€æš—å½±è¯…å’’ã€‘ï¼šé­”æ³•æŠ—æ€§ ${delta}ï¼ŒæŒç»­ ${duration} å›åˆ`, 'debuff');
                    }
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æš—å½±è¯…å’’ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }
        // é»‘æš—é£æš´ï¼š3å€æ”»å‡»æš—å½±ä¼¤å®³ï¼ˆåˆ†æ•£ï¼šéšæœºå•ä½“ï¼›é›†ä¸­ï¼šå…¨ä½“ï¼‰
        else if (bossAction === 'dark_storm') {
            const raw = Math.floor((boss.attack || 0) * (boss.darkStormMultiplier || 3));

            if (combat.strategy.stance === 'dispersed') {
                const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
                if (alivePlayers.length > 0) {
                    const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                    const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);

                    if (tIdx >= 0) {
                        const target = combat.playerStates[tIdx];
                        const shadowRes = calcShadowDamage(target, raw);

                        const shieldResult = applyShieldAbsorb(target, shadowRes.damage, logs, currentRound);
                        target.currentHp -= shieldResult.finalDamage;

                        const resPct = Math.round(shadowRes.resistReduction * 100);
                        const mrText = Number(shadowRes.magicResist) < 0 ? `ï¼ˆæœ‰æ•ˆé­”æŠ— ${Math.floor(shadowRes.magicResist)}ï¼‰` : '';
                        const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                        addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é»‘æš—é£æš´ã€‘ï¼ˆåˆ†æ•£ç«™ä½ï¼‰å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
                    }
                } else {
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é»‘æš—é£æš´ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é»‘æš—é£æš´ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰ï¼Œæ‰€æœ‰è§’è‰²å—åˆ°ä¼¤å®³ï¼`);

                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;

                    const shadowRes = calcShadowDamage(ps, raw);
                    const shieldResult = applyShieldAbsorb(ps, shadowRes.damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(shadowRes.resistReduction * 100);
                    const mrText = Number(shadowRes.magicResist) < 0 ? `ï¼ˆæœ‰æ•ˆé­”æŠ— ${Math.floor(shadowRes.magicResist)}ï¼‰` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
                });
            }
        }
    }

    // ==================== ç‘æ–‡æˆ´å°”ç”·çˆµæŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'baron_rivendare') {
        // æš—å½±ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆå¹¶å¥—ç”¨ä¼¤å®³å‡å…/å…¨èƒ½ï¼‰
        const calcShadowDamage = (playerState, rawDamage) => {
            const magicResist = playerState?.char?.stats?.magicResist || 0;
            const resistReduction = getMagicResistDamageReduction(magicResist);
            let damage = Math.floor((rawDamage || 0) * (1 - resistReduction));

            // åº”ç”¨å—ä¼¤å‡å…
            const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (playerState?.buffs) {
                playerState.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }
            const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
            const atonementTakenMult = getAtonementDamageTakenMult(playerState);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * versTakenMult));

            return { damage, resistReduction, magicResist };
        };

        // é¡ºåŠˆæ–©ï¼šåˆ†æ•£=æ‰“å¦å…‹ï¼›é›†ä¸­=æ‰“å…¨ä½“ï¼ˆ5Ã—æ”»å‡»ï¼Œç‰©ç†ï¼‰
        if (bossAction === 'cleave') {
            const raw = Math.floor((boss.attack || 0) * (boss.cleaveMultiplier || 5));

            if (combat.strategy.stance === 'dispersed') {
                const tIdx = pickAlivePlayerIndex();
                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);
                    const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼ˆåˆ†æ•£ç«™ä½ï¼‰å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                } else {
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰ï¼Œæ‰€æœ‰è§’è‰²å—åˆ°ä¼¤å®³ï¼`);
                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;
                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(ps, raw, true);
                    const shieldResult = applyShieldAbsorb(ps, damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                });
            }
        }

        // è‡´æ­»æ‰“å‡»ï¼šå¯¹å¦å…‹ 4Ã—æ”»å‡»ç‰©ç†ä¼¤å®³ + å‡ç–—50%
        else if (bossAction === 'mortal_strike') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.mortalStrikeMultiplier || 4));
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);

                const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                // æ–½åŠ å‡ç–—debuffï¼ˆå‚è€ƒèŒƒå…‹é‡Œå¤«ï¼‰
                target.debuffs = target.debuffs || {};
                target.debuffs.mortalStrike = {
                    healingReduction: boss.mortalStrikeDebuff?.healingReduction ?? 0.5,
                    duration: boss.mortalStrikeDebuff?.duration ?? 2
                };

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è‡´æ­»æ‰“å‡»ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰ï¼Œå¹¶æ–½åŠ ã€è‡´æ­»æ‰“å‡»ã€‘å‡ç–—${Math.round((boss.mortalStrikeDebuff?.healingReduction ?? 0.5) * 100)}%ï¼ˆæŒç»­${boss.mortalStrikeDebuff?.duration ?? 2}å›åˆï¼‰`, 'debuff');
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è‡´æ­»æ‰“å‡»ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

        // å¬å”¤éª·é«…å¤§å†›ï¼šå¬å”¤5ä¸ªéª·é«…ï¼ˆå¡«å……åˆ°ä¸Šé™ï¼‰
        else if (bossAction === 'summon_skeleton_army') {
            const aliveSkeletons = (combat.minions || []).filter(m => (m.hp ?? 0) > 0 && m.isSkeleton);
            const need = Math.max(0, (boss.summonCount || 5) - aliveSkeletons.length);

            for (let i = 0; i < need; i++) {
                combat.minions.push({
                    hp: boss.minion.maxHp,
                    maxHp: boss.minion.maxHp,
                    attack: boss.attack,
                    defense: boss.minion.defense,
                    isSkeleton: true,
                    dots: []
                });
            }

            if (need > 0) {
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€å¬å”¤éª·é«…å¤§å†›ã€‘å¬å”¤äº† ${need} ä¸ª${boss.minion.name}ï¼`);
                addLog(`â†’ ${boss.minion.name}ï¼šHP ${boss.minion.maxHp}ï¼ŒæŒ¥ç æ”»å‡» = ${boss.skeletonSlashMultiplier || 1.2}Ã—Bossæ”»å‡»ï¼ˆåªæ”»å‡»å¦å…‹ï¼‰`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å¬å”¤éª·é«…å¤§å†›ï¼Œä½†åœºä¸Šéª·é«…å·²æ»¡`);
            }
        }

        // æš—å½±éœ‡å‡»ï¼šå¯¹å¦å…‹ 3Ã—æ”»å‡»æš—å½±ä¼¤å®³ + DOTï¼ˆ1.5Ã—æ”»å‡»ï¼ŒæŒç»­3å›åˆï¼‰
        else if (bossAction === 'shadow_shock') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];

                const raw = Math.floor((boss.attack || 0) * (boss.shadowShockMultiplier || 3));
                const shadowRes = calcShadowDamage(target, raw);
                const shieldResult = applyShieldAbsorb(target, shadowRes.damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(shadowRes.resistReduction * 100);
                const mrText = Number(shadowRes.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(shadowRes.magicResist)}ï¼‰` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æš—å½±éœ‡å‡»ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);

                // æ–½åŠ DOT
                const dotDamage = Math.floor((boss.attack || 0) * (boss.shadowShockDotMultiplier || 1.5));
                const dotDuration = boss.shadowShockDotDuration || 3;

                target.dots = target.dots || [];
                const existing = target.dots.find(d => d.name === 'æš—å½±éœ‡å‡»');
                if (existing) {
                    existing.damagePerTurn = dotDamage;
                    existing.duration = dotDuration;
                    existing.school = 'shadow';
                    addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} çš„ã€æš—å½±éœ‡å‡»ã€‘æŒç»­æ—¶é—´åˆ·æ–°ï¼ˆæ¯å›åˆ ${dotDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ŒæŒç»­ ${dotDuration} å›åˆï¼‰`);
                } else {
                    target.dots.push({
                        name: 'æš—å½±éœ‡å‡»',
                        type: 'dot',
                        school: 'shadow',
                        damagePerTurn: dotDamage,
                        duration: dotDuration
                    });
                    addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} è·å¾—ã€æš—å½±éœ‡å‡»ã€‘ï¼šæ¯å›åˆ ${dotDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ŒæŒç»­ ${dotDuration} å›åˆ`);
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æš—å½±éœ‡å‡»ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }
    }

    // ==================== é›·å¾·Â·é»‘æ‰‹æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'rend_blackhand') {
        // ç«ç„°ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆå¹¶å¥—ç”¨ä¼¤å®³å‡å…/å…¨èƒ½ï¼‰
        const calcFireDamage = (playerState, rawDamage) => {
            const magicResist = playerState?.char?.stats?.magicResist || 0;
            const resistReduction = getMagicResistDamageReduction(magicResist);
            let damage = Math.floor((rawDamage || 0) * (1 - resistReduction));

            // åº”ç”¨å—ä¼¤å‡å…
            const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (playerState?.buffs) {
                playerState.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }
            const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
            const atonementTakenMult = getAtonementDamageTakenMult(playerState);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * versTakenMult));

            return { damage, resistReduction, magicResist };
        };

        // æŠ€èƒ½1ï¼šçƒˆç„°åæ¯
        // å¯¹å¦å…‹é€ æˆ 4Ã—æ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡ï¼‰ï¼Œå¹¶å¯¹å…¨é˜Ÿè¿½åŠ ä¸€æ¬¡â€œå¦å…‹å®é™…æ‰¿ä¼¤â€çš„ç«ç„°ä¼¤å®³
        if (bossAction === 'flame_breath') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.flameBreathMultiplier || 4));
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);
                const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çƒˆç„°åæ¯ã€‘å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);

                const splashBase = shieldResult.finalDamage;
                if (splashBase <= 0) {
                    addLog(`â†’ çƒˆç„°åæ¯çš„ç‰©ç†ä¼¤å®³è¢«å®Œå…¨å¸æ”¶ï¼Œæœªè§¦å‘é¢å¤–ç«ç„°ä¼¤å®³`);
                } else {
                    addLog(`â†’ çƒˆç„°å–·æ¶Œï¼šå…¨é˜Ÿé¢å¤–å—åˆ°ä¸€æ¬¡ç«ç„°ä¼¤å®³ï¼ˆåŸºå‡† ${splashBase}ï¼ŒæŒ‰å„è‡ªé­”æŠ—ç»“ç®—ï¼‰`);
                    combat.playerStates.forEach((ps, pIdx) => {
                        if (ps.currentHp <= 0) return;

                        const fireRes = calcFireDamage(ps, splashBase);
                        const shieldRes2 = applyShieldAbsorb(ps, fireRes.damage, logs, currentRound);
                        ps.currentHp -= shieldRes2.finalDamage;

                        const resPct = Math.round(fireRes.resistReduction * 100);
                        const mrText = Number(fireRes.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fireRes.magicResist)}ï¼‰` : '';
                        const shieldText2 = shieldRes2.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldRes2.absorbed}` : '';
                        addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldRes2.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText2}ï¼‰`);
                    });
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çƒˆç„°åæ¯ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

            // æŠ€èƒ½2ï¼šé¡ºåŠˆæ–©
        // åˆ†æ•£ï¼šæ‰“å¦å…‹ï¼›é›†ä¸­ï¼šæ‰“å…¨ä½“ï¼ˆ2Ã—æ”»å‡»ï¼Œç‰©ç†ï¼‰
        else if (bossAction === 'cleave') {
            const raw = Math.floor((boss.attack || 0) * (boss.cleaveMultiplier || 2));

            if (combat.strategy.stance === 'dispersed') {
                const tIdx = pickAlivePlayerIndex();
                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);
                    const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼ˆåˆ†æ•£ç«™ä½ï¼‰å¯¹ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                } else {
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
                }
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€é¡ºåŠˆæ–©ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰ï¼Œæ‰€æœ‰è§’è‰²å—åˆ°ä¼¤å®³ï¼`);
                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;
                    const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(ps, raw, true);
                    const shieldResult = applyShieldAbsorb(ps, damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const drPct = Math.round(dr * 100);
                    const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
                });
            }
        }

            // æŠ€èƒ½3ï¼šè·³è·ƒæ–©å‡»
        // é›†ä¸­ï¼šæ‰“å¦å…‹ï¼›åˆ†æ•£ï¼šéšæœºéå¦å…‹ï¼ˆ4Ã—æ”»å‡»ï¼Œç‰©ç†ï¼‰
        else if (bossAction === 'leap_slash') {
            const tankIdx = pickAlivePlayerIndex();
            if (tankIdx < 0) {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è·³è·ƒæ–©å‡»ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            } else {
                const raw = Math.floor((boss.attack || 0) * (boss.leapSlashMultiplier || 4));

                let targetIdx = tankIdx;
                let modeText = 'ï¼ˆé›†ä¸­ç«™ä½ï¼‰';

                if (combat.strategy.stance === 'dispersed') {
                    const candidates = combat.playerStates
                        .map((ps, idx) => ({ ps, idx }))
                        .filter(o => (o.ps?.currentHp ?? 0) > 0 && o.idx !== tankIdx)
                        .map(o => o.idx);

                    if (candidates.length > 0) {
                        targetIdx = candidates[Math.floor(Math.random() * candidates.length)];
                        modeText = 'ï¼ˆåˆ†æ•£ç«™ä½ï¼šéšæœºç›®æ ‡ï¼‰';
                    } else {
                        modeText = 'ï¼ˆåˆ†æ•£ç«™ä½ï¼šä»…å‰©å¦å…‹ï¼‰';
                    }
                }

                const target = combat.playerStates[targetIdx];
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);
                const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è·³è·ƒæ–©å‡»ã€‘${modeText}å‘½ä¸­ ä½ç½®${targetIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
            }
        }
    }

    // ==================== è¡€ç¥å“ˆå¡æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'hakkar') {
        // è‡ªç„¶ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆå¹¶å¥—ç”¨ä¼¤å®³å‡å…/å…¨èƒ½/æŒ«å¿—æ€’å¼ï¼‰
        const calcNatureDamage = (playerState, rawDamage) => {
            const magicResist = playerState?.char?.stats?.magicResist || 0;
            const resistReduction = getMagicResistDamageReduction(magicResist);
            let damage = Math.floor((rawDamage || 0) * (1 - resistReduction));

            const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (playerState?.buffs) {
                playerState.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }

            const demoralizingShoutMult = combat.bossDebuffs?.demoralizingShout?.damageMult ?? 1;
            const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
            const atonementTakenMult = getAtonementDamageTakenMult(playerState);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * demoralizingShoutMult * versTakenMult));

            return { damage, resistReduction, magicResist };
        };

        // æ˜¯å¦æ‹¥æœ‰ã€æ¯’æ€§ä¹‹è¡€ã€‘ï¼ˆç”¨äºã€è¡€æ¶²è™¹å¸ã€‘çš„æ²»ç–—/åå™¬åˆ¤å®šï¼‰
        const hasToxicBlood = (ps) => Array.isArray(ps?.dots) && ps.dots.some(d =>
            d && d.name === 'æ¯’æ€§ä¹‹è¡€' && (d.isPermanent || (d.duration ?? 0) > 0)
        );

        // æ–½åŠ ã€å •è½ä¹‹è¡€ã€‘ï¼ˆæ°¸ä¹…å å±‚ä¸­æ¯’DOTï¼š0.5Ã—Bossæ”»å‡»/å±‚/å›åˆï¼Œæš—å½±ä¼¤å®³ï¼‰
        const applyCorruptedBlood = (ps, pIdx) => {
            if (!ps || ps.currentHp <= 0) return;

            // âœ… çŸ®äººï¼šé¦–æ¬¡ä¸­æ¯’å…ç–«
            if (tryFirstDebuffImmunity(ps, 'poison', pIdx, 'å •è½ä¹‹è¡€')) {
                addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å…ç–«äº†ã€å •è½ä¹‹è¡€ã€‘`, 'debuff');
                return;
            }

            ps.dots = ps.dots || [];
            const mult = boss.corruptedBloodDotMultiplier ?? 0.5;
            const base = Math.floor((boss.attack || 0) * mult);

            const existing = ps.dots.find(d => d && d.name === 'å •è½ä¹‹è¡€');
            if (existing) {
                existing.stacks = (existing.stacks || 1) + 1;
                existing.type = 'poison';
                existing.isPoison = true;
                existing.school = 'shadow';
                existing.isPermanent = true;
                existing.duration = existing.duration ?? 999;

                const perTurn = Math.max(1, Math.floor(base * (existing.stacks || 1)));
                existing.damagePerTurn = perTurn;

                addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} çš„ã€å •è½ä¹‹è¡€ã€‘å åŠ åˆ°${existing.stacks}å±‚ï¼ˆæ¯å›åˆ${perTurn}ç‚¹æš—å½±ä¼¤å®³ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸï¼‰`, 'debuff');
            } else {
                const perTurn = Math.max(1, base);
                ps.dots.push({
                    name: 'å •è½ä¹‹è¡€',
                    type: 'poison',
                    isPoison: true,
                    school: 'shadow',
                    stacks: 1,
                    damagePerTurn: perTurn,
                    duration: 999,
                    isPermanent: true
                });
                addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} è·å¾—ã€å •è½ä¹‹è¡€ã€‘ï¼ˆæ¯å›åˆ${perTurn}ç‚¹æš—å½±ä¼¤å®³ï¼Œå¯å å±‚åˆ°æˆ˜æ–—ç»“æŸï¼‰`, 'debuff');
            }
        };

        // æŠ€èƒ½1ï¼šå¬å”¤å“ˆå¡ä¹‹å­ï¼ˆæœ€å¤š2ä¸ªï¼ŒHP80ä¸‡ï¼‰
        if (bossAction === 'summon_hakkar_sons') {
            const aliveSons = (combat.minions || []).filter(m => (m?.hp ?? 0) > 0 && m.isHakkarSon).length;
            const need = Math.max(0, (boss.summonCount || 2) - aliveSons);

            for (let i = 0; i < need; i++) {
                combat.minions.push({
                    hp: boss.minion.maxHp,
                    maxHp: boss.minion.maxHp,
                    attack: boss.attack,
                    defense: boss.minion.defense,
                    isHakkarSon: true,
                    deathProcessed: false,
                    dots: []
                });
            }

            if (need > 0) {
                addLog(`ã€${boss.name}ã€‘ä½¿ç”¨ã€å¬å”¤å“ˆå¡ä¹‹å­ã€‘å¬å”¤äº† ${need} ä¸ª${boss.minion.name}ï¼`);
                addLog(`â†’ ${boss.minion.name}ï¼šHP ${boss.minion.maxHp}ï¼Œæ¯å›åˆå¯¹å¦å…‹å–·åã€é…¸æ¶²ã€‘é€ æˆ ${(boss.acidMultiplier || 1.2)}Ã—Bossæ”»å‡» çš„è‡ªç„¶ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰`);
                addLog(`â†’ ${boss.minion.name}æ­»äº¡ï¼šå…¨é˜Ÿè·å¾—ã€æ¯’æ€§ä¹‹è¡€ã€‘ï¼ˆ${boss.toxicBloodDotAtkCoeff || 0.4}Ã—Bossæ”»å‡»/å›åˆï¼ŒæŒç»­ ${boss.toxicBloodDuration || 3} å›åˆï¼‰`);
            } else {
                addLog(`ã€${boss.name}ã€‘å°è¯•å¬å”¤å“ˆå¡ä¹‹å­ï¼Œä½†åœºä¸Šå“ˆå¡ä¹‹å­å·²æ»¡`);
            }
        }

        // æŠ€èƒ½2ï¼šè¡€æ¶²è™¹å¸ï¼ˆAOEè‡ªç„¶ä¼¤å®³ï¼Œå¹¶æ ¹æ®æ˜¯å¦ä¸­æ¯’æ€§ä¹‹è¡€å†³å®šæ²»ç–—/åå™¬ï¼‰
        else if (bossAction === 'blood_siphon') {
            const raw = Math.floor((boss.attack || 0) * (boss.bloodSiphonMultiplier || 3));
            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è¡€æ¶²è™¹å¸ã€‘ï¼`);

            let toxicCount = 0;
            let nonToxicCount = 0;

            combat.playerStates.forEach((ps, pIdx) => {
                if (!ps || ps.currentHp <= 0) return;

                if (hasToxicBlood(ps)) toxicCount += 1;
                else nonToxicCount += 1;

                const nat = calcNatureDamage(ps, raw);
                const shieldResult = applyShieldAbsorb(ps, nat.damage, logs, currentRound);
                ps.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(nat.resistReduction * 100);
                const mrText = Number(nat.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(nat.magicResist)}ï¼‰` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹è‡ªç„¶ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
            });

            const bossMax = boss.maxHp || 0;
            const healPct = boss.bloodSiphonHealPctPerNonToxic ?? 0.05;
            const dmgPct = boss.bloodSiphonSelfDmgPctPerToxic ?? 0.01;

            const heal = Math.floor(bossMax * healPct * nonToxicCount);
            const selfDmg = Math.floor(bossMax * dmgPct * toxicCount);

            if (nonToxicCount > 0) {
                addLog(`â†’ è™¹å¸åˆ° ${nonToxicCount} ä¸ªã€æœªä¸­æ¯’æ€§ä¹‹è¡€ã€‘ç›®æ ‡ï¼Œå“ˆå¡å›å¤ ${heal} ç‚¹ç”Ÿå‘½`);
            }
            if (toxicCount > 0) {
                addLog(`â†’ è™¹å¸åˆ° ${toxicCount} ä¸ªã€ä¸­æ¯’æ€§ä¹‹è¡€ã€‘ç›®æ ‡ï¼Œå“ˆå¡å—åˆ° ${selfDmg} ç‚¹åå™¬ä¼¤å®³`);
            }

            const beforeHp = combat.bossHp || 0;
            combat.bossHp = Math.max(0, Math.min(bossMax, Math.floor(beforeHp + heal - selfDmg)));
            const delta = combat.bossHp - beforeHp;
            if (delta !== 0) {
                addLog(`ã€${boss.name}ã€‘ç”Ÿå‘½å€¼å˜åŒ–ï¼š${delta > 0 ? '+' : ''}${delta}ï¼ˆ${beforeHp} â†’ ${combat.bossHp}ï¼‰`);
            }
        }

        // æŠ€èƒ½3ï¼šå •è½ä¹‹è¡€ï¼ˆä¸­æ¯’DOTï¼Œæš—å½±ä¼¤å®³ï¼Œå¯å å±‚åˆ°æˆ˜æ–—ç»“æŸï¼‰
        else if (bossAction === 'corrupted_blood') {
            if (combat.strategy.stance === 'concentrated') {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€å •è½ä¹‹è¡€ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼‰ï¼Œæ‰€æœ‰è§’è‰²è·å¾—1å±‚ã€å •è½ä¹‹è¡€ã€‘ï¼`);
                combat.playerStates.forEach((ps, pIdx) => applyCorruptedBlood(ps, pIdx));
            } else {
                const candidates = combat.playerStates
                    .map((ps, idx) => ({ ps, idx }))
                    .filter(o => (o.ps?.currentHp ?? 0) > 0)
                    .map(o => o.idx);

                if (candidates.length <= 0) {
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€å •è½ä¹‹è¡€ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
                } else {
                    const tIdx = candidates[Math.floor(Math.random() * candidates.length)];
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€å •è½ä¹‹è¡€ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${combat.playerStates[tIdx].char.name}ï¼`);
                    applyCorruptedBlood(combat.playerStates[tIdx], tIdx);
                }
            }
        }
    }


    // ==================== åŠ å°”æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'garr') {
        // ç«ç„°æ³•æœ¯ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆå¹¶å¥—ç”¨å—ä¼¤ä¹˜åŒº/å…¨èƒ½/æ•‘èµ/æŒ«å¿—/æ³•æœ¯æ˜“ä¼¤ï¼‰
        // è¿™é‡Œå¤ç”¨é€šç”¨ calcMagicDamage(...)
        const bossAction = boss.cycle[(combat.round - 1) % boss.cycle.length];

        const pickRandomAlivePlayerIndex = () => {
            const aliveIdx = combat.playerStates.map((p, idx) => ({ p, idx })).filter(x => x.p.currentHp > 0);
            if (aliveIdx.length === 0) return -1;
            return aliveIdx[Math.floor(Math.random() * aliveIdx.length)].idx;
        };

        if (bossAction === 'flame_impact') {
            // çƒˆç„°å†²å‡»ï¼šéšæœºç›®æ ‡ 3Ã—æ”»å‡» ç«ç„°æ³•æœ¯ä¼¤å®³ï¼Œå¹¶ç•™ä¸‹ç¼çƒ§DOT
            const tIdx = pickRandomAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];

                const raw = Math.floor((boss.attack || 0) * (boss.flameImpactMultiplier || 3));
                const fire = calcMagicDamage(target, raw);

                const shieldResult = applyShieldAbsorb(target, fire.damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(fire.resistReduction * 100);
                const mrText = Number(fire.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fire.magicResist)}ï¼‰` : '';
                const vulnPct = Math.round((fire.spellVulnMult - 1) * 100);
                const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çƒˆç„°å†²å‡»ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);

                // ç¼çƒ§DOTï¼šæ¯å›åˆ 1.5Ã—æ”»å‡»ï¼ŒæŒç»­4å›åˆ
                const dotRaw = Math.floor((boss.attack || 0) * (boss.flameImpactDotMultiplier || 1.5));
                target.dots = target.dots || [];
                target.dots.push({
                    name: 'ç¼çƒ§',
                    school: 'fire',
                    damagePerTurn: dotRaw,
                    duration: boss.flameImpactDotDuration || 4
                });
                addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} è¢«æ–½åŠ ã€ç¼çƒ§ã€‘ï¼ˆæ¯å›åˆ ${dotRaw} ç‚¹ç«ç„°ä¼¤å®³ï¼ŒæŒç»­ ${boss.flameImpactDotDuration || 4} å›åˆï¼‰`, 'debuff');
            }
        }

        else if (bossAction === 'summon_fire_elementals') {
            // å¬å”¤ç«å…ƒç´ ï¼šå¬å”¤2ä¸ªç«å…ƒç´ 
            const count = boss.summonCount || 2;

            combat.minions = Array.isArray(combat.minions) ? combat.minions : [];
            for (let i = 0; i < count; i++) {
                combat.minions.push({
                    name: boss.minion?.name || 'ç«å…ƒç´ ',
                    hp: boss.minion?.maxHp || 1500000,
                    maxHp: boss.minion?.maxHp || 1500000,
                    attack: boss.minion?.attack || boss.attack || 10800,
                    defense: boss.minion?.defense || 10000,
                    dots: [],
                    isFireElemental: true
                });
            }
            addLog(`ã€${boss.name}ã€‘å¬å”¤äº† ${count} ä¸ªã€${boss.minion?.name || 'ç«å…ƒç´ '}ã€‘ï¼`, 'summon');
        }

        else if (bossAction === 'flame_storm') {
            // çƒˆç„°é£æš´ï¼šéšæœºç›®æ ‡ 3Ã—ï¼›é›†ä¸­ç«™ä½ï¼šå…¨ä½“ 3Ã—
            const stance = combat.strategy?.stance || 'balanced';
            const raw = Math.floor((boss.attack || 0) * (boss.flameStormMultiplier || 3));

            if (stance === 'concentrated') {
                // å…¨ä½“
                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;
                    const fire = calcMagicDamage(ps, raw);

                    const shieldResult = applyShieldAbsorb(ps, fire.damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(fire.resistReduction * 100);
                    const mrText = Number(fire.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fire.magicResist)}ï¼‰` : '';
                    const vulnPct = Math.round((fire.spellVulnMult - 1) * 100);
                    const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çƒˆç„°é£æš´ã€‘å‘½ä¸­ ä½ç½®${pIdx + 1} ${ps.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);
                });
            } else {
                // éšæœºå•ä½“
                const tIdx = pickRandomAlivePlayerIndex();
                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    const fire = calcMagicDamage(target, raw);

                    const shieldResult = applyShieldAbsorb(target, fire.damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(fire.resistReduction * 100);
                    const mrText = Number(fire.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fire.magicResist)}ï¼‰` : '';
                    const vulnPct = Math.round((fire.spellVulnMult - 1) * 100);
                    const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çƒˆç„°é£æš´ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);
                }
            }
        }

        else if (bossAction === 'fire_shock') {
            // ç«ç„°éœ‡å‡»ï¼šå…¨ä½“ 3Ã—ï¼›åˆ†æ•£ç«™ä½ï¼šå‡»é£ï¼ˆä¸‹ä¸€å›åˆæ— æ³•è¡ŒåŠ¨ï¼‰
            const stance = combat.strategy?.stance || 'balanced';
            const raw = Math.floor((boss.attack || 0) * (boss.fireShockMultiplier || 3));

            combat.playerStates.forEach((ps, pIdx) => {
                if (ps.currentHp <= 0) return;

                const fire = calcMagicDamage(ps, raw);

                const shieldResult = applyShieldAbsorb(ps, fire.damage, logs, currentRound);
                ps.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(fire.resistReduction * 100);
                const mrText = Number(fire.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fire.magicResist)}ï¼‰` : '';
                const vulnPct = Math.round((fire.spellVulnMult - 1) * 100);
                const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ç«ç„°éœ‡å‡»ã€‘å‘½ä¸­ ä½ç½®${pIdx + 1} ${ps.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);
            });

            if (stance === 'dispersed') {
                combat.playerStates.forEach((ps, pIdx) => {
                    if (ps.currentHp <= 0) return;
                    ps.debuffs = ps.debuffs || {};
                    ps.debuffs.knockup = { duration: boss.knockupDuration || 1 };
                });
                addLog(`ã€${boss.name}ã€‘çš„ã€ç«ç„°éœ‡å‡»ã€‘è§¦å‘ã€å‡»é£ã€‘ï¼å…¨ä½“ä¸‹ä¸€å›åˆæ— æ³•è¡ŒåŠ¨`, 'debuff');
            }
        }
    }

    // ==================== è¿¦é¡¿ç”·çˆµæŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'baron_geddon') {
        // ä½¿ç”¨ bossBuffs è®°å½•â€œåœ°ç‹±çƒˆç„°â€å å±‚ï¼ˆæ¯æ¬¡æ–½æ”¾ä½¿ä¸‹ä¸€æ¬¡ä¼¤å®³+0.25Ã—Bossæ”»å‡»ï¼‰
        combat.bossBuffs = combat.bossBuffs || {};
        combat.bossBuffs.hellfireStacks = Math.max(0, Math.floor(Number(combat.bossBuffs.hellfireStacks || 0)));

        const base = Number.isFinite(Number(boss.hellfireBaseMultiplier)) ? Number(boss.hellfireBaseMultiplier) : 0.5;
        const inc = Number.isFinite(Number(boss.hellfireIncreaseMultiplier)) ? Number(boss.hellfireIncreaseMultiplier) : 0.25;

        const getHellfireMultiplier = (stacks) => {
            const s = Math.max(0, Math.floor(Number(stacks || 0)));
            return base + s * inc;
        };

        const pickRandomAlivePlayerIndex = () => {
            const aliveIdx = combat.playerStates
                .map((p, idx) => ({ p, idx }))
                .filter(x => (x.p?.currentHp ?? 0) > 0)
                .map(x => x.idx);
            if (aliveIdx.length <= 0) return -1;
            return aliveIdx[Math.floor(Math.random() * aliveIdx.length)];
        };

        // æŠ€èƒ½1ï¼šåœ°ç‹±çƒˆç„°ï¼ˆAOEï¼‰
        if (bossAction === 'hellfire') {
            const stacks = combat.bossBuffs.hellfireStacks || 0;
            const mult = getHellfireMultiplier(stacks);
            const raw = Math.floor((boss.attack || 0) * mult);

            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€åœ°ç‹±çƒˆç„°ã€‘ï¼ä¼¤å®³å€ç‡ ${mult.toFixed(2)}Ã—ï¼ˆåŸºç¡€${base} + å å±‚${stacks}Ã—${inc}ï¼‰`);

            combat.playerStates.forEach((ps, pIdx) => {
                if (!ps || ps.currentHp <= 0) return;

                const fire = calcMagicDamage(ps, raw);
                const shieldResult = applyShieldAbsorb(ps, fire.damage, logs, currentRound);
                ps.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(fire.resistReduction * 100);
                const mrText = Number(fire.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fire.magicResist)}ï¼‰` : '';
                const vulnPct = Math.round((fire.spellVulnMult - 1) * 100);
                const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);
            });

            // å å±‚ï¼šä½¿ä¸‹ä¸€æ¬¡åœ°ç‹±çƒˆç„°é¢å¤–+0.25Ã—Bossæ”»å‡»ï¼ˆå¯å åŠ ï¼‰
            combat.bossBuffs.hellfireStacks = (combat.bossBuffs.hellfireStacks || 0) + 1;
            const nextStacks = combat.bossBuffs.hellfireStacks;
            const nextMult = getHellfireMultiplier(nextStacks);
            addLog(`â†’ ä¸‹ä¸€æ¬¡ã€åœ°ç‹±çƒˆç„°ã€‘ä¼¤å®³æé«˜ ${inc}Ã—Bossæ”»å‡»ï¼ˆå½“å‰å å±‚ï¼š${nextStacks}ï¼Œä¸‹æ¬¡å€ç‡${nextMult.toFixed(2)}Ã—ï¼‰`);
        }

        // æŠ€èƒ½2ï¼šçµé­‚ç‡ƒçƒ§ï¼ˆå•ä½“æ‰“å¦å…‹ï¼‰
        else if (bossAction === 'soul_burn') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.soulBurnMultiplier || 8));

                const fire = calcMagicDamage(target, raw);
                const shieldResult = applyShieldAbsorb(target, fire.damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(fire.resistReduction * 100);
                const mrText = Number(fire.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fire.magicResist)}ï¼‰` : '';
                const vulnPct = Math.round((fire.spellVulnMult - 1) * 100);
                const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çµé­‚ç‡ƒçƒ§ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€çµé­‚ç‡ƒçƒ§ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

        // æŠ€èƒ½3ï¼šæ´»ä½“ç‚¸å¼¹ï¼ˆéšæœºç›®æ ‡ï¼›é›†ä¸­ç«™ä½ï¼šå…¨ä½“ï¼‰
        else if (bossAction === 'living_bomb') {
            const stance = combat.strategy?.stance || 'balanced';
            const tIdx = pickRandomAlivePlayerIndex();

            if (tIdx < 0) {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æ´»ä½“ç‚¸å¼¹ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            } else {
                const raw = Math.floor((boss.attack || 0) * (boss.livingBombMultiplier || 4));
                const knockDur = Math.max(1, Math.floor(Number(boss.livingBombKnockupDuration || 2)));

                if (stance === 'concentrated') {
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æ´»ä½“ç‚¸å¼¹ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼šå…¨ä½“å—å‡»ï¼‰ï¼ç‚¸å¼¹è½åœ¨ ä½ç½®${tIdx + 1} ${combat.playerStates[tIdx].char.name}`);
                    combat.playerStates.forEach((ps, pIdx) => {
                        if (!ps || ps.currentHp <= 0) return;

                        const fire = calcMagicDamage(ps, raw);
                        const shieldResult = applyShieldAbsorb(ps, fire.damage, logs, currentRound);
                        ps.currentHp -= shieldResult.finalDamage;

                        const resPct = Math.round(fire.resistReduction * 100);
                        const mrText = Number(fire.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fire.magicResist)}ï¼‰` : '';
                        const vulnPct = Math.round((fire.spellVulnMult - 1) * 100);
                        const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                        const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                        addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);
                    });
                } else {
                    const target = combat.playerStates[tIdx];

                    const fire = calcMagicDamage(target, raw);
                    const shieldResult = applyShieldAbsorb(target, fire.damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(fire.resistReduction * 100);
                    const mrText = Number(fire.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fire.magicResist)}ï¼‰` : '';
                    const vulnPct = Math.round((fire.spellVulnMult - 1) * 100);
                    const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æ´»ä½“ç‚¸å¼¹ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);
                }

                // å‡»é£ï¼šåªå‡»é£â€œç‚¸å¼¹ç›®æ ‡â€ï¼ˆé»˜è®¤ä¸åˆ†æ•£ç«™ä½ä¸€è‡´ï¼›é›†ä¸­ç«™ä½ä»å‡»é£ç‚¸å¼¹æºå¸¦è€…ï¼‰
                const bombTarget = combat.playerStates[tIdx];
                if (bombTarget && bombTarget.currentHp > 0) {
                    bombTarget.debuffs = bombTarget.debuffs || {};
                    bombTarget.debuffs.knockup = { duration: knockDur };
                    addLog(`â†’ ä½ç½®${tIdx + 1} ${bombTarget.char.name} è¢«ã€å‡»é£ã€‘ï¼Œ${knockDur}å›åˆæ— æ³•è¡ŒåŠ¨`, 'debuff');
                }
            }
        }
    }

    // ==================== ç„šåŒ–è€…å¤é›·æ›¼æ ¼æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'golemagg') {
        // ä½¿ç”¨ bossBuffs è®°å½•ã€ç‹‚æ€’ã€‘å å±‚ï¼šæ¯å±‚ä½¿ Boss ä¸ ç†”ç«æ¶çŠ¬ é€ æˆçš„æ‰€æœ‰ä¼¤å®³ +5%
        combat.bossBuffs = combat.bossBuffs || {};
        combat.bossBuffs.furyStacks = Math.max(0, Math.floor(Number(combat.bossBuffs.furyStacks || 0)));

        const furyPer = (typeof boss.furyPerStack === 'number' && Number.isFinite(boss.furyPerStack) && boss.furyPerStack > 0)
            ? boss.furyPerStack
            : 0.05;

        const getFuryMult = () => 1 + (combat.bossBuffs.furyStacks || 0) * furyPer;

        // ç†”ç«æ¶çŠ¬ç‹‚æš´é˜ˆå€¼ï¼šBossè¡€é‡ â‰¤ 30%
        const enragePct = (typeof boss.houndEnrageHpPct === 'number' && Number.isFinite(boss.houndEnrageHpPct) && boss.houndEnrageHpPct > 0)
            ? boss.houndEnrageHpPct
            : 0.30;

        if (!combat.bossBuffs.houndsEnraged && (combat.bossHp ?? 0) > 0 && (boss.maxHp || 0) > 0) {
            const hpPct = (combat.bossHp || 0) / (boss.maxHp || 1);
            if (hpPct <= enragePct) {
                combat.bossBuffs.houndsEnraged = true;
                addLog(`ã€${boss.name}ã€‘ç”Ÿå‘½å€¼ä½äº ${Math.round(enragePct * 100)}%ï¼ä¸¤åªã€${boss.minion?.name || 'ç†”ç«æ¶çŠ¬'}ã€‘è¿›å…¥ã€ç‹‚æš´ã€‘ï¼`, 'warning');
            }
        }

        const pickRandomAlivePlayerIndex = () => {
            const aliveIdx = combat.playerStates
                .map((p, idx) => ({ p, idx }))
                .filter(x => (x.p?.currentHp ?? 0) > 0)
                .map(x => x.idx);
            if (aliveIdx.length <= 0) return -1;
            return aliveIdx[Math.floor(Math.random() * aliveIdx.length)];
        };

        // æŠ€èƒ½1ï¼šç†”å²©å–·æº…ï¼ˆå¦å…‹ï¼š5Ã—Bossæ”»å‡» æ³•æœ¯ä¼¤å®³ï¼›å¹¶æ–½åŠ â€œæ‰¿ä¼¤+5%â€å¯å å±‚åˆ°æˆ˜æ–—ç»“æŸï¼‰
        if (bossAction === 'lava_splash') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];

                const raw = Math.floor((boss.attack || 0) * (boss.lavaSplashMultiplier || 5) * getFuryMult());
                const fire = calcMagicDamage(target, raw);

                const shieldResult = applyShieldAbsorb(target, fire.damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(fire.resistReduction * 100);
                const mrText = Number(fire.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fire.magicResist)}ï¼‰` : '';
                const vulnPct = Math.round((fire.spellVulnMult - 1) * 100);
                const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                const furyText = (combat.bossBuffs.furyStacks || 0) > 0 ? `ï¼ˆç‹‚æ€’${combat.bossBuffs.furyStacks}å±‚ï¼‰` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ç†”å²©å–·æº…ã€‘${furyText} å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);

                // æ‰¿ä¼¤æé«˜ï¼šç”¨ buffs çš„ damageTakenMult å®ç°ï¼ˆå¯å½±å“ç‰©ç†/æ³•æœ¯/DOTï¼‰ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸ
                const per = (typeof boss.lavaSplashVulnPerStack === 'number' && Number.isFinite(boss.lavaSplashVulnPerStack) && boss.lavaSplashVulnPerStack > 0)
                    ? boss.lavaSplashVulnPerStack
                    : 0.05;

                target.buffs = Array.isArray(target.buffs) ? target.buffs : [];
                const buffType = 'lava_splash_vuln';
                let existing = target.buffs.find(b => b.type === buffType);

                if (existing) {
                    existing.stacks = (existing.stacks || 1) + 1;
                    existing.damageTakenMult = 1 + (existing.stacks || 1) * per;
                } else {
                    existing = {
                        type: buffType,
                        name: 'ç†”å²©å–·æº…æ˜“ä¼¤',
                        stacks: 1,
                        damageTakenMult: 1 + 1 * per,
                        // ä¸å†™ durationï¼šæŒç»­åˆ°æˆ˜æ–—ç»“æŸï¼ˆbossCombatç»“æŸè‡ªåŠ¨æ¸…ç†ï¼‰
                        justApplied: true,
                    };
                    target.buffs.push(existing);
                }

                const stacks = existing.stacks || 1;
                const totalPct = Math.round(stacks * per * 100);
                addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} è·å¾—ã€ç†”å²©å–·æº…æ˜“ä¼¤ã€‘ï¼šå—åˆ°æ‰€æœ‰ä¼¤å®³ +${Math.round(per * 100)}%ï¼ˆå½“å‰${stacks}å±‚ï¼Œæ€»+${totalPct}%ï¼‰ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸ`, 'debuff');
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ç†”å²©å–·æº…ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

        // æŠ€èƒ½2ï¼šåœ°éœ‡æœ¯ï¼ˆéšæœºç›®æ ‡ 3Ã—ï¼›é›†ä¸­ç«™ä½ï¼šå…¨ä½“ 3Ã—ï¼‰
        else if (bossAction === 'earthquake') {
            const raw = Math.floor((boss.attack || 0) * (boss.earthquakeMultiplier || 3) * getFuryMult());
            const stance = combat.strategy?.stance || 'balanced';

            if (stance === 'concentrated') {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€åœ°éœ‡æœ¯ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼šå…¨ä½“å—å‡»ï¼‰ï¼`);
                combat.playerStates.forEach((ps, pIdx) => {
                    if (!ps || ps.currentHp <= 0) return;

                    const dmg = calcMagicDamage(ps, raw);
                    const shieldResult = applyShieldAbsorb(ps, dmg.damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(dmg.resistReduction * 100);
                    const mrText = Number(dmg.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(dmg.magicResist)}ï¼‰` : '';
                    const vulnPct = Math.round((dmg.spellVulnMult - 1) * 100);
                    const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹æ³•æœ¯ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);
                });
            } else {
                const tIdx = pickRandomAlivePlayerIndex();
                if (tIdx < 0) {
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€åœ°éœ‡æœ¯ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
                } else {
                    const target = combat.playerStates[tIdx];
                    const dmg = calcMagicDamage(target, raw);
                    const shieldResult = applyShieldAbsorb(target, dmg.damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(dmg.resistReduction * 100);
                    const mrText = Number(dmg.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(dmg.magicResist)}ï¼‰` : '';
                    const vulnPct = Math.round((dmg.spellVulnMult - 1) * 100);
                    const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€åœ°éœ‡æœ¯ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹æ³•æœ¯ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);
                }
            }
        }

        // æŠ€èƒ½3ï¼šç‚çˆ†æœ¯ï¼ˆéšæœºç›®æ ‡ 4Ã—ï¼›å¹¶ç•™ä¸‹ä½™çƒ¬DOTï¼š1.5Ã—/å›åˆï¼ŒæŒç»­4å›åˆï¼‰
        else if (bossAction === 'pyroblast') {
            const tIdx = pickRandomAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];

                const raw = Math.floor((boss.attack || 0) * (boss.pyroblastMultiplier || 4) * getFuryMult());
                const fire = calcMagicDamage(target, raw);

                const shieldResult = applyShieldAbsorb(target, fire.damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(fire.resistReduction * 100);
                const mrText = Number(fire.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fire.magicResist)}ï¼‰` : '';
                const vulnPct = Math.round((fire.spellVulnMult - 1) * 100);
                const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ç‚çˆ†æœ¯ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);

                const dotRaw = Math.floor((boss.attack || 0) * (boss.emberDotMultiplier || 1.5) * getFuryMult());
                const dur = Math.max(1, Math.floor(Number(boss.emberDotDuration || 4)));

                target.dots = target.dots || [];
                target.dots.push({
                    name: 'ä½™çƒ¬',
                    school: 'fire',
                    damagePerTurn: dotRaw,
                    duration: dur
                });
                addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} è¢«æ–½åŠ ã€ä½™çƒ¬ã€‘ï¼ˆæ¯å›åˆ ${dotRaw} ç‚¹ç«ç„°ä¼¤å®³ï¼ŒæŒç»­ ${dur} å›åˆï¼‰`, 'debuff');
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ç‚çˆ†æœ¯ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

        // æŠ€èƒ½4ï¼šç‹‚æ€’ï¼ˆå å±‚å¢ä¼¤ï¼‰
        else if (bossAction === 'fury') {
            combat.bossBuffs.furyStacks = (combat.bossBuffs.furyStacks || 0) + 1;
            const stacks = combat.bossBuffs.furyStacks || 1;
            const pct = Math.round(stacks * furyPer * 100);
            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ç‹‚æ€’ã€‘ï¼è‡ªèº«ä¸ç†”ç«æ¶çŠ¬é€ æˆçš„æ‰€æœ‰ä¼¤å®³ +${Math.round(furyPer * 100)}%ï¼ˆå½“å‰${stacks}å±‚ï¼Œæ€»+${pct}%ï¼‰ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸ`, 'buff');
        }
    }

    // ==================== ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'majordomo_executus') {
        combat.bossBuffs = combat.bossBuffs || {};

        const pickRandomAlivePlayerIndex = () => {
            const alive = combat.playerStates
                .map((ps, idx) => ((ps.currentHp ?? 0) > 0 ? idx : -1))
                .filter(idx => idx >= 0);
            if (alive.length === 0) return -1;
            return alive[Math.floor(Math.random() * alive.length)];
        };

        // æŠ€èƒ½1ï¼šåç‰©ç†æŠ¤ç›¾ï¼ˆå…¨ä½“æ•Œæ–¹å•ä½å…ç–«ç‰©ç†ä¼¤å®³ 2å›åˆï¼‰
        if (bossAction === 'anti_physical_shield') {
            const dur = Math.max(1, Math.floor(Number(boss.antiPhysicalDuration || 2)));
            combat.bossBuffs.executusPhysicalShield = dur;
            // é€šå¸¸ä¸¤è€…ä¸å åŠ ï¼šåˆ‡æ¢æŠ¤ç›¾æ—¶æ¸…ç©ºå¦ä¸€ä¾§
            combat.bossBuffs.executusMagicShield = 0;
            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€åç‰©ç†æŠ¤ç›¾ã€‘ï¼æ‰€æœ‰æ•Œæ–¹å•ä½å…ç–«ç‰©ç†ä¼¤å®³ï¼ŒæŒç»­ ${dur} å›åˆ`, 'buff');
        }

        // æŠ€èƒ½2ï¼šå¥¥çˆ†æœ¯ï¼ˆå¯¹å…¨ä½“è§’è‰²é€ æˆ 2Ã—Bossæ”»å‡» çš„æ³•æœ¯ä¼¤å®³ï¼Œè®¡ç®—é­”æŠ—ï¼‰
        else if (bossAction === 'arcane_explosion') {
            const raw = Math.floor((boss.attack || 0) * (boss.arcaneExplosionMultiplier || 2));
            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€å¥¥çˆ†æœ¯ã€‘ï¼`, 'warning');
            combat.playerStates.forEach((ps, pIdx) => {
                if ((ps.currentHp ?? 0) <= 0) return;
                const arc = calcMagicDamage(ps, raw);
                const shieldResult = applyShieldAbsorb(ps, arc.damage, logs, currentRound);
                ps.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(arc.resistReduction * 100);
                const mrText = Number(arc.magicResist) < 0 ? `ï¼ˆæœ‰æ•ˆé­”æŠ— ${Math.floor(arc.magicResist)}ï¼‰` : '';
                const vulnPct = Math.round((arc.spellVulnMult - 1) * 100);
                const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`â†’ å‘½ä¸­ ä½ç½®${pIdx + 1} ${ps.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹å¥¥æœ¯ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);
            });
        }

        // æŠ€èƒ½3ï¼šåé­”æ³•æŠ¤ç›¾ï¼ˆå…¨ä½“æ•Œæ–¹å•ä½å…ç–«æ³•æœ¯ä¼¤å®³ 2å›åˆï¼‰
        else if (bossAction === 'anti_magic_shield') {
            const dur = Math.max(1, Math.floor(Number(boss.antiMagicDuration || 2)));
            combat.bossBuffs.executusMagicShield = dur;
            combat.bossBuffs.executusPhysicalShield = 0;
            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€åé­”æ³•æŠ¤ç›¾ã€‘ï¼æ‰€æœ‰æ•Œæ–¹å•ä½å…ç–«æ³•æœ¯ä¼¤å®³ï¼ŒæŒç»­ ${dur} å›åˆ`, 'buff');
        }

        // å…œåº•ï¼šè‹¥å‡ºç°æœªçŸ¥åŠ¨ä½œï¼Œåˆ™è¿›è¡Œä¸€æ¬¡æ™®é€šç‰©ç†æ”»å‡»
        else {
            const tIdx = pickRandomAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor(boss.attack || 0);
                const dmgResult = calcMitigatedAndBlockedDamage(target, raw);
                const shieldResult = applyShieldAbsorb(target, dmgResult.damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;
                addLog(`ã€${boss.name}ã€‘è¿›è¡Œæ™®é€šæ”»å‡»ï¼Œå‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³`);
            }
        }
    }


    // ==================== ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯ï¼ˆå›¢é˜Ÿé¦–é¢†ï¼‰æŠ€èƒ½å¤„ç† ====================
    // æœºåˆ¶ï¼š
    // - ç«ç„°ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆcalcMagicDamageï¼‰
    // - è¢«åŠ¨ã€è¨å¼—æ‹‰æ–¯ï¼Œç‚é­”æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ‰‹ã€‘ï¼šæ¯å›åˆå¯¹å¦å…‹é€ æˆ 2.5Ã—BOSSæ”»å‡» çš„ç«ç„°ä¼¤å®³
    // - æŠ€èƒ½å¾ªç¯ï¼š
    //   æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ€’ â†’ å…ƒç´ æ€’ç« â†’ å²©æµ†å–·å‘ â†’ è®©ç«ç„°å‡€åŒ–ä¸€åˆ‡ â†’ ä¸‹æ½œ â†’ å…ƒç´ æ€’ç« â†’ å²©æµ†å–·å‘ â†’ è®©ç«ç„°å‡€åŒ–ä¸€åˆ‡ â†’ å¾ªç¯
    // - ç«™ä½ï¼š
    //   * é›†ä¸­ï¼šæ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ€’ æ”¹ä¸ºæ‰“å…¨é˜Ÿ
    //   * åˆ†æ•£ï¼šå…ƒç´ æ€’ç« / å²©æµ†å–·å‘ çš„ç›®æ ‡æ•°ä¼šéšã€ä¸‹æ½œã€‘æ¬¡æ•°å¢é•¿ï¼ˆæ¯æ¬¡ä¸‹æ½œ +1 ç›®æ ‡ï¼‰
    else if (combat.bossId === 'ragnaros') {
        combat.bossBuffs = combat.bossBuffs || {};
        combat.minions = Array.isArray(combat.minions) ? combat.minions : [];

        // åˆå§‹åŒ–
        if (!Number.isFinite(Number(combat.bossBuffs.ragnarosCycleIndex))) combat.bossBuffs.ragnarosCycleIndex = 0;
        if (!Number.isFinite(Number(combat.bossBuffs.ragnarosSubmergeTurns))) combat.bossBuffs.ragnarosSubmergeTurns = 0;
        if (!Number.isFinite(Number(combat.bossBuffs.ragnarosSubmergeCount))) combat.bossBuffs.ragnarosSubmergeCount = 0;
        if (!Number.isFinite(Number(combat.bossBuffs.ragnarosSonSerial))) combat.bossBuffs.ragnarosSonSerial = 0;

        const stance = combat.strategy?.stance || 'balanced';
        const cycle = (Array.isArray(boss.cycle) && boss.cycle.length > 0) ? boss.cycle : ['ragnaros_wrath'];
        const cycleIndex = Math.max(0, Math.floor(Number(combat.bossBuffs.ragnarosCycleIndex) || 0)) % cycle.length;
        const action = cycle[cycleIndex];

        // å·¥å…·ï¼šéšæœºæŠ½å– n ä¸ªå­˜æ´»ç©å®¶ï¼ˆä¸é‡å¤ï¼‰
        const pickNRandomAlivePlayers = (n) => {
            const alive = combat.playerStates
                .map((ps, idx) => ({ idx, hp: ps.currentHp }))
                .filter(x => x.hp > 0)
                .map(x => x.idx);

            const result = [];
            const need = Math.min(Math.max(0, Math.floor(n)), alive.length);

            for (let k = 0; k < need; k++) {
                const r = Math.floor(Math.random() * alive.length);
                result.push(alive[r]);
                alive.splice(r, 1);
            }
            return result;
        };

        // å·¥å…·ï¼šå¯¹æŒ‡å®šç©å®¶é€ æˆç«ç„°æ³•æœ¯ä¼¤å®³ï¼ˆé­”æŠ— + æ‰¿ä¼¤ + æŠ¤ç›¾ï¼‰
        const dealFireDamageToPlayer = (tIdx, rawDamage, prefixText = '') => {
            const target = combat.playerStates[tIdx];
            if (!target || target.currentHp <= 0) return;

            const fire = calcMagicDamage(target, rawDamage);
            const shieldResult = applyShieldAbsorb(target, fire.damage, logs, currentRound);
            target.currentHp -= shieldResult.finalDamage;

            const resPct = Math.round(fire.resistReduction * 100);
            const mrText = fire.magicResist ? `ï¼Œé­”æŠ— ${fire.magicResist}` : '';
            const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';

            addLog(`${prefixText}å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
        };

        // ä¸‹æ½œé˜¶æ®µï¼šBoss æœ¬å›åˆä¸è¡ŒåŠ¨ï¼ˆä»…éšä»è¡ŒåŠ¨ï¼‰ï¼Œä¸”å·²åœ¨ç©å®¶ä¾§åšâ€œå…ç–«æ‰€æœ‰ä¼¤å®³â€
        if (ragnarosSubmergeStart > 0) {
            addLog(`ã€${boss.name}ã€‘ä¸‹æ½œä¸­ï¼ˆå‰©ä½™${ragnarosSubmergeStart}å›åˆï¼‰ï¼šå…ç–«æ‰€æœ‰ä¼¤å®³`, 'buff');
        } else {
            // ===== è¢«åŠ¨ï¼šè¨å¼—æ‹‰æ–¯ï¼Œç‚é­”æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ‰‹ =====
            {
                const tIdx = pickAlivePlayerIndex();
                if (tIdx >= 0) {
                    const target = combat.playerStates[tIdx];
                    const mult = (typeof boss.sulfurasMultiplier === 'number') ? boss.sulfurasMultiplier : 2.5;
                    const raw = Math.floor((boss.attack || 0) * mult);

                    const fire = calcMagicDamage(target, raw);
                    const shieldResult = applyShieldAbsorb(target, fire.damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(fire.resistReduction * 100);
                    const mrText = fire.magicResist ? `ï¼Œé­”æŠ— ${fire.magicResist}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';

                    addLog(`ã€è¨å¼—æ‹‰æ–¯ã€‘æ¯å›åˆç¼çƒ§å‘½ä¸­ å¦å…‹ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`, 'debuff');
                }
            }

            // ===== æŠ€èƒ½ 1ï¼šæ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ€’ =====
            const doWrath = () => {
                const mult = (typeof boss.wrathMultiplier === 'number') ? boss.wrathMultiplier : 3;
                const raw = Math.floor((boss.attack || 0) * mult);

                if (stance === 'concentrated') {
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ€’ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼šå…¨é˜Ÿå—å‡»ï¼‰`, 'warning');
                    combat.playerStates.forEach((ps, idx) => {
                        if (ps.currentHp <= 0) return;
                        dealFireDamageToPlayer(idx, raw, `â†’ ã€æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ€’ã€‘`);
                    });
                } else {
                    const tIdx = pickAlivePlayerIndex();
                    if (tIdx < 0) return;
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ€’ã€‘ï¼ˆé”å®šå¦å…‹ï¼‰`, 'warning');
                    dealFireDamageToPlayer(tIdx, raw, `â†’ ã€æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ€’ã€‘`);
                }
            };

            // ===== æŠ€èƒ½ 2ï¼šå…ƒç´ æ€’ç« + ä½™çƒ¬DOT =====
            const doElementalFury = () => {
                const baseTargets = 1;
                const extraTargets = (stance === 'dispersed')
                    ? Number(combat.bossBuffs.ragnarosSubmergeCount || 0)
                    : 0;

                const targets = pickNRandomAlivePlayers(baseTargets + extraTargets);
                if (targets.length <= 0) return;

                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€å…ƒç´ æ€’ç«ã€‘ï¼ˆç›®æ ‡ ${targets.length} ä¸ªï¼‰`, 'warning');

                const hitMult = (typeof boss.elementalFuryMultiplier === 'number') ? boss.elementalFuryMultiplier : 1.5;
                const dotMult = (typeof boss.emberDotMultiplier === 'number') ? boss.emberDotMultiplier : 1.5;
                const dotDur = Math.max(1, Math.floor(Number(boss.emberDotDuration || 3)));

                const hitRaw = Math.floor((boss.attack || 0) * hitMult);
                const dotRaw = Math.floor((boss.attack || 0) * dotMult);

                targets.forEach(tIdx => {
                    dealFireDamageToPlayer(tIdx, hitRaw, `â†’ ã€å…ƒç´ æ€’ç«ã€‘`);

                    const ps = combat.playerStates[tIdx];
                    if (!ps || ps.currentHp <= 0) return;

                    ps.dots = ps.dots || [];
                    const existing = ps.dots.find(d => d && d.name === 'ä½™çƒ¬');
                    if (existing) {
                        existing.damagePerTurn = dotRaw;
                        existing.duration = dotDur;
                        existing.school = 'fire';
                    } else {
                        ps.dots.push({
                            name: 'ä½™çƒ¬',
                            damagePerTurn: dotRaw,
                            duration: dotDur,
                            school: 'fire',
                        });
                    }

                    addLog(`â†’ ä½ç½®${tIdx + 1} ${ps.char.name} è·å¾—ã€ä½™çƒ¬ã€‘DOTï¼šæ¯å›åˆ ${dotRaw} ç«ç„°ä¼¤å®³ï¼ŒæŒç»­${dotDur}å›åˆ`, 'debuff');
                });
            };

            // ===== æŠ€èƒ½ 3ï¼šå²©æµ†å–·å‘ =====
            const doMagmaEruption = () => {
                const baseTargets = 1;
                const extraTargets = (stance === 'dispersed')
                    ? Number(combat.bossBuffs.ragnarosSubmergeCount || 0)
                    : 0;

                const targets = pickNRandomAlivePlayers(baseTargets + extraTargets);
                if (targets.length <= 0) return;

                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€å²©æµ†å–·å‘ã€‘ï¼ˆç›®æ ‡ ${targets.length} ä¸ªï¼‰`, 'warning');

                const mult = (typeof boss.magmaEruptionMultiplier === 'number') ? boss.magmaEruptionMultiplier : 3;
                const raw = Math.floor((boss.attack || 0) * mult);

                targets.forEach(tIdx => {
                    dealFireDamageToPlayer(tIdx, raw, `â†’ ã€å²©æµ†å–·å‘ã€‘`);
                });
            };

            // ===== æŠ€èƒ½ 5ï¼šè®©ç«ç„°å‡€åŒ–ä¸€åˆ‡ï¼ˆå¤šæ®µçƒ­æµªï¼‰ =====
            const doPurifyAll = () => {
                const waves = Math.max(1, Math.floor(Number(boss.purifyWaves || 3)));
                const mult = (typeof boss.purifyMultiplier === 'number') ? boss.purifyMultiplier : 3;
                const raw = Math.floor((boss.attack || 0) * mult);

                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è®©ç«ç„°å‡€åŒ–ä¸€åˆ‡ã€‘ï¼ˆçƒ­æµª ${waves} æ®µï¼‰`, 'warning');

                for (let w = 1; w <= waves; w++) {
                    combat.playerStates.forEach((ps, idx) => {
                        if (ps.currentHp <= 0) return;
                        dealFireDamageToPlayer(idx, raw, `â†’ ã€çƒ­æµªç¬¬${w}æ®µã€‘`);
                    });
                }
            };

            // ===== æŠ€èƒ½ 4ï¼šä¸‹æ½œï¼ˆå…ç–«3å›åˆï¼Œå¬å”¤ç«ç„°ä¹‹å­ï¼‰ =====
            const doSubmerge = () => {
                const turns = Math.max(1, Math.floor(Number(boss.submergeDuration || 3)));
                combat.bossBuffs.ragnarosSubmergeTurns = turns;
                combat.bossBuffs.ragnarosSubmergeCount = Number(combat.bossBuffs.ragnarosSubmergeCount || 0) + 1;

                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ä¸‹æ½œã€‘ï¼å…ç–«æ‰€æœ‰ä¼¤å®³ï¼ŒæŒç»­ ${turns} å›åˆï¼Œå¹¶å¬å”¤ç«ç„°ä¹‹å­ï¼`, 'buff');

                const addCount = Math.max(0, Math.floor(Number(boss.sonCount || 4)));
                const sonHp = Math.floor(Number(boss.sonHp || 6000000));
                const atk = Math.floor(Number(boss.minion?.attack || boss.attack || 0));
                const def = Math.floor(Number(boss.minion?.defense || boss.defense || 0));
                const sonName = boss.minion?.name || 'ç«ç„°ä¹‹å­';

                for (let k = 0; k < addCount; k++) {
                    const serial = Number(combat.bossBuffs.ragnarosSonSerial || 0) + 1;
                    combat.bossBuffs.ragnarosSonSerial = serial;

                    combat.minions.push({
                        hp: sonHp,
                        maxHp: sonHp,
                        attack: atk,
                        defense: def,
                        immune: false,
                        dots: [],
                        isSonOfFlame: true,
                        displayName: `${sonName}${serial}`,
                    });
                }

                if (addCount > 0) {
                    addLog(`â†’ å¬å”¤ ${addCount} ä¸ªã€${sonName}ã€‘ï¼ˆHP ${sonHp}ï¼‰`, 'warning');
                }
            };

            // ===== æ‰§è¡ŒåŠ¨ä½œï¼ˆä½¿ç”¨ç‹¬ç«‹å¾ªç¯æŒ‡é’ˆï¼›ä¸‹æ½œæœŸé—´ä¸ä¼šæ¨è¿›ï¼‰ =====
            switch (action) {
                case 'ragnaros_wrath':
                    doWrath();
                    break;
                case 'elemental_fury':
                    doElementalFury();
                    break;
                case 'magma_eruption':
                    doMagmaEruption();
                    break;
                case 'purify_all':
                    doPurifyAll();
                    break;
                case 'submerge':
                    doSubmerge();
                    break;
                default:
                    doWrath();
                    break;
            }

            // æ¨è¿›å¾ªç¯ï¼ˆä¸‹æ½œæœ¬èº«ç®—ä¸€æ¬¡åŠ¨ä½œï¼‰
            combat.bossBuffs.ragnarosCycleIndex = (cycleIndex + 1) % cycle.length;
        }
    }

// ==================== æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰æŠ€èƒ½å¤„ç† ====================
    else if (combat.bossId === 'ossirian') {
        // è‡ªç„¶ä¼¤å®³ï¼šè®¡ç®—é­”æŠ—ï¼ˆå¹¶å¥—ç”¨ä¼¤å®³å‡å…/å…¨èƒ½/æŒ«å¿—æ€’å¼ï¼‰
        const calcNatureDamage = (playerState, rawDamage) => {
            const magicResist = playerState?.char?.stats?.magicResist || 0;
            const resistReduction = getMagicResistDamageReduction(magicResist);
            let damage = Math.floor((rawDamage || 0) * (1 - resistReduction));

            const takenMult = playerState?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (playerState?.buffs) {
                playerState.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }

            const demoralizingShoutMult = combat.bossDebuffs?.demoralizingShout?.damageMult ?? 1;
            const versTakenMult = getVersatilityDamageTakenMult(playerState?.char?.stats?.versatility);
            const atonementTakenMult = getAtonementDamageTakenMult(playerState);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * demoralizingShoutMult * versTakenMult));

            return { damage, resistReduction, magicResist };
        };

        // æ–½åŠ ã€å •è½ä¹‹è¡€ã€‘ï¼ˆæ°¸ä¹…å å±‚ä¸­æ¯’DOTï¼š0.5Ã—Bossæ”»å‡»/å±‚/å›åˆï¼Œæš—å½±ä¼¤å®³ï¼‰
        const applyCorruptedBlood = (ps, pIdx) => {
            if (!ps || ps.currentHp <= 0) return;

            // âœ… çŸ®äººï¼šé¦–æ¬¡ä¸­æ¯’å…ç–«
            if (tryFirstDebuffImmunity(ps, 'poison', pIdx, 'å •è½ä¹‹è¡€')) {
                addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å…ç–«äº†ã€å •è½ä¹‹è¡€ã€‘`, 'debuff');
                return;
            }

            ps.dots = ps.dots || [];
            const mult = boss.corruptedBloodDotMultiplier ?? 0.5;
            const base = Math.floor((boss.attack || 0) * mult);

            const existing = ps.dots.find(d => d && d.name === 'å •è½ä¹‹è¡€');
            if (existing) {
                existing.stacks = (existing.stacks || 1) + 1;
                existing.type = 'poison';
                existing.isPoison = true;
                existing.school = 'shadow';
                existing.isPermanent = true;
                existing.duration = existing.duration ?? 999;

                const perTurn = Math.max(1, Math.floor(base * (existing.stacks || 1)));
                existing.damagePerTurn = perTurn;

                addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} çš„ã€å •è½ä¹‹è¡€ã€‘å åŠ åˆ°${existing.stacks}å±‚ï¼ˆæ¯å›åˆ${perTurn}ç‚¹æš—å½±ä¼¤å®³ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸï¼‰`, 'debuff');
            } else {
                const perTurn = Math.max(1, base);
                ps.dots.push({
                    name: 'å •è½ä¹‹è¡€',
                    type: 'poison',
                    isPoison: true,
                    school: 'shadow',
                    stacks: 1,
                    damagePerTurn: perTurn,
                    duration: 999,
                    isPermanent: true
                });
                addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} è·å¾—ã€å •è½ä¹‹è¡€ã€‘ï¼ˆæ¯å›åˆ${perTurn}ç‚¹æš—å½±ä¼¤å®³ï¼Œå¯å å±‚åˆ°æˆ˜æ–—ç»“æŸï¼‰`, 'debuff');
            }
        };

        // å…œåº•ï¼šå¦‚æœæ°´æ™¶æ­»äºDOTç­‰ï¼Œåœ¨Bosså‡ºæ‰‹å‰ä¹Ÿå¤„ç†ä¸€æ¬¡
        processOssirianCrystalDeaths();

        // æŠ€èƒ½1ï¼šå¥¥æ–¯é‡Œå®‰ä¹‹åŠ›ï¼ˆ10Ã—æ”»å‡»ï¼Œç‰©ç†ä¼¤å®³ï¼Œæ‰“å½“å‰å¦å…‹ï¼‰
        if (bossAction === 'ossirian_strength') {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx >= 0) {
                const target = combat.playerStates[tIdx];
                const raw = Math.floor((boss.attack || 0) * (boss.ossirianStrengthMultiplier || 10));
                const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, true);
                const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
                target.currentHp -= shieldResult.finalDamage;

                const drPct = Math.round(dr * 100);
                const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€å¥¥æ–¯é‡Œå®‰ä¹‹åŠ›ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
            } else {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€å¥¥æ–¯é‡Œå®‰ä¹‹åŠ›ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
            }
        }

        // æŠ€èƒ½2ï¼šè·µè¸ï¼ˆ3Ã—æ”»å‡»ï¼Œè‡ªç„¶ï¼›åˆ†æ•£ç«™ä½é¢å¤–å‡»é£1å›åˆï¼‰
        else if (bossAction === 'trample') {
            const raw = Math.floor((boss.attack || 0) * (boss.trampleMultiplier || 3));
            const isDispersed = combat.strategy.stance === 'dispersed';

            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€è·µè¸ã€‘${isDispersed ? 'ï¼ˆåˆ†æ•£ç«™ä½ï¼šé™„å¸¦å‡»é£ï¼‰' : ''}ï¼`);

            combat.playerStates.forEach((ps, pIdx) => {
                if (!ps || ps.currentHp <= 0) return;

                const nat = calcNatureDamage(ps, raw);
                const shieldResult = applyShieldAbsorb(ps, nat.damage, logs, currentRound);
                ps.currentHp -= shieldResult.finalDamage;

                const resPct = Math.round(nat.resistReduction * 100);
                const mrText = Number(nat.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(nat.magicResist)}ï¼‰` : '';
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹è‡ªç„¶ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);

                if (isDispersed && ps.currentHp > 0) {
                    ps.debuffs = ps.debuffs || {};
                    ps.debuffs.knockup = { duration: Math.max(1, Math.floor(Number(boss.knockupDuration || 1))) };
                }
            });

            if (isDispersed) {
                addLog(`â†’ åˆ†æ•£ç«™ä½è§¦å‘ã€å‡»é£ã€‘ï¼šå…¨ä½“ä¸‹ä¸€å›åˆæ— æ³•è¡ŒåŠ¨`, 'debuff');
            }
        }
        // æŠ€èƒ½4ï¼šç»“èˆŒè¯…å’’ï¼ˆæ‰€æœ‰è§’è‰²æ€¥é€Ÿ/æš´å‡»é™ä¸º0ï¼ŒæŒç»­3å›åˆï¼‰
        else if (bossAction === 'tongue_curse') {
            const dur = Math.max(1, Math.floor(Number(boss.tongueCurseDuration || 3)));
            addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€ç»“èˆŒè¯…å’’ã€‘ï¼æ‰€æœ‰è§’è‰²æ€¥é€Ÿä¸æš´å‡»é™ä¸º0ï¼ˆæŒç»­${dur}å›åˆï¼‰`, 'debuff');

            combat.playerStates.forEach((ps) => {
                if (!ps || ps.currentHp <= 0) return;
                ps.debuffs = ps.debuffs || {};
                ps.debuffs.tongueCurse = { duration: dur };
            });
        }

        // æŠ€èƒ½5ï¼šåŒ…å›´ä¹‹é£ï¼ˆé»˜è®¤éšæœºï¼›é›†ä¸­ç«™ä½æ”¹ä¸ºå…¨ä½“ï¼‰
        else if (bossAction === 'surrounding_winds') {
            const raw = Math.floor((boss.attack || 0) * (boss.surroundingWindsMultiplier || 3));

            if (combat.strategy.stance === 'concentrated') {
                addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€åŒ…å›´ä¹‹é£ã€‘ï¼ˆé›†ä¸­ç«™ä½ï¼šå…¨ä½“ï¼‰ï¼`);
                combat.playerStates.forEach((ps, pIdx) => {
                    if (!ps || ps.currentHp <= 0) return;

                    const nat = calcNatureDamage(ps, raw);
                    const shieldResult = applyShieldAbsorb(ps, nat.damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(nat.resistReduction * 100);
                    const mrText = Number(nat.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(nat.magicResist)}ï¼‰` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`â†’ ä½ç½®${pIdx + 1} ${ps.char.name} å—åˆ° ${shieldResult.finalDamage} ç‚¹è‡ªç„¶ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
                });
            } else {
                const candidates = combat.playerStates
                    .map((ps, idx) => ({ ps, idx }))
                    .filter(o => (o.ps?.currentHp ?? 0) > 0)
                    .map(o => o.idx);

                if (candidates.length <= 0) {
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€åŒ…å›´ä¹‹é£ã€‘ï¼Œä½†æ²¡æœ‰å­˜æ´»ç›®æ ‡`);
                } else {
                    const tIdx = candidates[Math.floor(Math.random() * candidates.length)];
                    const target = combat.playerStates[tIdx];

                    const nat = calcNatureDamage(target, raw);
                    const shieldResult = applyShieldAbsorb(target, nat.damage, logs, currentRound);
                    target.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(nat.resistReduction * 100);
                    const mrText = Number(nat.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(nat.magicResist)}ï¼‰` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                    addLog(`ã€${boss.name}ã€‘æ–½æ”¾ã€åŒ…å›´ä¹‹é£ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹è‡ªç„¶ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
                }
            }
        }
    }


// ==================== å°å¼Ÿè¡ŒåŠ¨ ====================
    for (let i = 0; i < (combat.minions || []).length; i++) {
        const m = combat.minions[i];
        if ((m.hp ?? 0) <= 0) continue;

        // æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰ï¼šæ±²èƒ½æ°´æ™¶ä¸è¿›è¡Œæ”»å‡»è¡ŒåŠ¨
        if (combat.bossId === 'ossirian' && m.isEnergyCrystal) {
            continue;
        }

        // èŒƒå…‹é‡Œå¤«çš„ç«ç‚®æ‰‹ï¼šå¯¹å…¨é˜Ÿé€ æˆAOEä¼¤å®³
        if (combat.bossId === 'vancleef' && m.isCannoneer) {
            const baseAoeDamage = Math.floor((boss.attack || 0) * (boss.minion.aoeDamageMultiplier || 0.5));

            combat.playerStates.forEach((ps, pIdx) => {
                if (ps.currentHp <= 0) return;

                const armor = ps.char?.stats?.armor || 0;
                const dr = getArmorDamageReduction(armor);
                let dmg = applyPhysicalMitigation(baseAoeDamage, armor);

                // å—ä¼¤ä¹˜åŒº
                const takenMult = ps.char?.stats?.damageTakenMult ?? 1;
                let buffTakenMult = 1;
                if (ps.buffs) {
                    ps.buffs.forEach(b => {
                        if (b.damageTakenMult) {
                            buffTakenMult *= b.damageTakenMult;
                        }
                    });
                }
                const demoralizingShoutMult = combat.bossDebuffs?.demoralizingShout?.damageMult ?? 1;
                const versTakenMult = getVersatilityDamageTakenMult(ps.char?.stats?.versatility);
                dmg = Math.max(1, Math.floor(dmg * takenMult * buffTakenMult * getAtonementDamageTakenMult(ps) * demoralizingShoutMult * versTakenMult));

                // æŠ¤ç›¾å¸æ”¶
                const shieldResult = applyShieldAbsorb(ps, dmg, logs, currentRound);
                ps.currentHp -= shieldResult.finalDamage;

                // âœ… ä¿®å¤ï¼šè®¡ç®— drPct
                const drPct = Math.round(dr * 100);
                const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
                addLog(`ã€${boss.minion.name}${i + 1}ã€‘ç‚®å‡» ä½ç½®${pIdx + 1} ${ps.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${shieldText}ï¼‰`);
            });
        }

        // æ‹‰æ ¼çº³ç½—æ–¯çš„ç«ç„°ä¹‹å­ï¼šæ¯å›åˆå¯¹éšæœº2ç›®æ ‡é‡Šæ”¾ã€ç¼çƒ§ã€‘ï¼ˆ1.2Ã—BOSSæ”»å‡»çš„ç«ç„°æ³•æœ¯ä¼¤å®³ï¼‰
        else if (combat.bossId === 'ragnaros' && m.isSonOfFlame) {
            const aliveIdx = combat.playerStates
                .map((ps, idx) => ({ idx, hp: ps.currentHp }))
                .filter(x => x.hp > 0)
                .map(x => x.idx);

            if (aliveIdx.length > 0) {
                const n = Math.max(1, Math.floor(Number(boss.sonBurnTargets || 2)));
                const picked = [];
                const pool = aliveIdx.slice();
                const need = Math.min(n, pool.length);

                for (let k = 0; k < need; k++) {
                    const r = Math.floor(Math.random() * pool.length);
                    picked.push(pool[r]);
                    pool.splice(r, 1);
                }

                const mult = (typeof boss.sonBurnMultiplier === 'number') ? boss.sonBurnMultiplier : 1.2;
                const raw = Math.floor((boss.attack || 0) * mult);
                const sonLabel = m.displayName || (boss.minion?.name ? `${boss.minion.name}${i + 1}` : `ç«ç„°ä¹‹å­${i + 1}`);

                picked.forEach(pIdx => {
                    const ps = combat.playerStates[pIdx];
                    if (!ps || ps.currentHp <= 0) return;

                    const fire = calcMagicDamage(ps, raw);
                    const shieldResult = applyShieldAbsorb(ps, fire.damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(fire.resistReduction * 100);
                    const mrText = fire.magicResist ? `ï¼Œé­”æŠ— ${fire.magicResist}` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';

                    addLog(`ã€${sonLabel}ã€‘æ–½æ”¾ã€ç¼çƒ§ã€‘å‘½ä¸­ ä½ç½®${pIdx + 1} ${ps.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
                });
            }
        }
        // ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ï¼šçƒˆç„°è¡Œè€…åŒ»å¸ˆ/ç²¾è‹±ï¼ˆæ¯å›åˆè¢«åŠ¨ï¼‰
        else if (combat.bossId === 'majordomo_executus' && (m.isFlamewakerHealer || m.isFlamewakerElite)) {
            // åŒ»å¸ˆï¼šæ¯å›åˆä¸ºæ‰€æœ‰å·±æ–¹å•ä½å›å¤ 10 * Bossæ”»å‡» çš„ç”Ÿå‘½
            if (m.isFlamewakerHealer) {
                const rawHeal = Math.floor((boss.attack || 0) * (boss.healerHealMultiplier || 10));
                const label = m.displayName || (boss.healerName || 'çƒˆç„°è¡Œè€…åŒ»å¸ˆ');

                // Boss
                const bossMaxHp = Number(boss.maxHp || bossBase.maxHp || 0);
                const bossBefore = Number(combat.bossHp || 0);
                const bossHealed = Math.max(0, Math.min(rawHeal, Math.max(0, bossMaxHp - bossBefore)));
                if (bossHealed > 0) {
                    combat.bossHp = bossBefore + bossHealed;
                }

                // éšä»ï¼ˆåŒ…å«è‡ªå·±ï¼‰
                let addsHealedTotal = 0;
                combat.minions.forEach(mm => {
                    if (!mm || (mm.hp ?? 0) <= 0) return;
                    const before = Number(mm.hp || 0);
                    const maxHp = Number(mm.maxHp || before);
                    const healed = Math.max(0, Math.min(rawHeal, Math.max(0, maxHp - before)));
                    if (healed > 0) {
                        mm.hp = before + healed;
                        addsHealedTotal += healed;
                    }
                });

                addLog(`ã€${label}ã€‘è¢«åŠ¨ï¼šä¸ºå·±æ–¹å…¨ä½“å›å¤ ${rawHeal.toLocaleString()} ç”Ÿå‘½ï¼ˆBoss+${bossHealed.toLocaleString()}ï¼Œéšä»åˆè®¡+${addsHealedTotal.toLocaleString()}ï¼‰`);
            }

            // ç²¾è‹±ï¼šæ¯å›åˆå¯¹æ‰€æœ‰è§’è‰²é€ æˆ 1.5 * Bossæ”»å‡» çš„æ³•æœ¯ä¼¤å®³
            if (m.isFlamewakerElite) {
                const raw = Math.floor((boss.attack || 0) * (boss.eliteAoEDamageMultiplier || 1.5));
                const label = m.displayName || (boss.eliteName || 'çƒˆç„°è¡Œè€…ç²¾è‹±');

                combat.playerStates.forEach((ps, pIdx) => {
                    if ((ps.currentHp ?? 0) <= 0) return;

                    const { damage, resistReduction, magicResist } = calcMagicDamage(ps, raw);
                    const shieldResult = applyShieldAbsorb(ps, damage, logs, currentRound);
                    ps.currentHp -= shieldResult.finalDamage;

                    const resPct = Math.round(resistReduction * 100);
                    const mrText = magicResist < 0 ? `ï¼ˆæœ‰æ•ˆé­”æŠ— ${Math.floor(magicResist)}ï¼‰` : '';
                    const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';

                    addLog(`ã€${label}ã€‘å‘½ä¸­ ä½ç½®${pIdx + 1} ${ps.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹æ³•æœ¯ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
                });
            }
        }
// åŠ ä¸çš„äº¡çµå­¦å¾’ï¼šæ¯å›åˆéšæœºé‡Šæ”¾æš—å½±ç®­
        else if (combat.bossId === 'darkmaster_gandling' && m.isApprentice) {
            const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
            if (alivePlayers.length <= 0) break;

            // éšæœºé€‰æ‹©ä¸€ä¸ªç›®æ ‡
            const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
            const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);
            if (tIdx < 0) continue;

            const target = combat.playerStates[tIdx];

            // è®¡ç®—æœ‰æ•ˆé­”æŠ—ï¼ˆè€ƒè™‘ã€æš—å½±è¯…å’’ã€‘ï¼‰
            const baseMR = target.char?.stats?.magicResist || 0;
            const curseDelta = target.debuffs?.shadowCurse?.magicResistDelta || 0;
            const effectiveMR = baseMR + curseDelta;

            const raw = Math.floor((boss.attack || 0) * (boss.minionShadowBoltMultiplier || 2));
            const resistReduction = getMagicResistDamageReduction(effectiveMR);
            let damage = Math.floor(raw * (1 - resistReduction));

            // åº”ç”¨å—ä¼¤å‡å…
            const takenMult = target?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (target?.buffs) {
                target.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }
            const versTakenMult = getVersatilityDamageTakenMult(target?.char?.stats?.versatility);
            const atonementTakenMult = getAtonementDamageTakenMult(target);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * versTakenMult));

            // æŠ¤ç›¾å¸æ”¶
            const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
            target.currentHp -= shieldResult.finalDamage;

            const resPct = Math.round(resistReduction * 100);
            const mrText = effectiveMR < 0 ? `ï¼ˆæœ‰æ•ˆé­”æŠ— ${Math.floor(effectiveMR)}ï¼‰` : '';
            const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
            const minionName = boss.minion?.name || 'äº¡çµå­¦å¾’';
            addLog(`ã€${minionName}${i + 1}ã€‘æ–½æ”¾ã€æš—å½±ç®­ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹æš—å½±ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
        }


        // åŠ å°”çš„ç«å…ƒç´ ï¼šæ¯å›åˆæ–½æ”¾ã€ç¼çƒ­ä¹‹ç—›ã€‘ï¼ˆç«ç„°ä¼¤å®³è®¡ç®—é­”æŠ—ï¼‰ï¼Œå¹¶å åŠ â€œæ³•æœ¯æ˜“ä¼¤â€
        else if (combat.bossId === 'garr' && m.isFireElemental) {
            const alivePlayers = combat.playerStates.filter(p => p.currentHp > 0);
            if (alivePlayers.length <= 0) break;

            // éšæœºé€‰æ‹©ä¸€ä¸ªç›®æ ‡
            const randomTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
            const tIdx = combat.playerStates.findIndex(p => p.char.id === randomTarget.char.id);
            if (tIdx < 0) continue;

            const target = combat.playerStates[tIdx];

            const raw = Math.floor((boss.attack || 0) * (boss.scorchingPainMultiplier || 1.5));
            const fire = calcMagicDamage(target, raw);

            // æŠ¤ç›¾å¸æ”¶
            const shieldResult = applyShieldAbsorb(target, fire.damage, logs, currentRound);
            target.currentHp -= shieldResult.finalDamage;

            const resPct = Math.round(fire.resistReduction * 100);
            const mrText = Number(fire.magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(fire.magicResist)}ï¼‰` : '';
            const vulnPct = Math.round((fire.spellVulnMult - 1) * 100);
            const vulnText = vulnPct > 0 ? `ï¼Œæ³•æœ¯æ˜“ä¼¤+${vulnPct}%` : '';
            const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
            const minionName = boss.minion?.name || 'ç«å…ƒç´ ';
            addLog(`ã€${minionName}${i + 1}ã€‘æ–½æ”¾ã€ç¼çƒ­ä¹‹ç—›ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ç«ç„°ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${vulnText}${shieldText}ï¼‰`);

            // å åŠ æ³•æœ¯æ˜“ä¼¤ï¼ˆæŒç»­åˆ°æˆ˜æ–—ç»“æŸï¼Œå¯å å±‚ï¼‰
            if (target.currentHp > 0) {
                target.debuffs = target.debuffs || {};
                const per = (typeof boss.spellVulnerabilityPerStack === 'number' && Number.isFinite(boss.spellVulnerabilityPerStack) && boss.spellVulnerabilityPerStack > 0)
                    ? boss.spellVulnerabilityPerStack
                    : 0.02;

                const existing = target.debuffs.spellVulnerability;
                if (existing && typeof existing === 'object') {
                    existing.stacks = (existing.stacks || 0) + 1;
                    existing.pctPerStack = per;
                } else {
                    target.debuffs.spellVulnerability = { stacks: 1, pctPerStack: per };
                }

                const stacks = target.debuffs.spellVulnerability.stacks || 1;
                const totalPct = Math.round(stacks * per * 100);
                addLog(`â†’ ä½ç½®${tIdx + 1} ${target.char.name} è·å¾—ã€æ³•æœ¯æ˜“ä¼¤ã€‘ï¼šæ³•æœ¯ä¼¤å®³æ‰¿å— +${Math.round(per * 100)}%ï¼ˆå½“å‰${stacks}å±‚ï¼Œæ€»+${totalPct}%ï¼‰ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸ`, 'debuff');
            }
        }

        // ç„šåŒ–è€…å¤é›·æ›¼æ ¼ï¼šç†”ç«æ¶çŠ¬å¯¹å¦å…‹è¿›è¡Œæ™®é€šæ”»å‡»ï¼ˆç‰©ç†ï¼ŒåƒæŠ¤ç”²/æ ¼æŒ¡ï¼‰ï¼ŒBossâ‰¤30%è¡€é‡åè¿›å…¥ç‹‚æš´
        else if (combat.bossId === 'golemagg' && m.isMoltenHound) {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx < 0) break;

            const target = combat.playerStates[tIdx];

            // ç‹‚æ€’å å±‚ï¼ˆå¢ä¼¤ï¼‰ï¼šç”±BossæŠ€èƒ½ã€ç‹‚æ€’ã€‘å åŠ 
            combat.bossBuffs = combat.bossBuffs || {};
            const furyStacks = Math.max(0, Math.floor(Number(combat.bossBuffs.furyStacks || 0)));
            const furyPer = (typeof boss.furyPerStack === 'number' && Number.isFinite(boss.furyPerStack) && boss.furyPerStack > 0)
                ? boss.furyPerStack
                : 0.05;
            const furyMult = 1 + furyStacks * furyPer;

            // åˆ¤æ–­ç†”ç«æ¶çŠ¬ç‹‚æš´ï¼ˆBossè¡€é‡ â‰¤ 30%ï¼‰
            const enragePct = (typeof boss.houndEnrageHpPct === 'number' && Number.isFinite(boss.houndEnrageHpPct) && boss.houndEnrageHpPct > 0)
                ? boss.houndEnrageHpPct
                : 0.30;

            const hpPct = ((combat.bossHp ?? 0) > 0 && (boss.maxHp || 0) > 0)
                ? (combat.bossHp / (boss.maxHp || 1))
                : 1;

            const enraged = !!combat.bossBuffs.houndsEnraged || (hpPct <= enragePct);
            if (enraged && !combat.bossBuffs.houndsEnraged) {
                // å…œåº•ï¼šå¦‚æœæ²¡åœ¨Bossé˜¶æ®µæ ‡è®°åˆ°ï¼ˆä¾‹å¦‚Bossé˜¶æ®µè¢«è·³è¿‡ï¼‰ï¼Œè¿™é‡Œä¹Ÿæ ‡è®°ä¸€æ¬¡
                combat.bossBuffs.houndsEnraged = true;
                addLog(`ã€${boss.name}ã€‘ç”Ÿå‘½å€¼ä½äº ${Math.round(enragePct * 100)}%ï¼ä¸¤åªã€${boss.minion?.name || 'ç†”ç«æ¶çŠ¬'}ã€‘è¿›å…¥ã€ç‹‚æš´ã€‘ï¼`, 'warning');
            }

            const mult = enraged
                ? (boss.houndEnrageMultiplier || 3)
                : (boss.houndNormalMultiplier || 1.2);

            const raw = Math.floor((boss.attack || m.attack || 0) * mult * furyMult);
            const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, false);

            const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
            target.currentHp -= shieldResult.finalDamage;

            const drPct = Math.round(dr * 100);
            const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
            const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
            const furyText = furyStacks > 0 ? `ï¼Œç‹‚æ€’+${Math.round(furyStacks * furyPer * 100)}%` : '';
            const enrageText = enraged ? 'ã€ç‹‚æš´ã€‘' : '';
            const minionName = boss.minion?.name || 'ç†”ç«æ¶çŠ¬';

            addLog(`ã€${minionName}${i + 1}ã€‘${enrageText}æ’•å’¬ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ä¼¤å®³${furyText}ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
        }

        // ç‘æ–‡æˆ´å°”ç”·çˆµçš„éª·é«…ï¼šå¯¹å¦å…‹ï¼ˆ1å·ä½ï¼‰æŒ¥ç æ”»å‡»
        else if (combat.bossId === 'baron_rivendare' && m.isSkeleton) {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx < 0) break;

            const target = combat.playerStates[tIdx];
            const raw = Math.floor((boss.attack || 0) * (boss.skeletonSlashMultiplier || 1.2));
            const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, false);

            const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
            target.currentHp -= shieldResult.finalDamage;

            const drPct = Math.round(dr * 100);
            const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
            const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
            const minionName = boss.minion?.name || 'éª·é«…æˆ˜å£«';
            addLog(`ã€${minionName}${i + 1}ã€‘æŒ¥ç  ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
        }

        // å“ˆå¡ä¹‹å­ï¼šé…¸æ¶²ï¼ˆè‡ªç„¶ä¼¤å®³ï¼Œè®¡ç®—é­”æŠ—ï¼‰ï¼Œå‘½ä¸­å½“å‰å¦å…‹
        else if (combat.bossId === 'hakkar' && m.isHakkarSon) {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx < 0) break;

            const target = combat.playerStates[tIdx];

            const raw = Math.floor((boss.attack || 0) * (boss.acidMultiplier || 1.2));
            const magicResist = target.char?.stats?.magicResist || 0;
            const resistReduction = getMagicResistDamageReduction(magicResist);

            let damage = Math.floor(raw * (1 - resistReduction));

            // åº”ç”¨å—ä¼¤å‡å…
            const takenMult = target?.char?.stats?.damageTakenMult ?? 1;
            let buffTakenMult = 1;
            if (target?.buffs) {
                target.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult;
                });
            }
            const demoralizingShoutMult = combat.bossDebuffs?.demoralizingShout?.damageMult ?? 1;
            const versTakenMult = getVersatilityDamageTakenMult(target?.char?.stats?.versatility);
            const atonementTakenMult = getAtonementDamageTakenMult(target);
            damage = Math.max(1, Math.floor(damage * takenMult * buffTakenMult * atonementTakenMult * demoralizingShoutMult * versTakenMult));

            // æŠ¤ç›¾å¸æ”¶
            const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
            target.currentHp -= shieldResult.finalDamage;

            const resPct = Math.round(resistReduction * 100);
            const mrText = Number(magicResist) < 0 ? `ï¼ˆé­”æŠ— ${Math.floor(magicResist)}ï¼‰` : '';
            const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
            const minionName = boss.minion?.name || 'å“ˆå¡ä¹‹å­';
            addLog(`ã€${minionName}${i + 1}ã€‘å–·åã€é…¸æ¶²ã€‘å‘½ä¸­ ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹è‡ªç„¶ä¼¤å®³ï¼ˆé­”æŠ—å‡ä¼¤${resPct}%${mrText}${shieldText}ï¼‰`);
        }

// éœæ ¼çš„å°å¼Ÿï¼šæ™®é€šæ”»å‡»
        else {
            const tIdx = pickAlivePlayerIndex();
            if (tIdx < 0) break;

            const target = combat.playerStates[tIdx];
            const raw = Math.floor(m.attack || 0);
            const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, false);

            target.currentHp -= damage;

            const drPct = Math.round(dr * 100);
            const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
            const minionName = boss.minion?.name || 'å°å¼Ÿ';
            addLog(`ã€${minionName}ã€‘æ”»å‡» ä½ç½®${tIdx + 1} é€ æˆ ${damage} ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}ï¼‰`);
        }
        // è¨å°”è¯ºæ–¯çš„åå­—å†›ï¼šå¯¹å¦å…‹ï¼ˆ1å·ä½ï¼‰é€ æˆæ™®é€šæ”»å‡»
        if (combat.bossId === 'thalnos' && m.isCrusader) {
            const tIdx = pickAlivePlayerIndex(); // æ€»æ˜¯æ‰“1å·ä½ï¼ˆå¦å…‹ï¼‰
            if (tIdx < 0) break;

            const target = combat.playerStates[tIdx];
            const raw = Math.floor(m.attack || boss.attack || 0);
            const { damage, dr, blockedAmount } = calcMitigatedAndBlockedDamage(target, raw, false);

            // æŠ¤ç›¾å¸æ”¶
            const shieldResult = applyShieldAbsorb(target, damage, logs, currentRound);
            target.currentHp -= shieldResult.finalDamage;

            const drPct = Math.round(dr * 100);
            const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
            const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
            addLog(`ã€${boss.minion.name}${i + 1}ã€‘æ”»å‡» ä½ç½®${tIdx + 1} ${target.char.name}ï¼Œé€ æˆ ${shieldResult.finalDamage} ç‚¹ä¼¤å®³ï¼ˆæŠ¤ç”²å‡ä¼¤${drPct}%${blockText}${shieldText}ï¼‰`);
        }
    }

    // æ¸…ç†æ­»äº¡å°å¼Ÿ
    combat.minions = (combat.minions || []).filter(m => (m.hp ?? 0) > 0);

    // ==================== ç©å®¶èº«ä¸Šçš„DOTç»“ç®— ====================
    combat.playerStates.forEach((ps, pIdx) => {
        if (ps.currentHp <= 0) return;
        if (!ps.dots || ps.dots.length === 0) return;

        ps.dots = ps.dots.filter(dot => {
            // âœ… çŸ®äººï¼šçŸ³åƒå½¢æ€ - æœ¬åœºé¦–æ¬¡ä¸­æ¯’å…ç–«
            // çº¦å®šï¼špoison DOT ä½¿ç”¨ school: 'poison'ï¼ˆæˆ–æ˜¾å¼ type/isPoison æ ‡è®°ï¼‰
            const isPoisonDot = dot?.school === 'poison' || dot?.type === 'poison' || dot?.isPoison === true;
            if (isPoisonDot && tryFirstDebuffImmunity(ps, 'poison', pIdx, dot?.name || 'ä¸­æ¯’')) {
                addLog(`â†’ ã€${dot?.name || 'ä¸­æ¯’'}ã€‘è¢«å…ç–«ï¼Œæœªäº§ç”Ÿä¼¤å®³`, 'debuff');
                return false;
            }

            // DOTä¼¤å®³ç±»å‹ï¼š
            // - physicalï¼šæ²¿ç”¨ç°æœ‰é€»è¾‘ï¼ˆä¸»è¦ç”¨äºâ€œæµè¡€â€ï¼‰
            // - å…¶ä»–ï¼ˆfire/shadow/...ï¼‰ï¼šæŒ‰é­”æŠ—å‡ä¼¤ï¼ˆæ»¡è¶³â€œç«ç„°ä¼¤å®³è®¡ç®—é­”æŠ—â€è®¾è®¡ï¼‰
            const versTakenMult = getVersatilityDamageTakenMult(ps.char?.stats?.versatility);

            let base = Math.floor(dot.damagePerTurn || 0);
            let extraText = '';
            let spellVulnMult = 1;

            if (dot.school && dot.school !== 'physical') {
                const magicResist = ps.char?.stats?.magicResist || 0;
                const resistReduction = getMagicResistDamageReduction(magicResist);
                base = Math.floor(base * (1 - resistReduction));

                // æ³•æœ¯æ˜“ä¼¤ï¼šä»…å¯¹â€œéç‰©ç†â€DOTç”Ÿæ•ˆ
                spellVulnMult = getSpellVulnerabilityMult(ps);
                const vulnPct = Math.round((spellVulnMult - 1) * 100);

                const parts = [];
                parts.push(`é­”æŠ—å‡ä¼¤${Math.round(resistReduction * 100)}%`);
                if (vulnPct > 0) parts.push(`æ³•æœ¯æ˜“ä¼¤+${vulnPct}%`);
                extraText = parts.length ? `ï¼ˆ${parts.join('ï¼Œ')}ï¼‰` : '';
            }

            // âœ… æŠŠâ€œå—ä¼¤ä¹˜åŒºâ€è¡¥é½ï¼šè§’è‰²å¸¸é©» + buff(ç›¾å¢™ç­‰) + æŒ«å¿—æ€’å¼ + å…¨èƒ½
            const takenMult = ps.char?.stats?.damageTakenMult ?? 1;

            let buffTakenMult = 1;
            if (ps.buffs) {
                ps.buffs.forEach(b => {
                    if (b.damageTakenMult) buffTakenMult *= b.damageTakenMult; // ç›¾å¢™ç­‰
                });
            }

            // æŒ«å¿—æ€’å¼ï¼ˆbossDebuffs.demoralizingShoutï¼‰å·²æœ‰åœ¨åˆ«å¤„ç”¨ï¼Œè¿™é‡Œä¹Ÿè¡¥ä¸Š
            const demoralizingShoutMult = combat.bossDebuffs?.demoralizingShout?.damageMult ?? 1;

            // æœ€ç»ˆ DOT ä¼¤å®³
            let dmg = Math.max(1, Math.floor(base * takenMult * buffTakenMult * getAtonementDamageTakenMult(ps) * demoralizingShoutMult * versTakenMult * spellVulnMult));

            // ï¼ˆå¯é€‰ä½†æ¨èï¼‰DOT ä¹Ÿç»è¿‡æŠ¤ç›¾å¸æ”¶ï¼Œå’Œå…¶å®ƒä¼¤å®³ç»Ÿä¸€
            const shieldResult = applyShieldAbsorb(ps, dmg, logs, currentRound);
            ps.currentHp -= shieldResult.finalDamage;

            const shieldText = shieldResult.absorbed > 0 ? `ï¼ŒæŠ¤ç›¾å¸æ”¶ ${shieldResult.absorbed}` : '';
            const stackText = dot.stacks ? `ï¼ˆ${dot.stacks}å±‚ï¼‰` : '';
            addLog(
                `ã€${dot.name}ã€‘${stackText}å¯¹ ä½ç½®${pIdx + 1} ${ps.char.name} é€ æˆ ${shieldResult.finalDamage} ç‚¹${dot.school === 'physical' ? 'æµè¡€' : ''}ä¼¤å®³${extraText}${shieldText}ï¼ˆå‰©ä½™${dot.duration - 1}å›åˆï¼‰`
            );

// æ°¸ä¹…DOTä¸å‡å°‘æŒç»­æ—¶é—´
            if (!dot.isPermanent) {
                dot.duration -= 1;
            }
            return dot.duration > 0 || dot.isPermanent;
        });
    });

    // ==================== æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰ï¼šç ´ç”²çª—å£å€’è®¡æ—¶ ====================
    if (combat.bossId === 'ossirian') {
        // å¦‚æœæœ¬å›åˆå¼€å§‹æ—¶å°±å¤„äºâ€œé˜²å¾¡é™ä½â€çŠ¶æ€ï¼Œåˆ™å›åˆç»“æŸå‡ 1
        if (bossDefenseOverrideRemainingStart > 0) {
            combat.bossDefenseOverrideRemaining = Math.max(0, Math.floor(Number(combat.bossDefenseOverrideRemaining || 0)) - 1);

            if (combat.bossDefenseOverrideRemaining <= 0) {
                combat.bossDefenseOverrideRemaining = 0;
                delete combat.bossDefenseOverride;
                boss.defense = bossBase.defense;
                addLog(`ã€${boss.name}ã€‘çš„é˜²å¾¡æ¢å¤ï¼ˆ${bossBase.defense.toLocaleString()}ï¼‰`);
            }
        }
    }

    // ==================== ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯ï¼šæŠ¤ç›¾å€’è®¡æ—¶ ====================
    // åªåœ¨â€œå›åˆå¼€å§‹æ—¶å·²å­˜åœ¨â€çš„æŠ¤ç›¾åœ¨å›åˆç»“æŸé€’å‡ï¼Œé¿å…åˆšæ–½æ”¾å°±è¢«æ‰£æ‰æŒç»­æ—¶é—´ã€‚
    if (combat.bossId === 'majordomo_executus') {
        // åç‰©ç†æŠ¤ç›¾
        if (executusPhysicalShieldStart > 0) {
            const next = Math.max(0, Math.floor(Number(combat.bossBuffs.executusPhysicalShield || 0)) - 1);
            combat.bossBuffs.executusPhysicalShield = next;
            if (next <= 0 && executusPhysicalShieldStart > 0) {
                addLog(`ã€${boss.name}ã€‘çš„ã€åç‰©ç†æŠ¤ç›¾ã€‘æ¶ˆå¤±`, 'warning');
            }
        }

        // åé­”æ³•æŠ¤ç›¾
        if (executusMagicShieldStart > 0) {
            const next = Math.max(0, Math.floor(Number(combat.bossBuffs.executusMagicShield || 0)) - 1);
            combat.bossBuffs.executusMagicShield = next;
            if (next <= 0 && executusMagicShieldStart > 0) {
                addLog(`ã€${boss.name}ã€‘çš„ã€åé­”æ³•æŠ¤ç›¾ã€‘æ¶ˆå¤±`, 'warning');
            }
        }
    }


    // ==================== ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯ï¼šä¸‹æ½œå€’è®¡æ—¶ï¼ˆå›åˆæœ«ï¼‰ ====================
    if (combat.bossId === 'ragnaros') {
        if (ragnarosSubmergeStart > 0) {
            const next = Math.max(0, Math.floor(Number(combat.bossBuffs.ragnarosSubmergeTurns || 0)) - 1);
            combat.bossBuffs.ragnarosSubmergeTurns = next;

            if (next <= 0) {
                addLog(`ã€${boss.name}ã€‘ä»å²©æµ†ä¸­æµ®å‡ºï¼Œç»“æŸã€ä¸‹æ½œã€‘ï¼`, 'warning');
            }
        }
    }

    // ==================== èƒœè´Ÿåˆ¤å®š ====================
    const allPlayersDead = combat.playerStates.every(p => p.currentHp <= 0);
    const bossDead = combat.bossHp <= 0;

    if (bossDead || allPlayersDead) {
        let newState = {
            ...state,
            bossCombat: null
        };

        if (bossDead) {
            addLog('â˜…â˜…â˜… èƒœåˆ©ï¼è·å¾—å¥–åŠ± â˜…â˜…â˜…');

            // ===== ä¸–ç•ŒBossé‡ç”Ÿå†·å´ï¼š30åˆ†é’Ÿ =====
            newState.bossCooldowns = {
                ...(newState.bossCooldowns || {}),
                [combat.bossId]: 30 * 60
            };

            // ===== è·¨ä¸–ç´¯è®¡å‡»æ€æ¬¡æ•°ï¼ˆç”¨äºè§£é”è‡ªåŠ¨å‡»æ€ï¼‰ =====
            newState.worldBossKillCounts = {
                ...(newState.worldBossKillCounts || {}),
                [combat.bossId]: (newState.worldBossKillCounts?.[combat.bossId] || 0) + 1
            };

            if (!newState.defeatedBosses) newState.defeatedBosses = [];
            if (!newState.defeatedBosses.includes(combat.bossId)) {
                newState.defeatedBosses = [...newState.defeatedBosses, combat.bossId];
            }

            const alreadyDefeated = (state.defeatedBosses || []).includes('hogger');
            if (bossDead && combat.bossId === 'hogger' && !alreadyDefeated) {
                newState.showHoggerPlot = true;
            }

            newState.resources = {
                ...newState.resources,
                gold: newState.resources.gold + getEffectiveGoldGain(boss.rewards.gold, newState)
            };

            newState.characters = newState.characters.map(char => {
                const p = combat.playerStates.find(ps => ps.char.id === char.id);
                if (!p) return char;

                // âœ… åŒæ­¥ï¼šæŠŠæœ¬å›åˆæœ€ç»ˆè¡€é‡å†™å›ä¸»å­˜æ¡£è§’è‰²ï¼ˆé¿å…ç»“ç®—æ—¶è¡€é‡åœç•™åœ¨ä¸Šä¸€å›åˆï¼‰
                const worldMaxHp = Number(char.stats?.maxHp ?? char.stats?.hp) || 0;
                const combatHp = Number(p.currentHp) || 0;
                const baseHp = worldMaxHp > 0
                    ? Math.min(worldMaxHp, Math.max(0, Math.floor(combatHp)))
                    : Math.max(0, Math.floor(combatHp));

                let gainedExp = boss.rewards.exp * (1 + (char.stats.expBonus || 0));
                let newChar = { ...char, exp: char.exp + gainedExp };

                // å†™å…¥ç»“ç®—å‰è¡€é‡ï¼ˆç”¨äº calculateTotalStats ä¿ç•™ currentHpï¼‰
                newChar.stats = { ...newChar.stats, currentHp: baseHp };

                // âœ… æˆ˜å£«ï¼šä¹˜èƒœè¿½å‡»ï¼ˆ50çº§ï¼‰- Bossæˆ˜èƒœåˆ©åå›å¤æœ€å¤§ç”Ÿå‘½å€¼çš„ 20%
                if ((newChar.skills || []).includes('victory_rush')) {
                    const maxHp = Number(newChar.stats?.maxHp ?? worldMaxHp) || worldMaxHp;
                    const curHp = Number(newChar.stats?.currentHp ?? baseHp) || 0;

                    // æ­»äº¡ï¼ˆ<=0ï¼‰ä¸è§¦å‘ï¼Œé¿å…"å¤æ´»"ï¼›æ»¡è¡€ä¸è§¦å‘
                    if (maxHp > 0 && curHp > 0 && curHp < maxHp) {
                        const heal = Math.floor(maxHp * 0.20);
                        if (heal > 0) {
                            const nextHp = Math.min(maxHp, curHp + heal);
                            const realHeal = nextHp - curHp;
                            if (realHeal > 0) {
                                newChar.stats = { ...newChar.stats, currentHp: nextHp };
                                addLog(`ã€ä¹˜èƒœè¿½å‡»ã€‘${newChar.name} å›å¤ ${realHeal} ç‚¹ç”Ÿå‘½`, 'proc');
                            }
                        }
                    }
                }

                while (newChar.exp >= newChar.expToNext && newChar.level < 200) {
                    newChar.level += 1;
                    newChar.exp -= newChar.expToNext;
                    newChar.expToNext = Math.floor(100 * Math.pow(1.2, newChar.level - 1));
                    newChar.skills = learnNewSkills(newChar);
                }

                newChar.stats = calculateTotalStats(newChar, undefined, state);
                return newChar;
            });

            boss.rewards.items.forEach(itemTpl => {
                const dropId = (typeof itemTpl === 'string') ? itemTpl : itemTpl?.id;
                if (!dropId) return;

                if (newState.dropFilters?.[dropId] === false) return;

                // ===== æ¦‚ç‡åˆ¤å®šï¼ˆå åŠ æ‰è½å¢å¹…ï¼šæˆå°± + å¯»é¾™ä¼šï¼‰ =====
                const baseDropChance = itemTpl?.chance ?? 1;  // é»˜è®¤100%
                const dropChance = getEffectiveDropChance(baseDropChance, newState);
                if (Math.random() > dropChance) return;   // æœªå‘½ä¸­åˆ™è·³è¿‡

                if (FIXED_EQUIPMENTS?.[dropId]) {
                    const inst = createEquipmentInstance(dropId);
                    newState.inventory.push(inst);
                    newState = addEquipmentIdToCodex(newState, dropId);
                    return;
                }

                const tpl = ITEMS?.[dropId];
                if (tpl) {
                    newState.inventory.push({
                        ...tpl,
                        instanceId: `inv_${Date.now()}_${Math.random()}`,
                        id: tpl.id,
                    });
                    newState = addJunkIdToCodex(newState, dropId);
                    return;
                }

                newState.inventory.push({
                    instanceId: `boss_${Date.now()}_${Math.random()}`,
                    id: dropId,
                    name: dropId,
                    type: 'junk',
                });
            });

            // ===== åéª‘æ‰è½ï¼ˆä¸è¿›èƒŒåŒ…ï¼Œåªç‚¹äº®å›¾é‰´ï¼‰ =====
            {
                const res = tryUnlockMountFromBoss(newState, combat.bossId, (t) => addLog(t, 'loot'));
                newState = res.state;
            }

        } else {
            addLog('Ã—Ã—Ã— å¤±è´¥ï¼Œå…¨é˜Ÿé˜µäº¡ Ã—Ã—Ã—');

            // âœ… ç»Ÿè®¡ï¼šBOSSæŒ‘æˆ˜è¶…è¿‡4å›åˆåå¤±è´¥æ¬¡æ•°ï¼ˆç”¨äºæˆå°±ã€é“å¿ƒæ¾„æ¾ˆâ… /â…¡ã€‘ï¼‰
            if ((combat.round || 0) > 4) {
                const prev = newState.stats?.bossLateRoundDefeats || 0;
                newState.stats = { ...(newState.stats || {}), bossLateRoundDefeats: prev + 1 };
            }
        }

        const bossLogEntry = {
            id: `bosslog_${Date.now()}_${Math.random()}`,
            timestamp: Date.now(),
            characterName: 'é˜Ÿä¼',
            zoneName: 'ä¸–ç•Œé¦–é¢†',
            enemyName: boss.name,
            result: bossDead ? 'victory' : 'defeat',
            logs: logs,
            rewards: bossDead
                ? { gold: boss.rewards.gold, exp: boss.rewards.exp }
                : { gold: 0, exp: 0 },
        };

        newState.combatLogs = [bossLogEntry, ...(newState.combatLogs || [])].slice(0, 50);

        return newState;
    }

    // ç»§ç»­æˆ˜æ–—
    combat.logs = logs.slice(-50);

    const syncedCharacters = (state.characters || []).map(c => {
        const ps = combat.playerStates?.find(p => p.char?.id === c.id);
        if (!ps) return c;

        const maxHp = c.stats?.maxHp ?? ps.char?.stats?.maxHp ?? 0;
        const nextHp = Math.min(maxHp, Math.max(0, Math.floor(ps.currentHp ?? 0)));

        return {
            ...c,
            stats: { ...c.stats, currentHp: nextHp }
        };
    });

    return { ...state, characters: syncedCharacters, bossCombat: combat };
}


// ==================== INITIAL STATE ====================
const initialState = {
    currentMenu: 'map',
    frame: 0,      // æ€»å¸§
    lifeFrame: 0,  // æœ¬ä¸–å¸§
    // å½“å‰æ—¶é—´æ®µï¼ˆç”¨äºæš—å¤œç²¾çµã€ç²¾çµç²¾é­„ã€‘ç­‰æ—¶é—´æ®µè¢«åŠ¨ï¼›6:00-18:00=dayï¼‰
    nightElfSpiritPhase: (() => {
        const h = new Date().getHours();
        const cfg = RACE_TRAITS?.['æš—å¤œç²¾çµ']?.timeBasedStatBonus || {};
        const dayStart = Number.isFinite(Number(cfg.dayStart)) ? Number(cfg.dayStart) : 6;
        const nightStart = Number.isFinite(Number(cfg.nightStart)) ? Number(cfg.nightStart) : 18;
        const isDay = dayStart < nightStart
            ? (h >= dayStart && h < nightStart)
            : (h >= dayStart || h < nightStart);
        return isDay ? 'day' : 'night';
    })(),
    characters: [],
    characterSlots: 1,
    maxCharacterSlots: 15,
    resources: {
        gold: 500,
        spacetimeCoin: 0,
        wood: 200,
        ironOre: 50,
        ironIngot: 10,
        herb: 30,
        leather: 20,
        magicEssence: 5,
        alchemyOil: 5,
        population: 0,
        maxPopulation: 0,
    },
    // æ¯æ—¥é¦–æ¬¡ç‚¹å‡»ã€ä¿å­˜ã€‘å¥–åŠ±æ—¶ç©ºå¸çš„æ—¥æ ‡è¯†ï¼ˆYYYY-MM-DDï¼‰
    spacetimeCoinDailyRewardDayKey: '',
    buildings: {},  // â† æ·»åŠ è¿™ä¸€è¡Œ
    // åŠŸèƒ½å»ºç­‘æ•°é‡
    functionalBuildings: {},
    // èµ„æºå»ºç­‘å·¥äººåˆ†é… { buildingId: [charId1, charId2, ...] }
    resourceAssignments: {},
    research: {},
    currentResearch: null,
    researchProgress: 0,
    inventory: [],
    inventorySize: 80,
    inventorySizeExtra: 0,
    achievements: {},
    codex: [],
    codexJunk: [],
    codexMounts: [],
    zones: JSON.parse(JSON.stringify(ZONES)),
    assignments: {},
    combatLogs: [],
    stats: { battlesWon: 0, totalDamage: 0, totalHealing: 0, bossLateRoundDefeats: 0, grandVaultPicks: 0 },
    // åœ°å›¾åŒºåŸŸå‡»æ€ç»Ÿè®¡ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä¸ä¼šéšè½®å›/é‡ç”Ÿé‡ç½®ï¼‰
    // ä¾‹å¦‚ï¼š{ elwynn_forest: 12345 }
    zoneKillCounts: {},
    worldBossProgress: {},
    lastOnlineTime: Date.now(),
    offlineRewards: null,
    dropFilters: {}, // { [itemId]: true/false }  true=å…è®¸æ‰è½  false=ç¦æ­¢æ‰è½
    codexEquipLv100: [], // è®°å½•æ›¾ç»åˆ°è¿‡Lv100çš„è£…å¤‡æ¨¡æ¿idï¼ˆæ°¸ä¹…äº®æ¡†ï¼‰
    prepareBoss: null, // å½“å‰å‡†å¤‡æŒ‘æˆ˜çš„bossId
    bossTeam: [null, null, null], // 3ä¸ªä½ç½®çš„charId
    bossStrategy: { priorityBoss: true, stance: 'dispersed' }, // ç­–ç•¥
    bossCombat: null, // æ­£åœ¨è¿›è¡Œçš„bossæˆ˜çŠ¶æ€

    bossCooldowns: {}, // { [bossId]: remainingSeconds } ä¸–ç•ŒBossé‡ç”Ÿå†·å´ï¼ˆç§’ï¼‰

    // ===== ä¸–ç•Œé¦–é¢†è‡ªåŠ¨å‡»æ€ï¼ˆè·¨ä¸–ç´¯è®¡ï¼‰ =====
    // worldBossKillCounts: { [bossId]: number }   æ‰€æœ‰ä¸–(é‡ç”Ÿ)ç´¯è®¡å‡»æ€æ¬¡æ•°
    // worldBossAutoKill:  { [bossId]: boolean }  æ˜¯å¦å¼€å¯â€œCDç»“æŸåè‡ªåŠ¨å‡»æ€â€
    worldBossKillCounts: {},
    worldBossAutoKill: {},

    // ===== å®ä¼Ÿå®åº“ï¼ˆæ¯æ—¥æ—©ä¸Š 9 ç‚¹åˆ·æ–°ï¼‰ =====
    // dayKeyï¼šä»¥â€œæ—©ä¸Š9ç‚¹â€ä¸ºåˆ†ç•Œçš„æ—¥å‘¨æœŸæ ‡è¯†ï¼ˆä¾‹å¦‚ 2026-02-02ï¼‰
    // rowsï¼šå½“æ—¥å®åº“å†…å®¹ï¼ˆæŒä¹…åŒ–ï¼Œé¿å…åå¤æ‰“å¼€åˆ·æ–°ä¸åŒç»“æœï¼‰
    // claimedDayKeyï¼šå·²é¢†å–çš„æ—¥å‘¨æœŸï¼ˆç”¨äºâ€œå½“æ—¥å·²é¢†å–â€åˆ¤å®šï¼‰
    grandVault: {
        dayKey: '',
        rows: null,
        // { [badgeId]: [templateId1, templateId2, templateId3] }
        badgePicks: {},
        claimedDayKey: '',
        lastRefreshAt: 0,
        claimedAt: 0,
    },

    showHoggerPlot: false,
    showRebirthConfirm: false,
    showRebirthPlot: null,
    // è¡€è‰²åå­—å†›çš„å¾½ç« ï¼šé€‰æ‹©ç›®æ ‡è£…å¤‡çš„ä¸´æ—¶çŠ¶æ€
    showScarletBadgeModal: false,
    pendingScarletBadgeInstanceId: null,
    pendingBadgeItemId: null,
    rebirthCount: 0,
    rebirthUnlocked: false,
    rebirthBonuses: {
        exp: 0,
        gold: 0,
        drop: 0,
        researchSpeed: 0
    },
    rebirthBonds: [],
    defeatedBosses: [], // æœ¬ä¸–å‡»æ€çš„Bossåˆ—è¡¨
    questProgress: {
        // ä»»åŠ¡é“¾è¿›åº¦
        // vancleef_wanted: {
        //     status: 'in_progress',
        //     currentStep: 'step_2_investigate',
        //     flags: ['knows_background', 'suspicious_of_nobles'],
        //     completedSteps: ['step_1_accept', 'step_1b_background'],
        //     completedBranch: null  // 'suppress_vancleef' æˆ– 'slay_prestor'
        // }
    },
    questItems: [],  // ä»»åŠ¡ç‰©å“
    completedQuestBranches: [],  // å·²å®Œæˆçš„ä»»åŠ¡åˆ†æ”¯ï¼ˆç”¨äºæˆå°±ç­‰ï¼‰
    questTitles: []  // è·å¾—çš„ç§°å·
};

// ==================== BASE64 ENCODING (æ”¯æŒä¸­æ–‡) ====================
function encodeBase64(str) {
    // å…ˆç”¨ encodeURIComponent è½¬æ¢æˆ UTF-8ï¼Œå†ç”¨ btoa ç¼–ç 
    return btoa(unescape(encodeURIComponent(str)));
}

function decodeBase64(str) {
    // å…ˆç”¨ atob è§£ç ï¼Œå†ç”¨ decodeURIComponent è½¬å› UTF-8
    return decodeURIComponent(escape(atob(str)));
}

// ==================== LOCAL STORAGE ====================
const SAVE_KEY = 'wow_idle_game_save';

function saveToLocalStorage(state) {
    try {
        const saveData = JSON.stringify(state);
        localStorage.setItem(SAVE_KEY, saveData);
    } catch (e) {
        console.error('Failed to save to localStorage:', e);
    }
}

function loadFromLocalStorage() {
    try {
        const saveData = localStorage.getItem(SAVE_KEY);
        if (saveData) {
            return JSON.parse(saveData);
        }
    } catch (e) {
        console.error('Failed to load from localStorage:', e);
    }
    return null;
}

// ==================== OFFLINE REWARDS CALCULATOR ====================
function calculateOfflineRewards(state, offlineSeconds) {
    const MAX_OFFLINE_SECONDS = 2 * 24 * 60 * 60;
    const actualSeconds = Math.min(offlineSeconds, MAX_OFFLINE_SECONDS);

    let rewards = {
        gold: 0,
        exp: {},
        items: [],
        mounts: [], // âœ… ç¦»çº¿æœŸé—´è§£é”çš„åéª‘ï¼ˆä¸è¿›èƒŒåŒ…ï¼‰
        kingdomResources: {},   // âœ… æ–°å¢ï¼šä¸»åŸèµ„æº
        researchProgress: 0,
        combats: 0,
        // ç¦»çº¿æœŸé—´å„åœ°å›¾åŒºåŸŸçš„å‡»æ€æ•°ï¼ˆcombat è§†ä¸ºå‡»æ€ 1 ä¸ªæ€ªç‰©ï¼‰
        killsByZone: {}
    };
    Object.entries(state.assignments).forEach(([charId, zoneId]) => {
        const character = state.characters.find(c => c.id === charId);
        const zone = state.zones[zoneId];

        if (character && zone && zone.enemies) {
            const combatsPerSecond = 0.1;
            const totalCombats = Math.floor(actualSeconds * combatsPerSecond);

            rewards.combats += totalCombats;

            // âœ… ç¦»çº¿æˆ˜æ–—ä¹Ÿè®¡å…¥åœ°å›¾åŒºåŸŸå‡»æ€è®¡æ•°ï¼ˆç”¨äºæˆå°±ï¼šåé‡Œå¡å‰‘åœ£ç­‰ï¼‰
            rewards.killsByZone[zoneId] = (rewards.killsByZone[zoneId] || 0) + totalCombats;

            for (let i = 0; i < totalCombats; i++) {
                const enemy = zone.enemies[Math.floor(Math.random() * zone.enemies.length)];
                rewards.gold += getEffectiveGoldGain(enemy.gold, state);

                if (!rewards.exp[charId]) {
                    rewards.exp[charId] = 0;
                }
                const { expMult } = getMountMultipliers(state);
                rewards.exp[charId] += enemy.exp * (1 + (character.stats?.expBonus || 0)) * (expMult || 1);

                if (Math.random() < 0.1 && zone.resources) {
                    const resourceName = zone.resources[Math.floor(Math.random() * zone.resources.length)];
                    rewards.kingdomResources[resourceName] = (rewards.kingdomResources[resourceName] || 0) + 1;
                }

                const dropTable = DROP_TABLES[zone.id];
                if (dropTable?.equipment) {
                    const allowDrop = (id) => state.dropFilters?.[id] !== false; // é»˜è®¤å…è®¸
                    dropTable.equipment.filter(drop => allowDrop(drop.id)).forEach(drop => {
                        const base = (drop.chance ?? 0);
                        const effective = getEffectiveDropChance(base, state);
                        if (Math.random() < effective) {
                            const inst = createEquipmentInstance(drop.id);
                            if (inst) rewards.items.push(inst);
                        }
                    });

                }

                // âœ… ç¦»çº¿åéª‘æ‰è½ï¼šä¸è¿›èƒŒåŒ…ï¼Œåªè®°å½•åˆ° rewards.mountsï¼Œé¢†å–æ—¶ç‚¹äº®å›¾é‰´
                if (dropTable?.mounts) {
                    const already = new Set([...(Array.isArray(state.codexMounts) ? state.codexMounts : []), ...(rewards.mounts || [])]);
                    (Array.isArray(dropTable.mounts) ? dropTable.mounts : []).forEach(drop => {
                        const mountId = drop?.id;
                        if (!mountId || already.has(mountId)) return;
                        const baseChance = Number(drop.chance) || 0;
                        if (baseChance > 0 && Math.random() < baseChance) {
                            rewards.mounts.push(mountId);
                            already.add(mountId);
                        }
                    });
                }
            }
        }
    });

    if (state.currentResearch) {
        const research = RESEARCH[state.currentResearch];
        if (research) {
            const level = state.research[state.currentResearch] || 0;
            const cost = Math.floor(research.baseCost * Math.pow(1.2, level));
            const progressPerSecond = state.resources.gold >= cost ? 1 : 0;
            rewards.researchProgress = actualSeconds * progressPerSecond;
        }
    }

    return {
        rewards,
        actualSeconds,
        maxSeconds: MAX_OFFLINE_SECONDS
    };
}

const ARMOR_DR_CAP = 0.99;
const ARMOR_K = 3000; // ä½ å¯ä»¥è°ƒå‚ï¼š1000/5000/10000...

// ==================== é­”æŠ—å‡ä¼¤ï¼ˆç»Ÿä¸€å…¬å¼ï¼‰ ====================
// ç»Ÿä¸€é­”æŠ—ç³»æ•°ï¼ˆè°ƒå‚åªæ”¹è¿™é‡Œï¼‰
const magicresist_k = 800;

// è¿”å› 0~1 çš„å‡ä¼¤æ¯”ä¾‹ï¼ˆå…è®¸ä¸ºè´Ÿï¼Œä»£è¡¨æ˜“ä¼¤ï¼›ä¾‹å¦‚ -0.2 è¡¨ç¤ºå¤šåƒ20%ä¼¤å®³ï¼‰
function getMagicResistDamageReduction(magicResist) {
    const mr = Number(magicResist) || 0;
    const denom = mr + magicresist_k;

    // é¿å… mr æ°å¥½ç­‰äº -K æ—¶é™¤ 0 å¯¼è‡´æ•°å€¼çˆ†ç‚¸
    if (Math.abs(denom) < 1e-9) {
        return mr >= 0 ? 0.999 : -0.999;
    }

    return mr / denom;
}

function getArmorDamageReduction(armor) {
    const a = Math.max(0, armor || 0);
    const dr = a / (a + ARMOR_K);
    return Math.min(ARMOR_DR_CAP, dr);
}

function applyPhysicalMitigation(rawDamage, armor) {
    const dr = getArmorDamageReduction(armor);
    const reduced = rawDamage * (1 - dr);
    return Math.max(1, Math.floor(reduced)); // è‡³å°‘1ç‚¹ä¼¤å®³
}


// ==================== å…¨èƒ½å‡ä¼¤ï¼ˆå—åˆ°ä¼¤å®³ï¼‰ ====================
// è§„åˆ™ï¼šå…¨èƒ½å±æ€§è¿˜èƒ½æä¾›å‡ä¼¤ï¼Œæ•°å€¼ä¸ºï¼ˆå…¨èƒ½/20ï¼‰% ï¼Œä¸Šé™50%
// ä¾‹å¦‚ï¼šå…¨èƒ½=20 => 1%å‡ä¼¤ï¼›å…¨èƒ½=1000 => 50%å‡ä¼¤ï¼ˆå°é¡¶ï¼‰
const VERSATILITY_DR_CAP = 0.5;

// è¿”å› 0~0.5 çš„å‡ä¼¤æ¯”ä¾‹ï¼ˆå¦‚ 0.12 è¡¨ç¤º12%å‡ä¼¤ï¼‰
function getVersatilityDamageReduction(versatility) {
    const v = Math.max(0, Number(versatility) || 0);
    // ï¼ˆå…¨èƒ½/20ï¼‰% => (v/20)/100 => v/2000
    return Math.min(VERSATILITY_DR_CAP, v / 2000);
}

// è¿”å› 0.5~1 çš„ä¹˜åŒºï¼ˆå¦‚ 0.88 è¡¨ç¤ºæ‰¿å—88%ä¼¤å®³ï¼‰
function getVersatilityDamageTakenMult(versatility) {
    return 1 - getVersatilityDamageReduction(versatility);
}


// ==================== COMBAT SYSTEM ====================
// å°†æˆ˜æ–—æ‹†æˆâ€œå¤š tick å¤šå›åˆâ€æ¨è¿›ï¼šè¿™æ · UI èƒ½å®æ—¶çœ‹åˆ°è¡€é‡å˜åŒ–
function createCombatState(character, enemy, skillSlots) {
    // æˆ˜æ–—å†… buffsï¼ˆä¸æ”¹è§’è‰²æœ¬ä½“ï¼‰
    let buffs = []; // { blockRate, duration }

    // ä¿ç•™ 8 ä¸ªæ§½ä½é¡ºåºï¼šç©º/æ— æ•ˆ => rest
    const slots8 = Array.from({ length: 8 }, (_, i) => (skillSlots?.[i] ?? ''));

    const validSkills = slots8.map(sid => (sid && SKILLS[sid]) ? sid : 'rest');

    // ä¿é™©ï¼šå¦‚æœ rest ä¸å­˜åœ¨ï¼Œè‡³å°‘ä¸ä¼šå´©ï¼ˆå¯é€‰ï¼‰
    for (let i = 0; i < validSkills.length; i++) {
        if (!SKILLS[validSkills[i]]) validSkills[i] = 'basic_attack';
    }

    return {
        enemy: { ...enemy },
        enemyHp: enemy.hp,
        round: 0,
        skillIndex: 0,
        comboPoints: 0, // ç›—è´¼â€œæ˜Ÿâ€(è¿å‡»ç‚¹)
        buffs,
        enemyDebuffs: [], // æ€ªç‰©èº«ä¸Šçš„ debuff
        validSkills,
        talentBuffs: { attackFlat: 0, blockValueFlat: 0, spellPowerFlat: 0 },
        fortuneMisfortuneStacks: 0, // ç¥¸ç¦ç›¸ä¾å±‚æ•°
        fantasiaStacks: 0,          // å¹»æƒ³æ›²å±‚æ•°ï¼ˆæˆ’å¾‹ç‰§å¸ˆ50çº§å¤©èµ‹ï¼Œä»…æœ¬åœºæˆ˜æ–—ï¼‰
        fingersOfFrost: 0,          // å¯’å†°æŒ‡å±‚æ•°
        // âœ… å¤©èµ‹/æˆ˜æ–—å†…è§¦å‘çŠ¶æ€ï¼ˆæ¯åœºæˆ˜æ–—é‡ç½®ï¼‰
        talentFlags: {},
        logs: [],
        startedAt: Date.now(),
    };
}

function stepCombatRounds(character, combatState, roundsPerTick = 1, gameState) {
    let logs = [...(combatState.logs || [])];

    let charHp = Number.isFinite(character?.stats?.currentHp)
        ? character.stats.currentHp
        : (character?.stats?.maxHp ?? character?.stats?.hp ?? 0);

    let enemyHp = combatState.enemyHp ?? combatState.enemy?.hp ?? 0;
    let round = combatState.round ?? 0;
    let skillIndex = combatState.skillIndex ?? 0;

    // âœ… åœ°å›¾æˆ˜æ–—æ€»ä¼¤å®³åŠ æˆï¼ˆè£…å¤‡ç‰¹æ•ˆ + æˆå°±åŠ æˆï¼ŒäºŒè€…ä¹˜ç®—ï¼‰
    const mapDamageDealtMult = getMapDamageDealtMult(character, gameState);

    // âœ… ç›®æ ‡é˜²å¾¡ï¼ˆè€ƒè™‘æ— è§†é˜²å¾¡/ç©¿ç”²ç‰¹æ•ˆï¼‰
    const enemyDefenseRaw = Number(combatState?.enemy?.defense) || 0;
    const enemyDefense = getEffectiveTargetDefense(character, enemyDefenseRaw);

    // buffs
    let buffs = Array.isArray(combatState.buffs) ? [...combatState.buffs] : [];
    // enemy debuffs
    let enemyDebuffs = Array.isArray(combatState.enemyDebuffs) ? [...combatState.enemyDebuffs] : [];

    // å¤©èµ‹å å±‚ï¼ˆä»…æœ¬åœºæˆ˜æ–—æœ‰æ•ˆï¼‰
    let talentBuffs = combatState.talentBuffs
        ? { ...combatState.talentBuffs }
        : { attackFlat: 0, blockValueFlat: 0, spellPowerFlat: 0 };

    // ç¥¸ç¦ç›¸ä¾å±‚æ•°
    let fortuneMisfortuneStacks = combatState.fortuneMisfortuneStacks || 0;
    // å¹»æƒ³æ›²å±‚æ•°ï¼ˆä»…æœ¬åœºæˆ˜æ–—ï¼‰
    let fantasiaStacks = combatState.fantasiaStacks || 0;
    // å¯’å†°æŒ‡å±‚æ•°
    let fingersOfFrost = combatState.fingersOfFrost || 0;

    // âœ… å¤©èµ‹/æˆ˜æ–—å†…è§¦å‘çŠ¶æ€ï¼ˆä»…æœ¬åœºæˆ˜æ–—æœ‰æ•ˆï¼‰
    let talentFlags = (combatState.talentFlags && typeof combatState.talentFlags === 'object')
        ? { ...combatState.talentFlags }
        : {};

    // ç›—è´¼è¿å‡»ç‚¹ï¼ˆæ˜Ÿï¼‰
    let comboPoints = combatState.comboPoints || 0;

    const validSkills = Array.isArray(combatState.validSkills) && combatState.validSkills.length > 0
        ? combatState.validSkills
        : (() => {
            const slots8 = Array.from({ length: 8 }, (_, i) => (character.skillSlots?.[i] ?? ''));
            const v = slots8.map(sid => (sid && SKILLS[sid]) ? sid : 'rest');

            for (let i = 0; i < v.length; i++) {
                if (!SKILLS[v[i]]) v[i] = 'basic_attack';
            }
            return v;
        })();

    const getBuffBlockRate = () =>
        buffs.reduce((sum, b) => sum + (b.blockRate || 0), 0);

    const tickBuffs = () => {
        buffs = buffs
            .map(b => ({ ...b, duration: (b.duration ?? 0) - 1 }))
            .filter(b => {
                // æŠ¤ç›¾ï¼šæŒç»­æ—¶é—´åˆ°æœŸæˆ–å¸æ”¶é‡è€—å°½éƒ½ç§»é™¤
                if (b.type && ['ice_barrier', 'holy_barrier'].includes(b.type)) {
                    return (b.duration ?? 0) > 0 && (b.amount ?? 0) > 0;
                }
                // å…¶ä»–buffåªçœ‹æŒç»­æ—¶é—´
                return (b.duration ?? 0) > 0;
            });
    };
    const tickEnemyDebuffs = () => {
        enemyDebuffs = enemyDebuffs
            .map(d => ({ ...d, duration: (d.duration ?? 0) - 1 }))
            .filter(d => (d.duration ?? 0) > 0);
    };

    // ==================== ç‹‚å¾’ç›—è´¼30çº§å¤©èµ‹ï¼šæ‚è€æ‰“å‡» ====================
    // æ•ˆæœï¼šæ™®é€šæ”»å‡»/å½±è¢­ å åŠ ã€æ‚è€ã€‘ï¼ˆå…¨èƒ½+2ï¼Œæœ€å¤š25å±‚ï¼Œæœ¬åœºæˆ˜æ–—ï¼‰
    const procJugglingStrikes = (triggerSkillId) => {
        if (character?.classId !== 'outlaw_rogue') return;
        if (character?.talents?.[30] !== 'juggling_strikes') return;
        if (!['basic_attack', 'shadowstrike', 'sinister_strike'].includes(triggerSkillId)) return;

        const maxStacks = 25;
        const perStack = 2;

        const idx = buffs.findIndex(b => b?.type === 'juggling');
        if (idx === -1) {
            buffs.push({
                type: 'juggling',
                name: 'æ‚è€',
                stacks: 1,
                versatilityBonus: perStack,
                duration: 999,
            });
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'æ‚è€æ‰“å‡»',
                text: `ã€æ‚è€æ‰“å‡»ã€‘è·å¾—1å±‚ã€æ‚è€ã€‘ï¼ˆ1/${maxStacks}ï¼Œå…¨èƒ½+${perStack}ï¼‰`
            });
            return;
        }

        const old = buffs[idx];
        const curStacks = Math.max(0, Math.floor(Number(old.stacks) || 0));
        if (curStacks >= maxStacks) return;

        const nextStacks = Math.min(maxStacks, curStacks + 1);
        buffs[idx] = {
            ...old,
            stacks: nextStacks,
            versatilityBonus: nextStacks * perStack,
            duration: 999,
        };
        logs.push({
            round,
            kind: 'proc',
            actor: character.name,
            proc: 'æ‚è€æ‰“å‡»',
            text: `ã€æ‚è€æ‰“å‡»ã€‘è·å¾—1å±‚ã€æ‚è€ã€‘ï¼ˆ${nextStacks}/${maxStacks}ï¼Œå…¨èƒ½+${nextStacks * perStack}ï¼‰`
        });
    };

    const maxRounds = 200;

    for (let i = 0; i < roundsPerTick; i++) {
        if (charHp <= 0 || enemyHp <= 0 || round >= maxRounds) break;

        round++;

        // ===== 50çº§å¤©èµ‹ï¼šå¹»æƒ³æ›²ï¼ˆæ¯å›åˆ+1å±‚ï¼Œå½±å“ä¸‹ä¸€ä¸ªç¥åœ£æ–°æ˜Ÿï¼‰ =====
        if (character?.classId === 'discipline_priest' && character?.talents?.[50] === 'fantasia') {
            fantasiaStacks = (fantasiaStacks || 0) + 1;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'å¹»æƒ³æ›²',
                text: `ã€å¹»æƒ³æ›²ã€‘è·å¾—1å±‚ï¼ˆå½“å‰${fantasiaStacks}å±‚ï¼‰`
            });
        }

        // ==================== å›åˆå¼€å§‹ï¼šæŒç»­æ€§buffæ•ˆæœï¼ˆç›—è´¼ç­‰ï¼‰ ====================
        comboPoints = Number.isFinite(comboPoints) ? comboPoints : 0;
        if (Array.isArray(buffs) && buffs.length > 0) {
            buffs.forEach(b => {
                if (!b) return;

                // æ¯å›åˆæ²»ç–—ï¼ˆä¾‹å¦‚ï¼šçŒ©çº¢ä¹‹ç“¶ï¼‰
                if (typeof b.healPctPerTurn === 'number' && b.healPctPerTurn > 0) {
                    const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
                    const healAmount = Math.max(0, Math.floor(maxHp * b.healPctPerTurn));
                    if (healAmount > 0 && charHp > 0) {
                        const before = charHp;
                        charHp = Math.min(maxHp, charHp + healAmount);
                        const realHeal = charHp - before;
                        if (realHeal > 0) {
                            logs.push({
                                round,
                                actor: character.name,
                                action: b.name || 'æŒç»­æ²»ç–—',
                                target: character.name,
                                value: realHeal,
                                type: 'heal',
                                text: `ã€${b.name || 'æŒç»­æ²»ç–—'}ã€‘å›å¤ ${realHeal} ç‚¹ç”Ÿå‘½`
                            });
                        }
                    }
                }

                // æ¯å›åˆè·å¾—è¿å‡»ç‚¹ï¼ˆä¾‹å¦‚ï¼šå†²åŠ¨ï¼‰
                if (Number.isFinite(Number(b.comboPerTurn)) && Number(b.comboPerTurn) > 0) {
                    const gain = Math.max(0, Math.floor(Number(b.comboPerTurn)));
                    if (gain > 0) {
                        const maxCombo = getMaxComboPointsForChar(character);
                        const before = comboPoints;
                        comboPoints = Math.min(maxCombo, comboPoints + gain);
                        const realGain = comboPoints - before;
                        if (realGain > 0) {
                            logs.push({
                                round,
                                kind: 'proc',
                                actor: character.name,
                                proc: b.name || 'å¢ç›Š',
                                text: `ã€${b.name || 'å¢ç›Š'}ã€‘è·å¾— ${realGain} æ˜Ÿï¼ˆå½“å‰${comboPoints}æ˜Ÿï¼‰`
                            });
                        }
                    }
                }
            });
        }

        // ===== è§’è‰²å›åˆ =====
        let currentSkillId = validSkills[skillIndex % validSkills.length];
        let skill = SKILLS[currentSkillId];

        // ===== æ–°å¢ï¼šå¤„ç†æ¡ä»¶æŠ€èƒ½ =====
        if (skill && skill.type === 'conditional') {
            const condition = skill.condition;
            let conditionMet = false;

            // æ£€æŸ¥æ¡ä»¶ç±»å‹
            if (condition.type === 'has_buff') {
                // æ£€æŸ¥æ˜¯å¦æœ‰æŒ‡å®šbuff/å±‚æ•°
                if (condition.buffName === 'fingersOfFrost') {
                    conditionMet = (fingersOfFrost || 0) >= (condition.minStacks || 1);
                }
                // å¯ä»¥æ‰©å±•å…¶ä»–buffæ£€æŸ¥...
            }

            // æ ¹æ®æ¡ä»¶é€‰æ‹©å®é™…æŠ€èƒ½
            const actualSkillId = conditionMet ? skill.skillIfTrue : skill.skillIfFalse;
            currentSkillId = actualSkillId;
            skill = SKILLS[actualSkillId];

            // è®°å½•æ—¥å¿—
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'æ™ºèƒ½æŠ€èƒ½',
                text: `ã€å†°éœœæ‰“å‡»ã€‘åˆ¤æ–­ï¼š${conditionMet ? 'æœ‰å¯’å†°æŒ‡â†’å†°æªæœ¯' : 'æ— å¯’å†°æŒ‡â†’å¯’å†°ç®­'}`
            });
        }

        const slotIndex = skillIndex % validSkills.length;

        // âœ… ç§æ—ï¼šæš—å¤œç²¾çµã€éšéã€‘
        // æ•ˆæœï¼šåœ°å›¾æˆ˜æ–—ç¬¬1æ ¼(ç´¢å¼•0)æŠ€èƒ½é€ æˆçš„ä¼¤å®³æé«˜20%ï¼ˆä¹˜ç®—ï¼‰
        const raceTraitCombat = RACE_TRAITS?.[character?.race];
        let racialSlotDamageMult = 1;
        if (slotIndex === 0) {
            const m = Number(raceTraitCombat?.mapFirstSlotDamageMult);
            if (Number.isFinite(m) && m > 0) racialSlotDamageMult *= m;
        }

        // âœ… ç§æ—ï¼šé€šç”¨â€œå‰Næ ¼ä¼¤å®³ä¹˜åŒºâ€ï¼ˆä¾‹å¦‚ï¼šå…½äººã€è¡€æ€§ç‹‚æ€’ã€‘ï¼‰
        const firstNSlotCfg = raceTraitCombat?.firstNSlotDamageMult;
        if (firstNSlotCfg && typeof firstNSlotCfg === 'object') {
            const n = Math.max(0, Math.floor(Number(firstNSlotCfg.n) || 0));
            const m = Number(firstNSlotCfg.mult);
            if (n > 0 && slotIndex < n && Number.isFinite(m) && m > 0) {
                racialSlotDamageMult *= m;
            }
        }

        // ==================== è£…å¤‡ç‰¹æ•ˆï¼šå›åˆå¼€å§‹æ¦‚ç‡å±æ€§å¢ç›Šï¼ˆä»…æœ¬å›åˆï¼‰ ====================
        const { bonus: turnProcBonus, triggered: turnProcTriggered } = rollProcStatEffects(character, 'turn_start');
        if (turnProcTriggered.length > 0) {
            turnProcTriggered.forEach(tp => {
                const t = formatProcStatBonusText(tp.bonus);
                if (t) {
                    logs.push({
                        round,
                        kind: 'proc',
                        actor: character.name,
                        proc: tp.label,
                        text: `ã€${tp.label}ã€‘è§¦å‘ï¼š${t}ï¼ˆæœ¬å›åˆï¼‰`
                    });
                }
            });
        }

        // ==================== è£…å¤‡ç‰¹æ•ˆï¼šé›·éœ†ä¹‹æ€’ï¼ˆé£å‰‘ï¼‰ ====================
        // å›åˆå¼€å§‹20%æ¦‚ç‡ï¼šå¯¹æ•Œäººé€ æˆ1.2å€æ”»å‡»çš„è‡ªç„¶ä¼¤å®³ï¼›å¹¶è·å¾—æ‰¿ä¼¤-20%æŒç»­2å›åˆ
        const thunderfury = rollThunderfuryEffect(character, 'turn_start');
        if (thunderfury && enemyHp > 0) {
            const atk = Number(character?.stats?.attack) || 0;
            const raw = Math.floor(atk * (Number(thunderfury.damageMult) || 1.2));
            const actual = Math.max(1, Math.floor(raw - enemyDefense));
            enemyHp -= actual;

            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: thunderfury.label,
                text: `ã€${thunderfury.label}ã€‘é—ªç”µé“¾ï¼šå¯¹ ${combatState?.enemy?.name || 'æ•Œäºº'} é€ æˆ ${actual} è‡ªç„¶ä¼¤å®³`
            });

            // è‡ªèº«æ‰¿ä¼¤é™ä½Buffï¼ˆåˆ·æ–°ï¼‰
            const buffType = 'thunderfury_guard';
            const dur = Math.max(1, Math.floor(thunderfury.selfBuffDuration || 2));
            const dtm = Number(thunderfury.selfDamageTakenMult) || 0.8;
            const idx = buffs.findIndex(b => b?.type === buffType);
            if (idx === -1) {
                buffs.push({
                    type: buffType,
                    name: 'é›·éœ†å®ˆæŠ¤',
                    damageTakenMult: dtm,
                    duration: dur,
                    justApplied: true,
                });
            } else {
                buffs[idx] = {
                    ...buffs[idx],
                    name: 'é›·éœ†å®ˆæŠ¤',
                    damageTakenMult: dtm,
                    duration: dur,
                    justApplied: true,
                };
            }

            logs.push({
                round,
                kind: 'buff',
                actor: character.name,
                proc: 'é›·éœ†å®ˆæŠ¤',
                text: `ã€é›·éœ†å®ˆæŠ¤ã€‘å—åˆ°çš„æ‰€æœ‰ä¼¤å®³é™ä½ ${Math.round((1 - dtm) * 100)}%ï¼ˆæŒç»­${dur}å›åˆï¼‰`
            });
        }

        // ==================== è£…å¤‡ç‰¹æ•ˆï¼šæ¦‚ç‡è§¦å‘ä¼¤å®³ï¼ˆä¾‹å¦‚ï¼šè¨å¼—æ‹‰æ–¯Â·ç«ç„°ç®­ï¼‰ ====================
        const procDamages = rollProcDamageEffects(character, 'turn_start');
        if (procDamages.length > 0 && enemyHp > 0) {
            procDamages.forEach(pd => {
                const raw = Math.floor((Number(pd.rawDamage) || 0) * mapDamageDealtMult);
                const actual = Math.max(1, Math.floor(raw - enemyDefense));
                enemyHp -= actual;

                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: pd.label,
                    text: `ã€${pd.label}ã€‘å‘½ä¸­ ${combatState?.enemy?.name || 'æ•Œäºº'}ï¼šé€ æˆ ${actual} ${getSchoolCn(pd.school)}ä¼¤å®³`
                });
            });
        }

        // é¥°å“/è£…å¤‡ç‰¹æ•ˆï¼šæŠ€èƒ½æ å¼ºåŒ–ï¼ˆä¾‹å¦‚ï¼šç¬¬1æ ¼ä¸ç¬¬4æ ¼ï¼‰
        const slotBuff = getSkillSlotBuffBonus(character, slotIndex);
        // ç§æ—ï¼šæŠ€èƒ½æ ¼å±æ€§åŠ æˆï¼ˆä¾‹å¦‚ï¼šå·¨é­”ã€ç‹‚æš´ã€‘å‰4æ ¼æ€¥é€Ÿ+20ï¼‰
        const racialSlotBonus = getRacialSkillSlotStatBonus(character, slotIndex);


        // è®¡ç®—æœ¬å›åˆç”¨äºæŠ€èƒ½ç»“ç®—çš„é¢æ¿ï¼ˆä¸ä¼šå†™å›è§’è‰²æœ¬ä½“ï¼‰
        const calcStats = {
            ...character.stats,
            attack: (character.stats.attack || 0) + (talentBuffs.attackFlat || 0) + (slotBuff.attackBonus || 0),
            blockValue: (character.stats.blockValue || 0) + (talentBuffs.blockValueFlat || 0),
            spellPower: (character.stats.spellPower || 0) + (talentBuffs.spellPowerFlat || 0) + (slotBuff.spellPowerBonus || 0),
        };

        // ç§æ—ï¼šæŠ€èƒ½æ ¼å±æ€§åŠ æˆï¼ˆåŠ æ³•å åŠ ï¼‰
        Object.entries(racialSlotBonus || {}).forEach(([stat, add]) => {
            calcStats[stat] = (calcStats[stat] || 0) + (Number(add) || 0);
        });

        // å åŠ æœ¬å›åˆè§¦å‘çš„ä¸´æ—¶å±æ€§
        Object.entries(turnProcBonus || {}).forEach(([stat, add]) => {
            calcStats[stat] = (calcStats[stat] || 0) + (Number(add) || 0);
        });

        // Buffï¼šé¢æ¿å±æ€§åŠ æˆï¼ˆå¦‚åˆ‡å‰²/å†²åŠ¨/æ­£ä¸­çœ‰å¿ƒ/å†°å†·è¡€è„‰/äº‰åˆ†å¤ºç§’ç­‰ï¼‰
        if (Array.isArray(buffs) && buffs.length > 0) {
            buffs.forEach(b => {
                if (!b) return;
                if (Number.isFinite(Number(b.hasteBonus)) && Number(b.hasteBonus) !== 0) {
                    calcStats.haste = (calcStats.haste || 0) + (Number(b.hasteBonus) || 0);
                }
                if (Number.isFinite(Number(b.critRateBonus)) && Number(b.critRateBonus) !== 0) {
                    calcStats.critRate = (calcStats.critRate || 0) + (Number(b.critRateBonus) || 0);
                }
                // âœ… æš´å‡»ä¼¤å®³åŠ æˆï¼ˆä¾‹å¦‚ï¼šç‹‚å¾’ç›—è´¼30çº§å¤©èµ‹ã€åˆ€é”‹å†²åˆºã€‘ï¼‰
                if (Number.isFinite(Number(b.critDamageBonus)) && Number(b.critDamageBonus) !== 0) {
                    calcStats.critDamage = (calcStats.critDamage || 2.0) + (Number(b.critDamageBonus) || 0);
                }
                if (Number.isFinite(Number(b.masteryBonus)) && Number(b.masteryBonus) !== 0) {
                    calcStats.mastery = (calcStats.mastery || 0) + (Number(b.masteryBonus) || 0);
                }
                if (Number.isFinite(Number(b.versatilityBonus)) && Number(b.versatilityBonus) !== 0) {
                    calcStats.versatility = (calcStats.versatility || 0) + (Number(b.versatilityBonus) || 0);
                }
                if (Number.isFinite(Number(b.attackBonus)) && Number(b.attackBonus) !== 0) {
                    calcStats.attack = (calcStats.attack || 0) + (Number(b.attackBonus) || 0);
                }
                if (Number.isFinite(Number(b.spellPowerBonus)) && Number(b.spellPowerBonus) !== 0) {
                    calcStats.spellPower = (calcStats.spellPower || 0) + (Number(b.spellPowerBonus) || 0);
                }
            });
        }

        // ==================== ç‹‚å¾’ç›—è´¼40çº§å¤©èµ‹ï¼šå†·è¡€ ====================
        // æ•ˆæœï¼šç¬¬1æ ¼æŠ€èƒ½æš´å‡»ç‡+100%ï¼Œæš´å‡»ä¼¤å®³+50%
        if (character?.classId === 'outlaw_rogue' && character?.talents?.[40] === 'cold_blood' && slotIndex === 0) {
            calcStats.critRate = (Number(calcStats.critRate) || 0) + 100;
            calcStats.critDamage = (Number(calcStats.critDamage) || 2.0) + 0.5;
        }

        const charForCalc = {
            ...character,
            stats: calcStats
        };


        // å†°å†·è¡€è„‰æ˜¯å¦å¼€å¯ï¼ˆbuff å†…å« icyVeinsBuffï¼‰
        const icyVeinsBuff = buffs.some(b => b.type === 'icy_veins');
        // å†°é£æš´DOTæœŸé—´ -> å†°æªå¿…çˆ†
        const blizzardActive = enemyDebuffs.some(d =>
            d.type === 'dot' &&
            d.name === 'å†°é£æš´' &&
            d.enableIceLanceCrit === true
        );

        // ä¼ å…¥combatContextç»™æŠ€èƒ½è®¡ç®—ï¼ˆç”¨äºç¥¸ç¦ç›¸ä¾ç­‰ï¼‰
        const combatContext = {
            fortuneMisfortuneStacks,
            fantasiaStacks,
            fingersOfFrost,
            icyVeinsBuff,
            blizzardActive,
            comboPoints,
            enemyCount: enemyHp > 0 ? 1 : 0
        };

        const result = skill.calculate(charForCalc, combatContext);

        // ===== æ–°å¢ï¼šé›·éœ†ä¸€å‡»ï¼ˆå•ä½“é«˜ä¼¤ + æš´å‡»æ—¶æ–½åŠ é‡ä¼¤DOTï¼‰=====
        if (result.aoeDamage) {
            let damage = result.aoeDamage;

            // ç‹‚å¾’ç›—è´¼20çº§å¤©èµ‹ï¼šç´¢å‘½å¼ºèƒ½ - æ¶ˆè€—æ˜Ÿçš„æŠ€èƒ½æ¯æ¶ˆè€—1æ˜Ÿï¼Œæœ€ç»ˆä¼¤å®³+5%
            if (character?.classId === 'outlaw_rogue' && character?.talents?.[20] === 'fatal_empowerment' && result.consumeComboPoints) {
                const spent = (result.consumeComboPoints === 'all')
                    ? (comboPoints || 0)
                    : Math.min((comboPoints || 0), Math.max(0, Math.floor(Number(result.consumeComboPoints) || 0)));
                if (spent > 0) {
                    damage *= (1 + spent * 0.05);
                    logs.push({
                        round,
                        kind: 'proc',
                        actor: character.name,
                        proc: 'ç´¢å‘½å¼ºèƒ½',
                        text: `ã€ç´¢å‘½å¼ºèƒ½ã€‘æ¶ˆè€—${spent}æ˜Ÿï¼Œæœ¬æ¬¡ã€${skill.name}ã€‘ä¼¤å®³æé«˜${spent * 5}%`
                    });
                }
            }

            // 40çº§å¤©èµ‹ï¼šæ— åšä¸æ‘§ä¹‹åŠ› - ç›¾å¢™æœŸé—´ä¼¤å®³æé«˜50%
            let buffDamageDealtMult = 1;
            buffs.forEach(b => {
                if (b.damageDealtMult) {
                    buffDamageDealtMult *= b.damageDealtMult;
                }
            });

            // ==================== ç‹‚å¾’ç›—è´¼60çº§å¤©èµ‹ï¼šæ€¥ä¸å¯è€ ====================
            // å†²åŠ¨æœŸé—´ï¼šæ ¹æ®å½“å‰è¿å‡»ç‚¹(æ˜Ÿ)æé«˜æ€»ä¼¤å®³ï¼ˆæ¯æ˜Ÿ+3%ï¼‰
            if (character?.classId === 'outlaw_rogue' && character?.talents?.[60] === 'impatient') {
                const hasAR = Array.isArray(buffs) && buffs.some(b => b?.type === 'adrenaline_rush' && (b.duration ?? 0) > 0);
                if (hasAR) {
                    const cp = Math.max(0, Math.floor(Number(comboPoints) || 0));
                    if (cp > 0) {
                        buffDamageDealtMult *= (1 + cp * 0.03);
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'æ€¥ä¸å¯è€',
                            text: `ã€æ€¥ä¸å¯è€ã€‘å†²åŠ¨æœŸé—´å½“å‰${cp}æ˜Ÿï¼Œæœ¬æ¬¡ã€${skill.name}ã€‘ä¼¤å®³æé«˜${cp * 3}%`
                        });
                    }
                }
            }
            damage *= buffDamageDealtMult;

            // âœ… ç§æ—ï¼šæš—å¤œç²¾çµã€éšéã€‘ï¼ˆåœ°å›¾æˆ˜æ–—ç¬¬1æ ¼æŠ€èƒ½ä¼¤å®³+20%ï¼Œä¹˜ç®—ï¼‰
            damage *= racialSlotDamageMult;

            // âœ… è£…å¤‡ç‰¹æ•ˆï¼šåœ°å›¾å± æˆ®ï¼ˆåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼‰
            damage *= mapDamageDealtMult;

            // å…¨èƒ½ç­‰é€šç”¨ä¹˜åŒºå·²åœ¨ä¸Šå±‚calculateä¸­å¤„ç†ï¼Œè¿™é‡Œç›´æ¥æ‰£é˜²å¾¡
            const actualDamage = Math.max(1, Math.floor(damage - enemyDefense));
            enemyHp -= actualDamage;

            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: combatState.enemy?.name,
                value: actualDamage,
                type: 'damage',
                isCrit: result.isCrit
            });

            // æš´å‡»æ—¶æ–½åŠ é‡ä¼¤DOTï¼ˆä¸ç°æœ‰DOTç»“æ„å…¼å®¹ï¼‰
            if (result.isCrit && result.dotOnCrit) {
                enemyDebuffs.push({
                    type: 'dot',
                    sourceSkillId: currentSkillId,
                    sourceSkillName: skill.name,
                    damagePerTurn: Math.floor((result.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult),
                    duration: result.dotOnCrit.duration
                });

                logs.push({
                    round,
                    actor: character.name,
                    action: `${skill.name}(é‡ä¼¤)`,
                    target: combatState.enemy?.name,
                    value: Math.floor((result.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult),
                    type: 'debuff',
                    text: `ã€é‡ä¼¤ã€‘æ–½åŠ ï¼šæ¯å›åˆ ${Math.floor((result.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult)} ä¼¤å®³ï¼ŒæŒç»­ ${result.dotOnCrit.duration} å›åˆ`
                });
            }

            // 30çº§å¤©èµ‹ï¼šæŒ«å¿—æ€’å¼ - é›·éœ†ä¸€å‡»æ–½åŠ debuffï¼Œæ•Œäººé€ æˆçš„ä¼¤å®³é™ä½20%
            if (character.talents?.[30] === 'demoralizing_shout') {
                const existingShout = enemyDebuffs.find(d => d.type === 'demoralizing_shout');
                if (!existingShout) {
                    enemyDebuffs.push({
                        type: 'demoralizing_shout',
                        damageMult: 0.8,  // é€ æˆä¼¤å®³é™ä½20%
                        duration: 999     // æŒç»­æ•´åœºæˆ˜æ–—
                    });
                    logs.push({
                        round,
                        kind: 'proc',
                        actor: character.name,
                        proc: 'æŒ«å¿—æ€’å¼',
                        text: 'ã€æŒ«å¿—æ€’å¼ã€‘è§¦å‘ï¼šæ•Œäººé€ æˆçš„ä¼¤å®³é™ä½20%'
                    });
                }
            }

            // 30çº§å¤©èµ‹ï¼šå±±ä¸˜ä¹‹ç‹ - é›·éœ†ä¸€å‡»æœ‰50%å‡ ç‡å†æ¬¡é‡Šæ”¾ä¸€æ¬¡
            if (character.talents?.[30] === 'mountain_king' && Math.random() < 0.5) {
                const extraResult = skill.calculate(charForCalc);
                const extraDamage = Math.max(1, Math.floor((extraResult.aoeDamage * racialSlotDamageMult * mapDamageDealtMult) - enemyDefense));
                enemyHp -= extraDamage;

                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: 'å±±ä¸˜ä¹‹ç‹',
                    text: `ã€å±±ä¸˜ä¹‹ç‹ã€‘è§¦å‘ï¼šé›·éœ†ä¸€å‡»å†æ¬¡é‡Šæ”¾ï¼`
                });
                logs.push({
                    round,
                    actor: character.name,
                    action: `${skill.name}(å±±ä¸˜ä¹‹ç‹)`,
                    target: combatState.enemy?.name,
                    value: extraDamage,
                    type: 'damage',
                    isCrit: extraResult.isCrit
                });

                // é¢å¤–çš„é›·éœ†ä¸€å‡»ä¹Ÿèƒ½è§¦å‘æš´å‡»é‡ä¼¤
                if (extraResult.isCrit && extraResult.dotOnCrit) {
                    enemyDebuffs.push({
                        type: 'dot',
                        sourceSkillId: currentSkillId,
                        sourceSkillName: skill.name,
                        damagePerTurn: Math.floor((extraResult.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult),
                        duration: extraResult.dotOnCrit.duration
                    });

                    logs.push({
                        round,
                        actor: character.name,
                        action: `${skill.name}(å±±ä¸˜ä¹‹ç‹-é‡ä¼¤)`,
                        target: combatState.enemy?.name,
                        value: Math.floor((extraResult.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult),
                        type: 'debuff',
                        text: `ã€é‡ä¼¤ã€‘æ–½åŠ ï¼šæ¯å›åˆ ${Math.floor((extraResult.dotOnCrit.damagePerTurn || 0) * racialSlotDamageMult)} ä¼¤å®³ï¼ŒæŒç»­ ${extraResult.dotOnCrit.duration} å›åˆ`
                    });
                }
            }
        }else if (result.aoeDot) {
            // æŠŠ aoeDot å½“ä½œå•ä½“ dot æŒ‚åˆ° enemyDebuffs
            enemyDebuffs.push({
                type: 'dot',
                sourceSkillId: currentSkillId,
                sourceSkillName: result.aoeDot.name || skill.name,
                ...result.aoeDot, // school, damagePerTurn, duration, canGenerateFinger, name ç­‰
                // âœ… ç§æ—ï¼šæš—å¤œç²¾çµã€éšéã€‘â€”â€”è‹¥è¯¥æŠ€èƒ½ä½äºç¬¬1æ ¼ï¼Œåˆ™DOTä¹Ÿäº«å—ä¼¤å®³ä¹˜ç®—
                damagePerTurn: Math.floor((result.aoeDot.damagePerTurn || 0) * racialSlotDamageMult),
            });

            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: combatState.enemy?.name,
                type: 'debuff',
                text: `æ–½æ”¾ã€${result.aoeDot.name || skill.name}ã€‘ï¼šæ¯å›åˆ ${Math.floor((result.aoeDot.damagePerTurn || 0) * racialSlotDamageMult)}ï¼ŒæŒç»­ ${result.aoeDot.duration} å›åˆ`
            });
        }

        // ===== åŸæœ‰æ™®é€šä¼¤å®³é€»è¾‘ï¼ˆä¿æŒä¸å˜ï¼‰=====
        else if (result.damage) {
            let damage = result.damage;

            // ç‹‚å¾’ç›—è´¼20çº§å¤©èµ‹ï¼šç´¢å‘½å¼ºèƒ½ - æ¶ˆè€—æ˜Ÿçš„æŠ€èƒ½æ¯æ¶ˆè€—1æ˜Ÿï¼Œæœ€ç»ˆä¼¤å®³+5%
            if (character?.classId === 'outlaw_rogue' && character?.talents?.[20] === 'fatal_empowerment' && result.consumeComboPoints) {
                const spent = (result.consumeComboPoints === 'all')
                    ? (comboPoints || 0)
                    : Math.min((comboPoints || 0), Math.max(0, Math.floor(Number(result.consumeComboPoints) || 0)));
                if (spent > 0) {
                    damage *= (1 + spent * 0.05);
                    logs.push({
                        round,
                        kind: 'proc',
                        actor: character.name,
                        proc: 'ç´¢å‘½å¼ºèƒ½',
                        text: `ã€ç´¢å‘½å¼ºèƒ½ã€‘æ¶ˆè€—${spent}æ˜Ÿï¼Œæœ¬æ¬¡ã€${skill.name}ã€‘ä¼¤å®³æé«˜${spent * 5}%`
                    });
                }
            }

            // ===== 10çº§å¤©èµ‹ï¼šæš—å½±å¢å¹…ï¼ˆæš—å½±ä¼¤å®³ +20%ï¼‰=====
            if (character.talents?.[10] === 'shadow_amp' && result.school === 'shadow') {
                damage *= 1.2;
            }

            // ===== 20çº§å¤©èµ‹ï¼šé˜´æš—é¢ä¹‹åŠ›ï¼ˆå¿ƒçµéœ‡çˆ†ä¼¤å®³ +80%ï¼‰=====
            if (character.talents?.[20] === 'dark_side' && currentSkillId === 'mind_blast') {
                damage *= 1.8;
            }

            // 40çº§å¤©èµ‹ï¼šæ— åšä¸æ‘§ä¹‹åŠ› - ç›¾å¢™æœŸé—´ä¼¤å®³æé«˜50%
            let buffDamageDealtMultForDamage = 1;
            buffs.forEach(b => {
                if (b.damageDealtMult) {
                    buffDamageDealtMultForDamage *= b.damageDealtMult;
                }
            });

            // ==================== ç‹‚å¾’ç›—è´¼60çº§å¤©èµ‹ï¼šæ€¥ä¸å¯è€ ====================
            // å†²åŠ¨æœŸé—´ï¼šæ ¹æ®å½“å‰è¿å‡»ç‚¹(æ˜Ÿ)æé«˜æ€»ä¼¤å®³ï¼ˆæ¯æ˜Ÿ+3%ï¼‰
            if (character?.classId === 'outlaw_rogue' && character?.talents?.[60] === 'impatient') {
                const hasAR = Array.isArray(buffs) && buffs.some(b => b?.type === 'adrenaline_rush' && (b.duration ?? 0) > 0);
                if (hasAR) {
                    const cp = Math.max(0, Math.floor(Number(comboPoints) || 0));
                    if (cp > 0) {
                        buffDamageDealtMultForDamage *= (1 + cp * 0.03);
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'æ€¥ä¸å¯è€',
                            text: `ã€æ€¥ä¸å¯è€ã€‘å†²åŠ¨æœŸé—´å½“å‰${cp}æ˜Ÿï¼Œæœ¬æ¬¡ã€${skill.name}ã€‘ä¼¤å®³æé«˜${cp * 3}%`
                        });
                    }
                }
            }
            damage *= buffDamageDealtMultForDamage;

            // âœ… ç§æ—ï¼šæš—å¤œç²¾çµã€éšéã€‘ï¼ˆåœ°å›¾æˆ˜æ–—ç¬¬1æ ¼æŠ€èƒ½ä¼¤å®³+20%ï¼Œä¹˜ç®—ï¼‰
            damage *= racialSlotDamageMult;

            // âœ… è£…å¤‡ç‰¹æ•ˆï¼šåœ°å›¾å± æˆ®ï¼ˆåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼‰
            damage *= mapDamageDealtMult;

            // ===== 10çº§å¤©èµ‹ï¼šç¥åœ£å¢å¹…ï¼ˆæƒ©å‡»ï¼šç›®æ ‡å—æ³•æœ¯ä¼¤å®³ +10% æŒç»­2å›åˆï¼‰=====
            if (character.talents?.[10] === 'holy_vuln' && currentSkillId === 'smite') {
                enemyDebuffs.push({ type: 'spell_vuln', mult: 1.10, duration: 2 });
                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: 'ç¥åœ£å¢å¹…',
                    text: 'ã€ç¥åœ£å¢å¹…ã€‘è§¦å‘ï¼šç›®æ ‡å—åˆ°çš„æ³•æœ¯ä¼¤å®³ +10%ï¼ˆ2å›åˆï¼‰'
                });
            }

            const isSpellSchool = (result.school === 'holy' || result.school === 'shadow');
            let takenMult = 1;
            if (isSpellSchool) {
                const vuln = enemyDebuffs.find(d => d.type === 'spell_vuln');
                if (vuln) takenMult *= (vuln.mult ?? 1);
            }

            damage = Math.floor(damage * takenMult);
            const actualDamage = Math.max(1, damage - enemyDefense);
            enemyHp -= actualDamage;

            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: combatState.enemy?.name,
                value: actualDamage,
                type: 'damage',
                isCrit: result.isCrit
            });

            if (character.stats.atonement) {
                const healFromAtonement = Math.floor(actualDamage * character.stats.atonement.healingRate);
                const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
                const actualHeal = Math.min(healFromAtonement, maxHp - charHp);
                charHp += actualHeal;
                logs.push({
                    round,
                    actor: character.name,
                    action: `æ•‘èµ`,
                    target: character.name,
                    value: actualHeal,
                    type: 'heal',
                    text: `å› ä¸ºæ•‘èµæ¢å¤ ${healFromAtonement} ç‚¹ç”Ÿå‘½`
                });
            }

            // ==================== æ–°å¢ï¼šé­ç¬è€…è‹è¨æ–¯ç‰¹æ•ˆ - æ™®æ”»å50%æ¦‚ç‡å†æ¬¡æ™®æ”» ====================
            if (currentSkillId === 'basic_attack') {
                // ==================== ç‹‚å¾’ç›—è´¼40çº§å¤©èµ‹ï¼šæ·±é‚ƒè¯¡è®¡ ====================
                // æ•ˆæœï¼šæ™®é€šæ”»å‡»æš´å‡»æœ‰50%æ¦‚ç‡è·å¾—1é¢—æ˜Ÿ
                if (character?.classId === 'outlaw_rogue' && character?.talents?.[40] === 'deep_stratagem' && result.isCrit) {
                    if (Math.random() < 0.5) {
                        const maxCombo = getMaxComboPointsForChar(character);
                        const before = comboPoints;
                        comboPoints = Math.min(maxCombo, comboPoints + 1);
                        const realGain = comboPoints - before;
                        if (realGain > 0) {
                            logs.push({
                                round,
                                kind: 'proc',
                                actor: character.name,
                                proc: 'æ·±é‚ƒè¯¡è®¡',
                                text: `ã€æ·±é‚ƒè¯¡è®¡ã€‘è§¦å‘ï¼šæ™®é€šæ”»å‡»æš´å‡»è·å¾—1æ˜Ÿï¼ˆå½“å‰${comboPoints}æ˜Ÿï¼‰`
                            });
                        }
                    }
                }

                // ==================== ç‹‚å¾’ç›—è´¼60çº§å¤©èµ‹ï¼šèƒ†å¤§å¦„ä¸º ====================
                // æ™®æ”»è¿å‡»æ¦‚ç‡ +10%ï¼›è¿å‡»è§¦å‘æ—¶è·å¾—ç²¾é€šï¼ˆå¯å åŠ ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸï¼‰
                const equipRepeatChance = getBasicAttackRepeatChance(character);
                const talentRepeatBonus =
                    (character?.classId === 'outlaw_rogue' && character?.talents?.[60] === 'reckless_bravery')
                        ? 0.10
                        : 0;

                const repeatChance = Math.min(1, Math.max(0, (Number(equipRepeatChance) || 0) + talentRepeatBonus));
                const roll = Math.random();
                if (repeatChance > 0 && roll < repeatChance) {
                    const procLabel = (talentRepeatBonus > 0 && roll >= (Number(equipRepeatChance) || 0))
                        ? 'èƒ†å¤§å¦„ä¸º'
                        : 'é­ç¬è€…è‹è¨æ–¯';

                    logs.push({
                        round,
                        kind: 'proc',
                        actor: character.name,
                        proc: procLabel,
                        text: `ã€${procLabel}ã€‘è§¦å‘ï¼šå†æ¬¡å‘åŠ¨æ™®é€šæ”»å‡»ï¼`
                    });

                    // è¿å‡»è§¦å‘ï¼šè·å¾—ç²¾é€šï¼ˆä»…å½“ç‚¹äº†èƒ†å¤§å¦„ä¸ºï¼‰
                    if (talentRepeatBonus > 0) {
                        const perStack = 20;
                        const maxDuration = 999;

                        const idx = buffs.findIndex(b => b?.type === 'reckless_bravery_mastery');
                        if (idx === -1) {
                            buffs.push({
                                type: 'reckless_bravery_mastery',
                                name: 'èƒ†å¤§å¦„ä¸º',
                                stacks: 1,
                                masteryBonus: perStack,
                                duration: maxDuration,
                            });
                            logs.push({
                                round,
                                kind: 'proc',
                                actor: character.name,
                                proc: 'èƒ†å¤§å¦„ä¸º',
                                text: `ã€èƒ†å¤§å¦„ä¸ºã€‘è·å¾—${perStack}ç²¾é€šï¼ˆ1å±‚ï¼Œæ€»ç²¾é€š+${perStack}ï¼‰`
                            });
                        } else {
                            const old = buffs[idx];
                            const curStacks = Math.max(0, Math.floor(Number(old.stacks) || 0));
                            const nextStacks = curStacks + 1;
                            buffs[idx] = {
                                ...old,
                                stacks: nextStacks,
                                masteryBonus: nextStacks * perStack,
                                duration: maxDuration,
                            };
                            logs.push({
                                round,
                                kind: 'proc',
                                actor: character.name,
                                proc: 'èƒ†å¤§å¦„ä¸º',
                                text: `ã€èƒ†å¤§å¦„ä¸ºã€‘è·å¾—${perStack}ç²¾é€šï¼ˆ${nextStacks}å±‚ï¼Œæ€»ç²¾é€š+${nextStacks * perStack}ï¼‰`
                            });
                        }
                    }
                    // ===== å¤©èµ‹è§¦å‘ï¼ˆä¿æŒä¸å˜ï¼‰=====
                    if (currentSkillId === 'basic_attack' && character.talents?.[10] === 'plain') {
                        talentBuffs.attackFlat = (talentBuffs.attackFlat || 0) + 5;
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'è´¨æœ´',
                            value: 5,
                            text: 'ã€è´¨æœ´ã€‘è§¦å‘ï¼Œæ”»å‡»å¼ºåº¦ +5ï¼ˆæœ¬åœºæˆ˜æ–—ï¼‰'
                        });
                    }
                    enemyHp -= actualDamage;
                    logs.push({
                        round,
                        actor: character.name,
                        action: skill.name,
                        target: combatState.enemy?.name,
                        value: actualDamage,
                        type: 'damage',
                        isCrit: result.isCrit
                    });

                    // ===== 50çº§å¤©èµ‹ï¼šåœ£å‰‘ - æ™®æ”»é¢å¤–é€ æˆæ ¼æŒ¡å€¼ä¼¤å®³ =====
                    if (result.holySwordDamage && result.holySwordDamage > 0) {
                        const holySwordActualDamage = Math.max(1, Math.floor(result.holySwordDamage * racialSlotDamageMult * mapDamageDealtMult));
                        enemyHp -= holySwordActualDamage;

                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'åœ£å‰‘',
                            text: `ã€åœ£å‰‘ã€‘è§¦å‘ï¼šé¢å¤–é€ æˆ ${holySwordActualDamage} ç‚¹çœŸå®ä¼¤å®³ï¼ˆæ— è§†é˜²å¾¡ï¼‰`
                        });
                    }

                    // âœ… ç‹‚å¾’ç›—è´¼30çº§å¤©èµ‹ï¼šæ‚è€æ‰“å‡»ï¼ˆé‡å¤æ™®æ”»åŒæ ·å å±‚ï¼‰
                    procJugglingStrikes('basic_attack');

                    // 40çº§å¤©èµ‹ï¼šæ·±é‚ƒè¯¡è®¡ï¼ˆé‡å¤æ™®æ”»åŒæ ·åˆ¤å®šï¼‰
                    if (character?.classId === 'outlaw_rogue' && character?.talents?.[40] === 'deep_stratagem' && result.isCrit) {
                        if (Math.random() < 0.5) {
                            const maxCombo = getMaxComboPointsForChar(character);
                            const before = comboPoints;
                            comboPoints = Math.min(maxCombo, comboPoints + 1);
                            const realGain = comboPoints - before;
                            if (realGain > 0) {
                                logs.push({
                                    round,
                                    kind: 'proc',
                                    actor: character.name,
                                    proc: 'æ·±é‚ƒè¯¡è®¡',
                                    text: `ã€æ·±é‚ƒè¯¡è®¡ã€‘è§¦å‘ï¼šé‡å¤æ™®æ”»æš´å‡»è·å¾—1æ˜Ÿï¼ˆå½“å‰${comboPoints}æ˜Ÿï¼‰`
                                });
                            }
                        }
                    }
                }
            }

            // ==================== ç‹‚å¾’ç›—è´¼30çº§å¤©èµ‹ï¼šè—é”‹å¯»æ—¶ ====================
            // æ•ˆæœï¼šä¼å‡»æœ‰80%æ¦‚ç‡å†æ¬¡å‘åŠ¨ï¼Œæ¯ä¸ªæŠ€èƒ½æ ¼ä»…åˆ¤å®šä¸€æ¬¡ã€‚
            if (currentSkillId === 'ambush' && character?.classId === 'outlaw_rogue' && character?.talents?.[30] === 'hidden_edge_time') {
                talentFlags.hiddenEdgeTime = talentFlags.hiddenEdgeTime || { checkedSlots: {} };
                const checkedSlots = talentFlags.hiddenEdgeTime.checkedSlots || {};
                talentFlags.hiddenEdgeTime.checkedSlots = checkedSlots;

                // æ¯ä¸ªæŠ€èƒ½æ ¼ä»…åˆ¤å®šä¸€æ¬¡ï¼ˆæ— è®ºæˆè´¥ï¼‰
                if (!checkedSlots[slotIndex]) {
                    checkedSlots[slotIndex] = true;

                    if (Math.random() < 0.8 && enemyHp > 0) {
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'è—é”‹å¯»æ—¶',
                            text: 'ã€è—é”‹å¯»æ—¶ã€‘è§¦å‘ï¼šä¼å‡»å†æ¬¡å‘åŠ¨ï¼'
                        });

                        const extraSkill = SKILLS['ambush'];
                        const extraResult = extraSkill.calculate(charForCalc, combatContext);

                        if (extraResult?.damage) {
                            let extraDamage = extraResult.damage;

                            // ä¸æ™®é€šä¼¤å®³é€»è¾‘ä¿æŒä¸€è‡´ï¼ˆbuff/æ˜“ä¼¤/ç§æ—/åœ°å›¾å± æˆ®ç­‰ï¼‰
                            if (character?.classId === 'outlaw_rogue' && character?.talents?.[20] === 'fatal_empowerment' && extraResult.consumeComboPoints) {
                                const spent = (extraResult.consumeComboPoints === 'all')
                                    ? (comboPoints || 0)
                                    : Math.min((comboPoints || 0), Math.max(0, Math.floor(Number(extraResult.consumeComboPoints) || 0)));
                                if (spent > 0) {
                                    extraDamage *= (1 + spent * 0.05);
                                    logs.push({
                                        round,
                                        kind: 'proc',
                                        actor: character.name,
                                        proc: 'ç´¢å‘½å¼ºèƒ½',
                                        text: `ã€ç´¢å‘½å¼ºèƒ½ã€‘æ¶ˆè€—${spent}æ˜Ÿï¼Œæœ¬æ¬¡ã€ä¼å‡»(è—é”‹å¯»æ—¶)ã€‘ä¼¤å®³æé«˜${spent * 5}%`
                                    });
                                }
                            }

                            if (character.talents?.[10] === 'shadow_amp' && extraResult.school === 'shadow') {
                                extraDamage *= 1.2;
                            }

                            extraDamage *= buffDamageDealtMultForDamage;
                            extraDamage *= racialSlotDamageMult;
                            extraDamage *= mapDamageDealtMult;

                            const isSpellSchoolExtra = (extraResult.school === 'holy' || extraResult.school === 'shadow');
                            let takenMultExtra = 1;
                            if (isSpellSchoolExtra) {
                                const vuln = enemyDebuffs.find(d => d.type === 'spell_vuln');
                                if (vuln) takenMultExtra *= (vuln.mult ?? 1);
                            }

                            extraDamage = Math.floor(extraDamage * takenMultExtra);
                            const extraActual = Math.max(1, extraDamage - enemyDefense);
                            enemyHp -= extraActual;

                            logs.push({
                                round,
                                actor: character.name,
                                action: `${skill.name}(è—é”‹å¯»æ—¶)`,
                                target: combatState.enemy?.name,
                                value: extraActual,
                                type: 'damage',
                                isCrit: extraResult.isCrit
                            });

                            // æ•‘èµæœºåˆ¶ï¼ˆé€šç”¨ï¼Œä¸å½±å“ç›—è´¼ï¼Œä½†ä¿æŒä¸€è‡´ï¼‰
                            if (character.stats.atonement) {
                                const healFromAtonement = Math.floor(extraActual * character.stats.atonement.healingRate);
                                const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
                                const actualHeal = Math.min(healFromAtonement, maxHp - charHp);
                                charHp += actualHeal;
                                logs.push({
                                    round,
                                    actor: character.name,
                                    action: 'æ•‘èµ',
                                    target: character.name,
                                    value: actualHeal,
                                    type: 'heal',
                                    text: `å› ä¸ºæ•‘èµæ¢å¤ ${actualHeal} ç‚¹ç”Ÿå‘½`
                                });
                            }
                        }

                        // âœ… é¢å¤–ä¼å‡»ä¹Ÿäº§ç”Ÿè¿å‡»ç‚¹ï¼ˆæ˜Ÿï¼‰
                        if (extraResult?.generateComboPoints) {
                            const gain = Math.max(0, Math.floor(Number(extraResult.generateComboPoints) || 0));
                            if (gain > 0) {
                                const maxCombo = getMaxComboPointsForChar(character);
                                const before = comboPoints;
                                comboPoints = Math.min(maxCombo, comboPoints + gain);
                                const realGain = comboPoints - before;
                                if (realGain > 0) {
                                    logs.push({
                                        round,
                                        kind: 'proc',
                                        actor: character.name,
                                        proc: 'è¿å‡»ç‚¹',
                                        text: `ã€è¿å‡»ç‚¹ã€‘å› ã€è—é”‹å¯»æ—¶ã€‘é¢å¤–è·å¾— ${realGain} æ˜Ÿï¼ˆå½“å‰${comboPoints}æ˜Ÿï¼‰`
                                    });
                                }
                            }
                        }
                    } else {
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'è—é”‹å¯»æ—¶',
                            text: 'ã€è—é”‹å¯»æ—¶ã€‘æœªè§¦å‘ï¼šä¼å‡»æ²¡æœ‰å†æ¬¡å‘åŠ¨'
                        });
                    }
                }
            }
        }
        // ===== åŸæœ‰å…¶ä»–æŠ€èƒ½é€»è¾‘ï¼ˆä¿æŒä¸å˜ï¼‰=====
        else if (result.heal) {
            const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
            const actualHeal = Math.min(result.heal, maxHp - charHp);
            charHp += actualHeal;
            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: character.name,
                value: actualHeal,
                type: 'heal'
            });
        }
        else if (result.buff) {
            buffs.push({ ...result.buff });
            let buffText = '';
            if (result.buff.damageTakenMult) {
                const damageReduction = Math.round((1 - result.buff.damageTakenMult) * 100);
                buffText = `å¼€å¯ç›¾å¢™ï¼šå—åˆ°ä¼¤å®³é™ä½${damageReduction}%`;
                if (result.buff.damageDealtMult && result.buff.damageDealtMult > 1) {
                    const damageIncrease = Math.round((result.buff.damageDealtMult - 1) * 100);
                    buffText += `ï¼Œé€ æˆä¼¤å®³æé«˜${damageIncrease}%`;
                }

                // 60çº§å¤©èµ‹ï¼šæ³°å¦å£å’ - ç›¾å¢™æœŸé—´é¢æ¿å±æ€§åŠ æˆ
                if (Number.isFinite(Number(result.buff.masteryBonus)) && Number(result.buff.masteryBonus) !== 0) {
                    buffText += `ï¼Œç²¾é€š+${result.buff.masteryBonus}`;
                }
                if (Number.isFinite(Number(result.buff.versatilityBonus)) && Number(result.buff.versatilityBonus) !== 0) {
                    buffText += `ï¼Œå…¨èƒ½+${result.buff.versatilityBonus}`;
                }
            }

            // å†°å†·è¡€è„‰ / ç›—è´¼å¢ç›Šç­‰
            if (!buffText && result.buff.type === 'icy_veins') {
                buffText = `ã€å†°å†·è¡€è„‰ã€‘å†°éœœä¼¤å®³+50%ï¼Œæ€¥é€Ÿ+50%`;
            }
            if (!buffText && result.buff.type === 'blade_flurry') {
                buffText = 'ã€å‰‘åˆƒä¹±èˆã€‘æ™®æ”»/åˆºéª¨/ä¼å‡»/æ­£ä¸­çœ‰å¿ƒå°†è§¦å‘å¤åˆ¶ä¼¤å®³';
            }
            if (!buffText && result.buff.type === 'slice_and_dice') {
                const vBonus = result.buff.versatilityBonus || 0;
                buffText = `ã€åˆ‡å‰²ã€‘æ€¥é€Ÿ+${result.buff.hasteBonus || 0}` + (vBonus ? `ï¼Œå…¨èƒ½+${vBonus}` : '');
            }
            if (!buffText && result.buff.type === 'between_the_eyes') {
                buffText = `ã€æ­£ä¸­çœ‰å¿ƒã€‘æš´å‡»ç‡+${result.buff.critRateBonus || 0}%`;
            }
            if (!buffText && result.buff.type === 'adrenaline_rush') {
                buffText = `ã€å†²åŠ¨ã€‘æ€¥é€Ÿ+${result.buff.hasteBonus || 0}ï¼Œæ¯å›åˆ+${result.buff.comboPerTurn || 0}æ˜Ÿ`;
            }
            if (!buffText && result.buff.type === 'crimson_vial') {
                buffText = `ã€çŒ©çº¢ä¹‹ç“¶ã€‘æ¯å›åˆå›å¤${Math.round((result.buff.healPctPerTurn || 0) * 100)}%æœ€å¤§ç”Ÿå‘½å€¼`;
            }
            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: character.name,
                value: result.buff.duration ?? 0,
                type: 'buff',
                text: buffText
            });
        }

        // ===== æŠ¤ç›¾æŠ€èƒ½å¤„ç† =====
        if (result.shield) {
            // æ£€æŸ¥æ˜¯å¦å·²æœ‰åŒç±»å‹æŠ¤ç›¾ï¼Œå¦‚æœæœ‰åˆ™åˆ·æ–°
            const existingShieldIdx = buffs.findIndex(b => b.type === result.shield.type);
            if (existingShieldIdx !== -1) {
                // åˆ·æ–°æŠ¤ç›¾ï¼šå–æ–°æ—§æŠ¤ç›¾çš„è¾ƒå¤§å€¼
                const oldShield = buffs[existingShieldIdx];
                buffs[existingShieldIdx] = {
                    ...result.shield,
                    amount: Math.max(oldShield.amount, result.shield.amount)
                };
                logs.push({
                    round,
                    actor: character.name,
                    action: skill.name,
                    target: character.name,
                    type: 'shield',
                    value: result.shield.amount,
                    text: `åˆ·æ–°ã€${result.shield.name}ã€‘æŠ¤ç›¾ï¼Œå½“å‰å¸æ”¶é‡ï¼š${buffs[existingShieldIdx].amount}`
                });
            } else {
                // æ·»åŠ æ–°æŠ¤ç›¾
                buffs.push({ ...result.shield });
                logs.push({
                    round,
                    actor: character.name,
                    action: skill.name,
                    target: character.name,
                    type: 'shield',
                    value: result.shield.amount,
                    text: `è·å¾—ã€${result.shield.name}ã€‘æŠ¤ç›¾ï¼Œå¯å¸æ”¶ ${result.shield.amount} ç‚¹ä¼¤å®³ï¼ŒæŒç»­ ${result.shield.duration} å›åˆ`
                });
            }
        }

        if (result.dot) {
            enemyDebuffs.push({
                type: 'dot',
                sourceSkillId: currentSkillId,
                sourceSkillName: skill.name,
                ...result.dot,
                // âœ… ç§æ—ï¼šæš—å¤œç²¾çµã€éšéã€‘â€”â€”è‹¥è¯¥æŠ€èƒ½ä½äºç¬¬1æ ¼ï¼Œåˆ™DOTä¹Ÿäº«å—ä¼¤å®³ä¹˜ç®—
                damagePerTurn: Math.floor((result.dot.damagePerTurn || 0) * racialSlotDamageMult),
            });

            logs.push({
                round,
                actor: character.name,
                action: `${skill.name}(æ–½åŠ )`,
                target: combatState.enemy?.name,
                value: Math.floor((result.dot.damagePerTurn || 0) * racialSlotDamageMult),
                type: 'debuff',
                text: `æ–½åŠ æŒç»­ä¼¤å®³ï¼šæ¯å›åˆ ${Math.floor((result.dot.damagePerTurn || 0) * racialSlotDamageMult)}ï¼ŒæŒç»­ ${result.dot.duration} å›åˆ`
            });
        }

        if (result.healAll) {
            const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
            const actualHeal = Math.min(result.healAll, maxHp - charHp);
            charHp += actualHeal;
            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: character.name,
                value: actualHeal,
                type: 'heal'
            });
        }
        // ===== è‹¦ä¿®æŠ€èƒ½å¤„ç† =====
        else if (result.penanceHeal) {
            // è‹¦ä¿®æ²»ç–—è‡ªå·±ï¼ˆæ™®é€šæˆ˜æ–—ä¸­åªæœ‰ä¸€ä¸ªè§’è‰²ï¼Œæ‰€ä»¥æ²»ç–—è‡ªå·±ï¼‰
            const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
            const actualHeal = Math.min(result.penanceHeal, maxHp - charHp);
            charHp += actualHeal;

            let healText = `è‹¦ä¿®æ²»ç–— ${actualHeal}`;
            if (fortuneMisfortuneStacks > 0 && character.talents?.[40] === 'fortune_misfortune') {
                healText += `ï¼ˆç¥¸ç¦ç›¸ä¾ ${fortuneMisfortuneStacks} å±‚åŠ æˆï¼‰`;
            }

            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: character.name,
                value: actualHeal,
                type: 'heal',
                text: healText
            });

            // ==================== æˆ’å¾‹ç‰§å¸ˆ60çº§å¤©èµ‹ï¼šç—›è‹¦å‹åˆ¶ ====================
            // è‹¦ä¿®ä½¿å½“å‰ç›®æ ‡è·å¾—30%å‡ä¼¤ï¼ˆbuffä¹˜ç®—ï¼‰ï¼ŒæŒç»­2å›åˆï¼ˆåœ°å›¾æˆ˜æ–—ä¸­â€œç›®æ ‡=è‡ªå·±â€ï¼‰
            if (character?.classId === 'discipline_priest' && character?.talents?.[60] === 'pain_suppression') {
                const duration = 2;
                const damageTakenMult = 0.7;

                const idx = buffs.findIndex(b => b?.type === 'pain_suppression');
                if (idx === -1) {
                    buffs.push({
                        type: 'pain_suppression',
                        name: 'ç—›è‹¦å‹åˆ¶',
                        damageTakenMult,
                        duration
                    });
                } else {
                    buffs[idx] = {
                        ...buffs[idx],
                        type: 'pain_suppression',
                        name: 'ç—›è‹¦å‹åˆ¶',
                        damageTakenMult,
                        duration
                    };
                }

                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: 'ç—›è‹¦å‹åˆ¶',
                    text: `ã€ç—›è‹¦å‹åˆ¶ã€‘è§¦å‘ï¼šå—åˆ°ä¼¤å®³é™ä½30%ï¼ŒæŒç»­${duration}å›åˆ`
                });
            }

            // 40çº§å¤©èµ‹ï¼šç»ˆæè‹¦ä¿® - é€ æˆä¼¤å®³
            if (result.penanceDamage) {
                const actualDamage = Math.max(
                    1,
                    Math.floor(result.penanceDamage * racialSlotDamageMult * mapDamageDealtMult) - enemyDefense
                );
                enemyHp -= actualDamage;
                if (character.stats.atonement) {
                    const healFromAtonement = Math.floor(actualDamage * character.stats.atonement.healingRate);
                    const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
                    const actualHeal = Math.min(healFromAtonement, maxHp - charHp);
                    charHp += actualHeal;
                    logs.push({
                        round,
                        actor: character.name,
                        action: `æ•‘èµ`,
                        target: character.name,
                        value: actualHeal,
                        type: 'heal',
                        text: `å› ä¸ºæ•‘èµæ¢å¤ ${healFromAtonement} ç‚¹ç”Ÿå‘½`
                    });
                }
                logs.push({
                    round,
                    actor: character.name,
                    action: `${skill.name}(ç»ˆæè‹¦ä¿®)`,
                    target: combatState.enemy?.name,
                    value: actualDamage,
                    type: 'damage',
                    isCrit: result.penanceDamageIsCrit,
                    text: 'ã€ç»ˆæè‹¦ä¿®ã€‘é€ æˆä¼¤å®³'
                });

            }

            // 40çº§å¤©èµ‹ï¼šäº‰åˆ†å¤ºç§’ - æ€¥é€Ÿbuff
            if (result.applyHasteBuff) {
                buffs.push({
                    type: 'haste',
                    hasteBonus: result.applyHasteBuff.hasteBonus,
                    duration: result.applyHasteBuff.duration
                });
                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: 'äº‰åˆ†å¤ºç§’',
                    text: `ã€äº‰åˆ†å¤ºç§’ã€‘è§¦å‘ï¼šæ€¥é€Ÿ+${result.applyHasteBuff.hasteBonus}%ï¼ŒæŒç»­${result.applyHasteBuff.duration}å›åˆ`
                });
            }

            // æ¸…ç©ºç¥¸ç¦ç›¸ä¾å±‚æ•°
            if (result.clearFortuneStacks) {
                fortuneMisfortuneStacks = 0;
            }
        }

        if (result.applyAtonement) {
            // âœ… æ•‘èµæ¯”ä¾‹éœ€è¦åƒæˆ’å¾‹ç‰§å¸ˆç²¾é€šï¼ˆåŸºç¡€ 20% + ç²¾é€šåŠ æˆï¼‰
            const existingRate = character.stats.atonement?.healingRate;
            const mastery = Number(character.stats.mastery) || 0;

            // ä¸ calculateTotalStats é‡Œçš„â€œç²¾é€šï¼šæ•‘èµâ€ä¿æŒä¸€è‡´
            const actualHeal = (typeof existingRate === 'number')
                ? existingRate
                : (0.20 + (mastery / 10) / 100);
            const atonementDuration = result.applyAtonement.duration || 2;
            // âœ… 60çº§å¤©èµ‹ï¼šä»æ…ˆ - æ•‘èµé¢å¤–æä¾›5%å‡ä¼¤ï¼ˆä¹˜ç®—ï¼‰
            const benevolence = (character?.classId === 'discipline_priest' && character?.talents?.[60] === 'benevolence');

            character.stats.atonement = {
                healingRate: actualHeal,
                duration: atonementDuration,
                ...(benevolence ? { damageTakenMult: 0.95 } : {})
            };
            logs.push({
                round,
                actor: character.name,
                action: skill.name,
                target: character.name,
                value: `æ•‘èµç”Ÿæ•ˆï¼ŒæŒç»­ ${atonementDuration} å›åˆï¼Œæ²»ç–—é‡ï¼š${actualHeal}å€ä¼¤å®³${benevolence ? 'ï¼ˆä»æ…ˆï¼šé¢å¤–5%å‡ä¼¤ï¼‰' : ''}`,
                type: 'buff'
            });
        }

        // ===== å¹»æƒ³æ›²ï¼šç¥åœ£æ–°æ˜Ÿæ–½æ”¾åæ¸…ç©ºå±‚æ•° =====
        if (result.clearFantasiaStacks) {
            const used = Number(result.fantasiaStacksUsed) || fantasiaStacks;
            fantasiaStacks = 0;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'å¹»æƒ³æ›²',
                text: `ã€å¹»æƒ³æ›²ã€‘æ¶ˆè€—${used}å±‚ï¼Œå¼ºåŒ–æœ¬æ¬¡ç¥åœ£æ–°æ˜Ÿåæ¸…ç©ºå±‚æ•°`
            });
        }

        // ===== å¤©èµ‹è§¦å‘ï¼ˆä¿æŒä¸å˜ï¼‰=====
        if (currentSkillId === 'basic_attack' && character.talents?.[10] === 'plain') {
            talentBuffs.attackFlat = (talentBuffs.attackFlat || 0) + 5;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'è´¨æœ´',
                value: 5,
                text: 'ã€è´¨æœ´ã€‘è§¦å‘ï¼Œæ”»å‡»å¼ºåº¦ +5ï¼ˆæœ¬åœºæˆ˜æ–—ï¼‰'
            });
        }

        // ==================== ç‹‚å¾’ç›—è´¼30çº§å¤©èµ‹ ====================
        // æ‚è€æ‰“å‡»ï¼šæ™®é€šæ”»å‡»/å½±è¢­å å±‚å…¨èƒ½ï¼ˆæœ¬åœºæˆ˜æ–—ï¼‰
        procJugglingStrikes(currentSkillId);

        // åˆ€é”‹å†²åˆºï¼šä¼å‡»åè·å¾—æš´å‡»ä¼¤å®³+50%ï¼ˆæŒç»­4å›åˆï¼‰
        if (currentSkillId === 'ambush' && character?.classId === 'outlaw_rogue' && character?.talents?.[30] === 'blade_dash') {
            const duration = 4;
            const bonus = 0.5;
            const idx = buffs.findIndex(b => b?.type === 'blade_dash');
            if (idx === -1) {
                buffs.push({
                    type: 'blade_dash',
                    name: 'åˆ€é”‹å†²åˆº',
                    duration,
                    critDamageBonus: bonus,
                });
            } else {
                buffs[idx] = {
                    ...buffs[idx],
                    duration,
                    critDamageBonus: bonus,
                };
            }
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'åˆ€é”‹å†²åˆº',
                text: `ã€åˆ€é”‹å†²åˆºã€‘è§¦å‘ï¼šæš´å‡»ä¼¤å®³+50%ï¼ŒæŒç»­${duration}å›åˆ`
            });
        }

        if (currentSkillId === 'smite' && character.talents?.[10] === 'holy_infusion') {
            talentBuffs.spellPowerFlat = (talentBuffs.spellPowerFlat || 0) + 2;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'ç¥åœ£çŒæ³¨',
                value: 2,
                text: 'ã€ç¥åœ£çŒæ³¨ã€‘è§¦å‘ï¼Œæ³•æœ¯å¼ºåº¦ +2ï¼ˆæœ¬åœºæˆ˜æ–—ï¼‰'
            });
        }

        // 40çº§å¤©èµ‹ï¼šç¥¸ç¦ç›¸ä¾ - æƒ©å‡»å’Œå¿ƒçµéœ‡çˆ†ç´¯ç§¯å±‚æ•°
        if ((currentSkillId === 'smite' || currentSkillId === 'mind_blast') && character.talents?.[40] === 'fortune_misfortune') {
            fortuneMisfortuneStacks += 1;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'ç¥¸ç¦ç›¸ä¾',
                value: fortuneMisfortuneStacks,
                text: `ã€ç¥¸ç¦ç›¸ä¾ã€‘å±‚æ•°+1ï¼Œå½“å‰${fortuneMisfortuneStacks}å±‚ï¼ˆè‹¦ä¿®æ²»ç–—é‡+${fortuneMisfortuneStacks * 25}%ï¼‰`
            });
        }

        // âœ… å†°æªæ¶ˆè€—å¯’å†°æŒ‡
        if (result.consumeFingersOfFrost) {
            fingersOfFrost = Math.max(0, fingersOfFrost - 1);
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'å¯’å†°æŒ‡',
                value: fingersOfFrost,
                text: `æ¶ˆè€— 1 å±‚å¯’å†°æŒ‡ï¼ˆå‰©ä½™ ${fingersOfFrost} å±‚ï¼‰`
            });
        }

        // ==================== ç›—è´¼ï¼šè¿å‡»ç‚¹ï¼ˆæ˜Ÿï¼‰ç»“ç®— ====================
        // æŠ€èƒ½çš„ calculate å¯è¿”å›ï¼š
        // - generateComboPoints: number
        // - consumeComboPoints: 'all' | number
        comboPoints = Number.isFinite(comboPoints) ? comboPoints : 0;
        if (result.consumeComboPoints) {
            const spent = result.consumeComboPoints === 'all'
                ? comboPoints
                : Math.min(comboPoints, Math.max(0, Math.floor(Number(result.consumeComboPoints) || 0)));
            if (spent > 0) {
                comboPoints = Math.max(0, comboPoints - spent);
                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: 'è¿å‡»ç‚¹',
                    text: `ã€è¿å‡»ç‚¹ã€‘æ¶ˆè€— ${spent} æ˜Ÿï¼ˆå½“å‰${comboPoints}æ˜Ÿï¼‰`
                });

                // ç‹‚å¾’ç›—è´¼20çº§å¤©èµ‹ï¼šæ— æƒ… - æ¯æ¶ˆè€—1æ˜Ÿï¼Œ20%æ¦‚ç‡è¿”è¿˜1æ˜Ÿ
                if (character?.classId === 'outlaw_rogue' && character?.talents?.[20] === 'ruthless') {
                    let refunded = 0;
                    for (let k = 0; k < spent; k++) {
                        if (Math.random() < 0.2) refunded += 1;
                    }
                    if (refunded > 0) {
                        const maxCombo = getMaxComboPointsForChar(character);
                        const beforeRefund = comboPoints;
                        comboPoints = Math.min(maxCombo, comboPoints + refunded);
                        const realRefund = comboPoints - beforeRefund;
                        if (realRefund > 0) {
                            logs.push({
                                round,
                                kind: 'proc',
                                actor: character.name,
                                proc: 'æ— æƒ…',
                                text: `ã€æ— æƒ…ã€‘è§¦å‘ï¼šè¿”è¿˜ ${realRefund} æ˜Ÿï¼ˆå½“å‰${comboPoints}æ˜Ÿï¼‰`
                            });
                        }
                    }
                }
            }
        }
        if (result.generateComboPoints) {
            const gain = Math.max(0, Math.floor(Number(result.generateComboPoints) || 0));
            if (gain > 0) {
                const maxCombo = getMaxComboPointsForChar(character);
                const before = comboPoints;
                comboPoints = Math.min(maxCombo, comboPoints + gain);
                const realGain = comboPoints - before;
                if (realGain > 0) {
                    logs.push({
                        round,
                        kind: 'proc',
                        actor: character.name,
                        proc: 'è¿å‡»ç‚¹',
                        text: `ã€è¿å‡»ç‚¹ã€‘è·å¾— ${realGain} æ˜Ÿï¼ˆå½“å‰${comboPoints}æ˜Ÿï¼‰`
                    });
                }
            }
        }

        skillIndex++;

        if (enemyHp <= 0) break;

        // ===== DOT ç»“ç®—ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼Œé‡ä¼¤DOTä¼šè‡ªåŠ¨å‚ä¸ï¼‰=====
        const hasteFromBuffsForDot = Array.isArray(buffs)
            ? buffs.reduce((sum, b) => sum + (Number(b?.hasteBonus) || 0), 0)
            : 0;

        // ==================== æˆ’å¾‹ç‰§å¸ˆ30çº§å¤©èµ‹ï¼šæš—å½±é­” ====================
        // æ•ˆæœï¼šæ¯å›åˆé€ æˆ 0.3 å€æ³•æœ¯å¼ºåº¦çš„æš—å½±ä¼¤å®³
        // è¯´æ˜ï¼šä½œä¸ºè¢«åŠ¨â€œDOTç±»å›åˆä¼¤å®³â€ï¼Œåœ¨ DOT ç»“ç®—é˜¶æ®µè§¦å‘ä¸€æ¬¡ã€‚
        if (character?.classId === 'discipline_priest' && character?.talents?.[30] === 'shadowfiend') {
            // åŸºç¡€ï¼š0.3 *ï¼ˆå½“å‰é¢æ¿æ³•å¼º + æœ¬åœºæˆ˜æ–—å åŠ æ³•å¼ºï¼‰
            // é»˜è®¤ 0.6 * æ³•å¼ºï¼›60çº§å¤©èµ‹ã€å‚¬å¿ƒé­”ã€‘= 1.2 * æ³•å¼ºï¼ˆéœ€è¦å·²ç‚¹30çº§æš—å½±é­”æ‰ä¼šè¿›å…¥æœ¬æ®µï¼‰
            const sfCoeff = (character?.talents?.[60] === 'mindbender') ? 1.2 : 0.6;
            let sfDamage = ((character?.stats?.spellPower || 0) + (talentBuffs?.spellPowerFlat || 0)) * sfCoeff;

            // 10çº§å¤©èµ‹ï¼šæš—å½±å¢å¹…ï¼ˆæš—å½±ä¼¤å®³ +20%ï¼‰
            if (character.talents?.[10] === 'shadow_amp') {
                sfDamage *= 1.2;
            }

            // æ³•æœ¯æ˜“ä¼¤ï¼ˆå¦‚ï¼šåœ£å…‰æ˜“ä¼¤ï¼‰
            const sfVuln = enemyDebuffs.find(x => x.type === 'spell_vuln');
            if (sfVuln?.mult) {
                sfDamage *= sfVuln.mult;
            }

            // æ€¥é€Ÿï¼šä½œä¸º DOT ç±»å›åˆä¼¤å®³ï¼ŒåŒæ ·äº«å—â€œæ€¥é€Ÿ*2%â€çš„ä¼¤å®³åŠ æˆ
            sfDamage *= (1 + ((((character?.stats?.haste) || 0) + hasteFromBuffsForDot) * 0.02));

            // âœ… è£…å¤‡ç‰¹æ•ˆï¼šåœ°å›¾å± æˆ®ï¼ˆåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼‰
            sfDamage *= mapDamageDealtMult;

            const isCrit = Math.random() < ((character?.stats?.critRate || 0) / 100);
            if (isCrit) {
                sfDamage *= (character?.stats?.critDamage || 2);
            }

            sfDamage = Math.floor(sfDamage);
            const actualSf = Math.max(1, sfDamage - enemyDefense);

            // æ•‘èµæœºåˆ¶ï¼ˆä¿æŒä¸å…¶å®ƒ DOT ä¸€è‡´ï¼šæŒ‰å®é™…ä¼¤å®³è§¦å‘ï¼‰
            if (character.stats.atonement) {
                const healFromAtonement = Math.floor(actualSf * character.stats.atonement.healingRate);
                const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
                const actualHeal = Math.min(healFromAtonement, maxHp - charHp);
                charHp += actualHeal;
                logs.push({
                    round,
                    actor: character.name,
                    action: 'æ•‘èµ',
                    target: character.name,
                    value: actualHeal,
                    type: 'heal',
                    text: `å› ä¸ºæ•‘èµæ¢å¤ ${actualHeal} ç‚¹ç”Ÿå‘½`
                });
            }

            enemyHp -= actualSf;
            logs.push({
                round,
                actor: character.name,
                action: 'æš—å½±é­”',
                target: combatState.enemy?.name,
                value: actualSf,
                type: 'damage',
                text: `ã€æš—å½±é­”ã€‘é€ æˆ ${actualSf} æš—å½±ä¼¤å®³`+isCrit?`ã€çˆ†å‡»ã€‘`:``,
            });
        }

        const dots = enemyDebuffs.filter(d => d.type === 'dot');
        if (dots.length > 0) {
            for (const d of dots) {
                let dotDamage = d.damagePerTurn ?? 0;

                if (character.talents?.[10] === 'shadow_amp' && d.school === 'shadow') {
                    dotDamage *= 1.2;
                }

                const isSpellSchool = (d.school === 'holy' || d.school === 'shadow');
                if (isSpellSchool) {
                    const vuln = enemyDebuffs.find(x => x.type === 'spell_vuln');
                    if (vuln?.mult) dotDamage *= vuln.mult;
                }

                // æ€¥é€Ÿï¼šDOT ä¼¤å®³æé«˜ï¼ˆæ€¥é€Ÿ * 2%ï¼‰
                dotDamage *= (1 + ((((character?.stats?.haste) || 0) + hasteFromBuffsForDot) * 0.02));

                // âœ… è£…å¤‡ç‰¹æ•ˆï¼šåœ°å›¾å± æˆ®ï¼ˆåœ°å›¾æˆ˜æ–—ä¼¤å®³åŠ æˆï¼‰
                dotDamage *= mapDamageDealtMult;
                dotDamage = Math.floor(dotDamage);
                const actualDot = Math.max(1, dotDamage - enemyDefense);
                if (character.stats.atonement) {
                    const healFromAtonement = Math.floor(actualDot * character.stats.atonement.healingRate);
                    const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
                    const actualHeal = Math.min(healFromAtonement, maxHp - charHp);
                    charHp += actualHeal;
                    logs.push({
                        round,
                        actor: character.name,
                        action: 'æ•‘èµ',
                        target: character.name,
                        value: actualHeal,
                        type: 'heal',
                        text: `å› ä¸ºæ•‘èµæ¢å¤ ${actualHeal} ç‚¹ç”Ÿå‘½`
                    });
                }

                enemyHp -= actualDot;

                logs.push({
                    round,
                    actor: character.name,
                    action: `${d.sourceSkillName || 'æŒç»­ä¼¤å®³'}(æŒç»­)`,
                    target: combatState.enemy?.name,
                    value: actualDot,
                    type: 'damage'
                });

                // 30çº§å¤©èµ‹ï¼šæ®‹æš´åŠ¨åŠ› - é‡ä¼¤ä¼¤å®³çš„150%æ²»ç–—è‡ªå·±
                if (character.talents?.[30] === 'brutal_momentum' && d.sourceSkillName === 'é›·éœ†ä¸€å‡»') {
                    const healAmount = Math.floor(actualDot * 1.5);
                    const maxHp = character.stats.maxHp ?? character.stats.hp ?? 0;
                    const actualHeal = Math.min(healAmount, maxHp - charHp);
                    if (actualHeal > 0) {
                        charHp += actualHeal;
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'æ®‹æš´åŠ¨åŠ›',
                            value: actualHeal,
                            type: 'heal',
                            text: `ã€æ®‹æš´åŠ¨åŠ›ã€‘è§¦å‘ï¼šæ²»ç–— ${actualHeal} ç‚¹ç”Ÿå‘½`
                        });
                    }
                }

                // âœ… 30çº§å¤©èµ‹ï¼šå®ç ç²¾é€š - å¯’å†°å®ç çš„DOTæœ‰æ¦‚ç‡ç”Ÿæˆå¯’å†°æŒ‡
                if (character.talents?.[30] === 'orb_mastery' && d.canGenerateFinger) {
                    if (Math.random() < 0.25) { // æ¦‚ç‡ä½ å¯ä»¥æŒ‰Bossæˆ˜é€»è¾‘å¯¹é½ï¼›
                        fingersOfFrost += 1;
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'å®ç ç²¾é€š',
                            value: fingersOfFrost,
                            text: `ã€å®ç ç²¾é€šã€‘è§¦å‘ï¼šè·å¾— 1 å±‚å¯’å†°æŒ‡ï¼ˆå½“å‰ ${fingersOfFrost} å±‚ï¼‰`
                        });
                    }
                }


                if (enemyHp <= 0) break;
            }
        }

        // æ•‘èµæŒç»­æ—¶é—´å¤„ç†ï¼ˆä¿æŒä¸å˜ï¼‰
        if (character.stats.atonement && character.stats.atonement.duration > 0) {
            character.stats.atonement.duration -= 1;
        }
        if (character.stats.atonement && character.stats.atonement.duration <= 0) {
            delete character.stats.atonement;
            logs.push({
                round,
                actor: character.name,
                action: "æ•‘èµç»“æŸ",
                target: character.name,
                value: "æ•‘èµæ•ˆæœç»“æŸ",
                type: 'buff'
            });
        }

        // ===== æ•Œäººå›åˆ =====
        const dr = getArmorDamageReduction(character.stats.armor);
        const rawEnemyDamage = applyPhysicalMitigation(combatState.enemy?.attack ?? 0, character.stats.armor);

        // ===== 50çº§å¤©èµ‹ï¼šæ ¼æŒ¡çªç ´ - è¶…è¿‡95%çš„æ ¼æŒ¡ç‡è½¬åŒ–ä¸ºæ ¼æŒ¡å€¼åŠ æˆ =====
        let baseBlockRate = (character.stats.blockRate || 0) + getBuffBlockRate();
        let blockBreakthroughBonusValue = 0;

        if (character.talents?.[50] === 'block_breakthrough' && baseBlockRate > 95) {
            const excessBlockRate = baseBlockRate - 95;
            // è¶…å‡ºéƒ¨åˆ†è½¬åŒ–ä¸ºæ ¼æŒ¡å€¼ç™¾åˆ†æ¯”åŠ æˆ
            blockBreakthroughBonusValue = Math.floor((character.stats.blockValue || 0) * (excessBlockRate / 100));
            baseBlockRate = 95; // æ ¼æŒ¡ç‡å°é¡¶95%
        }

        const blockChance = Math.max(
            0,
            Math.min(
                0.95,
                ((character.stats.blockRate || 0) + getBuffBlockRate()) / 100
            )
        );

        let finalDamage = rawEnemyDamage;
        let blockedAmount = 0;

        if (Math.random() < blockChance) {
            // æ ¼æŒ¡å€¼ = åŸºç¡€æ ¼æŒ¡å€¼ + å¤©èµ‹åŠ æˆ + æ ¼æŒ¡çªç ´åŠ æˆ
            const blockValue = Math.floor(
                (character.stats.blockValue || 0) +
                (talentBuffs.blockValueFlat || 0) +
                blockBreakthroughBonusValue
            );
            blockedAmount = Math.min(finalDamage - 1, blockValue);
            finalDamage = Math.max(1, finalDamage - blockedAmount);
        }

        if (blockedAmount > 0 && character.talents?.[10] === 'block_master') {
            talentBuffs.blockValueFlat = (talentBuffs.blockValueFlat || 0) + 10;
            logs.push({
                round,
                kind: 'proc',
                actor: character.name,
                proc: 'æ ¼æŒ¡å¤§å¸ˆ',
                value: 10,
                text: 'ã€æ ¼æŒ¡å¤§å¸ˆã€‘è§¦å‘ï¼Œæ ¼æŒ¡å€¼ +10ï¼ˆæœ¬åœºæˆ˜æ–—ï¼‰'
            });
        }

        // ===== 60çº§å¤©èµ‹ï¼šç›¾åˆºåå‡» =====
        // æ¯æ¬¡æˆåŠŸæ ¼æŒ¡åï¼Œå¯¹å½“å‰æ•Œäººé€ æˆç­‰åŒäºæœ¬æ¬¡è¢«æ ¼æŒ¡æ‰çš„ä¼¤å®³å€¼çš„çœŸå®ä¼¤å®³
        if (blockedAmount > 0 && character.talents?.[60] === 'shield_spikes') {
            const spikeDmg = Math.floor(blockedAmount);
            if (spikeDmg > 0) {
                enemyHp -= spikeDmg;
                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: 'ç›¾åˆºåå‡»',
                    value: spikeDmg,
                    text: `ã€ç›¾åˆºåå‡»ã€‘è§¦å‘ï¼šå¯¹ ${combatState.enemy?.name || 'æ•Œäºº'} é€ æˆ ${spikeDmg} ç‚¹çœŸå®ä¼¤å®³`
                });
            }
        }

        // ===== æ–°å¢ï¼šbuffå‡ä¼¤ä¹˜åŒºï¼ˆç›¾å¢™ç­‰ï¼‰=====
        let buffDamageTakenMult = 1;
        let buffDamageDealtMult = 1;  // 40çº§å¤©èµ‹ï¼šæ— åšä¸æ‘§ä¹‹åŠ›
        buffs.forEach(b => {
            if (b.damageTakenMult) {
                buffDamageTakenMult *= b.damageTakenMult;
            }
            if (b.damageDealtMult) {
                buffDamageDealtMult *= b.damageDealtMult;
            }
        });

        // 30çº§å¤©èµ‹ï¼šæŒ«å¿—æ€’å¼ - æ•Œäººé€ æˆçš„ä¼¤å®³é™ä½20%
        const demoralizingShout = enemyDebuffs.find(d => d.type === 'demoralizing_shout');
        const enemyDamageMult = demoralizingShout ? demoralizingShout.damageMult : 1;

        const atonementTakenMult = character.stats.atonement?.damageTakenMult ?? 1;

        finalDamage = Math.max(1, Math.floor(finalDamage * (character.stats.damageTakenMult || 1) * buffDamageTakenMult * atonementTakenMult * enemyDamageMult * getVersatilityDamageTakenMult(character.stats.versatility)));

        // ===== æ–°å¢ï¼šæŠ¤ç›¾å¸æ”¶ä¼¤å®³ =====
        let shieldAbsorbed = 0;
        const shieldBuff = buffs.find(b => b.type && b.amount > 0 && ['ice_barrier', 'holy_barrier'].includes(b.type));

        if (shieldBuff && finalDamage > 0) {
            // è®¡ç®—æŠ¤ç›¾å¸æ”¶é‡
            shieldAbsorbed = Math.min(shieldBuff.amount, finalDamage);
            shieldBuff.amount -= shieldAbsorbed;
            finalDamage -= shieldAbsorbed;

            // æŠ¤ç›¾å—å‡»è§¦å‘æ•ˆæœ
            if (shieldBuff.onHitEffect) {
                if (shieldBuff.onHitEffect.type === 'generate_finger' && character.classId === 'frost_mage') {
                    if (Math.random() < shieldBuff.onHitEffect.chance) {
                        fingersOfFrost = (fingersOfFrost || 0) + 1;
                        logs.push({
                            round,
                            kind: 'proc',
                            actor: character.name,
                            proc: 'å¯’å†°æŠ¤ä½“',
                            text: `ã€å¯’å†°æŠ¤ä½“ã€‘è§¦å‘ï¼šè·å¾—1å±‚å¯’å†°æŒ‡ï¼ˆå½“å‰${fingersOfFrost}å±‚ï¼‰`
                        });
                    }
                }
            }

            // æŠ¤ç›¾ç ´ç¢
            if (shieldBuff.amount <= 0) {
                logs.push({
                    round,
                    kind: 'proc',
                    actor: character.name,
                    proc: shieldBuff.name,
                    text: `ã€${shieldBuff.name}ã€‘æŠ¤ç›¾ç ´ç¢ï¼`
                });
                // ä»buffsä¸­ç§»é™¤ï¼ˆæˆ–æ ‡è®°ä¸º0ï¼Œåœ¨tickBuffsæ—¶æ¸…ç†ï¼‰
                const shieldIdx = buffs.findIndex(b => b.type === shieldBuff.type);
                if (shieldIdx !== -1) {
                    buffs.splice(shieldIdx, 1);
                }
            }
        }

        charHp -= finalDamage;
        const blockText = blockedAmount > 0 ? `ï¼Œæ ¼æŒ¡ ${blockedAmount}` : '';
        logs.push({
            round,
            actor: combatState.enemy?.name,
            action: `æ™®é€šæ”»å‡»(æŠ¤ç”²å‡ä¼¤ ${(dr * 100).toFixed(3)}%${blockText})`,
            target: character.name,
            value: Math.floor(finalDamage),
            type: 'damage'
        });

        // å›åˆç»“æŸï¼Œbuff/debuff duration -1ï¼ˆä¿æŒåŸæœ‰ï¼‰
        tickBuffs();
        tickEnemyDebuffs();
    }

    const finished = (charHp <= 0) || (enemyHp <= 0) || (round >= 50);

    return {
        finished,
        won: enemyHp <= 0,
        charHp,
        combatState: {
            ...combatState,
            enemyHp,
            round,
            skillIndex,
            comboPoints,
            buffs,
            enemyDebuffs,
            validSkills,
            logs,
            talentBuffs,
            fortuneMisfortuneStacks,
            fantasiaStacks,
            fingersOfFrost, // æŠŠæœ€æ–°å±‚æ•°å­˜å›å»
            talentFlags,
        }
    };
}

// ==================== è®¡ç®—åŠŸèƒ½å»ºç­‘åŠ¨æ€æˆæœ¬ ====================
function getFunctionalBuildingCost(buildingId, state) {
    const building = FUNCTIONAL_BUILDINGS[buildingId];
    if (!building) return {};

    const builtCount = state.functionalBuildings?.[buildingId] || 0;

    // æ¯å¤šå»ºé€ ä¸€åº§ï¼Œæˆæœ¬å¢åŠ 20%
    const MAX_COST_INCREASE_PCT = 200000;
    const MAX_MULTIPLIER = 1 + MAX_COST_INCREASE_PCT / 100;

    const rawMultiplier = Math.pow(1.2, builtCount);
    const multiplier = Math.min(rawMultiplier, MAX_MULTIPLIER);

    const cost = {};
    Object.entries(building.cost).forEach(([res, amount]) => {
        cost[res] = Math.ceil(amount * multiplier);
    });

    return cost;
}

// ==================== å–·æ³‰æ•ˆç‡å€ç‡ï¼ˆå–·æ³‰è‰åª/å–·æ³‰å¤–é¥°ï¼Œç‹¬ç«‹ä¹˜åŒºï¼‰ ====================
function getFountainEfficiency(state) {
    const lawnCount = Math.max(0, Math.floor(Number(state?.functionalBuildings?.fountain_lawn) || 0));
    const decorCount = Math.max(0, Math.floor(Number(state?.functionalBuildings?.fountain_decor) || 0));

    const lawnMult = 1 + 0.10 * Math.min(20, lawnCount);
    const decorMult = 1 + 0.10 * Math.min(20, decorCount);

    return {
        lawnCount,
        decorCount,
        lawnMult,
        decorMult,
        totalMult: lawnMult * decorMult,
    };
}

// ==================== GAME REDUCER ====================
function gameReducer(state, action) {
    switch (action.type) {
        case 'TOGGLE_WORLD_BOSS_AUTOKILL': {
            const { bossId } = action.payload || {};
            if (!bossId) return state;
            const cur = !!state.worldBossAutoKill?.[bossId];
            return {
                ...state,
                worldBossAutoKill: {
                    ...(state.worldBossAutoKill || {}),
                    [bossId]: !cur,
                }
            };
        }

        case 'TOGGLE_DROP_FILTER': {
            const { itemId } = action.payload;
            const current = state.dropFilters?.[itemId];

            // current === false => åˆ‡å› true
            // undefined / true => åˆ‡æˆ false
            const nextValue = current === false;

            return {
                ...state,
                dropFilters: {
                    ...(state.dropFilters || {}),
                    [itemId]: nextValue
                }
            };
        }

        case 'APPLY_OFFLINE_REWARDS': {
            const { rewards, actualSeconds } = action.payload;
            let newState = { ...state };

            newState.resources = {
                ...newState.resources,
                gold: newState.resources.gold + rewards.gold
            };

            newState.characters = newState.characters.map(char => {
                if (rewards.exp[char.id]) {
                    let exp = char.exp + rewards.exp[char.id];
                    let level = char.level;
                    let expToNext = char.expToNext;

                    while (exp >= expToNext && level < 60) {
                        exp -= expToNext;
                        level++;
                        expToNext = Math.floor(100 * Math.pow(1.2, level - 1));
                    }

                    const updatedChar = { ...char, exp, level, expToNext };
                    updatedChar.stats = calculateTotalStats(updatedChar, undefined, state);
                    return updatedChar;
                }
                return char;
            });

            // âœ… ç¦»çº¿èµ„æºè¿›ä¸»åŸ resourcesï¼ˆæŒ‰åç§°æ˜ å°„åˆ° keyï¼‰
            const mapResourceNameToKey = (name) => {
                const m = {
                    'æœ¨æ': 'wood',
                    'è‰è¯': 'herb',
                    'é“çŸ¿': 'ironOre',
                    'æ¯›çš®': 'leather',
                    'é­”æ³•ç²¾å': 'magicEssence',
                    'ç‚¼é‡‘æ²¹': 'alchemyOil',
                };
                return m[name] || null;
            };

            if (rewards.kingdomResources) {
                const res = { ...newState.resources };
                Object.entries(rewards.kingdomResources).forEach(([cnName, amount]) => {
                    const key = mapResourceNameToKey(cnName);
                    if (!key) return;
                    res[key] = (res[key] || 0) + (amount || 0);
                });
                newState.resources = res;
            }

            if (rewards.items.length > 0) {
                newState.inventory = [...newState.inventory];

                const allowDrop = (id) => state.dropFilters?.[id] !== false;
                rewards.items.forEach(item => {
                    const itemId = (typeof item === 'string') ? null : item?.id;
                    // âœ… æ‰è½å¼€å…³ï¼šå¯¹æ‰€æœ‰â€œæœ‰ id çš„ç‰©å“â€ç”Ÿæ•ˆï¼ˆåŒ…å« Boss å¾½ç« ç­‰ consumableï¼‰
                    if (itemId && !allowDrop(itemId)) return;

                    if (newState.inventory.length < newState.inventorySize) {
                        if (typeof item === 'string') {
                            newState.inventory.push({
                                id: `item_${Date.now()}_${Math.random()}`,
                                name: item,
                                type: 'resource'
                            });
                        } else {
                            newState.inventory.push(item);
                        }

                        if (item && item.type === 'equipment') {
                            newState = addEquipmentIdToCodex(newState, item.id);
                        } else if (itemId) {
                            // âœ… éè£…å¤‡ç±»æ‰è½ï¼ˆjunk / consumable / å…¶å®ƒï¼‰ï¼šç»Ÿä¸€è®°å½•åˆ°ç‰©å“å›¾é‰´é›†åˆ
                            newState = addJunkIdToCodex(newState, itemId);
                        }
                    }
                });
            }

            // âœ… ç¦»çº¿æœŸé—´è§£é”çš„åéª‘ï¼šç›´æ¥ç‚¹äº®åéª‘å›¾é‰´ï¼ˆä¸è¿›èƒŒåŒ…ï¼‰
            if (Array.isArray(rewards.mounts) && rewards.mounts.length > 0) {
                rewards.mounts.forEach(mid => {
                    newState = addMountIdToCodex(newState, mid);
                });
            }

            if (rewards.researchProgress > 0 && newState.currentResearch) {
                newState.researchProgress = Math.min(
                    100,
                    newState.researchProgress + rewards.researchProgress
                );
            }

            // âœ… ç¦»çº¿æˆ˜æ–—ç»Ÿè®¡ï¼šè®¡å…¥æ€»æˆ˜æ–—èƒœåˆ©æ•° & å„åŒºåŸŸå‡»æ€æ•°ï¼ˆè·¨ä¸–ç´¯è®¡ï¼Œä¸ä¼šè¢«é‡ç”Ÿé‡ç½®ï¼‰æš‚æ—¶ä¸è®°å½•
            /*const offlineCombats = Number(rewards.combats) || 0;
            if (offlineCombats > 0) {
                newState.stats = {
                    ...(newState.stats || {}),
                    battlesWon: (newState.stats?.battlesWon || 0) + offlineCombats,
                };
            }

            const killsByZone = (rewards.killsByZone && typeof rewards.killsByZone === 'object' && !Array.isArray(rewards.killsByZone))
                ? rewards.killsByZone
                : null;

            if (killsByZone) {
                const nextZoneKillCounts = (newState.zoneKillCounts && typeof newState.zoneKillCounts === 'object' && !Array.isArray(newState.zoneKillCounts))
                    ? { ...newState.zoneKillCounts }
                    : {};

                Object.entries(killsByZone).forEach(([zid, cnt]) => {
                    const add = Math.max(0, Math.floor(Number(cnt) || 0));
                    if (!zid || add <= 0) return;
                    nextZoneKillCounts[zid] = (nextZoneKillCounts[zid] || 0) + add;
                });

                newState.zoneKillCounts = nextZoneKillCounts;
            }*/

            newState.offlineRewards = null;
            newState.lastOnlineTime = Date.now();

            return newState;
        }

        case 'CALCULATE_OFFLINE_REWARDS': {
            const now = Date.now();
            const offlineSeconds = Math.floor((now - state.lastOnlineTime) / 1000);

            if (offlineSeconds > 60) {
                const offlineData = calculateOfflineRewards(state, offlineSeconds);
                return {
                    ...state,
                    offlineRewards: offlineData
                };
            }

            return {
                ...state,
                lastOnlineTime: now
            };
        }

        case 'DISMISS_OFFLINE_REWARDS': {
            return {
                ...state,
                offlineRewards: null,
                lastOnlineTime: Date.now()
            };
        }

        case 'TICK': {
            const deltaSeconds = action.payload?.deltaSeconds ?? 1;

            let newState = {
                ...state,
                frame: state.frame + deltaSeconds ,
                lifeFrame: (state.lifeFrame || 0) + deltaSeconds,};
// ===== æ—¶é—´æ®µåˆ‡æ¢ï¼šæš—å¤œç²¾çµã€ç²¾çµç²¾é­„ã€‘ =====
// ä»…åœ¨ 6:00 / 18:00 è¾¹ç•Œå‘ç”Ÿå˜åŒ–æ—¶é‡ç®—ä¸€æ¬¡å…¨é˜Ÿå±æ€§ï¼Œé¿å…æ¯ç§’å…¨é‡é‡ç®—ã€‚
            {
                const hour = new Date().getHours();
                const cfg = RACE_TRAITS?.['æš—å¤œç²¾çµ']?.timeBasedStatBonus || {};
                const dayStart = Number.isFinite(Number(cfg.dayStart)) ? Number(cfg.dayStart) : 6;
                const nightStart = Number.isFinite(Number(cfg.nightStart)) ? Number(cfg.nightStart) : 18;
                const isDay = dayStart < nightStart
                    ? (hour >= dayStart && hour < nightStart)
                    : (hour >= dayStart || hour < nightStart);
                const phase = isDay ? 'day' : 'night';
                if (newState.nightElfSpiritPhase !== phase) {
                    newState.nightElfSpiritPhase = phase;

                    // é˜Ÿä¼é‡Œæœ‰æš—å¤œç²¾çµæ—¶æ‰éœ€è¦é‡ç®—
                    if ((newState.characters || []).some(c => c?.race === 'æš—å¤œç²¾çµ')) {
                        newState.characters = recalcPartyStats(newState, newState.characters);
                    }
                }
            }


            // ===== è·¨ä¸–ç´¯è®¡ï¼šåœ°å›¾åŒºåŸŸå‡»æ€è®¡æ•°ï¼ˆç”¨äºæˆå°±ï¼Œå¦‚ã€Œåé‡Œå¡å‰‘åœ£ã€ï¼‰ =====
            // è¯´æ˜ï¼šè¯¥è®¡æ•°ä¸åº”å› é‡ç”Ÿ/ä»»ä½•æ“ä½œè€Œè¢«é‡ç½®ï¼Œå› æ­¤æŒ‚åœ¨ state.zoneKillCounts å¹¶éšå­˜æ¡£æŒä¹…åŒ–ã€‚
            let zoneKillCountsUpdated = false;
            let nextZoneKillCounts = (newState.zoneKillCounts && typeof newState.zoneKillCounts === 'object' && !Array.isArray(newState.zoneKillCounts))
                ? { ...newState.zoneKillCounts }
                : {};


            // ===== ä¸–ç•ŒBossé‡ç”Ÿå†·å´ï¼ˆç§’ï¼‰ =====
            if (newState.bossCooldowns && typeof newState.bossCooldowns === 'object') {
                const nextCooldowns = {};
                const readyNow = []; // æœ¬ tick å†…å†·å´å½’é›¶çš„ boss
                Object.entries(newState.bossCooldowns).forEach(([bid, sec]) => {
                    const left = Math.max(0, Math.floor((sec || 0) - deltaSeconds));
                    if (left > 0) {
                        nextCooldowns[bid] = left;
                    } else {
                        readyNow.push(bid);
                    }
                });
                newState.bossCooldowns = nextCooldowns;
                newState.__readyWorldBosses = readyNow; // ä¸´æ—¶å­—æ®µï¼ˆä»…æœ¬æ¬¡ reducer å†…ä½¿ç”¨ï¼‰
            }

            // ===== è‡ªåŠ¨å‡»æ€ä¸–ç•Œé¦–é¢† =====
            // è§„åˆ™ï¼šæ¯ä¸ª boss ç´¯è®¡å‡»æ€>=10åï¼Œå¯å¼€å¯ï¼›å½“ CD å¥½äº†ï¼ˆæˆ–æœ¬æ¥å°±æ²¡CDï¼‰å°±è‡ªåŠ¨å‡»æ€å¹¶æ‰è½
            // æ³¨æ„ï¼šä¸åœ¨ bossCombat ä¸­æ‰§è¡Œï¼Œé¿å…æ‰“æ–­æ‰‹åŠ¨æŒ‘æˆ˜
            if (!newState.bossCombat) {
                const killCounts = newState.worldBossKillCounts || {};
                const autoCfg = newState.worldBossAutoKill || {};

                const canAutoKillBoss = (bossId) => {
                    const boss = WORLD_BOSSES?.[bossId];
                    if (!boss) return false;

                    // è§£é”æ¡ä»¶ï¼šç­‰çº§/é“å…·
                    const unlockedByLevel = !boss.unlockLevel || (newState.characters || []).some(c => (c.level || 0) >= (boss.unlockLevel || 0));
                    if (!unlockedByLevel) return false;
                    if (bossId === 'prestor_lady' && !newState.worldBossProgress?.prestor_lady) return false;

                    // è‡ªåŠ¨å‡»æ€è§£é”ï¼šç´¯è®¡10æ¬¡
                    if ((killCounts[bossId] || 0) < 10) return false;

                    // å¿…é¡»å¼€å¯å¼€å…³
                    if (!autoCfg[bossId]) return false;

                    // CD å¿…é¡»ä¸º 0ï¼ˆç¼ºå¤±ä¹Ÿè§†ä¸º 0ï¼‰
                    const cd = newState.bossCooldowns?.[bossId] || 0;
                    if (cd > 0) return false;

                    return true;
                };

                const grantBossRewardsAuto = (bossId) => {
                    const bossData = BOSS_DATA[bossId] || WORLD_BOSSES[bossId];
                    if (!bossData?.rewards) return;

                    // 1) è®¾ç½®ä¸‹ä¸€æ¬¡CD
                    newState.bossCooldowns = {
                        ...(newState.bossCooldowns || {}),
                        [bossId]: 30 * 60,
                    };

                    // 2) æœ¬ä¸–å‡»æ€æ ‡è®°ï¼ˆé‡ç”ŸåŠ æˆéœ€è¦ï¼‰
                    if (!newState.defeatedBosses) newState.defeatedBosses = [];
                    if (!newState.defeatedBosses.includes(bossId)) {
                        newState.defeatedBosses = [...newState.defeatedBosses, bossId];
                    }

                    // 3) è·¨ä¸–ç´¯è®¡å‡»æ€æ¬¡æ•°
                    newState.worldBossKillCounts = {
                        ...(newState.worldBossKillCounts || {}),
                        [bossId]: (newState.worldBossKillCounts?.[bossId] || 0) + 1
                    };

                    // 4) é‡‘å¸
                    newState.resources = {
                        ...newState.resources,
                        gold: (newState.resources.gold || 0) + getEffectiveGoldGain((bossData.rewards.gold || 0), newState)
                    };

                    // 5) ç»éªŒï¼šè‡ªåŠ¨å‡»æ€ä¸å‘ç»éªŒï¼ˆåªå‘é‡‘å¸/è£…å¤‡ï¼‰ï¼Œé¿å…æŒ‚æœºåˆ·ç­‰çº§

                    // 6) æ‰è½
                    (bossData.rewards.items || []).forEach(itemTpl => {
                        const dropId = (typeof itemTpl === 'string') ? itemTpl : itemTpl?.id;
                        if (!dropId) return;

                        if (newState.dropFilters?.[dropId] === false) return;

                        const baseDropChance = itemTpl?.chance ?? 1;
                        const dropChance = getEffectiveDropChance(baseDropChance, newState);
                        if (Math.random() > dropChance) return;

                        if (FIXED_EQUIPMENTS?.[dropId]) {
                            const inst = createEquipmentInstance(dropId);
                            newState.inventory.push(inst);
                            newState = addEquipmentIdToCodex(newState, dropId);
                            return;
                        }

                        const tpl = ITEMS?.[dropId];
                        if (tpl) {
                            newState.inventory.push({
                                ...tpl,
                                instanceId: `autoBoss_${Date.now()}_${Math.random()}`,
                                id: tpl.id,
                            });
                            newState = addJunkIdToCodex(newState, dropId);
                            return;
                        }

                        newState.inventory.push({
                            instanceId: `autoBoss_${Date.now()}_${Math.random()}`,
                            id: dropId,
                            name: dropId,
                            type: 'junk',
                        });
                    });

                    // 7) åéª‘æ‰è½ï¼ˆä¸è¿›èƒŒåŒ…ï¼Œåªç‚¹äº®å›¾é‰´ï¼‰
                    const extraAutoLogs = [];
                    {
                        const res = tryUnlockMountFromBoss(newState, bossId, (t) => extraAutoLogs.push(t));
                        newState = res.state;
                    }

                    // 8) è®°å½•æˆ˜æ–—æ—¥å¿—ï¼ˆç”¨äºå¯è¿½æº¯ï¼‰
                    const bossLogEntry = {
                        id: `bosslog_${Date.now()}_${Math.random()}`,
                        timestamp: Date.now(),
                        characterName: 'é˜Ÿä¼',
                        zoneName: 'ä¸–ç•Œé¦–é¢†',
                        enemyName: bossData.name || bossId,
                        result: 'victory',
                        logs: [`ã€è‡ªåŠ¨å‡»æ€ã€‘${bossData.name || bossId} å·²è¢«è‡ªåŠ¨å‡»æ€ï¼Œè·å¾—é‡‘å¸ä¸æ‰è½ã€‚`, ...extraAutoLogs],
                        rewards: { gold: bossData.rewards.gold || 0, exp: 0 },
                    };
                    newState.combatLogs = [bossLogEntry, ...(newState.combatLogs || [])].slice(0, 50);
                };

                // å…ˆå¤„ç†â€œåˆšåˆšè½¬å¥½â€çš„ bossï¼Œå†å¤„ç†â€œæœ¬æ¥å°±æ²¡CDâ€çš„ bossï¼ˆé¿å…åŒ tick å†…é‡å¤ï¼‰
                const readyFromCd = Array.isArray(newState.__readyWorldBosses) ? newState.__readyWorldBosses : [];
                const processed = new Set();
                readyFromCd.forEach(bid => {
                    if (processed.has(bid)) return;
                    if (!canAutoKillBoss(bid)) return;
                    processed.add(bid);
                    grantBossRewardsAuto(bid);
                });

                Object.keys(WORLD_BOSSES || {}).forEach(bid => {
                    if (processed.has(bid)) return;
                    if (!canAutoKillBoss(bid)) return;
                    processed.add(bid);
                    grantBossRewardsAuto(bid);
                });
            }

            // æ¸…ç†ä¸´æ—¶å­—æ®µ
            if (newState.__readyWorldBosses) delete newState.__readyWorldBosses;

            newState.lastOnlineTime = Date.now();

            let newResources = { ...newState.resources };

            // ===== èµ„æºå»ºç­‘äº§å‡º =====
            Object.entries(newState.resourceAssignments || {}).forEach(([buildingId, workers]) => {
                if (!workers || workers.length === 0) return;

                const buildingData = RESOURCE_BUILDINGS[buildingId];
                if (!buildingData) return;

                // æ£€æŸ¥æ¶ˆè€—èµ„æºæ˜¯å¦è¶³å¤Ÿ
                if (buildingData.consumption) {
                    let canProduce = true;
                    Object.entries(buildingData.consumption).forEach(([res, amount]) => {
                        if ((newResources[res] || 0) < amount * workers.length) {
                            canProduce = false;
                        }
                    });
                    if (!canProduce) return;

                    // æ‰£é™¤æ¶ˆè€—
                    Object.entries(buildingData.consumption).forEach(([res, amount]) => {
                        newResources[res] -= amount * workers.length;
                    });
                }

                // è®¡ç®—äº§å‡º
                const production = calculateBuildingProduction(buildingId, workers, newState);
                const resourceType = buildingData.resourceType;
                newResources[resourceType] = (newResources[resourceType] || 0) + production * deltaSeconds;
            });

            // ===== åŠŸèƒ½å»ºç­‘æ•ˆæœ =====
            const fountainCount = newState.functionalBuildings?.plaza_fountain || 0;
            const { totalMult: fountainEfficiencyMult } = getFountainEfficiency(newState);
            const trainingCount = newState.functionalBuildings?.training_dummy || 0;
            const warehouseCount = newState.functionalBuildings?.warehouse || 0;
            const glowLighthouseCount = newState.functionalBuildings?.glow_lighthouse || 0;

            // ä»“åº“å¢åŠ èƒŒåŒ…å¤§å°
            const bonusInventorySize = warehouseCount * 1;
            newState.inventorySize = 80 + bonusInventorySize + (newState.inventorySizeExtra || 0);

            newState.resources = newResources;

            // ===== è„±æˆ˜å›è¡€ï¼ˆå–·æ³‰åŠ æˆï¼‰ =====
            const BASE_REGEN_DELAY_MS = 5000;
            const REGEN_DELAY_MS = Math.max(0, BASE_REGEN_DELAY_MS - glowLighthouseCount * 1000);
            const REGEN_PER_SECOND = 10;
            const now = Date.now();

            const researchBonus = {};
            Object.entries(newState.research).forEach(([id, level]) => {
                const research = RESEARCH[id];
                if (research) {
                    researchBonus[research.effect] = (researchBonus[research.effect] || 0) + research.bonus * level;
                }
            });

            // âœ… æˆå°±ï¼šæ‰€æœ‰å»ºç­‘äº§é‡åŠ æˆï¼ˆå»ºè®¾è€…ç³»åˆ—ç­‰ï¼‰
            const achResourceBonus = getAchievementResourceBonus(newState);

            Object.entries(newState.buildings || {}).forEach(([buildingId, count]) => {
                if (count > 0) {
                    const building = BUILDINGS[buildingId];
                    Object.entries(building.production || {}).forEach(([resource, amount]) => {
                        const bonus = researchBonus[resource] || 0;
                        const { resourceMult } = getMountMultipliers(newState);
                        const production = amount * count * (1 + bonus) * (1 + achResourceBonus) * (resourceMult || 1);
                        newResources[resource] = (newResources[resource] || 0) + production;
                    });
                    Object.entries(building.consumption || {}).forEach(([resource, amount]) => {
                        newResources[resource] = (newResources[resource] || 0) - amount * count;
                    });
                }
            });

            const maxPopBonus = researchBonus.population || 0;
            const houseCount = (newState.buildings||{}).house || 0;
            newResources.maxPopulation = Math.floor(houseCount * 2 * (1 + maxPopBonus));

            newState.resources = newResources;

            if (newState.currentResearch) {
                const research = RESEARCH[newState.currentResearch];
                const level = newState.research[newState.currentResearch] || 0;
                const cost = Math.floor(research.baseCost * Math.pow(1.2, level));

                if (newState.resources.gold >= cost) {
                    newState.researchProgress += 1;
                    if (newState.researchProgress >= 100) {
                        newState.research = {
                            ...newState.research,
                            [newState.currentResearch]: level + 1
                        };
                        newState.researchProgress = 0;
                        newState.resources.gold -= cost;
                    }
                }
            }


            // Bossæˆ˜æ–—æ¨è¿›
            if (newState.bossCombat) {
                newState = stepBossCombat(newState);
            }

            const toRecall = [];

            // åå°æˆ˜æ–—ï¼ˆæ‹†åˆ†æˆå¤š tick æ¨è¿›ï¼Œå®æ—¶æ›´æ–°è¡€é‡ï¼‰
            const COMBAT_START_INTERVAL_FRAMES = 10; // ä¸æ—§é€»è¾‘ä¿æŒèŠ‚å¥ï¼šæ¯10å¸§â€œå¼€ä¸€åœºâ€
            const COMBAT_ROUNDS_PER_TICK = 2; // æ¯ç§’æ¨è¿›2å›åˆï¼šæœ€å¤š20å›åˆ => æœ€é•¿çº¦10ç§’
            const PULL_INTERVAL_MS = 1000; // æ¯ 1 ç§’å°è¯•æ‹‰æ€ª

            Object.entries(newState.assignments).forEach(([charId, zoneId]) => {
                const zone = newState.zones[zoneId];
                const charIndex = newState.characters.findIndex(c => c.id === charId);

                console.log("ã€æ´¾é£å¾ªç¯ã€‘", {
                    charId, zoneId,
                    hasZone: !!zone,
                    enemiesLen: zone?.enemies?.length,
                    charIndex,
                    frame: newState.frame,
                    frameType: typeof newState.frame,
                });

                if (charIndex === -1) return;


                let char = { ...newState.characters[charIndex] };

                if (!zone || !zone.enemies) return;

                const now = Date.now();

                // å…³é”®ï¼šæ¯ä¸ªè§’è‰²ä¸€ä¸ªâ€œä¸Šæ¬¡æ‹‰æ€ªæ£€æŸ¥æ—¶é—´â€
                const lastPullTry = char.lastPullTry || 0;
                // âœ… ä¿®å¤ï¼šåªæœ‰"åˆ°ç‚¹"ä¸”è„±æˆ˜å›è¡€å®Œæˆï¼ˆæˆ–è¡€é‡å·²æ»¡ï¼‰æ‰ä¼šæ‹‰æ€ªå¼€å§‹æ–°æˆ˜æ–—
                if (!char.combatState && now - lastPullTry >= PULL_INTERVAL_MS) {
                    char.lastPullTry = now;
                    const lastCombatTime = char.lastCombatTime || 0;
                    const maxHp = char.stats?.maxHp ?? char.stats?.hp ?? 0;
                    const curHp = char.stats?.currentHp ?? maxHp;

                    // âœ… æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦å®Œæˆè„±æˆ˜å›è¡€æœŸï¼ˆæˆ–è¡€é‡å·²æ»¡ï¼‰
                    const isRegenPeriodOver = (now - lastCombatTime >= REGEN_DELAY_MS);
                    const isFullHp = curHp >= maxHp;

                    // âœ… æ·»åŠ è°ƒè¯•æ—¥å¿—
                    console.log('ã€æˆ˜æ–—æ£€æŸ¥ã€‘', {
                        charName: char.name,
                        now,
                        lastCombatTime,
                        timeSinceCombat: now - lastCombatTime,
                        REGEN_DELAY_MS,
                        isRegenPeriodOver,
                        curHp,
                        maxHp,
                        isFullHp,
                        willStartCombat: isRegenPeriodOver && isFullHp
                    });

                    // åªæœ‰å›è¡€æœŸç»“æŸæˆ–è¡€é‡å·²æ»¡ï¼Œæ‰å¼€å§‹æ–°æˆ˜æ–—
                    if (isRegenPeriodOver && isFullHp) {
                        const enemy = zone.enemies[Math.floor(Math.random() * zone.enemies.length)];
                        char.combatState = createCombatState(char, enemy, char.skillSlots || []);
                        char.lastCombatTime = now; // è¿›å…¥æˆ˜æ–—
                        console.log('ã€å¼€å§‹æ–°æˆ˜æ–—ã€‘', char.name);
                    }
                }

                // æ¨è¿›å½“å‰æˆ˜æ–—ï¼šæ¯tickæ›´æ–°ä¸€æ¬¡ currentHp => UI å®æ—¶å˜åŒ–
                if (char.combatState) {
                    char.lastCombatTime = now; // æˆ˜æ–—ä¸­æŒç»­åˆ·æ–°ï¼Œç¡®ä¿ä¸ä¼šè¢«è„±æˆ˜å›è¡€é€»è¾‘å½±å“

                    const step = stepCombatRounds(char, char.combatState, COMBAT_ROUNDS_PER_TICK, newState);

                    const endHp = Number.isFinite(step.charHp)
                        ? Math.max(0, Math.floor(step.charHp))
                        : (char.stats.currentHp ?? char.stats.maxHp);

                    char.stats = { ...char.stats, currentHp: endHp };
                    char.combatState = step.combatState;

                    // æˆ˜æ–—ç»“æŸï¼šå†™æ—¥å¿—ã€ç»“ç®—å¥–åŠ±ã€æ¸… combatState
                    if (step.finished) {
                        char.lastCombatTime = now; // ç»“æŸä¹Ÿåˆ·æ–°ä¸€æ¬¡ï¼šè„±æˆ˜å›è¡€ä»è¿™é‡Œå¼€å§‹è®¡æ—¶

                        const enemy = step.combatState.enemy;

                        const finalLogs = step.combatState.logs || [];

                        // âœ… ç§æ—ï¼šå®¾è‡³å¦‚å½’ï¼ˆäººç±»ï¼‰- åœ°å›¾æˆ˜æ–—ç»“æŸåå›å¤æœ€å¤§ç”Ÿå‘½å€¼çš„ 10%
                        const raceTrait = RACE_TRAITS?.[char.race];
                        const hospitalityPct = Number(raceTrait?.mapCombatEndHealPct) || 0;
                        if (hospitalityPct > 0) {
                            const maxHp = Number(char.stats?.maxHp ?? char.stats?.hp) || 0;
                            const curHp = Number(char.stats?.currentHp ?? maxHp) || 0;

                            // æ­»äº¡ï¼ˆ<=0ï¼‰ä¸è§¦å‘ï¼Œé¿å…â€œå¤æ´»â€ï¼›æ»¡è¡€ä¸è§¦å‘
                            if (maxHp > 0 && curHp > 0 && curHp < maxHp) {
                                const heal = Math.floor(maxHp * hospitalityPct);
                                if (heal > 0) {
                                    const nextHp = Math.min(maxHp, curHp + heal);
                                    if (nextHp !== curHp) {
                                        char.stats = { ...char.stats, currentHp: nextHp };

                                        // å†™å…¥æˆ˜æ–—æ—¥å¿—ï¼ˆæ©™è‰²ï¼šè¢«åŠ¨è§¦å‘ï¼‰
                                        finalLogs.push({
                                            kind: 'proc',
                                            proc: 'å®¾è‡³å¦‚å½’',
                                            text: `ã€å®¾è‡³å¦‚å½’ã€‘è§¦å‘ï¼šå›å¤ ${nextHp - curHp} ç‚¹ç”Ÿå‘½`
                                        });
                                    }
                                }
                            }
                        }


                        // âœ… æˆ˜å£«ï¼šä¹˜èƒœè¿½å‡»ï¼ˆ50çº§ï¼‰- æˆ˜æ–—èƒœåˆ©åå›å¤æœ€å¤§ç”Ÿå‘½å€¼çš„ 20%
                        if (step.won && (char.skills || []).includes('victory_rush')) {
                            const maxHp = Number(char.stats?.maxHp ?? char.stats?.hp) || 0;
                            const curHp = Number(char.stats?.currentHp ?? maxHp) || 0;

                            // æ­»äº¡ï¼ˆ<=0ï¼‰ä¸è§¦å‘ï¼Œé¿å…"å¤æ´»"ï¼›æ»¡è¡€ä¸è§¦å‘
                            if (maxHp > 0 && curHp > 0 && curHp < maxHp) {
                                const heal = Math.floor(maxHp * 0.20);
                                if (heal > 0) {
                                    const nextHp = Math.min(maxHp, curHp + heal);
                                    if (nextHp !== curHp) {
                                        char.stats = { ...char.stats, currentHp: nextHp };

                                        // å†™å…¥æˆ˜æ–—æ—¥å¿—ï¼ˆæ©™è‰²ï¼šè¢«åŠ¨è§¦å‘ï¼‰
                                        finalLogs.push({
                                            kind: 'proc',
                                            proc: 'ä¹˜èƒœè¿½å‡»',
                                            text: `ã€ä¹˜èƒœè¿½å‡»ã€‘è§¦å‘ï¼šå›å¤ ${nextHp - curHp} ç‚¹ç”Ÿå‘½`
                                        });
                                    }
                                }
                            }
                        }


                        newState.combatLogs = [
                            {
                                id: `log_${Date.now()}_${Math.random()}`,
                                timestamp: Date.now(),
                                characterName: char.name,
                                zoneName: zone.name,
                                enemyName: enemy.name,
                                result: step.won ? 'victory' : 'defeat',
                                logs: finalLogs,
                                rewards: step.won ? { gold: enemy.gold, exp: enemy.exp } : { gold: 0, exp: 0 }
                            },
                            ...newState.combatLogs
                        ].slice(0, 50);

                        // æ¸…ç†æˆ˜æ–—çŠ¶æ€
                        char.combatState = null;

                        // å¤±è´¥ï¼šå¦‚æœæ­»äº¡åˆ™å¬å›
                        if (!step.won) {
                            if (endHp <= 0) {
                                toRecall.push(charId);
                            }
                        } else {
                            // èƒœåˆ©ç»“ç®—
                            newState.resources.gold += getEffectiveGoldGain(enemy.gold, newState);

                            const { expMult } = getMountMultipliers(newState);
                            let expGained = (1 + (char.stats.expBonus || 0));
                            char.exp += enemy.exp * expGained * (expMult || 1);

                            while (char.exp >= char.expToNext && char.level < 200) {
                                char.exp -= char.expToNext;
                                char.level++;
                                char.expToNext = Math.floor(100 * Math.pow(1.2, char.level - 1));
                                char.skills = learnNewSkills(char);
                                char.stats = calculateTotalStats(char, undefined, state);
                            }

                            newState.stats.battlesWon++;

                            // âœ… è·¨ä¸–ç´¯è®¡ï¼šåœ°å›¾åŒºåŸŸå‡»æ€è®¡æ•°ï¼ˆç”¨äºæˆå°±è¿›åº¦ï¼Œä»»ä½•æ“ä½œ/é‡ç”Ÿä¸é‡ç½®ï¼‰
                            if (zoneId) {
                                nextZoneKillCounts[zoneId] = (nextZoneKillCounts[zoneId] || 0) + 1;
                                zoneKillCountsUpdated = true;
                            }

                            const mapResourceNameToKey = (name) => {
                                const m = {
                                    'æœ¨æ': 'wood',
                                    'è‰è¯': 'herb',
                                    'é“çŸ¿': 'ironOre',
                                    'æ¯›çš®': 'leather',
                                    'é­”æ³•ç²¾å': 'magicEssence',
                                    'ç‚¼é‡‘æ²¹': 'alchemyOil',
                                };
                                return m[name] || null;
                            };

                            if (Math.random() < 0.1 && zone.resources) {
                                const resourceName = zone.resources[Math.floor(Math.random() * zone.resources.length)];
                                const key = mapResourceNameToKey(resourceName);
                                if (key) {
                                    newState.resources = { ...newState.resources, [key]: (newState.resources[key] || 0) + 1 };
                                }
                            }

                            // âœ… æ–°å¢ï¼šè®°å½•æ‰è½ç‰©å“
                            const droppedItems = [];

                            // âœ… è£…å¤‡æ‰è½ï¼ˆä¿®æ”¹ç‰ˆï¼šè®°å½•æ‰è½ä¿¡æ¯ï¼‰
                            const dropTable = DROP_TABLES[zone.id];
                            if (dropTable?.equipment && newState.inventory.length < newState.inventorySize) {
                                const allowDrop = (id) => state.dropFilters?.[id] !== false;

                                dropTable.equipment.filter(drop => allowDrop(drop.id)).forEach(drop => {
                                    if (newState.inventory.length >= newState.inventorySize) return;

                                    const baseChance = drop.chance ?? 0;
                                    const effectiveChance = getEffectiveDropChance(baseChance, newState);

                                    if (Math.random() < effectiveChance) {
                                        const instance = createEquipmentInstance(drop.id);
                                        if (instance) {
                                            newState.inventory.push(instance);
                                            newState = addEquipmentIdToCodex(newState, drop.id);

                                            // âœ… è®°å½•æ‰è½ä¿¡æ¯
                                            droppedItems.push({
                                                name: instance.name,
                                                rarity: instance.rarity,
                                                chance: effectiveChance * 100, // è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼ˆåŠ æˆåï¼‰
                                                baseChance: baseChance * 100   // è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼ˆåŸºç¡€ï¼‰
                                            });
                                        }
                                    }
                                });
                            }

                            // âœ… ç‰©å“æ‰è½ï¼ˆå¦‚æœä½ ä¹Ÿæƒ³ç”¨æ‰è½è¡¨çš„ itemsï¼‰
                            if (dropTable?.items && newState.inventory.length < newState.inventorySize) {

                                const allowDrop = (id) => state.dropFilters?.[id] !== false; // é»˜è®¤å…è®¸

                                dropTable.items.filter(drop => allowDrop(drop.id)).forEach(drop => {
                                    if (newState.inventory.length >= newState.inventorySize) return;

                                    const baseChance = drop.chance ?? 0;
                                    const effectiveChance = getEffectiveDropChance(baseChance, newState);
                                    if (Math.random() < effectiveChance) {
                                        const tpl = ITEMS[drop.id];
                                        if (tpl) {
                                            newState.inventory.push({
                                                ...tpl,
                                                instanceId: `inv_${Date.now()}_${Math.random()}`,
                                                id: tpl.id,            // ä¿æŒæ¨¡æ¿ id: IT_001
                                            });
                                            newState = addJunkIdToCodex(newState, drop.id);

                                            // âœ… è®°å½•æ‰è½ä¿¡æ¯
                                            droppedItems.push({
                                                name: tpl.name,
                                                rarity: tpl.rarity || 'white',
                                                chance: effectiveChance * 100, // è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼ˆåŠ æˆåï¼‰
                                                baseChance: baseChance * 100   // è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼ˆåŸºç¡€ï¼‰
                                            });
                                        }
                                    }
                                });
                            }

                            // âœ… åéª‘æ‰è½ï¼ˆä¸è¿›èƒŒåŒ…ï¼Œåªç‚¹äº®åéª‘å›¾é‰´ï¼‰
                            if (dropTable?.mounts) {
                                const mountSet = new Set(Array.isArray(newState.codexMounts) ? newState.codexMounts : []);
                                (Array.isArray(dropTable.mounts) ? dropTable.mounts : []).forEach(drop => {
                                    const mountId = drop?.id;
                                    if (!mountId) return;
                                    // å·²ç‚¹äº®åˆ™ä¸å†Rollï¼Œé¿å…åˆ·å±
                                    if (mountSet.has(mountId)) return;

                                    const baseChance = Number(drop.chance) || 0;
                                    if (baseChance <= 0) return;
                                    if (Math.random() < baseChance) {
                                        newState = addMountIdToCodex(newState, mountId);
                                        const mount = (Array.isArray(MOUNT_CODEX) ? MOUNT_CODEX : []).find(m => m?.id === mountId);
                                        const bonusText = mount?.bonus ? formatBonusText(mount.bonus) : '';
                                        finalLogs.push({
                                            round: 'ç»“ç®—',
                                            kind: 'mount',
                                            itemName: mount?.name || mountId,
                                            rarity: 'gold',
                                            chance: baseChance * 100,
                                            text: `ğŸ‰ è·å¾—åéª‘ã€${mount?.name || mountId}ã€‘ï¼å·²ç‚¹äº®åéª‘å›¾é‰´${bonusText ? `ï¼ˆ${bonusText}ï¼‰` : ''}`
                                        });
                                    }
                                });
                            }

                            // âœ… å°†æ‰è½ä¿¡æ¯æ·»åŠ åˆ°æˆ˜æ–—æ—¥å¿—
                            if (droppedItems.length > 0) {
                                const fmtPct = (pct) => (pct < 1 ? pct.toFixed(2) : pct.toFixed(1));
                                droppedItems.forEach(item => {
                                    const basePct = Number.isFinite(item.baseChance) ? item.baseChance : item.chance;
                                    const effPct = item.chance;
                                    const showArrow = Number.isFinite(item.baseChance) && Math.abs(basePct - effPct) > 1e-9;
                                    finalLogs.push({
                                        round: 'ç»“ç®—',
                                        kind: 'drop',
                                        itemName: item.name,
                                        rarity: item.rarity,
                                        chance: item.chance,
                                        text: `ğŸ æ‰è½ã€${item.name}ã€‘ï¼Œæ¦‚ç‡ï¼š${fmtPct(basePct)}%${showArrow ? ` â†’ ${fmtPct(effPct)}%` : ''}`
                                    });
                                });
                            }

                        }
                    }

                    // å†™å›è§’è‰²
                    newState.characters = [...newState.characters];
                    newState.characters[charIndex] = char;
                }
            });
            if (toRecall.length > 0) {
                const newAssignments = { ...newState.assignments };
                toRecall.forEach(id => delete newAssignments[id]);
                newState.assignments = newAssignments;
            }

            // å†™å›è·¨ä¸–ç´¯è®¡å‡»æ€è®¡æ•°ï¼ˆç”¨äºæˆå°±è¿›åº¦ï¼‰
            if (zoneKillCountsUpdated) {
                newState.zoneKillCounts = nextZoneKillCounts;
            }

            // âœ… æˆå°±è§£é”æ£€æµ‹ï¼ˆè‹¥æˆå°±ä¼šå½±å“å±æ€§ï¼Œå¦‚ hpPctï¼Œéœ€è¦é‡ç®—å…¨é˜Ÿé¢æ¿ï¼‰
            let achievementUnlockedThisTick = false;
            Object.entries(ACHIEVEMENTS).forEach(([id, achievement]) => {
                if (!newState.achievements[id] && achievement.condition(newState)) {
                    newState.achievements = { ...newState.achievements, [id]: true };
                    achievementUnlockedThisTick = true;
                }
            });

            if (achievementUnlockedThisTick) {
                // æˆå°±å¯èƒ½æ”¹å˜è§’è‰²æ€»è¡€é‡ç­‰æ°¸ä¹…å±æ€§ï¼Œéœ€è¦ç«‹å³é‡ç®—ï¼Œå¦åˆ™éœ€è¦ç­‰åˆ°ä¸‹æ¬¡å‡çº§/é‡ç®—æ‰ç”Ÿæ•ˆ
                newState.characters = recalcPartyStats(newState, newState.characters);
            }

            const maxCharLevel = Math.max(...newState.characters.map(c => c.level), 0);
            Object.values(newState.zones).forEach(zone => {
                if (!zone.unlocked && zone.unlockLevel && maxCharLevel >= zone.unlockLevel) {
                    zone.unlocked = true;
                }
            });


            newState.characters = newState.characters.map(char => {
                const maxHp = char.stats?.maxHp ?? char.stats?.hp ?? 0;
                const curHp = char.stats?.currentHp ?? maxHp;

                // æˆ˜æ–—ä¸­ä¸å›è¡€
                if (char.combatState) return char;

                if (curHp >= maxHp) return char;

                const lastCombatTime = char.lastCombatTime || 0;
                if (now - lastCombatTime < REGEN_DELAY_MS) return char;

                const fountainRegen = fountainCount * 2 * fountainEfficiencyMult;

                return {
                    ...char,
                    stats: {
                        ...char.stats,
                        currentHp: Math.min(maxHp, curHp + REGEN_PER_SECOND + fountainRegen)
                    }
                };
            });

            // ==================== æ–°å¢ï¼šæœºæ¢°è‡‚è‡ªåŠ¨åˆæˆå‰Næ ¼è£…å¤‡ ====================
            const mechanicalArmCount = newState.functionalBuildings?.mechanical_arm ?? 0;
            const autoMergeSlots = Math.min(10, mechanicalArmCount);

            // è®¡æ—¶å™¨ï¼ˆæ¯30ç§’æ‰§è¡Œä¸€æ¬¡ï¼‰
            let timer = (newState.autoMergeTimer || 0) + deltaSeconds;
            let executions = 0;
            while (timer >= 30) {
                timer -= 30;
                executions++;
            }
            newState.autoMergeTimer = timer;

            if (executions > 0 && autoMergeSlots > 0 && newState.inventory?.length > 0) {
                let newInventory = [...newState.inventory];

                for (let exec = 0; exec < executions; exec++) {
                    let changed = false;

                    // ä»å‰åˆ°åå¤„ç†å‰ N æ ¼ç›®æ ‡
                    for (let slot = 0; slot < autoMergeSlots && slot < newInventory.length; slot++) {
                        let target = newInventory[slot];

                        if (!target || target.type !== 'equipment' || (target.currentLevel ?? 1) >= 100) {
                            continue;
                        }

                        const oldLevel = target.currentLevel ?? 1;

                        // é“¾å¼åƒåŒæ¬¾ï¼ˆåªåƒåé¢çš„ï¼‰
                        while (true) {
                            let sourceIndex = -1;
                            for (let j = slot + 1; j < newInventory.length; j++) {
                                const source = newInventory[j];
                                if (source &&
                                    source.type === 'equipment' &&
                                    source.id === target.id &&
                                    source.instanceId !== target.instanceId) {
                                    sourceIndex = j;
                                    break;
                                }
                            }

                            if (sourceIndex === -1) break; // æ²¡åŒæ¬¾äº†

                            const source = newInventory[sourceIndex];

                            // æ–°è§„åˆ™ï¼šç­‰çº§ = ç›®æ ‡å½“å‰ç­‰çº§ + æ¥æºç­‰çº§ + 1
                            target.currentLevel = Math.min(100,
                                (target.currentLevel ?? 1) + (source.currentLevel ?? 1) + 1
                            );

                            // æ›´æ–°å±æ€§
                            target.stats = scaleStats(
                                target.baseStats,
                                target.growth,
                                target.currentLevel
                            );

                            // ç§»é™¤è¢«åƒçš„è£…å¤‡
                            newInventory.splice(sourceIndex, 1);

                            changed = true;

                            // æ»¡çº§ååœæ­¢åƒï¼ˆé¿å…æ— æ„ä¹‰ç»§ç»­æ‰¾ï¼‰
                            if (target.currentLevel >= 100) break;
                        }

                        // å†™å›
                        newInventory[slot] = target;

                        // Lv100 å›¾é‰´è§£é”
                        if (oldLevel < 100 && target.currentLevel >= 100) {
                            newState.lv100Codex = {
                                ...(newState.lv100Codex || {}),
                                [target.id]: true
                            };
                            newState.combatLogs = [
                                ...(newState.combatLogs || []),
                                `æœºæ¢°è‡‚è‡ªåŠ¨åˆæˆï¼š${target.name} è¾¾åˆ° Lv100ï¼Œå›¾é‰´è§£é”ï¼`
                            ];
                        }
                    }

                    if (!changed) break; // æœ¬æ¬¡æ‰§è¡Œæ²¡åˆæˆä»»ä½•ä¸œè¥¿ï¼Œæå‰ç»“æŸ
                }

                newState.inventory = newInventory;
            }
            // ==================== æœºæ¢°è‡‚é€»è¾‘ç»“æŸ ====================

            // å¸§æ•°ç´¯è®¡
            newState.frame = (newState.frame || 0) + deltaSeconds;
            newState.lifeFrame = (newState.lifeFrame || 0) + deltaSeconds;

            return newState;
        }

        case 'CREATE_CHARACTER': {
            const { name, race, classId } = action.payload;
            console.log(race);
            if (state.characters.length >= state.characterSlots) return state;

            const classData = CLASSES[classId];
            const baseSkillSlots = Array(8).fill('basic_attack');
            const baseSkills = classData.skills.filter(s => s.level <= 1).map(s => s.skillId);
            const raceExtraSkills = RACE_TRAITS?.[race]?.extraSkills || [];
            console.log(RACE_TRAITS?.[race]?.extraSkills.length);
            const newChar = {
                id: `char_${Date.now()}`,
                name,
                race,
                classId,
                level: 1,
                exp: 0,
                expToNext: 100,
                equipment: {},
                talents: {},
                // å½“å‰æ¿€æ´»çš„æŠ€èƒ½æ§½ä½ï¼ˆç”¨äºæˆ˜æ–—è¯»å–ï¼‰
                skillSlots: [...baseSkillSlots],
                // ä¸‰å¥—æŠ€èƒ½é…ç½®ï¼š1/2/3
                skillSets: [
                    [...baseSkillSlots],
                    [...baseSkillSlots],
                    [...baseSkillSlots]
                ],
                activeSkillSet: 0,
                skills: Array.from(new Set([...(baseSkills || []), ...(raceExtraSkills || [])])),
                buffs: [],
                lastCombatTime: 0,
                combatState: null,
            };

            newChar.stats = calculateTotalStats(newChar, undefined, state);

            return {
                ...state,
                characters: [...state.characters, newChar]
            };
        }

        case 'UPDATE_SKILL_SETS': {
            const { characterId, skillSets, activeSkillSet } = action.payload || {};
            const charIndex = state.characters.findIndex(c => c.id === characterId);
            if (charIndex === -1) return state;

            const make8 = (arr, fallback) => Array.from({ length: 8 }, (_, i) => (arr?.[i] ?? fallback?.[i] ?? ''));

            const newChars = [...state.characters];
            const target = newChars[charIndex];

            const base = make8(target.skillSlots || [], Array(8).fill('basic_attack'));

            let setsRaw = Array.isArray(skillSets) ? skillSets : null;
            if (!setsRaw || setsRaw.length === 0) {
                setsRaw = [base, [...base], [...base]];
            }

            const s0 = make8(setsRaw[0], base);
            const s1 = make8(setsRaw[1], s0);
            const s2 = make8(setsRaw[2], s0);
            const normalizedSets = [s0, s1, s2];

            let active = Number.isFinite(Number(activeSkillSet))
                ? Math.floor(Number(activeSkillSet))
                : (Number.isFinite(Number(target.activeSkillSet)) ? Math.floor(Number(target.activeSkillSet)) : 0);
            active = Math.max(0, Math.min(2, active));

            const activeSlots = normalizedSets[active] || s0;

            newChars[charIndex] = {
                ...target,
                skillSets: normalizedSets,
                activeSkillSet: active,
                // åŒæ­¥ï¼šæˆ˜æ–—è¯»å– skillSlotsï¼ˆæ¿€æ´»çš„é‚£å¥—ï¼‰
                skillSlots: [...activeSlots],
            };

            return {
                ...state,
                characters: newChars
            };
        }

        // legacyï¼šåªæ›´æ–°â€œå½“å‰æ¿€æ´»é…ç½®â€çš„ skillSlotsï¼Œå¹¶å†™å›åˆ° skillSets[active]
        case 'UPDATE_SKILL_SLOTS': {
            const { characterId, skillSlots } = action.payload || {};
            const charIndex = state.characters.findIndex(c => c.id === characterId);
            if (charIndex === -1) return state;

            const make8 = (arr, fallback) => Array.from({ length: 8 }, (_, i) => (arr?.[i] ?? fallback?.[i] ?? ''));

            const newChars = [...state.characters];
            const target = newChars[charIndex];

            let active = Number.isFinite(Number(target.activeSkillSet)) ? Math.floor(Number(target.activeSkillSet)) : 0;
            active = Math.max(0, Math.min(2, active));

            const slots8 = make8(skillSlots, target.skillSlots || Array(8).fill(''));
            const base = make8(target.skillSlots || [], Array(8).fill('basic_attack'));

            // ensure existing sets
            const raw = Array.isArray(target.skillSets) ? target.skillSets : null;
            const s0 = make8(raw?.[0], base);
            const s1 = make8(raw?.[1], s0);
            const s2 = make8(raw?.[2], s0);
            const normalizedSets = [s0, s1, s2];
            normalizedSets[active] = [...slots8];

            newChars[charIndex] = {
                ...target,
                skillSlots: [...slots8],
                skillSets: normalizedSets,
                activeSkillSet: active
            };

            return {
                ...state,
                characters: newChars
            };
        }

        case 'SYNC_CHARACTER_SKILLS': {
            const { characterId } = action.payload;
            const charIndex = state.characters.findIndex(c => c.id === characterId);
            if (charIndex === -1) return state;

            const target = state.characters[charIndex];
            const curSkills = target.skills || [];
            const nextSkills = learnNewSkills(target);

            // æ²¡æœ‰æ–°æŠ€èƒ½åˆ™ä¸æ›´æ–°
            const isSame =
                nextSkills.length === curSkills.length &&
                nextSkills.every(s => curSkills.includes(s));

            if (isSame) return state;

            const newChars = [...state.characters];
            newChars[charIndex] = { ...target, skills: nextSkills };

            // ä¿é™©ï¼šé‡ç®—å…¨é˜Ÿå±æ€§ï¼ˆå…‰ç¯ç­‰ï¼‰
            const updatedParty = recalcPartyStats(state, newChars);

            return {
                ...state,
                characters: updatedParty
            };
        }


        case 'EQUIP_ITEM': {
            const { characterId, itemInstanceId } = action.payload;

            // 1) æ‰¾åˆ°èƒŒåŒ…é‡Œçš„è¿™ä»¶è£…å¤‡
            const invIdx = state.inventory.findIndex(i =>
                (i.instanceId && i.instanceId === itemInstanceId) ||
                (!i.instanceId && i.id === itemInstanceId) // å…¼å®¹è€å­˜æ¡£
            );
            if (invIdx === -1) return state;

            const item = state.inventory[invIdx];
            if (!item || item.type !== 'equipment') return state;

            const slot = item.slot;
            if (!slot) return state;

            // 2) æ›´æ–°è§’è‰²ï¼šæŠŠè£…å¤‡æ”¾è¿›å¯¹åº” slot
            const newChars = state.characters.map(c => {
                if (c.id !== characterId) return c;

                const prevEquipped = c.equipment?.[slot] || null;

                const nextChar = {
                    ...c,
                    equipment: {
                        ...(c.equipment || {}),
                        [slot]: item,
                    },
                };

                // 3) é‡ç®—å±æ€§ï¼ˆä½ å·²ç»æœ‰ calculateTotalStatsï¼‰
                nextChar.stats = calculateTotalStats(nextChar, undefined, state);

                // æŠŠä¹‹å‰ç©¿ç€çš„åŒæ§½è£…å¤‡ï¼ˆå¦‚æœæœ‰ï¼‰ä¸´æ—¶æŒ‚åˆ° nextChar ä¸Šï¼Œæ–¹ä¾¿åé¢å¡å›èƒŒåŒ…
                nextChar.__prevEquipped = prevEquipped;
                return nextChar;
            });

            // 4) èƒŒåŒ…ç§»é™¤å·²è£…å¤‡ç‰©å“ï¼Œå¹¶æŠŠè¢«æ›¿æ¢ä¸‹æ¥çš„è£…å¤‡å¡å›èƒŒåŒ…ï¼ˆæœ‰ç©ºé—´æ‰å¡ï¼‰
            const newInventory = [...state.inventory];
            newInventory.splice(invIdx, 1);

            const equippedChar = newChars.find(c => c.id === characterId);
            const prevEquipped = equippedChar?.__prevEquipped;
            if (prevEquipped) {
                if (newInventory.length < state.inventorySize) {
                    newInventory.push(prevEquipped);
                }
            }

            // æ¸…ç†ä¸´æ—¶å­—æ®µ
            const cleanedChars = newChars.map(c => {
                if (c.__prevEquipped === undefined) return c;
                const { __prevEquipped, ...rest } = c;
                return rest;
            });

            const finalChars = recalcPartyStats(state,cleanedChars);

            return {
                ...state,
                characters: finalChars,
                inventory: newInventory,
            };
        }

        case 'UNEQUIP_ITEM': {
            const { characterId, slot } = action.payload;

            // Ensure the character exists
            const char = state.characters.find(c => c.id === characterId);
            if (!char) return state;

            // Get the item to unequip
            const equipped = char.equipment?.[slot];
            if (!equipped) return state;

            // Ensure the inventory has space
            if (state.inventory.length >= state.inventorySize) return state;

            // Map over characters and update their stats after unequipping the item
            const newChars = state.characters.map(c => {
                if (c.id !== characterId) return c;

                // Clone the character's equipment to avoid mutation
                const newEquipment = { ...c.equipment };
                delete newEquipment[slot];  // Remove the equipment from the slot

                // Recalculate stats after unequipping the item
                const updatedChar = { ...c, equipment: newEquipment };
                updatedChar.stats = calculateTotalStats(updatedChar, undefined, state);

                return updatedChar;
            });

            // Add the unequipped item back to the inventory
            const newInventory = [...state.inventory, equipped];

            const finalChars = recalcPartyStats(state,newChars);
            return {
                ...state,
                characters: finalChars,
                inventory: newInventory,
            };
        }



        case 'MERGE_EQUIPMENT': {
            const { instanceIdA, instanceIdB } = action.payload;

            const idxA = state.inventory.findIndex(i => i.instanceId === instanceIdA);
            const idxB = state.inventory.findIndex(i => i.instanceId === instanceIdB);
            if (idxA === -1 || idxB === -1 || idxA === idxB) return state;

            const eqA = state.inventory[idxA];
            const eqB = state.inventory[idxB];
            if (eqA.type !== 'equipment' || eqB.type !== 'equipment') return state;

            const merged = mergeEquipments(eqA, eqB);
            if (!merged) return state;

            const newInventory = [...state.inventory];
            newInventory.splice(Math.max(idxA, idxB), 1);
            newInventory.splice(Math.min(idxA, idxB), 1);
            newInventory.push(merged);

            let nextState = {
                ...addEquipmentIdToCodex(state, merged.id),
                inventory: newInventory
            };

            if ((merged.currentLevel ?? merged.level ?? 0) >= 100) {
                nextState = addEquipmentIdToLv100Codex(nextState, merged.id);
            }

            return nextState;
        }



        case 'MERGE_EQUIPMENT_CHAIN': {
            const { targetInstanceId } = action.payload || {};
            if (!targetInstanceId) return state;

            let inv = [...state.inventory];

            const getLevel = (eq) => (eq?.currentLevel ?? eq?.level ?? 0);

            let targetIdx = inv.findIndex(i => i?.type === 'equipment' && i.instanceId === targetInstanceId);
            if (targetIdx === -1) return state;

            let target = inv[targetIdx];
            if (target?.type !== 'equipment') return state;

            while (getLevel(target) < 100) {
                const otherIdx = inv.findIndex(i =>
                    i?.type === 'equipment' &&
                    i.instanceId !== target.instanceId &&
                    i.id === target.id
                );

                if (otherIdx === -1) break;

                const other = inv[otherIdx];
                const merged = mergeEquipments(target, other);
                if (!merged) break;

                // ç§»é™¤è¢«åˆæˆçš„ä¸¤ä»¶è£…å¤‡ï¼ˆå…ˆåˆ è¾ƒå¤§ç´¢å¼•ï¼‰
                const idxA = inv.findIndex(i => i?.instanceId === target.instanceId);
                const idxB = inv.findIndex(i => i?.instanceId === other.instanceId);
                if (idxA === -1 || idxB === -1) break;

                inv.splice(Math.max(idxA, idxB), 1);
                inv.splice(Math.min(idxA, idxB), 1);

                inv.push(merged);
                target = merged;
            }

            let nextState = {
                ...addEquipmentIdToCodex(state, target.id),
                inventory: inv
            };

            if (getLevel(target) >= 100) {
                nextState = addEquipmentIdToLv100Codex(nextState, target.id);
            }

            return nextState;
        }

        case 'ASSIGN_ZONE': {
            const { characterId, zoneId } = action.payload;

            // æ£€æŸ¥è§’è‰²æ˜¯å¦åœ¨ä¸»åŸèµ„æºå»ºç­‘å·¥ä½œ
            const isInResourceBuilding = Object.values(state.resourceAssignments || {})
                .flat()
                .includes(characterId);

            if (isInResourceBuilding) {
                // è§’è‰²æ­£åœ¨ä¸»åŸé‡‡é›†ï¼Œä¸èƒ½æ´¾é£å»åœ°å›¾
                console.warn(`è§’è‰² ${characterId} æ­£åœ¨ä¸»åŸé‡‡é›†ï¼Œæ— æ³•æ´¾é£åˆ°åœ°å›¾`);
                return state;
            }

            return {
                ...state,
                assignments: {
                    ...state.assignments,
                    [characterId]: zoneId
                }
            };
        }

        case 'UNASSIGN_CHARACTER': {
            const { characterId } = action.payload;
            const newAssignments = { ...state.assignments };
            delete newAssignments[characterId];

            // å¬å›æ—¶è§†ä¸ºè„±æˆ˜ï¼šæ¸…ç†æˆ˜æ–—çŠ¶æ€ï¼Œå¹¶åˆ·æ–° lastCombatTimeï¼ˆ5ç§’åå¼€å§‹å›è¡€ï¼‰
            const newChars = state.characters.map(c => {
                if (c.id !== characterId) return c;
                return {
                    ...c,
                    combatState: null,
                    lastCombatTime: Date.now()
                };
            });

            return {
                ...state,
                assignments: newAssignments,
                characters: newChars
            };
        }

        case 'BUILD': {
            const { buildingId } = action.payload;
            const building = BUILDINGS[buildingId];

            // å·²å»ºæ•°é‡ï¼ˆå»ºç¬¬1åº§æ—¶ builtCount=0 â†’ 100% æˆæœ¬ï¼‰
            const builtCount = state.buildings[buildingId] || 0;

            // æ¯å¤šä¸€åº§ +10%
            const multiplier = 1 + builtCount * 0.1;

            // è®¡ç®—åŠ¨æ€æˆæœ¬ï¼ˆå‘ä¸Šå–æ•´é¿å…å‡ºç°å°æ•°ï¼‰
            const dynamicCost = {};
            Object.entries(building.cost).forEach(([resource, amount]) => {
                dynamicCost[resource] = Math.ceil(amount * multiplier);
            });

            // æ ¡éªŒèµ„æºå¤Ÿä¸å¤Ÿ
            let canBuild = true;
            Object.entries(dynamicCost).forEach(([resource, amount]) => {
                if ((state.resources[resource] || 0) < amount) canBuild = false;
            });
            if (!canBuild) return state;

            // æ‰£èµ„æº
            const newResources = { ...state.resources };
            Object.entries(dynamicCost).forEach(([resource, amount]) => {
                newResources[resource] -= amount;
            });

            return {
                ...state,
                resources: newResources,
                buildings: {
                    ...state.buildings,
                    [buildingId]: builtCount + 1
                }
            };
        }


        case 'START_RESEARCH': {
            const { researchId } = action.payload;
            const research = RESEARCH?.[researchId];

            // å®‰å…¨æ ¡éªŒï¼šä¸å­˜åœ¨/æœªè§£é”åˆ™æ‹’ç»å¼€å§‹ç ”ç©¶
            if (!research) return state;
            if (research.unlockBoss && !(state.defeatedBosses || []).includes(research.unlockBoss)) {
                alert(`æœªè§£é”ï¼šéœ€è¦å‡»è´¥ ${WORLD_BOSSES?.[research.unlockBoss]?.name || research.unlockBoss}`);
                return state;
            }

            if (state.currentResearch) return state;
            return {
                ...state,
                currentResearch: researchId,
                researchProgress: 0
            };
        }

        case 'CANCEL_RESEARCH': {
            return {
                ...state,
                currentResearch: null,
                researchProgress: 0
            };
        }

        case 'USE_ITEM': {
            const { itemInstanceId } = action.payload;

            const idx = state.inventory.findIndex(i =>
                (i.instanceId && i.instanceId === itemInstanceId) ||
                (!i.instanceId && i.id === itemInstanceId) // å…¼å®¹è€æ•°æ®
            );
            if (idx === -1) return state;

            const item = state.inventory[idx];
            // âœ… é‚€è¯·å‡½é€»è¾‘
            if (item.id === 'REBIRTH_INVITATION') {
                const newInventory = [...state.inventory];
                newInventory.splice(idx, 1);

                const alreadyRebirthed = (state.rebirthCount || 0) > 0;

                return {
                    ...state,
                    inventory: newInventory,
                    rebirthUnlocked: true,
                    showRebirthConfirm: !alreadyRebirthed // åªæœ‰æ²¡é‡ç”Ÿè¿‡æ‰å¼¹ç¡®è®¤
                };
            }

            // âœ… ä¿®å¤ï¼šé»‘é¾™åŒ–èº«çš„è¯æ˜ - éœ€è¦æ­£ç¡®è¿”å›æ–°state
            if (item.id === 'IT_BLACK_DRAGON_PROOF') {
                const newInventory = [...state.inventory];
                newInventory.splice(idx, 1);

                return {
                    ...state,
                    inventory: newInventory,
                    worldBossProgress: {
                        ...state.worldBossProgress,
                        prestor_lady: true
                    }
                };
            }


// âœ… å¾½ç« ç±»é“å…·ï¼ˆå¤ç”¨â€œè¡€è‰²åå­—å†›å¾½ç« â€æ¨¡å¼ï¼‰ï¼šæ‰“å¼€â€œé€‰æ‹©ç›®æ ‡è£…å¤‡â€æ¨¡æ€æ¡†ï¼Œä¸ç«‹åˆ»æ¶ˆè€—
            if (BADGE_UPGRADE_RULES?.[item.id]) {
                return {
                    ...state,
                    showScarletBadgeModal: true,
                    pendingScarletBadgeInstanceId: item.instanceId || item.id,
                    pendingBadgeItemId: item.id
                };
            }

            const newInventory = [...state.inventory];
            newInventory.splice(idx, 1);

            return { ...state, inventory: newInventory };
        }

        case 'CLOSE_SCARLET_BADGE_MODAL': {
            return {
                ...state,
                showScarletBadgeModal: false,
                pendingScarletBadgeInstanceId: null,
                pendingBadgeItemId: null
            };
        }

        case 'APPLY_SCARLET_BADGE': {
            const { targetInstanceId } = action.payload || {};
            const badgeInstanceId = state.pendingScarletBadgeInstanceId;
            const badgeItemId = state.pendingBadgeItemId || 'IT_SCARLET_CRUSADER_BADGE';
            const rule = BADGE_UPGRADE_RULES?.[badgeItemId] || BADGE_UPGRADE_RULES.IT_SCARLET_CRUSADER_BADGE;
            if (!targetInstanceId || !badgeInstanceId) return state;

            // 1) æ ¡éªŒå¾½ç« ä»åœ¨èƒŒåŒ…
            const badgeIdx = state.inventory.findIndex(i =>
                (i.instanceId && i.instanceId === badgeInstanceId) ||
                (!i.instanceId && i.id === badgeInstanceId)
            );
            if (badgeIdx === -1) {
                return {
                    ...state,
                    showScarletBadgeModal: false,
                    pendingScarletBadgeInstanceId: null,
                    pendingBadgeItemId: null
                };
            }

            // 2) æ‰¾åˆ°ç›®æ ‡è£…å¤‡ï¼ˆå¯èƒ½åœ¨èƒŒåŒ…ï¼Œä¹Ÿå¯èƒ½å·²è£…å¤‡ï¼‰
            const invTargetIdx = state.inventory.findIndex(i => i?.type === 'equipment' && i.instanceId === targetInstanceId);
            let targetEq = invTargetIdx >= 0 ? state.inventory[invTargetIdx] : null;

            // å¦‚æœä¸åœ¨èƒŒåŒ…ï¼Œå°è¯•åœ¨è§’è‰²å·²è£…å¤‡ä¸­æŸ¥æ‰¾
            if (!targetEq) {
                for (const c of (state.characters || [])) {
                    for (const eq of Object.values(c.equipment || {})) {
                        if (eq?.type === 'equipment' && eq.instanceId === targetInstanceId) {
                            targetEq = eq;
                            break;
                        }
                    }
                    if (targetEq) break;
                }
            }

            if (!targetEq || !rule.isEligible(targetEq)) {
                return state; // éæ³•ç›®æ ‡ç›´æ¥å¿½ç•¥ï¼ˆUIé‡Œä¸€èˆ¬ä¸ä¼šå‡ºç°ï¼‰
            }


// 3) å‡çº§ç›®æ ‡è£…å¤‡ï¼ˆrule.incçº§ï¼Œå°é¡¶rule.capï¼‰
            const tpl = FIXED_EQUIPMENTS?.[targetEq.id];
            const hardCap = rule.cap ?? 100;
            const maxLv = Math.min(hardCap, (targetEq.maxLevel ?? tpl?.maxLevel ?? hardCap));
            const curLv = (targetEq.currentLevel ?? targetEq.level ?? 0);
            const nextLv = Math.min(maxLv, curLv + (rule.inc ?? 2));

            const baseStats = targetEq.baseStats || tpl?.baseStats || {};
            const growth = targetEq.growth || tpl?.growth || {};

            const upgradedEq = {
                ...targetEq,
                currentLevel: nextLv,
                stats: scaleStats(baseStats, growth, nextLv)
            };

            // 4) æ›´æ–°èƒŒåŒ…/è§’è‰²ä¸­çš„é‚£ä»¶è£…å¤‡
            let newInventory = [...state.inventory];
            if (invTargetIdx >= 0) {
                newInventory[invTargetIdx] = upgradedEq;
            }

            const newChars = (state.characters || []).map(c => {
                let changed = false;
                const nextEquip = { ...(c.equipment || {}) };
                for (const [slot, eq] of Object.entries(nextEquip)) {
                    if (eq?.type === 'equipment' && eq.instanceId === targetInstanceId) {
                        nextEquip[slot] = upgradedEq;
                        changed = true;
                    }
                }
                if (!changed) return c;
                const nextChar = { ...c, equipment: nextEquip };
                nextChar.stats = calculateTotalStats(nextChar, undefined, state);
                return nextChar;
            });

            // 5) æ¶ˆè€—å¾½ç« 
            newInventory.splice(badgeIdx, 1);

            // 6) äº®æ¡† Lv100 å›¾é‰´ï¼ˆå¦‚æœåˆ°è¾¾100ï¼‰
            let nextState = {
                ...state,
                inventory: newInventory,
                characters: recalcPartyStats(state, newChars),
                showScarletBadgeModal: false,
                pendingScarletBadgeInstanceId: null
            };
            if ((upgradedEq.currentLevel ?? 0) >= 100) {
                nextState = addEquipmentIdToLv100Codex(nextState, upgradedEq.id);
            }
            return nextState;
        }

        case 'SELL_ITEM': {
            const { itemInstanceId } = action.payload;

            const idx = state.inventory.findIndex(i =>
                (i.instanceId && i.instanceId === itemInstanceId) ||
                (!i.instanceId && i.id === itemInstanceId) // å…¼å®¹è€æ•°æ®
            );
            if (idx === -1) return state;

            const item = state.inventory[idx];
            if (!item.sellPrice) return state;

            const newInventory = [...state.inventory];
            newInventory.splice(idx, 1);

            return {
                ...state,
                inventory: newInventory,
                resources: {
                    ...state.resources,
                    gold: state.resources.gold + getEffectiveGoldGain(item.sellPrice, state)
                }
            };
        }

        case 'SELL_ALL_JUNK': {
            // è®¤å®šï¼štype === 'junk' ä¸”æœ‰ sellPrice çš„éƒ½ç®—â€œåƒåœ¾å¯å‡ºå”®â€
            const junkItems = state.inventory.filter(i => i?.type === 'junk' && (i.sellPrice || 0) > 0);
            if (junkItems.length === 0) return state;

            const totalGold = junkItems.reduce((sum, it) => sum + (it.sellPrice || 0), 0);

            const newInventory = state.inventory.filter(i => !(i?.type === 'junk' && (i.sellPrice || 0) > 0));

            return {
                ...state,
                inventory: newInventory,
                resources: {
                    ...state.resources,
                    gold: state.resources.gold + getEffectiveGoldGain(totalGold, state)
                }
            };
        }

        // ==================== å®ä¼Ÿå®åº“ï¼šé¢†å–å¥–åŠ± ====================
        // payload: { templateId }
        // é¢†å–æ—¶è£…å¤‡ç­‰çº§å›ºå®šä¸º 5 çº§
        case 'CLAIM_GRAND_VAULT_REWARD': {
            const { templateId } = action.payload || {};
            if (!templateId) return state;

            const nowTs = Date.now();
            const snap = computeGrandVaultSnapshot(state, nowTs);
            const dayKey = snap.dayKey;
            const gv = snap.grandVault || {};
            const rows = snap.rows || [];

            // å½“æ—¥å·²é¢†å–ï¼šé˜»æ­¢å†æ¬¡é¢†å–
            if (gv.claimedDayKey === dayKey) {
                alert('å®ä¼Ÿå®åº“ï¼šå½“æ—¥å·²ç»é¢†å–ã€‚');
                return state;
            }

            // åªå…è®¸é¢†å–å½“å‰å®åº“å€™é€‰ä¸­çš„è£…å¤‡ï¼ˆé˜²æ­¢ç»•è¿‡ UI/è¿‡æœŸé¢†å–ï¼‰
            const isInVault = Array.isArray(rows) && rows.some(r => (r?.equipTemplateIds || []).includes(templateId));
            if (!isInVault) {
                alert('å®ä¼Ÿå®åº“ï¼šè¯¥å¥–åŠ±ä¸å±äºå½“å‰å®åº“ï¼ˆå¯èƒ½å·²åˆ·æ–°ï¼‰ã€‚');
                return { ...state, grandVault: gv };
            }

            // èƒŒåŒ…æ»¡åˆ™ä¸é¢†å–
            if ((state.inventory?.length || 0) >= (state.inventorySize || 0)) {
                return { ...state, grandVault: gv };
            }

            const inst0 = createEquipmentInstance(templateId);
            if (!inst0) return { ...state, grandVault: gv };

            const lv = GRAND_VAULT_EQUIP_LEVEL;
            const baseStats = inst0.baseStats || FIXED_EQUIPMENTS?.[templateId]?.baseStats || {};
            const growth = inst0.growth || FIXED_EQUIPMENTS?.[templateId]?.growth || {};

            const inst = {
                ...inst0,
                currentLevel: lv,
                stats: scaleStats(baseStats, growth, lv)
            };

            let newState = {
                ...state,
                stats: {
                    ...(state.stats || {}),
                    grandVaultPicks: (state.stats?.grandVaultPicks || 0) + 1
                },
                grandVault: {
                    ...gv,
                    claimedDayKey: dayKey,
                    claimedAt: nowTs,
                },
                inventory: [...(state.inventory || []), inst]
            };

            newState = addEquipmentIdToCodex(newState, templateId);
            return newState;
        }

        case 'SET_GRAND_VAULT': {
            const gv = action.payload?.grandVault;
            if (!gv || typeof gv !== 'object' || Array.isArray(gv)) return state;

            return {
                ...state,
                grandVault: gv
            };
        }

        case 'SET_TALENT': {
            const { characterId, tier, talentId } = action.payload || {};
            if (!characterId || !tier) return state;

            const updatedChars = state.characters.map(c => {
                if (c.id !== characterId) return c;

                const talents = { ...(c.talents || {}) };
                talents[tier] = talentId;

                return { ...c, talents };
            });

            // å…³é”®ï¼šå…‰ç¯ä¼šå½±å“å…¨é˜Ÿï¼Œæ‰€ä»¥è¦å…¨é˜Ÿä¸€èµ·é‡ç®—
            const newChars = recalcPartyStats(state,updatedChars);

            return { ...state, characters: newChars };
        }


        case 'SET_MENU': {
            return {
                ...state,
                currentMenu: action.payload
            };
        }

        case 'EXPORT_SAVE': {
            return state;
        }

        case 'CLAIM_SPACETIME_COIN_DAILY_SAVE_REWARD': {
            const { dayKey, amount } = action.payload || {};
            if (!dayKey) return state;
            const amt = Math.max(0, Math.floor(Number(amount) || 0));
            if (amt <= 0) return state;

            // åŒä¸€å¤©åªèƒ½é¢†å–ä¸€æ¬¡
            if (state.spacetimeCoinDailyRewardDayKey === dayKey) return state;

            return {
                ...state,
                spacetimeCoinDailyRewardDayKey: dayKey,
                resources: {
                    ...(state.resources || {}),
                    spacetimeCoin: (state.resources?.spacetimeCoin || 0) + amt,
                }
            };
        }


        case 'BUY_SPACETIME_SHOP_ITEM': {
            const { shopItemId } = action.payload || {};
            if (!shopItemId) return state;

            const catalog = Array.isArray(SPACETIME_SHOP_ITEMS) ? SPACETIME_SHOP_ITEMS : [];
            const item = catalog.find(i => i?.id === shopItemId);
            if (!item) return state;

            const price = Math.max(0, Math.floor(Number(item.price) || 0));
            if (price <= 0) return state;

            const curCoin = Math.max(0, Math.floor(Number(state.resources?.spacetimeCoin) || 0));
            if (curCoin < price) return state;

            // âœ… åéª‘ï¼šç›´æ¥ç‚¹äº®å›¾é‰´ï¼ˆä¸è¿›èƒŒåŒ…ï¼‰
            if (item.type === 'mount' && item.mountId) {
                const cur = Array.isArray(state.codexMounts) ? state.codexMounts : [];
                if (cur.includes(item.mountId)) return state;

                let newState = {
                    ...state,
                    resources: {
                        ...(state.resources || {}),
                        spacetimeCoin: curCoin - price,
                    }
                };

                newState = addMountIdToCodex(newState, item.mountId);

                // âœ… ç«‹å³é‡ç®—å…¨é˜Ÿå±æ€§ï¼Œè®©å…¨å±€åŠ æˆç«‹åˆ»ç”Ÿæ•ˆï¼ˆä¿æŒä¸æ‰è½åéª‘ä¸€è‡´ï¼‰
                if (newState?.characters) {
                    newState = { ...newState, characters: recalcPartyStats(newState, newState.characters) };
                }

                return newState;
            }

            return state;
        }

        case 'IMPORT_SAVE': {
            try {
                const decoded = JSON.parse(decodeBase64(action.payload));

                // ===== 0ï¸âƒ£ resources æ·±åˆå¹¶ï¼ˆå«æ–°å¢ï¼šæ—¶ç©ºå¸ï¼‰=====
                decoded.resources = {
                    ...initialState.resources,
                    ...((decoded.resources && typeof decoded.resources === 'object' && !Array.isArray(decoded.resources))
                        ? decoded.resources
                        : {})
                };
                // æ•°å€¼é˜²å¾¡ï¼šç¡®ä¿æ˜¯éè´Ÿæ•´æ•°
                decoded.resources.spacetimeCoin = Math.max(0, Math.floor(Number(decoded.resources.spacetimeCoin) || 0));

                // æ¯æ—¥é¦–æ¬¡ã€ä¿å­˜ã€‘å¥–åŠ±æ ‡è®°ï¼ˆYYYY-MM-DDï¼‰
                decoded.spacetimeCoinDailyRewardDayKey ??= '';
                if (typeof decoded.spacetimeCoinDailyRewardDayKey !== 'string') {
                    decoded.spacetimeCoinDailyRewardDayKey = '';
                }

                // ===== 1ï¸âƒ£ è¡¥è€å­˜æ¡£å­—æ®µï¼ˆé˜²å¾¡æ€§ï¼‰=====
                decoded.rebirthBonuses ??= {};
                decoded.rebirthBonuses.exp ??= 0;
                decoded.rebirthBonuses.gold ??= 0;
                decoded.rebirthBonds ??= [];
                decoded.codexEquipLv100 ??= [];
                decoded.bossCooldowns ??= {};
                decoded.worldBossKillCounts ??= {};
                decoded.worldBossAutoKill ??= {};

                // ===== å®ä¼Ÿå®åº“ï¼ˆæ¯æ—¥æ—©ä¸Š9ç‚¹åˆ·æ–°ï¼‰å…¼å®¹æ—§æ¡£ =====
                decoded.grandVault ??= {};
                if (typeof decoded.grandVault !== 'object' || Array.isArray(decoded.grandVault)) {
                    decoded.grandVault = {};
                }
                decoded.grandVault.dayKey ??= '';
                decoded.grandVault.rows ??= null;
                decoded.grandVault.badgePicks ??= {};
                if (typeof decoded.grandVault.badgePicks !== 'object' || Array.isArray(decoded.grandVault.badgePicks)) {
                    decoded.grandVault.badgePicks = {};
                }
                decoded.grandVault.claimedDayKey ??= '';
                decoded.grandVault.lastRefreshAt ??= 0;
                decoded.grandVault.claimedAt ??= 0;

                decoded.zoneKillCounts ??= {};
                if (typeof decoded.zoneKillCounts !== 'object' || Array.isArray(decoded.zoneKillCounts)) {
                    decoded.zoneKillCounts = {};
                }

                // statsï¼ˆç”¨äºæˆå°±/ç»Ÿè®¡ï¼‰
                decoded.stats ??= {};
                decoded.stats.battlesWon ??= 0;
                decoded.stats.totalDamage ??= 0;
                decoded.stats.totalHealing ??= 0;
                decoded.stats.bossLateRoundDefeats ??= 0;
                decoded.stats.grandVaultPicks ??= 0;

// ===== 2ï¸âƒ£ è§’è‰²æŠ€èƒ½æ ï¼šä¸‰å¥—æŠ€èƒ½é…ç½®å…¼å®¹æ—§æ¡£ =====
                if (Array.isArray(decoded.characters)) {
                    decoded.characters = decoded.characters.map(c => {
                        const make8 = (arr, fallback) => Array.from({ length: 8 }, (_, i) => (arr?.[i] ?? fallback?.[i] ?? ''));
                        const baseSlots = make8(c.skillSlots || [], Array(8).fill('basic_attack'));

                        let sets = Array.isArray(c.skillSets) ? c.skillSets : null;
                        if (!sets || sets.length === 0) {
                            sets = [baseSlots, [...baseSlots], [...baseSlots]];
                        } else {
                            const s0 = make8(sets[0], baseSlots);
                            const s1 = make8(sets[1], s0);
                            const s2 = make8(sets[2], s0);
                            sets = [s0, s1, s2];
                        }

                        let active = Number.isFinite(Number(c.activeSkillSet)) ? Math.floor(Number(c.activeSkillSet)) : 0;
                        active = Math.max(0, Math.min(2, active));

                        const activeSlots = sets[active] || baseSlots;

                        // âœ… ç§æ—é¢å¤–æŠ€èƒ½ï¼šç¡®ä¿æ—§å­˜æ¡£çš„äººç±»ä¹Ÿèƒ½æ‹¿åˆ°
                        let learnedSkills = Array.isArray(c.skills) ? c.skills : [];
                        try {
                            learnedSkills = learnNewSkills({ ...c, skills: learnedSkills });
                        } catch (e) {
                            // ignore
                        }
                        const raceExtraSkills = RACE_TRAITS?.[c.race]?.extraSkills || [];
                        const mergedSkills = Array.from(new Set([...(learnedSkills || []), ...(raceExtraSkills || [])]));

                        return {
                            ...c,
                            skills: mergedSkills,
                            skillSets: sets,
                            activeSkillSet: active,
                            // åŒæ­¥ï¼šæˆ˜æ–—è¯»å– skillSlotsï¼ˆæ¿€æ´»çš„é‚£å¥—ï¼‰
                            skillSlots: make8(activeSlots, baseSlots),
                        };
                    });
                }

// ===== 3ï¸âƒ£ å…³é”®ï¼šé‡ç®—å…¨é˜Ÿå±æ€§ =====
                const fixedCharacters = recalcPartyStats(
                    decoded,
                    decoded.characters
                );

                return {
                    ...decoded,
                    characters: fixedCharacters,
                    lastOnlineTime: Date.now(),
                    offlineRewards: null
                };
            } catch (e) {
                console.error('IMPORT_SAVE failed', e);
                return state;
            }
        }

        case 'EXPAND_CHARACTER_SLOTS': {
            if (state.characterSlots >= state.maxCharacterSlots) return state;
            const cost = 1000 * Math.pow(2, state.characterSlots);
            if (state.resources.gold < cost) return state;

            return {
                ...state,
                resources: {
                    ...state.resources,
                    gold: state.resources.gold - cost
                },
                characterSlots: state.characterSlots + 1
            };
        }

        case 'CLEAR_COMBAT_LOGS': {
            return {
                ...state,
                combatLogs: []
            };
        }

        case 'OPEN_BOSS_PREPARE': {
            const bossId = action.payload;
            const cd = state.bossCooldowns?.[bossId] || 0;
            if (cd > 0) {
                const mm = String(Math.floor(cd / 60)).padStart(2, '0');
                const ss = String(cd % 60).padStart(2, '0');
                alert(`ã€${BOSS_DATA[bossId]?.name || bossId}ã€‘æ­£åœ¨é‡ç”Ÿä¸­ï¼Œå‰©ä½™ ${mm}:${ss}`);
                return state;
            }
            return {
                ...state,
                prepareBoss: bossId,
                // âœ… å›¢é˜Ÿé¦–é¢†æ”¯æŒ 5 äººï¼›ä¸–ç•Œé¦–é¢†é»˜è®¤ 3 äºº
                bossTeam: Array(getBossPartySize(bossId)).fill(null),
                bossStrategy: { priorityBoss: true, stance: 'dispersed' }
            };
        }

        case 'CLOSE_BOSS_PREPARE': {
            return { ...state, prepareBoss: null, bossTeam: [null, null, null] };
        }

        case 'SET_BOSS_TEAM_SLOT': {
            const { slot, charId } = action.payload;
            const newTeam = [...state.bossTeam];
            // å¦‚æœåŒä¸€ä¸ªè§’è‰²å·²å­˜åœ¨ï¼Œç§»é™¤æ—§ä½ç½®
            const oldSlot = newTeam.indexOf(charId);
            if (oldSlot !== -1 && oldSlot !== slot) newTeam[oldSlot] = null;
            newTeam[slot] = charId ?? null;
            return { ...state, bossTeam: newTeam };
        }

        case 'SET_BOSS_STRATEGY': {
            const { key, value } = action.payload;
            return {
                ...state,
                bossStrategy: { ...state.bossStrategy, [key]: value }
            };
        }

        case 'START_BOSS_COMBAT': {
            const bossId = state.prepareBoss;
            if (!bossId) return state;
            const boss = BOSS_DATA[bossId];
            if (!boss) return state;

            const teamIds = state.bossTeam.filter(Boolean);
            if (teamIds.length === 0) return state;

            const teamChars = teamIds.map(id => state.characters.find(c => c.id === id)).filter(Boolean);
            // é‡æ–°è®¡ç®—é˜Ÿä¼å…‰ç¯
            const recalcedTeam = recalcPartyStats(state,teamChars.map(c => ({ ...c })));
            // âœ… æˆå°±ï¼šä»…BOSSæˆ˜æ–—ç”Ÿå‘½åŠ æˆï¼ˆå¦‚ã€é“å¿ƒæ¾„æ¾ˆâ… /â…¡ã€‘ï¼‰
            const bossHpPctBonus = getAchievementBossHpPctBonus(state);
            const recalcedTeamForBoss = (Number.isFinite(bossHpPctBonus) && bossHpPctBonus > 0)
                ? recalcedTeam.map(char => {
                    const baseMaxHp = Number(char.stats?.maxHp) || 0;
                    const nextMaxHp = Math.floor(baseMaxHp * (1 + bossHpPctBonus));
                    const baseHp = Number(char.stats?.hp) || baseMaxHp;
                    const nextHp = Math.floor(baseHp * (1 + bossHpPctBonus));
                    return {
                        ...char,
                        stats: {
                            ...char.stats,
                            hp: nextHp,
                            maxHp: nextMaxHp,
                            currentHp: nextMaxHp,
                        }
                    };
                })
                : recalcedTeam;


            const playerStates = recalcedTeamForBoss.map(char => ({
                char,
                currentHp: char.stats.maxHp,
                currentMp: char.stats.maxMp,
                skillIndex: 0,
                comboPoints: 0, // ç›—è´¼â€œæ˜Ÿâ€(è¿å‡»ç‚¹)
                buffs: [],
                talentBuffs: { attackFlat: 0, blockValueFlat: 0, spellPowerFlat: 0 },
                fortuneMisfortuneStacks: 0, // ç¥¸ç¦ç›¸ä¾å±‚æ•°
                fantasiaStacks: 0,          // å¹»æƒ³æ›²å±‚æ•°ï¼ˆæˆ’å¾‹ç‰§å¸ˆ50çº§å¤©èµ‹ï¼Œä»…æœ¬åœºæˆ˜æ–—ï¼‰
                fingersOfFrost: 0, // å¯’å†°æŒ‡å±‚æ•°ï¼ˆå†°éœœæ³•å¸ˆï¼‰
                // âœ… ç§æ—æˆ˜æ–—å†…è§¦å‘çŠ¶æ€ï¼ˆæ¯åœºæˆ˜æ–—é‡ç½®ï¼‰
                racialFlags: {
                    stoneformCurseUsed: false,
                    stoneformPoisonUsed: false,
                },
                // âœ… å¤©èµ‹/æˆ˜æ–—å†…è§¦å‘çŠ¶æ€ï¼ˆæ¯åœºBossæˆ˜é‡ç½®ï¼‰
                talentFlags: {},
                validSkills: Array.from({ length: 8 }, (_, i) => {
                    const sid = char.skillSlots?.[i] || '';
                    return sid && SKILLS[sid] ? sid : 'rest';
                }).map(sid => SKILLS[sid] ? sid : 'basic_attack')
            }));

            return {
                ...state,
                bossCombat: {
                    bossId,
                    strategy: { ...state.bossStrategy },
                    playerStates,
                    bossHp: boss.maxHp,
                    minions: [],
                    minionDebuffs: [],
                    bossDebuffs: [],
                    round: 0,
                    logs: []
                },
                prepareBoss: null
            };
        }
        case 'CLOSE_HOGGER_PLOT': return { ...state, showHoggerPlot: false };
        case 'OPEN_REBIRTH_CONFIRM': return { ...state, showRebirthConfirm: true };
        case 'CLOSE_REBIRTH_CONFIRM': return { ...state, showRebirthConfirm: false };
        case 'PERFORM_REBIRTH': {
            const equippedCount = state.characters.reduce((sum, char) =>
                sum + Object.values(char.equipment || {}).filter(Boolean).length, 0);
            if (state.inventory.length + equippedCount > state.inventorySize) {
                alert('é“å…·æ ç©ºé—´ä¸è¶³ï¼Œè¯·æ¸…ç†æˆ–æ‰©å®¹èƒŒåŒ…ä»¥å­˜æ”¾æ‰€æœ‰è£…å¤‡ï¼');
                return state;
            }

            let newState = { ...state, showRebirthConfirm: false };

            // å¸ä¸‹æ‰€æœ‰è£…å¤‡
            const extraItems = [];
            newState.characters = newState.characters.map(char => {
                Object.values(char.equipment || {}).forEach(eq => { if (eq) extraItems.push(eq); });
                return { ...char, equipment: {} };
            });
            newState.inventory = [...newState.inventory, ...extraItems];

            // ==================== æ–°çš„é‡ç”ŸåŠ æˆè®¡ç®—å…¬å¼ ====================
            // å¸§æ•°åŠ æˆï¼šå¯¹æ•°å‡½æ•°ï¼Œ3600å¸§â†’10%, 36000å¸§â†’20%, 86400å¸§â†’30%
            // å…¬å¼ï¼šframeBonus = 0.1 * log10(frame / 360)ï¼Œæœ€å°0
            const frame = state.lifeFrame || 0;
            const frameBonus = frame >= 360 ? 0.1 * Math.log10(frame / 360) : 0;

            // ç­‰çº§åŠ æˆï¼šæ¯çº§0.2%ï¼Œæœ€é«˜ç­‰çº§
            const maxLevel = state.characters.reduce((m, c) => Math.max(m, c.level || 0), 0);
            const levelBonus = maxLevel * 0.002;

            // BossåŠ æˆï¼šæ ¹æ®å‡»æ€çš„Bossç»™äºˆåŠ æˆï¼ˆä½¿ç”¨å…¨å±€ BOSS_BONUS_CONFIG å•ä¸€æ•°æ®æºï¼‰
            const bossBonus = BOSS_BONUS;
            const defeatedBosses = state.defeatedBosses || [];
            const totalBossBonus = defeatedBosses.reduce((sum, bossId) => sum + (bossBonus[bossId] || 0), 0);

            // æ€»åŠ æˆï¼ˆç»éªŒ/é‡‘å¸ç›¸åŒï¼Œæ‰è½å’Œç ”ç©¶æœ‰ç³»æ•°ï¼‰
            // ä¸‰é¡¹ä¹˜åŒºï¼šå¸§æ•° / æœ€é«˜ç­‰çº§ / Bosså‡»æ€ â€”â€” ä¹˜ç®—ï¼Œä¸åŠ ç®—
            const newExp = (1 + frameBonus) * (1 + levelBonus) * (1 + totalBossBonus) - 1;
            const newGold = newExp;
            const newDrop = newExp * 0.6;
            const newResearch = newExp * 0.5;

            // âš ï¸ é‡è¦ï¼šæ¸…ç©ºä¸Šä¸€ä¸–åŠ æˆï¼Œä½¿ç”¨æ–°çš„åŠ æˆå€¼ï¼ˆä¸å åŠ ï¼‰
            newState.rebirthBonuses = {
                exp: newExp,
                gold: newGold,
                drop: newDrop,
                researchSpeed: newResearch
            };

            // éšæœºç¾ç»Šï¼ˆç¾ç»Šä»ç„¶å åŠ ä¿ç•™ï¼‰
            const possibleBonds = ['baoernai', 'jianyue'];
            const newBond = possibleBonds[Math.floor(Math.random() * possibleBonds.length)];
            newState.rebirthBonds = [...newState.rebirthBonds, newBond];

            // æ¶ˆè€—é‚€è¯·å‡½
            const tokenIdx = newState.inventory.findIndex(i => i.id === 'REBIRTH_INVITATION');
            if (tokenIdx >= 0) newState.inventory.splice(tokenIdx, 1);

            newState.rebirthCount += 1;

            // é‡ç”Ÿå‰§æƒ…æ•°æ®
            newState.showRebirthPlot = {
                frame: frame,
                maxLevel: maxLevel,
                defeatedBosses: defeatedBosses,
                newExp: (newExp * 100).toFixed(1),
                newGold: (newGold * 100).toFixed(1),
                newDrop: (newDrop * 100).toFixed(1),
                newResearch: (newResearch * 100).toFixed(1),
                newBond: BOND_NAMES[newBond],
                rebirthCount: newState.rebirthCount
            };

            // ==================== é‡ç”Ÿä¿ç•™ï¼šåŠŸèƒ½å»ºç­‘ï¼ˆå…¨éƒ¨ä¿ç•™ï¼Œä¸ä¼šæ¶ˆå¤±ï¼‰ ====================
            // éœ€æ±‚ï¼šé‡ç”Ÿåã€æ‰€æœ‰ã€‘åŠŸèƒ½å»ºç­‘æ•°é‡éƒ½ä¿ç•™ï¼ˆåŒ…å«ï¼šå–·æ³‰/ä»“åº“/è®­ç»ƒå‡äºº/æœºæ¢°è‡‚/å¯»é¾™ä¼šç­‰ï¼‰ã€‚
            // å…¼å®¹æ—§æ¡£ï¼šfunctionalBuildings å¯èƒ½ä¸ºç©º/éå¯¹è±¡
            const keptFunctionalBuildings = (newState.functionalBuildings && typeof newState.functionalBuildings === 'object' && !Array.isArray(newState.functionalBuildings))
                ? { ...newState.functionalBuildings }
                : {};

            const keptWarehouseCount = Math.max(0, Math.floor(Number(keptFunctionalBuildings.warehouse) || 0));
            const keptInventorySizeExtra = newState.inventorySizeExtra || 0;

            // é‡ç½®æ¸¸æˆè¿›åº¦
            // âœ… ä¿ç•™ï¼šæ—¶ç©ºå¸ï¼ˆè·¨ä¸–è´§å¸ï¼Œä¸åº”éšé‡ç”Ÿæ¸…é›¶ï¼‰
            const keptSpacetimeCoin = Math.floor(Number(newState.resources?.spacetimeCoin) || 0);

            newState.characters = [];
            newState.resources = { ...initialState.resources, gold: 500, spacetimeCoin: keptSpacetimeCoin };
            newState.buildings = {};
            // âœ… ä¿ç•™æ‰€æœ‰åŠŸèƒ½å»ºç­‘
            newState.functionalBuildings = keptFunctionalBuildings;
            // ç«‹åˆ»åŒæ­¥èƒŒåŒ…ä¸Šé™ï¼ˆé¿å…UI/æ‰è½é€»è¾‘ä½¿ç”¨æ—§å€¼ï¼‰
            newState.inventorySizeExtra = keptInventorySizeExtra;
            newState.inventorySize = 80 + keptWarehouseCount * 1 + keptInventorySizeExtra;
            // æ–°ä¸€ä¸–ä»0å¼€å§‹è®¡ï¼ˆæœºæ¢°è‡‚ä¾ç„¶ä¿ç•™ï¼Œä½†è®¡æ—¶å™¨é‡ç½®æ›´ç›´è§‚ï¼‰
            newState.autoMergeTimer = 0;
            newState.research = {};
            newState.currentResearch = null;
            newState.researchProgress = 0;
            newState.assignments = {};
            newState.zones = JSON.parse(JSON.stringify(ZONES));
            newState.achievements = {};
            newState.prepareBoss = null;
            newState.bossTeam = [null, null, null];
            newState.bossCombat = null;
            newState.currentMenu = 'map';
            newState.lifeFrame = 0; // æ–°ä¸€ä¸–ä»0å¼€å§‹è®¡
            newState.defeatedBosses = []; // æ¸…ç©ºæœ¬ä¸–å‡»æ€çš„Boss
            newState.bossCooldowns = {}; // é‡ç”Ÿåä¸–ç•ŒBosså†·å´é‡ç½®
            newState.questProgress = {};  // é‡ç½®æ‰€æœ‰ä»»åŠ¡è¿›åº¦
            newState.questItems = [];     // æ¸…ç©ºä»»åŠ¡ç‰©å“
            return newState;
        }
        case 'CHEAT_ADD_GOLD': {
            return {
                ...state,
                resources: {
                    ...state.resources,
                    gold: state.resources.gold + action.payload
                }
            };
        }
        case "CHEAT_ADD_SPACETIME_COIN": {

            const raw = action?.payload;
            const delta = Math.floor(Number(raw));

            if (!Number.isFinite(delta) || delta <= 0) return state;

            return {
                ...state,
                resources: {
                    ...state.resources,
                    spacetimeCoin: (state.resources?.spacetimeCoin ?? 0) + delta,
                },
            };
        }


        case 'CHEAT_ADD_EQUIPMENT': {
            const newInventory = [...state.inventory, action.payload];

            // è‡ªåŠ¨ç‚¹äº®å›¾é‰´
            let newCodex = state.codex.slice();
            if (!newCodex.includes(action.payload.id)) {
                newCodex.push(action.payload.id);
            }

            // å¦‚æœè¾¾åˆ° Lv.100ï¼Œç‚¹äº® Lv100 å›¾é‰´
            let newCodexLv100 = state.codexEquipLv100.slice();
            if (action.payload.currentLevel >= 100 && !newCodexLv100.includes(action.payload.id)) {
                newCodexLv100.push(action.payload.id);
            }

            return {
                ...state,
                inventory: newInventory,
                codex: newCodex,
                codexEquipLv100: newCodexLv100
            };
        }
        case 'CHEAT_ADD_LV100_CODEX': {
            const id = action.payload;
            let newCodexLv100 = state.codexEquipLv100.slice();
            if (!newCodexLv100.includes(id)) {
                newCodexLv100.push(id);
            }
            return {
                ...state,
                codexEquipLv100: newCodexLv100
            };
        }
        case 'CHEAT_ADD_BAGSLOT': {
            const amount = Math.max(0, parseInt(action.payload) || 0);
            const warehouseCount = state.functionalBuildings?.warehouse || 0;
            const nextExtra = (state.inventorySizeExtra || 0) + amount;
            return {
                ...state,
                inventorySizeExtra: nextExtra,
                inventorySize: 80 + warehouseCount * 1 + nextExtra,
            };
        }
        case 'CHEAT_ADD_EXP': {
            const { amount, charIndex } = action.payload;
            if (charIndex < 0 || charIndex >= state.characters.length) {
                return state; // å®‰å…¨æ£€æŸ¥
            }

            const newCharacters = [...state.characters];
            let char = { ...newCharacters[charIndex] };

            // åŠ ç»éªŒ
            char.exp = (char.exp || 0) + amount;

            // å‡çº§å¾ªç¯
            while (char.exp >= char.expToNext && char.level < 200) {
                char.level += 1;
                char.exp -= char.expToNext;
                char.expToNext = Math.floor(100 * Math.pow(1.2, char.level - 1));
                char.skills = learnNewSkills(char); // å­¦ä¼šæ–°æŠ€èƒ½
            }

            // é‡ç®—æ€»å±æ€§ï¼ˆä½¿ç”¨å…¨é˜Ÿå…‰ç¯ï¼‰
            const updatedParty = recalcPartyStats(state, newCharacters.map(c => c.id === char.id ? char : c));
            const updatedChar = updatedParty.find(c => c.id === char.id);

            newCharacters[charIndex] = updatedChar || char;

            return {
                ...state,
                characters: newCharacters
            };
        }
        case 'CLOSE_REBIRTH_PLOT':
            return { ...state, showRebirthPlot: null };
        case "DELETE_CHARACTER": {
            const { characterId } = action.payload || {};
            if (!characterId) return state;

            // æ‰¾åˆ°è¦åˆ çš„è§’è‰²ï¼ˆä¸ºäº†æŠŠè£…å¤‡é€€å›èƒŒåŒ…ï¼‰
            const target = (state.characters || []).find(c => c.id === characterId);
            if (!target) return state;

            // 1) è£…å¤‡é€€å›èƒŒåŒ…ï¼šæŠŠ target.equipment é‡Œæ‰€æœ‰å·²ç©¿æˆ´è£…å¤‡æå‡ºæ¥
            const equippedItems = Object.values(target.equipment || {}).filter(Boolean);

            // æ³¨æ„ï¼šä½ çš„ç³»ç»Ÿå¯¹æ‰è½/å¥–åŠ±å…¥åŒ…ä¼šæ£€æŸ¥ inventorySizeï¼ˆé¿å…è¶…ä¸Šé™ï¼‰
            // è¿™é‡Œåˆ é™¤è§’è‰²å±äºâ€œé€€å›å·²æœ‰ç‰©å“â€ï¼Œå»ºè®®ä¹Ÿéµå®ˆä¸Šé™ï¼šèƒ½æ”¾å¤šå°‘æ”¾å¤šå°‘ï¼Œå‰©ä½™ä¸¢å¼ƒï¼ˆé¿å…èƒŒåŒ…æ— é™è†¨èƒ€ï¼‰
            const freeSlots = Math.max(0, (state.inventorySize ?? 0) - (state.inventory?.length ?? 0));
            const canReturn = equippedItems.slice(0, freeSlots);
            const newInventory = [...(state.inventory || []), ...canReturn];

            // 2) ä»è§’è‰²åˆ—è¡¨ç§»é™¤ï¼ˆè§’è‰²æœ¬ä½“ä¸Šå°±åŒ…å« exp/talents/skillSlots/combatState ç­‰ï¼‰
            // è§’è‰²å¯¹è±¡åŒ…å« expã€equipmentã€talentsã€skillSlotsã€combatState ç­‰å­—æ®µï¼Œåˆ æ‰å¯¹è±¡å³å¯æ¸…ç† :contentReference[oaicite:2]{index=2}
            const newCharacters = (state.characters || []).filter(c => c.id !== characterId);

            // 3) æ¸…ç† assignmentsï¼ˆé˜²æ­¢ç¦»çº¿å¥–åŠ±/æ´¾é£é€»è¾‘ä»ç„¶å¼•ç”¨å·²åˆ é™¤è§’è‰²ï¼‰
            const newAssignments = { ...(state.assignments || {}) };
            delete newAssignments[characterId];

            // 4) æ¸…ç† bossTeamï¼šæŠŠé˜µå®¹é‡Œå¼•ç”¨çš„ charId ç½®ç©º
            // bossTeam åœ¨ state é‡Œæ˜¯ [null, null, null] å­˜ charId :contentReference[oaicite:3]{index=3}
            const newBossTeam = (state.bossTeam || []).map(id => (id === characterId ? null : id));

            // 5) æ¸…ç† bossCombatï¼ˆå¦‚æœè¯¥è§’è‰²æ­£åœ¨ä¸–ç•Œé¦–é¢†æˆ˜é‡Œï¼‰
            let newBossCombat = state.bossCombat;
            if (newBossCombat?.playerStates?.some(ps => ps?.char?.id === characterId)) {
                newBossCombat = null; // æœ€ç¨³å¦¥ï¼šç›´æ¥ä¸­æ­¢è¿™åœº boss æˆ˜ï¼Œé¿å…æ®‹ç•™ playerStates å¼•ç”¨å·²åˆ è§’è‰²
            }

            // 6) ä½ é¡¹ç›®é‡Œå¤šå¤„ä¼šé‡ç®—å…¨é˜Ÿ/å…‰ç¯ç­‰ï¼Œè¿™é‡Œä¿æŒä¸€è‡´
            const finalChars = recalcPartyStats(state, newCharacters);

            return {
                ...state,
                characters: finalChars,
                inventory: newInventory,
                assignments: newAssignments,
                bossTeam: newBossTeam,
                bossCombat: newBossCombat,
            };
        }
        case 'SYNTHESIZE_EQ_044': {
            const getLevel = (eq) => (eq?.currentLevel ?? eq?.level ?? 0);

            const idxA = state.inventory.findIndex(i => i?.type === 'equipment' && i.id === 'EQ_041' && getLevel(i) >= 100);
            const idxB = state.inventory.findIndex(i => i?.type === 'equipment' && i.id === 'EQ_042' && getLevel(i) >= 100);
            if (idxA === -1 || idxB === -1) return state;

            // èƒŒåŒ…ç©ºé—´ï¼šç§»é™¤2ä»¶å†åŠ 1ä»¶ï¼Œä¸€å®šæœ‰ç©ºé—´ï¼Œä¸ç”¨é¢å¤–åˆ¤æ–­
            const tpl = FIXED_EQUIPMENTS['EQ_044'];
            if (!tpl) return state;

            const instance = {
                ...tpl,
                instanceId: `syn_${Date.now()}_${Math.random().toString(36)}`,
                qualityColor: getRarityColor(tpl.rarity),
                currentLevel: 0,
                stats: scaleStats(tpl.baseStats, tpl.growth, 0)
            };

            const newInventory = [...state.inventory];
            newInventory.splice(Math.max(idxA, idxB), 1);
            newInventory.splice(Math.min(idxA, idxB), 1);
            newInventory.push(instance);

            let nextState = {
                ...state,
                inventory: newInventory
            };

            // è®°å½•å›¾é‰´ï¼ˆè·Ÿä½ åˆæˆè£…å¤‡åè®°å›¾é‰´çš„é€»è¾‘ä¸€è‡´ï¼‰:contentReference[oaicite:5]{index=5}
            nextState = addEquipmentIdToCodex(nextState, instance.id);

            return nextState;
        }

        // ===== èµ„æºå»ºç­‘æ´¾é£ =====
        case 'ASSIGN_RESOURCE_BUILDING': {
            const { characterId, buildingId } = action.payload;

            if (!characterId || !buildingId) {
                console.warn('ASSIGN_RESOURCE_BUILDING: ç¼ºå°‘ characterId æˆ– buildingId');
                return state;
            }

            const building = RESOURCE_BUILDINGS[buildingId];
            if (!building) {
                console.warn(`ASSIGN_RESOURCE_BUILDING: æ‰¾ä¸åˆ°å»ºç­‘ ${buildingId}`);
                return state;
            }

            // æ£€æŸ¥è§’è‰²æ˜¯å¦å­˜åœ¨
            const charExists = state.characters.some(c => c.id === characterId);
            if (!charExists) {
                console.warn(`ASSIGN_RESOURCE_BUILDING: æ‰¾ä¸åˆ°è§’è‰² ${characterId}`);
                return state;
            }

            // æ£€æŸ¥è§’è‰²æ˜¯å¦åœ¨åœ°å›¾æ‰“æ€ª
            if (state.assignments?.[characterId]) {
                console.warn(`è§’è‰² ${characterId} æ­£åœ¨åœ°å›¾æ‰“æ€ªï¼Œæ— æ³•æ´¾é£åˆ°ä¸»åŸé‡‡é›†`);
                return state;
            }

            // âœ… ç¡®ä¿ resourceAssignments æ˜¯å¯¹è±¡
            const currentResourceAssignments = state.resourceAssignments || {};

            // âœ… å…³é”®ä¿®å¤ï¼šè¿‡æ»¤æ‰ä¸å­˜åœ¨çš„è§’è‰²ID
            const existingCharIds = new Set(state.characters.map(c => c.id));
            const currentWorkers = (currentResourceAssignments[buildingId] || [])
                .filter(id => existingCharIds.has(id));

            // æ£€æŸ¥æ˜¯å¦å·²è¾¾ä¸Šé™
            if (currentWorkers.length >= building.maxWorkers) {
                console.warn(`å»ºç­‘ ${buildingId} å·²è¾¾æœ€å¤§å·¥äººæ•° ${building.maxWorkers}`);
                return state;
            }

            // âœ… æ¸…ç†æ‰€æœ‰å»ºç­‘ä¸­ä¸å­˜åœ¨çš„è§’è‰²ï¼Œå¹¶ç§»é™¤å½“å‰è§’è‰²çš„æ—§åˆ†é…
            let newAssignments = {};
            Object.keys(currentResourceAssignments).forEach(bid => {
                newAssignments[bid] = (currentResourceAssignments[bid] || [])
                    .filter(id => existingCharIds.has(id) && id !== characterId);
            });

            // æ·»åŠ åˆ°æ–°å»ºç­‘
            newAssignments[buildingId] = [...(newAssignments[buildingId] || []), characterId];

            console.log(`âœ“ æˆåŠŸæ´¾é£è§’è‰² ${characterId} åˆ° ${buildingId}`);

            return {
                ...state,
                resourceAssignments: newAssignments
            };
        }

        case 'UNASSIGN_RESOURCE_BUILDING': {
            const { characterId, buildingId } = action.payload;
            const currentWorkers = state.resourceAssignments?.[buildingId] || [];

            return {
                ...state,
                resourceAssignments: {
                    ...state.resourceAssignments,
                    [buildingId]: currentWorkers.filter(id => id !== characterId)
                }
            };
        }

        // ===== åŠŸèƒ½å»ºç­‘å»ºé€  =====
        case 'BUILD_FUNCTIONAL': {
            const { buildingId } = action.payload;
            const building = FUNCTIONAL_BUILDINGS[buildingId];
            if (!building) return state;

            // âœ… è§£é”æ£€æŸ¥ï¼šéœ€è¦å…ˆå‡»è´¥æŒ‡å®š Boss
            if (building.unlockBoss && !(state.defeatedBosses || []).includes(building.unlockBoss)) {
                return state;
            }

            const currentCount = state.functionalBuildings?.[buildingId] || 0;

            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ä¸Šé™
            if (currentCount >= building.maxCount) return state;

            // âœ… ä½¿ç”¨åŠ¨æ€æˆæœ¬
            const dynamicCost = getFunctionalBuildingCost(buildingId, state);

            // æ£€æŸ¥èµ„æº
            let canBuild = true;
            Object.entries(dynamicCost).forEach(([res, amount]) => {
                if ((state.resources[res] || 0) < amount) canBuild = false;
            });
            if (!canBuild) return state;

            // æ‰£é™¤èµ„æº
            const newResources = { ...state.resources };
            Object.entries(dynamicCost).forEach(([res, amount]) => {
                newResources[res] -= amount;
            });

            return {
                ...state,
                resources: newResources,
                functionalBuildings: {
                    ...state.functionalBuildings,
                    [buildingId]: currentCount + 1
                }
            };
        }
        case 'SORT_INVENTORY': {
            const sortedInventory = [...state.inventory].sort((a, b) => {
                // 1. è£…å¤‡ä¼˜å…ˆäºéè£…å¤‡
                const aIsEquip = a.type === 'equipment' ? 1 : 0;
                const bIsEquip = b.type === 'equipment' ? 1 : 0;
                if (aIsEquip !== bIsEquip) return bIsEquip - aIsEquip; // è£…å¤‡åœ¨å‰

                // 2. å¯¹äºè£…å¤‡ï¼ŒæŒ‰ ID æ’åºï¼ˆEQ_001, EQ_002...ï¼‰
                if (a.type === 'equipment' && b.type === 'equipment') {
                    // æå–æ•°å­—éƒ¨åˆ†è¿›è¡Œæ¯”è¾ƒï¼ˆEQ_001 -> 1, EQ_002 -> 2ï¼‰
                    const aIdNum = parseInt((a.id || '').replace(/\D/g, '')) || 0;
                    const bIdNum = parseInt((b.id || '').replace(/\D/g, '')) || 0;

                    if (aIdNum !== bIdNum) {
                        return bIdNum - aIdNum; // ID ä»å¤§åˆ°å°
                    }

                    // 3. åŒIDè£…å¤‡æŒ‰ç­‰çº§æ’åºï¼ˆä»å¤§åˆ°å°ï¼‰
                    const aLevel = a.currentLevel ?? a.level ?? 0;
                    const bLevel = b.currentLevel ?? b.level ?? 0;
                    return bLevel - aLevel; // ç­‰çº§ä»å¤§åˆ°å°
                }

                // 4. éè£…å¤‡ç‰©å“æŒ‰IDå­—æ¯æ’åº
                return (a.id || '').localeCompare(b.id || '');
            });

            return {
                ...state,
                inventory: sortedInventory
            };
        }
        case 'CHEAT_SET_REBIRTH_BONUS': {
            const { exp, gold, drop, researchSpeed } = action.payload || {};

            const nextState = {
                ...state,
                rebirthBonuses: {
                    ...(state.rebirthBonuses || {}),
                    exp: Number(exp) || 0,
                    gold: Number(gold) || 0,
                    drop: Number(drop) || 0,
                    researchSpeed: Number(researchSpeed) || 0,
                },
            };

            return {
                ...nextState,
                characters: recalcPartyStats(nextState, nextState.characters),
            };
        }
        case 'MOVE_INVENTORY_ITEM': {
            const { fromIndex, toIndex } = action.payload;

            if (fromIndex === toIndex) return state;
            if (fromIndex < 0 || fromIndex >= state.inventory.length) return state;
            if (toIndex < 0 || toIndex >= state.inventorySize) return state;

            const newInventory = [...state.inventory];
            const [movedItem] = newInventory.splice(fromIndex, 1);

            // å¦‚æœç›®æ ‡ä½ç½®è¶…å‡ºå½“å‰æ•°ç»„é•¿åº¦ï¼Œç›´æ¥pushåˆ°æœ«å°¾
            // å¦åˆ™æ’å…¥åˆ°æŒ‡å®šä½ç½®
            if (toIndex >= newInventory.length) {
                newInventory.push(movedItem);
            } else {
                newInventory.splice(toIndex, 0, movedItem);
            }

            return {
                ...state,
                inventory: newInventory
            };
        }
        case 'START_QUEST': {
            const { questId } = action.payload;
            const quest = QUEST_CHAINS[questId];
            if (!quest) return state;

            // æ£€æŸ¥è§£é”æ¡ä»¶
            if (quest.unlockCondition) {
                if (quest.unlockCondition.type === 'boss_defeated') {
                    if (!state.defeatedBosses?.includes(quest.unlockCondition.bossId)) {
                        return state;
                    }
                }
            }

            // æ£€æŸ¥æ˜¯å¦å·²å®Œæˆï¼ˆæœ¬ä¸–ï¼‰
            if (state.questProgress[questId]?.status === 'completed') {
                return state;
            }

            return {
                ...state,
                questProgress: {
                    ...state.questProgress,
                    [questId]: {
                        status: QUEST_STATUS.IN_PROGRESS,
                        currentStep: Object.keys(quest.steps)[0],  // ç¬¬ä¸€æ­¥
                        flags: [],
                        completedSteps: [],
                        completedBranch: null
                    }
                }
            };
        }

        case 'QUEST_CHOICE': {
            const { questId, choiceId } = action.payload;
            const quest = QUEST_CHAINS[questId];
            const progress = state.questProgress[questId];
            if (!quest || !progress) return state;

            const currentStep = quest.steps[progress.currentStep];
            if (!currentStep) return state;

            const choice = currentStep.choices.find(c => c.id === choiceId);
            if (!choice) return state;

            // æ£€æŸ¥æ˜¯å¦æ»¡è¶³æ¡ä»¶
            if (choice.requireFlag && !choice.requireFlag.every(f => progress.flags.includes(f))) {
                return state;
            }

            let newState = { ...state };
            let newProgress = { ...progress };

            // æ ‡è®°å½“å‰æ­¥éª¤å®Œæˆ
            newProgress.completedSteps = [...newProgress.completedSteps, progress.currentStep];

            // è®¾ç½®æ ‡è®°
            if (choice.flagSet) {
                newProgress.flags = [...new Set([...newProgress.flags, ...choice.flagSet])];
            }

            // å‘æ”¾å¥–åŠ±
            if (choice.rewards) {
                if (choice.rewards.gold) {
                    newState.resources = {
                        ...newState.resources,
                        gold: newState.resources.gold + getEffectiveGoldGain(choice.rewards.gold, newState)
                    };
                }
                if (choice.rewards.exp) {
                    // ç»™æ‰€æœ‰è§’è‰²åŠ ç»éªŒ
                    newState.characters = newState.characters.map(char => {
                        let gained = choice.rewards.exp * (1 + (char.stats?.expBonus || 0));
                        let newExp = char.exp + gained;
                        let level = char.level;
                        let expToNext = char.expToNext;
                        while (newExp >= expToNext && level < 200) {
                            newExp -= expToNext;
                            level++;
                            expToNext = Math.floor(100 * Math.pow(1.2, level - 1));
                        }
                        return { ...char, exp: newExp, level, expToNext };
                    });
                }
            }

            // å¤„ç†ç»“æŸä»»åŠ¡
            if (choice.endQuest) {
                newProgress.status = QUEST_STATUS.FAILED;
                newProgress.currentStep = null;
            } else if (choice.nextStep) {
                const nextStepData = quest.steps[choice.nextStep];

                // æ£€æŸ¥æ˜¯å¦æ˜¯ç»“å±€
                if (nextStepData?.isEnding) {
                    newProgress.currentStep = choice.nextStep;
                    // ç»“å±€å¥–åŠ±éœ€è¦é¢å¤–æ¡ä»¶ï¼ˆå¦‚å‡»è´¥Bossï¼‰æ‰èƒ½é¢†å–
                } else {
                    newProgress.currentStep = choice.nextStep;
                }
            }

            newState.questProgress = {
                ...newState.questProgress,
                [questId]: newProgress
            };

            return newState;
        }

        case 'COMPLETE_QUEST_ENDING': {
            const { questId } = action.payload;
            const quest = QUEST_CHAINS[questId];
            const progress = state.questProgress[questId];
            if (!quest || !progress) return state;

            const endingStep = quest.steps[progress.currentStep];
            if (!endingStep?.isEnding) return state;

            // æ£€æŸ¥ç»“å±€æ¡ä»¶
            if (endingStep.requirement) {
                if (endingStep.requirement.type === 'boss_defeated') {
                    if (!state.defeatedBosses?.includes(endingStep.requirement.bossId)) {
                        return state;  // æ¡ä»¶ä¸æ»¡è¶³
                    }
                }
            }

            let newState = { ...state };

            // å‘æ”¾ç»“å±€å¥–åŠ±
            const rewards = endingStep.rewards;
            if (rewards) {
                if (rewards.gold) {
                    newState.resources = {
                        ...newState.resources,
                        gold: newState.resources.gold + getEffectiveGoldGain(rewards.gold, newState)
                    };
                }
                if (rewards.exp) {
                    newState.characters = newState.characters.map(char => {
                        // ... åŠ ç»éªŒé€»è¾‘
                        return char;
                    });
                }
                if (rewards.items) {
                    rewards.items.forEach(itemDef => {
                        if (itemDef.guaranteed || Math.random() < (itemDef.chance || 1)) {
                            const tpl = QUEST_REWARD_EQUIPMENTS[itemDef.id] || FIXED_EQUIPMENTS[itemDef.id];
                            if (tpl) {
                                const instance = createEquipmentInstance(itemDef.id);
                                if (instance) {
                                    newState.inventory = [...newState.inventory, instance];
                                    newState = addEquipmentIdToCodex(newState, itemDef.id);
                                }
                            }
                        }
                    });
                }
                if (rewards.title) {
                    newState.questTitles = [...(newState.questTitles || []), rewards.title];
                }
            }

            // æ ‡è®°ä»»åŠ¡å®Œæˆ
            newState.questProgress = {
                ...newState.questProgress,
                [questId]: {
                    ...progress,
                    status: QUEST_STATUS.COMPLETED,
                    completedBranch: endingStep.branch
                }
            };

            // è®°å½•å®Œæˆçš„åˆ†æ”¯
            newState.completedQuestBranches = [
                ...(newState.completedQuestBranches || []),
                { questId, branch: endingStep.branch, ending: endingStep.id }
            ];

            return newState;
        }

        default:
            return state;
    }
}

// ==================== UI COMPONENTS ====================
const Panel = ({ title, children, actions, style }) => (
    <div style={{
        background: 'linear-gradient(135deg, rgba(30,25,20,0.95) 0%, rgba(20,15,12,0.98) 100%)',
        border: '2px solid #4a3c2a',
        borderRadius: 8,
        padding: 20,
        marginBottom: 16,
        boxShadow: '0 4px 16px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.05)',
        ...style
    }}>
        <div style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: title ? 16 : 0,
            paddingBottom: title ? 12 : 0,
            borderBottom: title ? '1px solid rgba(201,162,39,0.2)' : 'none'
        }}>
            {title && (
                <h3 style={{
                    margin: 0,
                    fontSize: 18,
                    color: '#c9a227',
                    textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
                    fontWeight: 600
                }}>
                    {title}
                </h3>
            )}
            {actions && <div style={{ display: 'flex', gap: 8 }}>{actions}</div>}
        </div>
        {children}
    </div>
);

const Button = ({ children, onClick, variant = 'primary', disabled, style }) => {
    const variants = {
        primary: {
            background: disabled
                ? 'rgba(60,60,60,0.5)'
                : 'linear-gradient(180deg, rgba(201,162,39,0.9), rgba(139,115,25,0.9))',
            color: disabled ? '#666' : '#fff',
            border: `2px solid ${disabled ? '#444' : '#c9a227'}`,
        },
        secondary: {
            background: 'rgba(40,35,30,0.8)',
            color: '#c9a227',
            border: '2px solid #5a4c3a',
        },
        danger: {
            background: 'linear-gradient(180deg, rgba(180,50,50,0.9), rgba(120,30,30,0.9))',
            color: '#fff',
            border: '2px solid #a03030',
        }
    };

    return (
        <button
            onClick={onClick}
            disabled={disabled}
            style={{
                padding: '8px 16px',
                ...variants[variant],
                borderRadius: 4,
                cursor: disabled ? 'not-allowed' : 'pointer',
                fontFamily: 'inherit',
                fontSize: 13,
                fontWeight: 600,
                transition: 'all 0.2s',
                boxShadow: disabled ? 'none' : '0 2px 6px rgba(0,0,0,0.4)',
                textShadow: disabled ? 'none' : '1px 1px 2px rgba(0,0,0,0.6)',
                ...style
            }}
        >
            {children}
        </button>
    );
};

const StatBar = ({ label, current, max, color = '#4CAF50' }) => (
    <div style={{ marginBottom: 8 }}>
        <div style={{
            display: 'flex',
            justifyContent: 'space-between',
            fontSize: 11,
            color: '#aaa',
            marginBottom: 4
        }}>
            <span>{label}</span>
            <span>{Math.floor(current)} / {Math.floor(max)}</span>
        </div>
        <div style={{
            height: 8,
            background: 'rgba(0,0,0,0.5)',
            borderRadius: 4,
            overflow: 'hidden',
            border: '1px solid rgba(255,255,255,0.1)'
        }}>
            <div style={{
                height: '100%',
                width: `${Math.min(100, (current / max) * 100)}%`,
                background: `linear-gradient(90deg, ${color}, ${color}dd)`,
                transition: 'width 0.3s',
                boxShadow: `0 0 8px ${color}88`
            }} />
        </div>
    </div>
);

// ==================== MODALS ====================

// æŠ€èƒ½ç¼–è¾‘æ¨¡æ€æ¡†
const SkillEditorModal = ({ character, onClose, onSave, state }) => {
    // ===== ä¸‰å¥—æŠ€èƒ½é…ç½®ï¼ˆå…¼å®¹æ—§å­˜æ¡£ï¼šåªæœ‰ skillSlotsï¼‰=====
    const initSkillSets = () => {
        const base = Array.from({ length: 8 }, (_, i) => (character.skillSlots?.[i] ?? ''));
        const setsRaw = Array.isArray(character.skillSets) ? character.skillSets : null;

        const make8 = (arr, fallback) => Array.from({ length: 8 }, (_, i) => (arr?.[i] ?? fallback?.[i] ?? ''));

        if (!setsRaw || setsRaw.length === 0) {
            // æ—§æ¡£ï¼šåªæœ‰ skillSlotsï¼Œä¸‰å¥—å…ˆå¤åˆ¶ä¸€ä»½
            const s0 = make8(base, base);
            return [s0, [...s0], [...s0]];
        }

        const s0 = make8(setsRaw[0], base);
        const s1 = make8(setsRaw[1], s0);
        const s2 = make8(setsRaw[2], s0);

        return [s0, s1, s2];
    };

    const initActiveSet = () => {
        const v = Number(character.activeSkillSet);
        if (!Number.isFinite(v)) return 0;
        return Math.max(0, Math.min(2, Math.floor(v)));
    };

    const [activeSet, setActiveSet] = useState(initActiveSet);
    const [skillSets, setSkillSets] = useState(initSkillSets);

    const skillSlots = skillSets?.[activeSet] || Array(8).fill('');

    // è·å–æŠ€èƒ½çš„å®é™…é™åˆ¶ï¼ˆè€ƒè™‘å¤©èµ‹æ•ˆæœï¼‰
    const getSkillLimit = (skillId) => {
        const skill = SKILLS[skillId];
        let limit = skill?.limit ?? Infinity;

        // 40çº§å¤©èµ‹ï¼šæŠ¤å«ç¥ç›¾ - ç›¾å¢™å¯é…ç½®2æ¬¡
        if (skillId === 'shield_wall' && character.talents?.[40] === 'guardian_shield') {
            limit = 2;
        }

        // å†°éœœæ³•å¸ˆ40çº§å¤©èµ‹ï¼šåŒå½—æ˜Ÿ - å½—æ˜Ÿé£æš´å¯é…ç½®2æ¬¡
        if (skillId === 'comet_storm' && character.talents?.[40] === 'double_comet') {
            limit = 2;
        }

        // æˆ’å¾‹ç‰§å¸ˆ20çº§å¤©èµ‹ï¼šåœ£å…‰çš„è®¸è¯º - çœŸè¨€æœ¯ï¼šè€€å¯å¤šé…ç½®1æ¬¡
        if (skillId === 'power_word_radiance' && character.talents?.[20] === 'radiance_plus') {
            limit = (skill?.limit || 2) + 1;
        }

        return limit;
    };

    const handleSlotChange = (index, skillId) => {
        const newSlots = [...skillSlots];
        newSlots[index] = skillId;

        // ç»Ÿè®¡æ¯ä¸ªæŠ€èƒ½åœ¨æŠ€èƒ½æ ä¸­çš„å‡ºç°æ¬¡æ•°
        const countMap = {};
        newSlots.forEach(sid => {
            if (!sid) return;
            countMap[sid] = (countMap[sid] || 0) + 1;
        });

        // æ ¡éªŒæ¯ä¸ªæŠ€èƒ½çš„ limitï¼ˆè€ƒè™‘å¤©èµ‹ï¼‰
        for (const [sid, count] of Object.entries(countMap)) {
            const skill = SKILLS[sid];
            const limit = getSkillLimit(sid);

            if (count > limit) {
                alert(`${skill.name} åœ¨æŠ€èƒ½æ ä¸­æœ€å¤šåªèƒ½æ”¾ ${limit} æ¬¡`);
                return; // âŒ é˜»æ­¢è¿™æ¬¡ä¿®æ”¹
            }
        }

        const nextSets = [...(skillSets || [Array(8).fill(''), Array(8).fill(''), Array(8).fill('')])];
        nextSets[activeSet] = newSlots;
        setSkillSets(nextSets);
    };

    const SwitchButton = ({ idx }) => {
        const isActive = activeSet === idx;
        return (
            <button
                onClick={() => setActiveSet(idx)}
                style={{
                    width: 38,
                    height: 38,
                    borderRadius: 8,
                    cursor: 'pointer',
                    fontWeight: 800,
                    fontSize: 14,
                    color: isActive ? '#1a1510' : '#c9a227',
                    background: isActive
                        ? 'linear-gradient(180deg, rgba(255,215,0,0.95), rgba(201,162,39,0.95))'
                        : 'rgba(0,0,0,0.35)',
                    border: isActive ? '2px solid #ffd700' : '2px solid #5a4c3a',
                    boxShadow: isActive ? '0 0 14px rgba(255,215,0,0.35)' : 'none',
                }}
                title={`æŠ€èƒ½é…ç½® ${idx + 1}ï¼ˆé€‰ä¸­åå°†ç”¨äºåœ°å›¾æˆ˜æ–— / BOSSæˆ˜æ–—ï¼‰`}
            >
                {idx + 1}
            </button>
        );
    };

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20
        }} >
            <div style={{
                background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                border: '3px solid #c9a227',
                borderRadius: 12,
                padding: 24,
                maxWidth: 650,
                width: '100%',
                boxShadow: '0 8px 32px rgba(201,162,39,0.3)',
            }} onClick={(e) => e.stopPropagation()}>
                <div style={{ marginBottom: 18 }}>
                    <h2 style={{ margin: '0 0 8px 0', fontSize: 20, color: '#ffd700' }}>
                        ç¼–è¾‘æŠ€èƒ½æ  - {character.name}
                    </h2>
                    <div style={{ fontSize: 12, color: '#888', lineHeight: 1.6 }}>
                        <div>æˆ˜æ–—æ—¶ä¼šå¾ªç¯ä½¿ç”¨è¿™ 8 ä¸ªæŠ€èƒ½ã€‚</div>
                    </div>

                    <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: 10,
                        marginTop: 12
                    }}>
                        <div style={{ fontSize: 12, color: '#aaa' }}>æŠ€èƒ½é…ç½®ï¼š</div>
                        <div style={{ display: 'flex', gap: 8 }}>
                            <SwitchButton idx={0} />
                            <SwitchButton idx={1} />
                            <SwitchButton idx={2} />
                        </div>
                        <div style={{
                            marginLeft: 'auto',
                            fontSize: 12,
                            color: '#c9a227',
                            background: 'rgba(0,0,0,0.25)',
                            border: '1px solid rgba(201,162,39,0.35)',
                            padding: '6px 10px',
                            borderRadius: 999
                        }}>
                            å½“å‰ï¼šé…ç½® {activeSet + 1}
                        </div>
                    </div>
                </div>

                <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(4, 1fr)',
                    gap: 12,
                    marginBottom: 20
                }}>
                    {skillSlots.map((skillId, index) => (
                        <div key={index} style={{
                            background: 'rgba(0,0,0,0.3)',
                            border: '2px solid #4a3c2a',
                            borderRadius: 6,
                            padding: 12,
                            textAlign: 'center'
                        }}>
                            <div style={{ fontSize: 10, color: '#888', marginBottom: 8 }}>
                                æ§½ä½ {index + 1}
                            </div>
                            <select
                                value={skillId}
                                onChange={(e) => handleSlotChange(index, e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '6px',
                                    background: 'rgba(0,0,0,0.4)',
                                    border: '1px solid #4a3c2a',
                                    borderRadius: 4,
                                    color: '#fff',
                                    fontSize: 11,
                                    cursor: 'pointer'
                                }}
                            >
                                <option value="">ç©º</option>
                                {character.skills // è¢«åŠ¨æŠ€èƒ½ä»…ç”¨äºå±•ç¤ºï¼Œä¸å…è®¸å¡è¿›å¾ªç¯æŠ€èƒ½æ 
                                    .filter((sid) => sid && SKILLS[sid] && SKILLS[sid].type !== 'passive').map(sid => {
                                        const skill = SKILLS[sid];
                                        return (
                                            <option key={sid} value={sid}>
                                                {skill.icon} {skill.name}
                                            </option>
                                        );
                                    })}
                            </select>
                            {skillId && SKILLS[skillId] && (
                                <div style={{
                                    fontSize: 24,
                                    marginTop: 8
                                }}>
                                    {
                                        SKILLS[skillId].iconUrl ? (
                                            <img
                                                src={SKILLS[skillId].iconUrl}
                                                alt={SKILLS[skillId].name}
                                                style={{
                                                    width: 24,
                                                    height: 24,
                                                    objectFit: "contain",
                                                    imageRendering: "pixelated",
                                                    background: "#000",
                                                    border: "1px solid #444",
                                                    borderRadius: 4,
                                                }}
                                            />
                                        ) : (
                                            SKILLS[skillId].icon
                                        )
                                    }
                                </div>
                            )}
                        </div>
                    ))}
                </div>

                <div style={{ display: 'flex', gap: 12 }}>
                    <Button onClick={() => {
                        // âœ… ä¿å­˜ä¸‰å¥—é…ç½® + å½“å‰æ¿€æ´»é…ç½®
                        onSave(character.id, skillSets, activeSet);
                        onClose();
                    }} style={{ flex: 1 }}>
                        âœ“ ä¿å­˜
                    </Button>
                    <Button onClick={onClose} variant="secondary" style={{ flex: 1 }}>
                        å–æ¶ˆ
                    </Button>
                </div>
            </div>
        </div>
    );
};



// æŸ¥çœ‹å¯ç”¨æŠ€èƒ½ï¼ˆæ’é™¤â€œä¼‘æ¯/æ™®é€šæ”»å‡»â€ï¼‰
const SkillViewerModal = ({ character, onClose }) => {
    const availableSkillIds = (character.skills || []).filter(
        (sid) => sid && sid !== 'rest' && sid !== 'basic_attack' && SKILLS[sid]
    );

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20
        }} onClick={onClose}>
            <div style={{
                background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                border: '3px solid #c9a227',
                borderRadius: 12,
                padding: 24,
                maxWidth: 700,
                width: '100%',
                maxHeight: '80vh',
                overflowY: 'auto',
                boxShadow: '0 8px 32px rgba(201,162,39,0.3)',
            }} onClick={(e) => e.stopPropagation()}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 16 }}>
                    <div>
                        <h2 style={{ margin: 0, fontSize: 20, color: '#ffd700' }}>
                            æŸ¥çœ‹æŠ€èƒ½ - {character.name}
                        </h2>
                        <div style={{ fontSize: 12, color: '#888', marginTop: 4 }}>
                            ä»…å±•ç¤ºå¯ç”¨æŠ€èƒ½
                        </div>
                    </div>
                    <Button onClick={onClose} variant="secondary">âœ• å…³é—­</Button>
                </div>

                {availableSkillIds.length === 0 ? (
                    <div style={{ textAlign: 'center', padding: 40, color: '#666' }}>
                        æš‚æ— å¯ç”¨æŠ€èƒ½
                    </div>
                ) : (
                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(2, 1fr)',
                        gap: 12
                    }}>
                        {availableSkillIds.map((sid) => {
                            const skill = SKILLS[sid];
                            // è·å–æŠ€èƒ½çš„å®é™…é™åˆ¶ï¼ˆè€ƒè™‘å¤©èµ‹æ•ˆæœï¼‰
                            let limit = skill.limit;
                            if (sid === 'shield_wall' && character.talents?.[40] === 'guardian_shield') {
                                limit = 2;
                            }
                            // å†°éœœæ³•å¸ˆ40çº§å¤©èµ‹ï¼šåŒå½—æ˜Ÿ
                            if (sid === 'comet_storm' && character.talents?.[40] === 'double_comet') {
                                limit = 2;
                            }
                            // æˆ’å¾‹ç‰§å¸ˆ20çº§å¤©èµ‹ï¼šåœ£å…‰çš„è®¸è¯º
                            if (sid === 'power_word_radiance' && character.talents?.[20] === 'radiance_plus') {
                                limit = (skill?.limit || 2) + 1;
                            }
                            return (
                                <div key={sid} style={{
                                    background: 'rgba(0,0,0,0.3)',
                                    border: '1px solid #4a3c2a',
                                    borderRadius: 10,
                                    padding: 14
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 10, marginBottom: 8 }}>
                                        <div style={{ fontSize: 26 }}>
                                            {
                                                skill.iconUrl ? (
                                                    <img
                                                        src={skill.iconUrl}
                                                        alt={skill.name}
                                                        style={{
                                                            width: 26,
                                                            height: 26,
                                                            objectFit: "contain",
                                                            imageRendering: "pixelated",
                                                            background: "#000",
                                                            border: "1px solid #444",
                                                            borderRadius: 4,
                                                        }}
                                                    />
                                                ) : (
                                                    skill.icon
                                                )
                                            }
                                        </div>
                                        <div style={{ flex: 1 }}>
                                            <div style={{ color: '#ffd700', fontWeight: 700, fontSize: 13 }}>
                                                {skill.name}
                                            </div>
                                            <div style={{ color: '#888', fontSize: 11 }}>
                                                ç±»å‹ï¼š{skill.type}{typeof limit === 'number' ? ` Â· æ§½ä½ä¸Šé™ï¼š${limit}` : ''}
                                            </div>
                                        </div>
                                    </div>

                                    <div style={{ fontSize: 12, color: '#ccc', lineHeight: 1.5 }}>
                                        {skill.description}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                )}
            </div>
        </div>
    );
};

// ==================== COMBAT LOGS (MODULE) ====================
// ç»Ÿä¸€æˆ˜æ–—æ—¥å¿—è§„èŒƒï¼š
// - ä¸»åŠ¨æŠ€èƒ½ï¼šæ˜¾ç¤ºâ€œä½¿ç”¨â€
// - è¢«åŠ¨è§¦å‘ï¼ˆå¤©èµ‹/è¢«åŠ¨ï¼‰ï¼šæ˜¾ç¤ºâ€œã€xxxã€‘è§¦å‘ï¼š...â€ï¼Œä¸ç®—ä¸€æ¬¡è¡ŒåŠ¨
// - ç³»ç»Ÿäº‹ä»¶ï¼šæ˜¾ç¤ºçº¯æ–‡æœ¬
function normalizeCombatLogEntry(entry) {
    if (!entry || typeof entry !== 'object') {
        return { kind: 'system', text: String(entry ?? '') };
    }
    if (entry.kind) return entry;

    // å…¼å®¹æ—§å­—æ®µï¼štype
    if (entry.type === 'talent') {
        return { ...entry, kind: 'proc', proc: entry.action || entry.proc || 'è¢«åŠ¨' };
    }
    if (entry.type === 'damage' || entry.type === 'heal' || entry.type === 'buff' || entry.type === 'block') {
        return { ...entry, kind: 'skill' };
    }
    return { ...entry, kind: 'system', text: entry.text || entry.action || '' };
}

function renderCombatLogLine(entry) {
    const e = normalizeCombatLogEntry(entry);

    // ç³»ç»Ÿæ—¥å¿—
    if (e.kind === 'system') {
        return (
            <>
                <span style={{ color: '#aaa' }}>{e.text || ''}</span>
            </>
        );
    }

    // âœ… æ–°å¢ï¼šæ‰è½æ—¥å¿—
    if (e.kind === 'drop') {
        const rarityColors = {
            white: '#d9d9d9',
            green: '#1eff00',
            blue: '#0070dd',
            purple: '#a335ee',
            orange: '#ff8000'
        };
        const color = rarityColors[e.rarity] || '#ffd700';

        return (
            <>
                <span style={{ color: '#ffd700' }}>ğŸ æ‰è½</span>
                {' '}
                <span style={{
                    color: color,
                    fontWeight: 600,
                    textShadow: `0 0 6px ${color}66`
                }}>
                    ã€{e.itemName}ã€‘
                </span>
                <span style={{ color: '#888', marginLeft: 8, fontSize: '0.9em' }}>
                    æ¦‚ç‡ï¼š{e.chance < 1 ? e.chance.toFixed(2) : e.chance.toFixed(1)}%
                </span>
            </>
        );
    }

    // è¢«åŠ¨è§¦å‘ï¼šä¸æ˜¾ç¤ºâ€œä½¿ç”¨â€ï¼Œä¹Ÿä¸é‡å¤æ˜¾ç¤ºæ–½æ”¾è€…ï¼ˆç»Ÿä¸€ç”±æ–‡æœ¬è‡ªèº«è¡¨è¾¾ï¼‰
    if (e.kind === 'proc') {
        return (
            <>
                <span style={{ color: '#ff9800' }}>
                    {e.text || `ã€${e.proc || e.action || 'è¢«åŠ¨'}ã€‘è§¦å‘`}
                </span>
            </>
        );
    }

// ä¸»åŠ¨æŠ€èƒ½ï¼šä¿ç•™åŸæ¥çš„â€œä½¿ç”¨â€è¯­ä¹‰
    return (
        <>
            <span style={{ color: '#ffd700' }}>{e.actor}</span>
            {' '}ä½¿ç”¨{' '}
            <span style={{ color: '#4CAF50' }}>{e.action}</span>

            {e.type === 'damage' && (
                <>
                    {' '}å¯¹{' '}
                    <span style={{ color: '#ff6b6b' }}>{e.target}</span>
                    {' '}é€ æˆ{' '}
                    <span style={{ color: '#f44336', fontWeight: 600 }}>
                        {e.value}
                    </span>
                    {' '}ç‚¹ä¼¤å®³
                    {e.isCrit && (
                        <span style={{ color: '#ff9800', marginLeft: 4 }}>
                            [æš´å‡»!]
                        </span>
                    )}
                </>
            )}

            {e.type === 'heal' && (
                <>
                    {' '}æ¢å¤{' '}
                    <span style={{ color: '#4CAF50', fontWeight: 600 }}>
                        {e.value}
                    </span>
                    {' '}ç‚¹ç”Ÿå‘½
                </>
            )}

            {e.type === 'block' && (
                <>
                    {' '}æ ¼æŒ¡äº†{' '}
                    <span style={{ color: '#4CAF50', fontWeight: 600 }}>
                        {e.value}
                    </span>
                    {' '}ç‚¹ä¼¤å®³
                </>
            )}

            {e.type === 'buff' && (
                <>
                    {' '}è·å¾—æ•ˆæœï¼ˆæŒç»­{' '}
                    <span style={{ color: '#4CAF50', fontWeight: 700 }}>{e.value}</span>
                    {' '}å›åˆï¼‰
                </>
            )}
        </>
    );
}

// æˆ˜æ–—æ—¥å¿—æ¨¡æ€æ¡†
const CombatLogsModal = ({ logs, onClose, onClear }) => {

    const safe = Array.isArray(logs) ? logs : [];

    const normalized = safe
        .filter(Boolean)
        .map((x) => {
            if (typeof x === "string") {
                return {
                    id: `legacy_${Date.now()}_${Math.random()}`,
                    timestamp: Date.now(),
                    characterName: "ç³»ç»Ÿ",
                    zoneName: "",
                    enemyName: "",
                    result: "victory",
                    logs: [x],
                    rewards: { gold: 0, exp: 0 },
                    drops: [],

                };
            }
            return {
                ...x,
                logs: Array.isArray(x.logs) ? x.logs : [],
                drops: Array.isArray(x.drops) ? x.drops : [] // âœ… æ–°å¢
            };
        });

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20
        }} onClick={onClose}>
            <div style={{
                background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                border: '3px solid #c9a227',
                borderRadius: 12,
                padding: 24,
                maxWidth: 800,
                width: '100%',
                maxHeight: '80vh',
                display: 'flex',
                flexDirection: 'column',
                boxShadow: '0 8px 32px rgba(201,162,39,0.3)',
            }} onClick={(e) => e.stopPropagation()}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 16 }}>
                    <h2 style={{ margin: 0, fontSize: 20, color: '#ffd700' }}>
                        æˆ˜æ–—æ—¥å¿—
                    </h2>
                    <div style={{ display: 'flex', gap: 8 }}>
                        <Button onClick={onClear} variant="danger">æ¸…ç©ºæ—¥å¿—</Button>
                        <Button onClick={onClose} variant="secondary">âœ• å…³é—­</Button>
                    </div>
                </div>

                <div style={{
                    flex: 1,
                    overflowY: 'auto',
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 6,
                    padding: 12
                }}>
                    {logs.length === 0 ? (
                        <div style={{ textAlign: 'center', color: '#666', padding: 40 }}>
                            æš‚æ— æˆ˜æ–—è®°å½•
                        </div>
                    ) : (
                        normalized.map(log => (
                            <div key={log.id} style={{
                                background: log.result === 'victory' ? 'rgba(76,175,80,0.1)' : 'rgba(244,67,54,0.1)',
                                border: `1px solid ${log.result === 'victory' ? '#4CAF50' : '#f44336'}`,
                                borderRadius: 6,
                                padding: 12,
                                marginBottom: 12
                            }}>
                                <div style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    marginBottom: 8,
                                    paddingBottom: 8,
                                    borderBottom: '1px solid rgba(255,255,255,0.1)'
                                }}>
                                    <div>
                                        <span style={{ color: '#ffd700', fontWeight: 600 }}>
                                            {log.characterName}
                                        </span>
                                        <span style={{ color: '#888', margin: '0 8px' }}>VS</span>
                                        <span style={{ color: '#ff6b6b', fontWeight: 600 }}>
                                            {log.enemyName}
                                        </span>
                                        <span style={{ color: '#888', marginLeft: 8 }}>
                                            @ {log.zoneName}
                                        </span>
                                    </div>
                                    <div style={{
                                        fontSize: 11,
                                        color: log.result === 'victory' ? '#4CAF50' : '#f44336',
                                        fontWeight: 600
                                    }}>
                                        {log.result === 'victory' ? 'âœ“ èƒœåˆ©' : 'âœ— å¤±è´¥'}
                                    </div>
                                </div>

                                <div style={{
                                    maxHeight: 200,
                                    overflowY: 'auto',
                                    fontSize: 11,
                                    color: '#ccc'
                                }}>
                                    {(log.logs || []).map((entry, i) => (
                                        <div key={i} style={{
                                            padding: '4px 0',
                                            borderBottom: i < log.logs.length - 1 ? '1px solid rgba(255,255,255,0.05)' : 'none'
                                        }}>
                                            <span style={{ color: '#888' }}>å›åˆ{entry.round}:</span>{' '}
                                            {renderCombatLogLine(entry)}
                                        </div>
                                    ))}
                                </div>

                                {/* åœ¨å¥–åŠ±æ˜¾ç¤ºåæ·»åŠ æ‰è½æ‘˜è¦ */}
                                {log.drops && log.drops.length > 0 && (
                                    <div style={{
                                        marginTop: 8,
                                        paddingTop: 8,
                                        borderTop: '1px solid rgba(255,255,255,0.1)',
                                        fontSize: 12
                                    }}>
                                        <span style={{ color: '#ffd700', marginRight: 8 }}>ğŸ æ‰è½ï¼š</span>
                                        {log.drops.map((drop, idx) => {
                                            const rarityColors = {
                                                white: '#d9d9d9',
                                                green: '#1eff00',
                                                blue: '#0070dd',
                                                purple: '#a335ee',
                                                orange: '#ff8000'
                                            };
                                            const color = rarityColors[drop.rarity] || '#ffd700';
                                            return (
                                                <span key={idx} style={{ marginRight: 12 }}>
                                                <span style={{ color: color, fontWeight: 600 }}>{drop.name}</span>
                                                <span style={{ color: '#666', fontSize: 10, marginLeft: 4 }}>
                                                    ({drop.chance < 1 ? drop.chance.toFixed(2) : drop.chance.toFixed(1)}%)
                                                </span>
                                                </span>
                                            );
                                        })}
                                    </div>
                                )}

                                {log.rewards && (
                                    <div style={{
                                        marginTop: 8,
                                        paddingTop: 8,
                                        borderTop: '1px solid rgba(255,255,255,0.1)',
                                        fontSize: 11,
                                        color: '#ffd700'
                                    }}>
                                        å¥–åŠ±: ğŸª™{log.rewards.gold} | â­{log.rewards.exp}
                                    </div>
                                )}
                            </div>
                        ))
                    )}
                </div>
            </div>
        </div>
    );
};

// è§’è‰²è¯¦æƒ…æ¨¡æ€æ¡†
const CharacterDetailsModal = ({ characterId, state, onClose, onUnequip, onEditSkills, onViewSkills, onSyncSkills }) => {
    const character = state.characters.find(c => c.id === characterId);

    // è§’è‰²è¢«åˆ é™¤/ä¸å­˜åœ¨æ—¶ï¼Œç›´æ¥ä¸æ¸²æŸ“ï¼ˆæˆ–ä½ ä¹Ÿå¯ä»¥ onClose()ï¼‰
    if (!character) return null;

    const [syncTip, setSyncTip] = useState(null);
    const syncTipTimerRef = useRef(null);

    const showSyncTip = (msg) => {
        setSyncTip(msg);
        if (syncTipTimerRef.current) clearTimeout(syncTipTimerRef.current);
        syncTipTimerRef.current = setTimeout(() => setSyncTip(null), 1500);
    };

    useEffect(() => {
        return () => {
            if (syncTipTimerRef.current) clearTimeout(syncTipTimerRef.current);
        };
    }, []);

    const currentSkills = character.skills || [];
    const levelSkills = learnNewSkills(character);
    const missingSkills = levelSkills.filter(s => !currentSkills.includes(s));
    const canSyncSkills = missingSkills.length > 0;

    const statNames = {
        hp: 'ç”Ÿå‘½å€¼',
        mp: 'æ³•åŠ›å€¼',
        attack: 'æ”»å‡»å¼ºåº¦',
        spellPower: 'æ³•æœ¯å¼ºåº¦',
        armor: 'æŠ¤ç”²',
        magicResist: 'é­”æ³•æŠ—æ€§',
        haste: 'æ€¥é€Ÿ',
        critRate: 'æš´å‡»ç‡',
        critDamage: 'æš´å‡»ä¼¤å®³',
        mastery: 'ç²¾é€š',
        versatility: 'å…¨èƒ½',
        blockRate: 'æ ¼æŒ¡ç‡',
        blockValue: 'æ ¼æŒ¡å€¼',
        // æ–°å¢é‡‡é›†å±æ€§
        proficiency: 'ç†Ÿç»ƒ',
        precision: 'ç²¾ç»†',
        perception: 'æ„ŸçŸ¥',
    };

    const setBonuses = getSetBonusesForCharacter(character);
    // âœ… é‡‡é›†å±æ€§ï¼ˆå«ç­‰çº§/è£…å¤‡/ç§æ—åŠ æˆï¼‰ï¼Œç”¨äºå±æ€§æ å±•ç¤º
    const gatherStats = calculateGatherStats(character);

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20,
            overflowY: 'auto'
        }} onClick={onClose}>
            <div style={{
                background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                border: '3px solid #c9a227',
                borderRadius: 12,
                padding: 24,
                maxWidth: 900,
                width: '100%',
                maxHeight: '90vh',
                overflowY: 'auto',
                boxShadow: '0 8px 32px rgba(201,162,39,0.3)',
            }} onClick={(e) => e.stopPropagation()}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: 20 }}>
                    <div>
                        <h2 style={{ margin: '0 0 8px 0', fontSize: 24, color: '#ffd700' }}>
                            {character.name}
                        </h2>
                        <div style={{ fontSize: 14, color: '#888' }}>
                            Lv.{character.level} {character.race} {CLASSES[character.classId].name}
                        </div>
                    </div>
                    <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
                        <Button onClick={onViewSkills} variant="secondary">ğŸ‘ æŸ¥çœ‹æŠ€èƒ½</Button>
                        <Button onClick={onEditSkills} variant="secondary">âœï¸ ç¼–è¾‘æŠ€èƒ½</Button>
                        <Button
                            onClick={() => {
                                if (!onSyncSkills) return;
                                onSyncSkills();
                                // ç®€å•æç¤ºï¼šå­¦ä¼šæœ¬ç­‰çº§åº”å­¦ä¼šçš„æŠ€èƒ½ï¼ˆç”¨äºæ—§è§’è‰²è¡¥é½æ–°æŠ€èƒ½ï¼‰
                                showSyncTip(`åŒæ­¥æˆåŠŸï¼šå­¦ä¼š ${missingSkills.length} ä¸ªæŠ€èƒ½`);
                            }}
                            variant="secondary"
                            disabled={!canSyncSkills}
                            title={canSyncSkills ? 'å­¦ä¼šå½“å‰ç­‰çº§åº”å­¦ä¼šçš„æŠ€èƒ½ï¼ˆè¡¥é½æ–°æŠ€èƒ½ï¼‰' : 'å½“å‰å·²å­¦ä¼šæœ¬ç­‰çº§åº”å­¦ä¼šçš„æŠ€èƒ½'}
                        >
                            ğŸ“š å­¦ä¼šæœ¬çº§æŠ€èƒ½
                        </Button>
                        <Button onClick={onClose} variant="secondary">âœ• å…³é—­</Button>
                    </div>
                </div>

                {syncTip && (
                    <div style={{
                        marginTop: 10,
                        background: 'rgba(0,0,0,0.35)',
                        border: '1px solid rgba(201,162,39,0.35)',
                        color: '#f3e6b3',
                        padding: '8px 12px',
                        borderRadius: 8,
                        fontSize: 13,
                    }}>
                        âœ… {syncTip}
                    </div>
                )}

                <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: 20 }}>
                    {/* å·¦ä¾§ï¼šå±æ€§ */}
                    <div>
                        <h3 style={{ fontSize: 16, color: '#c9a227', marginBottom: 12 }}>è§’è‰²å±æ€§</h3>
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: 6,
                            padding: 12,
                            border: '1px solid #4a3c2a'
                        }}>
                            {Object.entries(statNames).map(([stat, name]) => (
                                <div key={stat} style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    padding: '6px 0',
                                    borderBottom: '1px solid rgba(255,255,255,0.05)',
                                    fontSize: 12
                                }}>
                                    <span style={{ color: '#aaa' }}>{name}</span>
                                    <span style={{ color: '#ffd700', fontWeight: 600 }}>
                                        {(() => {
                                            const isGatherStat = stat === 'proficiency' || stat === 'precision' || stat === 'perception';
                                            const rawValue = isGatherStat
                                                ? (gatherStats?.[stat] ?? 0)
                                                : (character.stats?.[stat] ?? 0);

                                            if (stat === 'critRate' || stat === 'blockRate') {
                                                return `${Number(rawValue || 0).toFixed(1)}%`;
                                            }
                                            if (stat === 'critDamage') {
                                                return `${Math.round((Number(rawValue) || 0) * 100)}%`;
                                            }
                                            return Math.floor(Number(rawValue) || 0);
                                        })()}
                                    </span>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* å³ä¾§ï¼šè£…å¤‡ */}
                    <div>
                        <h3 style={{ fontSize: 16, color: '#c9a227', marginBottom: 12 }}>è£…å¤‡</h3>
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 8 }}>
                            {Object.entries(EQUIPMENT_SLOTS).map(([slot, slotInfo]) => {
                                const equipped = character.equipment[slot];
                                return (
                                    <div
                                        key={slot}
                                        style={{
                                            background: equipped ? 'rgba(201,162,39,0.15)' : 'rgba(0,0,0,0.3)',
                                            border: `2px solid ${equipped ? '#c9a227' : '#4a3c2a'}`,
                                            borderRadius: 6,
                                            padding: 12,
                                            minHeight: 80,
                                            position: 'relative'
                                        }}
                                    >
                                        <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                                            {equipped ? (
                                                <ItemIcon item={equipped} size={18} />
                                            ) : (
                                                <span>{slotInfo.icon}</span>
                                            )}
                                            <span>{slotInfo.name}</span>
                                        </div>


                                        {equipped ? (
                                            <>
                                                <div style={{
                                                    fontSize: 12,
                                                    color: equipped.qualityColor,
                                                    fontWeight: 600,
                                                    marginBottom: 6
                                                }}>
                                                    {equipped.name}
                                                </div>

                                                <div style={{ fontSize: 10, color: '#aaa', marginBottom: 8 }}>
                                                    {Object.entries(equipped.stats).map(([stat, value]) => (
                                                        <div key={stat}>
                                                            {statNames[stat] || stat}: +{formatItemStatValue(stat, value)}
                                                        </div>
                                                    ))}
                                                </div>

                                                <Button
                                                    onClick={() => onUnequip(character.id, slot)}
                                                    variant="danger"
                                                    style={{ padding: '4px 8px', fontSize: 10, width: '100%' }}
                                                >
                                                    å¸ä¸‹
                                                </Button>
                                            </>
                                        ) : (
                                            <div style={{
                                                fontSize: 24,
                                                color: '#333',
                                                textAlign: 'center',
                                                paddingTop: 8
                                            }}>
                                                âˆ…
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>

                        {/* å¥—è£…æ•ˆæœ */}
                        {setBonuses.length > 0 && (
                            <div style={{
                                marginTop: 14,
                                padding: 12,
                                borderRadius: 8,
                                background: 'rgba(0,0,0,0.25)',
                                border: '1px solid rgba(201,162,39,0.25)'
                            }}>
                                <div style={{ fontSize: 14, fontWeight: 800, color: '#ffd700', marginBottom: 8 }}>
                                    å¥—è£…æ•ˆæœ
                                </div>

                                <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                                    {setBonuses.map(set => (
                                        <div key={set.setId} style={{
                                            padding: 10,
                                            borderRadius: 8,
                                            background: 'rgba(0,0,0,0.25)',
                                            border: '1px solid rgba(201,162,39,0.18)'
                                        }}>
                                            <div style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'baseline',
                                                marginBottom: 6
                                            }}>
                                                <div style={{ fontSize: 13, fontWeight: 800, color: '#c9a227' }}>
                                                    {set.name}
                                                </div>
                                                <div style={{ fontSize: 11, color: '#aaa' }}>
                                                    å·²è£…å¤‡ {set.count} ä»¶
                                                </div>
                                            </div>

                                            <div style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                                                {set.activated.map((t, idx) => (
                                                    <div key={idx} style={{ fontSize: 12, color: '#ddd' }}>
                                                        âœ… {t.count} ä»¶ï¼š{formatBonusText(t.bonus)}
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};





// ç‰©å“è¯¦æƒ…æ¨¡æ€æ¡†
const ItemDetailsModal = ({ item, onClose, onEquip, characters, state , dispatch }) => {
    const [selectedCharId, setSelectedCharId] = useState('');

    const statNames = {
        hp: 'ç”Ÿå‘½å€¼',
        mp: 'æ³•åŠ›å€¼',
        attack: 'æ”»å‡»å¼ºåº¦',
        spellPower: 'æ³•æœ¯å¼ºåº¦',
        armor: 'æŠ¤ç”²',
        magicResist: 'é­”æ³•æŠ—æ€§',
        haste: 'æ€¥é€Ÿ',
        critRate: 'æš´å‡»ç‡',
        critDamage: 'æš´å‡»ä¼¤å®³',
        mastery: 'ç²¾é€š',
        versatility: 'å…¨èƒ½',
        blockRate: 'æ ¼æŒ¡ç‡',
        blockValue: 'æ ¼æŒ¡å€¼',
        expBonus: 'ç»éªŒå€¼å¢å¹…',
        proficiency: 'ç†Ÿç»ƒ',
        precision: 'ç²¾ç»†',
        perception: 'æ„ŸçŸ¥',
    };

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20
        }} onClick={onClose}>
            <div style={{
                background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                border: `3px solid ${item.qualityColor || '#4a3c2a'}`,
                borderRadius: 12,
                padding: 24,
                maxWidth: 400,
                width: '100%',
                boxShadow: `0 8px 32px ${item.qualityColor}44`,
            }} onClick={(e) => e.stopPropagation()}>
                <div style={{ textAlign: 'center', marginBottom: 20 }}>
                    <div style={{ fontSize: 48, marginBottom: 12 }}>
                        <ItemIcon item={item} size={32} />
                    </div>
                    <h2 style={{
                        margin: '0 0 8px 0',
                        fontSize: 20,
                        color: item.qualityColor,
                        textShadow: '2px 2px 4px rgba(0,0,0,0.8)'
                    }}>
                        {item.name}
                    </h2>
                    <div style={{ fontSize: 12, color: '#888' }}>
                        {EQUIPMENT_SLOTS[item.slot]?.name} Â· ç­‰çº§ {item.currentLevel ?? item.level ?? 0} Â· {item.quality}
                    </div>
                </div>

                <div style={{
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 8,
                    padding: 16,
                    marginBottom: 20
                }}>
                    <h3 style={{ fontSize: 14, color: '#c9a227', marginBottom: 12 }}>å±æ€§</h3>
                    {Object.entries(item.stats).map(([stat, value]) => (
                        <div
                            key={stat}
                            style={{
                                display: 'flex',
                                justifyContent: 'space-between',
                                padding: '6px 0',
                                borderBottom: '1px solid rgba(255,255,255,0.05)',
                                fontSize: 12
                            }}
                        >
                            <span style={{ color: '#aaa' }}>{statNames[stat] || stat}</span>
                            <span style={{ color: '#4CAF50', fontWeight: 600 }}>
                                +{formatItemStatValue(stat, value)}
                            </span>
                        </div>
                    ))}
                </div>

                {/* ç‰¹æ®Šæ•ˆæœæ˜¾ç¤º */}
                {(() => {
                  const effects = getEquipmentSpecialEffectList(item);
                  if (effects.length === 0) return null;

                  const fmtPct = (v) => `${Math.round((Number(v) || 0) * 100)}%`;

                  return (
                    <div style={{
                      background: 'rgba(255, 152, 0, 0.1)',
                      border: '1px solid rgba(255, 152, 0, 0.3)',
                      borderRadius: 8,
                      padding: 16,
                      marginBottom: 20
                    }}>
                      <h3 style={{ fontSize: 14, color: '#ff9800', marginBottom: 12 }}>âš¡ ç‰¹æ®Šæ•ˆæœ</h3>

                      {effects.map((se, idx) => {
                        if (!se || typeof se !== 'object') return null;

                        const type = se.type;
                        const chance = Math.max(0, Math.min(1, Number(se.chance) || 0));
                        const trigger = se.trigger || 'turn_start';

                        return (
                          <div key={idx} style={{ marginTop: idx ? 12 : 0 }}>

                            {/* skill_slot_buffï¼šæŠ€èƒ½æ ¼å¼ºåŒ– */}
                            {type === 'skill_slot_buff' && (() => {
                              const slots = Array.isArray(se.slots)
                                ? se.slots
                                : (Number.isFinite(Number(se.slot)) ? [Number(se.slot)] : []);
                              const slotText = slots.length ? slots.map(s => s + 1).join('ã€') : 'ï¼Ÿ';

                              const atk = Number(se.attackBonus) || 0;
                              const sp = Number(se.spellPowerBonus) || 0;

                              return (
                                <div style={{ fontSize: 12, color: '#ffb74d', lineHeight: 1.6 }}>
                                  åœ¨ç¬¬ <span style={{ color: '#ffd700', fontWeight: 600 }}>{slotText}</span> æŠ€èƒ½æ ¼é‡Šæ”¾æŠ€èƒ½æ—¶ï¼š
                                  {atk !== 0 && (
                                    <div style={{ marginTop: 8, color: '#fff' }}>
                                      â€¢ æ”»å‡»å¼ºåº¦ <span style={{ color: '#4CAF50', fontWeight: 600 }}>+{formatItemStatValue('attack', atk)}</span>
                                    </div>
                                  )}
                                  {sp !== 0 && (
                                    <div style={{ marginTop: 8, color: '#fff' }}>
                                      â€¢ æ³•æœ¯å¼ºåº¦ <span style={{ color: '#4CAF50', fontWeight: 600 }}>+{formatItemStatValue('spellPower', sp)}</span>
                                    </div>
                                  )}
                                  <div style={{
                                    marginTop: 12,
                                    padding: '8px 12px',
                                    background: 'rgba(255,215,0,0.1)',
                                    borderRadius: 6,
                                    border: '1px dashed rgba(255,215,0,0.3)',
                                    fontSize: 11,
                                    color: '#c9a227'
                                  }}>
                                    ğŸ’¡ æç¤ºï¼šè¯¥ç‰¹æ•ˆä¼šéšè£…å¤‡ç­‰çº§çº¿æ€§å¢å¼ºï¼ˆlv0=1x, lv100=2xï¼‰
                                  </div>
                                </div>
                              );
                            })()}

                            {/* basic_attack_repeat */}
                            {type === 'basic_attack_repeat' && (
                              <div style={{ fontSize: 12, color: '#ffb74d', lineHeight: 1.6 }}>
                                <div style={{ marginBottom: 8, color: '#fff' }}>
                                  ä½¿ç”¨æ™®é€šæ”»å‡»åï¼Œæœ‰ <span style={{ color: '#ffd700', fontWeight: 600 }}>{(chance * 100).toFixed(0)}%</span> æ¦‚ç‡å†æ¬¡å‘åŠ¨ä¸€æ¬¡æ™®é€šæ”»å‡»
                                </div>
                                <div style={{
                                  marginTop: 12,
                                  padding: '8px 12px',
                                  background: 'rgba(255,215,0,0.1)',
                                  borderRadius: 6,
                                  border: '1px dashed rgba(255,215,0,0.3)',
                                  fontSize: 11,
                                  color: '#c9a227'
                                }}>
                                  ğŸ’¡ æç¤ºï¼šè¿å‡»ä¼¤å®³ä¸æ™®é€šæ”»å‡»ç›¸åŒï¼Œå¯è§¦å‘â€œè´¨æœ´â€ç­‰æ™®æ”»ç›¸å…³å¤©èµ‹
                                </div>
                              </div>
                            )}

                            {/* proc_stat */}
                            {type === 'proc_stat' && (
                              <div style={{ fontSize: 12, color: '#ffb74d', lineHeight: 1.6 }}>
                                <div style={{ marginBottom: 8, color: '#fff' }}>
                                  {(trigger === 'turn_start') ? 'æ¯å›åˆå¼€å§‹' : 'è§¦å‘æ—¶'}æœ‰ <span style={{ color: '#ffd700', fontWeight: 600 }}>{(chance * 100).toFixed(0)}%</span> æ¦‚ç‡è·å¾—ä»¥ä¸‹å¢ç›Šï¼ˆä»…æœ¬å›åˆï¼‰ï¼š
                                </div>

                                {Object.entries((se.stats && typeof se.stats === 'object') ? se.stats : {}).map(([stat, value]) => (
                                  <div key={stat} style={{ marginTop: 8, color: '#fff' }}>
                                    â€¢ {statNames[stat] || stat}{' '}
                                    <span style={{ color: '#4CAF50', fontWeight: 600 }}>+{formatItemStatValue(stat, value)}</span>
                                  </div>
                                ))}

                                {se.scaleWithLevel && (
                                  <div style={{
                                    marginTop: 12,
                                    padding: '8px 12px',
                                    background: 'rgba(255,215,0,0.1)',
                                    borderRadius: 6,
                                    border: '1px dashed rgba(255,215,0,0.3)',
                                    fontSize: 11,
                                    color: '#c9a227'
                                  }}>
                                    ğŸ’¡ æç¤ºï¼šè¯¥ç‰¹æ•ˆä¼šéšè£…å¤‡ç­‰çº§æå‡è€Œå¢å¼ºï¼ˆlv0=1x, lv100=2xï¼‰
                                  </div>
                                )}
                              </div>
                            )}

                            {/* proc_damage */}
                            {type === 'proc_damage' && (
                              <div style={{ fontSize: 12, color: '#ffb74d', lineHeight: 1.6 }}>
                                <div style={{ marginBottom: 8, color: '#fff' }}>
                                  {(trigger === 'turn_start') ? 'æ¯å›åˆå¼€å§‹' : 'è§¦å‘æ—¶'}æœ‰ <span style={{ color: '#ffd700', fontWeight: 600 }}>{(chance * 100).toFixed(0)}%</span> æ¦‚ç‡è§¦å‘
                                  <span style={{ color: '#ffd700', fontWeight: 600 }}> {se.name || 'é¢å¤–ä¼¤å®³'} </span>ï¼š
                                </div>
                                <div style={{ marginTop: 8, color: '#fff' }}>
                                  â€¢ ä¼¤å®³ï¼š{Number(se.damageMult) ? `${Number(se.damageMult)}Ã—` : ''}{se.basedOn === 'spellPower' ? 'æ³•æœ¯å¼ºåº¦' : 'æ”»å‡»å¼ºåº¦'}{Number(se.damageFlat) ? ` + ${Math.floor(Number(se.damageFlat) || 0)}` : ''}ï¼ˆ{getSchoolCn(se.school)}ï¼‰
                                </div>
                              </div>
                            )}

                            {/* ignore_defense */}
                            {type === 'ignore_defense' && (
                              <div style={{ fontSize: 12, color: '#ffb74d', lineHeight: 1.6 }}>
                                <div style={{ color: '#fff' }}>
                                  ğŸ›¡ï¸ ç©¿ç”²ï¼šæ— è§†æ•Œäºº <span style={{ color: '#ffd700', fontWeight: 600 }}>{fmtPct(se.pct ?? se.ignorePct ?? se.value)}</span> é˜²å¾¡
                                </div>
                              </div>
                            )}

                            {/* thunderfuryï¼šæŒ‰ä½ å½“å‰æ•°æ®å­—æ®µå±•ç¤ºï¼ˆä¸å† NaNï¼‰ */}
                            {type === 'thunderfury' && (() => {
                              const damageMult = Number(se.damageMult) || 1.2;
                              const selfDamageTakenMult = Number(se.selfDamageTakenMult) || 0.8;
                              const selfBuffDuration = Math.max(1, Math.floor(Number(se.selfBuffDuration) || 2));
                              const reductionPct = Math.round((1 - selfDamageTakenMult) * 100);

                              return (
                                <div style={{ fontSize: 12, color: '#ffb74d', lineHeight: 1.6 }}>
                                  <div style={{ marginBottom: 8, color: '#fff' }}>
                                    æ¯å›åˆå¼€å§‹æœ‰ <span style={{ color: '#ffd700', fontWeight: 600 }}>{(chance * 100).toFixed(0)}%</span> æ¦‚ç‡é‡Šæ”¾ä¸€é“é—ªç”µé“¾ï¼š
                                  </div>
                                  <div style={{ marginTop: 8, color: '#fff' }}>
                                    â€¢ å¯¹æ‰€æœ‰æ•Œäººé€ æˆ <span style={{ color: '#ffd700', fontWeight: 600 }}>{damageMult.toFixed(1)}å€æ”»å‡»å¼ºåº¦</span> çš„è‡ªç„¶ä¼¤å®³
                                  </div>
                                  <div style={{ marginTop: 8, color: '#fff' }}>
                                    â€¢ å¹¶ä½¿è‡ªèº«å—åˆ°çš„æ‰€æœ‰ä¼¤å®³é™ä½ <span style={{ color: '#ffd700', fontWeight: 600 }}>{reductionPct}%</span> ï¼ŒæŒç»­ <span style={{ color: '#ffd700', fontWeight: 600 }}>{selfBuffDuration}</span> å›åˆ
                                  </div>
                                  <div style={{ marginTop: 12, fontSize: 11, color: '#c9a227' }}>
                                    ğŸ’¡ è¯´æ˜ï¼šå¯¹BOSSæˆ˜çš„å°æ€ªä¹Ÿæœ‰æ•ˆ
                                  </div>
                                </div>
                              );
                            })()}

                            {/* map_slayer */}
                            {type === 'map_slayer' && (
                              <div style={{ fontSize: 12, color: '#ffb74d', lineHeight: 1.6 }}>
                                <div style={{ marginBottom: 8, color: '#fff' }}>
                                  åœ°å›¾æˆ˜æ–—ä¸­é€ æˆçš„ä¼¤å®³æé«˜ <span style={{ color: '#ffd700', fontWeight: 600 }}>{fmtPct(se.bonusDamageVsMap)}</span>
                                </div>
                              </div>
                            )}

                            {/* fallback */}
                            {![ 'skill_slot_buff','basic_attack_repeat','proc_stat','proc_damage','ignore_defense','thunderfury','map_slayer' ].includes(type) && (
                              <div style={{ fontSize: 12, color: '#aaa' }}>
                                âš¡ ç‰¹æ•ˆï¼š{String(type || 'unknown')}
                              </div>
                            )}

                          </div>
                        );
                      })}
                    </div>
                  );
                })()}


                <div style={{ marginBottom: 12 }}>
                  <div style={{ fontSize: 12, color: '#aaa', marginBottom: 6 }}>é€‰æ‹©è¦è£…å¤‡çš„è§’è‰²</div>
                  <select
                    value={selectedCharId}
                    onChange={(e) => setSelectedCharId(e.target.value)}
                    style={{
                      width: '100%',
                      padding: '10px 12px',
                      borderRadius: 8,
                      border: '1px solid rgba(255,255,255,0.18)',
                      background: 'rgba(0,0,0,0.35)',
                      color: '#eee',
                      outline: 'none',
                      fontSize: 12,
                    }}
                  >
                        <option value="">é€‰æ‹©è§’è‰²...</option>
                        {characters.map(char => (
                            <option key={char.id} value={char.id}>
                                {char.name} (Lv.{char.level})
                            </option>
                        ))}
                  </select>
                </div>

                <div style={{ display: 'flex', gap: 12 }}>
                    {item.id === 'REBIRTH_INVITATION' && (
                        <Button
                            variant="danger"
                            onClick={() => {
                                dispatch({ type: 'USE_ITEM', payload: { itemInstanceId: item.instanceId || item.id } });
                                onClose();
                            }}
                            style={{ flex: 1 }}
                        >
                            ğŸŒ€ ä½¿ç”¨é‚€è¯·å‡½
                        </Button>
                    )}
                    <Button
                        onClick={() => {
                            if (selectedCharId) {
                                onEquip(selectedCharId, item.instanceId || item.id);
                                onClose();
                            }
                        }}
                        disabled={!selectedCharId}
                        style={{ flex: 1 }}
                    >
                        è£…å¤‡
                    </Button>
                    {(() => {
                        const getLevel = (eq) => (eq?.currentLevel ?? eq?.level ?? 0);
                        const isMatA = item.id === 'EQ_041' && getLevel(item) >= 100;
                        const isMatB = item.id === 'EQ_042' && getLevel(item) >= 100;

                        const hasOther =
                            isMatA
                                ? state.inventory.some(i => i?.type === 'equipment' && i.id === 'EQ_042' && getLevel(i) >= 100)
                                : isMatB
                                    ? state.inventory.some(i => i?.type === 'equipment' && i.id === 'EQ_041' && getLevel(i) >= 100)
                                    : false;

                        if (!(hasOther && (isMatA || isMatB))) return null;

                        return (
                            <Button
                                onClick={() => {
                                    if (window.confirm('æ¶ˆè€—ã€åå‡»è€…æ¡‘è¨æ–¯ Lv100ã€‘ä¸ã€ä¿æŠ¤è€…åŠ è¨æ–¯ Lv100ã€‘åˆæˆã€é­ç¬è€…è‹è¨æ–¯ Lv0ã€‘ï¼Ÿ')) {
                                        dispatch({ type: 'SYNTHESIZE_EQ_044' });
                                        onClose();
                                    }
                                }}
                                style={{ flex: 1 }}
                            >
                                âš—ï¸ è‹è¨æ–¯
                            </Button>
                        );
                    })()}
                    <Button
                        variant="danger"
                        onClick={() => {
                            if (window.confirm(`ç¡®å®šè¦ä¸¢å¼ƒ ${item.name} å—ï¼Ÿ`)) {
                                dispatch({ type: 'USE_ITEM', payload: { itemInstanceId: item.instanceId || item.id } });
                                onClose();
                            }
                        }}
                    >
                        ğŸ—‘ï¸ ä¸¢å¼ƒ
                    </Button>
                    <Button onClick={onClose} variant="secondary" style={{ flex: 1 }}>
                        å…³é—­
                    </Button>
                </div>
            </div>
        </div>
    );
};


// æ—¶ç©ºå¸å¥–åŠ±æ¨¡æ€æ¡†ï¼ˆæ¯æ—¥é¦–æ¬¡ä¿å­˜ï¼‰
const SpacetimeCoinRewardModal = ({ amount = 1000, total, onClose }) => {
    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1001,
            padding: 20
        }}>
            <div style={{
                background: 'linear-gradient(135deg, rgba(25,18,12,0.98) 0%, rgba(15,10,8,0.98) 100%)',
                border: '3px solid #7bdcff',
                borderRadius: 12,
                padding: 28,
                maxWidth: 420,
                width: '100%',
                boxShadow: '0 10px 36px rgba(123,220,255,0.25), inset 0 1px 0 rgba(255,255,255,0.08)',
            }}>
                <div style={{ textAlign: 'center', marginBottom: 18 }}>
                    <div style={{ fontSize: 54, marginBottom: 8 }}>ğŸŒ€</div>
                    <h2 style={{
                        margin: '0 0 8px 0',
                        fontSize: 22,
                        color: '#b9f3ff',
                        textShadow: '2px 2px 4px rgba(0,0,0,0.8)'
                    }}>
                        è·å¾—æ—¶ç©ºå¸ï¼
                    </h2>
                    <div style={{ color: '#cfefff', fontSize: 14, lineHeight: 1.6 }}>
                        æ¯æ—¥é¦–æ¬¡ç‚¹å‡» <span style={{ color: '#fff', fontWeight: 700 }}>ä¿å­˜</span> å¥–åŠ±
                        <span style={{ color: '#7bdcff', fontWeight: 800 }}> +{Math.floor(amount)} </span>
                        æ—¶ç©ºå¸
                    </div>
                    {typeof total === 'number' && (
                        <div style={{ marginTop: 10, fontSize: 12, color: '#9ad7e8' }}>
                            å½“å‰æ—¶ç©ºå¸ï¼š<span style={{ color: '#fff', fontWeight: 700 }}>{Math.floor(total)}</span>
                        </div>
                    )}
                </div>

                <div style={{ display: 'flex', justifyContent: 'center' }}>
                    <Button onClick={onClose} style={{ minWidth: 140 }}>
                        âœ“ çŸ¥é“äº†
                    </Button>
                </div>
            </div>
        </div>
    );
};


// æ—¶ç©ºå•†åŸï¼ˆä½¿ç”¨æ—¶ç©ºå¸ï¼‰
const SpacetimeShopModal = ({ state, dispatch, onClose }) => {
    const [toast, setToast] = useState(null);
    const [brokenImages, setBrokenImages] = useState({});

    const items = Array.isArray(SPACETIME_SHOP_ITEMS) ? SPACETIME_SHOP_ITEMS : [];
    const coin = Math.max(0, Math.floor(Number(state?.resources?.spacetimeCoin) || 0));

    const codexMounts = Array.isArray(state?.codexMounts) ? state.codexMounts : [];
    const mountSet = new Set(codexMounts);

    const isOwned = (item) => {
        if (!item) return false;
        if (item.type === 'mount' && item.mountId) return mountSet.has(item.mountId);
        return false;
    };

    useEffect(() => {
        if (!toast) return;
        const t = setTimeout(() => setToast(null), 2200);
        return () => clearTimeout(t);
    }, [toast]);

    const onBuy = (item) => {
        if (!item?.id) return;

        if (isOwned(item)) {
            setToast({ type: 'info', text: 'ä½ å·²ç»æ‹¥æœ‰è¯¥ç‰©å“ï¼ˆå›¾é‰´å·²ç‚¹äº®ï¼‰ã€‚' });
            return;
        }

        const price = Math.max(0, Math.floor(Number(item.price) || 0));
        if (coin < price) {
            setToast({ type: 'error', text: 'æ—¶ç©ºå¸ä¸è¶³ã€‚' });
            return;
        }

        dispatch({ type: 'BUY_SPACETIME_SHOP_ITEM', payload: { shopItemId: item.id } });

        const bonusText = item.bonus ? formatBonusText(item.bonus) : '';
        setToast({ type: 'success', text: `è´­ä¹°æˆåŠŸï¼ã€${item.name}ã€‘å·²ç‚¹äº®ï¼ˆ${bonusText || 'å·²ç”Ÿæ•ˆ'}ï¼‰` });
    };

    const rarityMeta = (rarity) => {
        if (rarity === 'legendary') return { name: 'ä¼ è¯´', color: '#ffd700' };
        if (rarity === 'epic') return { name: 'å²è¯—', color: '#b06cff' };
        if (rarity === 'rare') return { name: 'ç²¾è‰¯', color: '#4aa3ff' };
        return { name: 'æ™®é€š', color: '#d9d9d9' };
    };

    return (
        <div
            style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: 'radial-gradient(circle at 30% 18%, rgba(123,220,255,0.20) 0%, rgba(40,12,60,0.20) 26%, rgba(0,0,0,0.92) 58%, rgba(0,0,0,0.96) 100%)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 1200,
                padding: 20
            }}
            onMouseDown={(e) => {
                // ç‚¹å‡»é®ç½©å…³é—­
                if (e.target === e.currentTarget) onClose?.();
            }}
        >
            <style>{`
                @keyframes stShopSpin {
                    from { transform: rotate(0deg); }
                    to { transform: rotate(360deg); }
                }
                @keyframes stShopFloat {
                    0% { transform: translateY(0px); opacity: 0.75; }
                    50% { transform: translateY(-8px); opacity: 1; }
                    100% { transform: translateY(0px); opacity: 0.75; }
                }
                @keyframes stShopShimmer {
                    0% { background-position: 0% 50%; }
                    50% { background-position: 100% 50%; }
                    100% { background-position: 0% 50%; }
                }
            `}</style>

            <div style={{
                position: 'relative',
                width: 'min(980px, 96vw)',
                maxHeight: '90vh',
                borderRadius: 16,
                overflow: 'hidden',
                border: '2px solid rgba(123,220,255,0.40)',
                boxShadow: '0 22px 80px rgba(0,0,0,0.75), 0 0 60px rgba(123,220,255,0.18)',
                background: 'linear-gradient(135deg, rgba(18,10,28,0.98) 0%, rgba(10,14,22,0.98) 45%, rgba(12,8,18,0.99) 100%)',
                backdropFilter: 'blur(8px)',
            }}>
                {/* èƒŒæ™¯è£…é¥°ï¼šæ˜Ÿäº‘/ç¬¦æ–‡ */}
                <div style={{
                    position: 'absolute',
                    inset: 0,
                    backgroundImage: `
                        radial-gradient(circle at 18% 22%, rgba(255,215,0,0.12) 0%, transparent 35%),
                        radial-gradient(circle at 82% 18%, rgba(123,220,255,0.18) 0%, transparent 40%),
                        radial-gradient(circle at 50% 80%, rgba(176,108,255,0.12) 0%, transparent 45%),
                        repeating-linear-gradient(135deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 10px)
                    `,
                    opacity: 0.55,
                    pointerEvents: 'none'
                }} />

                {/* æ—‹è½¬æ˜Ÿé—¨ */}
                <div style={{
                    position: 'absolute',
                    top: -140,
                    right: -140,
                    width: 360,
                    height: 360,
                    borderRadius: '50%',
                    background: 'conic-gradient(from 90deg, rgba(123,220,255,0.0), rgba(123,220,255,0.35), rgba(255,215,0,0.12), rgba(176,108,255,0.18), rgba(123,220,255,0.0))',
                    filter: 'blur(1px)',
                    opacity: 0.65,
                    animation: 'stShopSpin 18s linear infinite',
                    pointerEvents: 'none'
                }} />
                <div style={{
                    position: 'absolute',
                    bottom: -180,
                    left: -180,
                    width: 420,
                    height: 420,
                    borderRadius: '50%',
                    background: 'conic-gradient(from 180deg, rgba(255,215,0,0.0), rgba(255,215,0,0.18), rgba(123,220,255,0.18), rgba(255,215,0,0.0))',
                    filter: 'blur(2px)',
                    opacity: 0.55,
                    animation: 'stShopSpin 26s linear infinite reverse',
                    pointerEvents: 'none'
                }} />

                {/* é¡¶éƒ¨æ  */}
                <div style={{
                    position: 'relative',
                    padding: '18px 18px 12px 18px',
                    borderBottom: '1px solid rgba(123,220,255,0.18)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    gap: 12
                }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                        <div style={{
                            width: 46,
                            height: 46,
                            borderRadius: '50%',
                            position: 'relative',
                            overflow: 'hidden',
                            border: '1px solid rgba(123,220,255,0.45)',
                            boxShadow: '0 0 18px rgba(123,220,255,0.20), inset 0 1px 0 rgba(255,255,255,0.10)',
                            background: 'radial-gradient(circle at 30% 30%, rgba(255,255,255,0.20), rgba(123,220,255,0.12) 45%, rgba(0,0,0,0) 72%)'
                        }}>
                            <div style={{
                                position: 'absolute',
                                inset: -18,
                                background: 'conic-gradient(from 90deg, rgba(123,220,255,0.0), rgba(123,220,255,0.35), rgba(255,215,0,0.12), rgba(123,220,255,0.0))',
                                animation: 'stShopSpin 4s linear infinite'
                            }} />
                            <div style={{
                                position: 'absolute',
                                inset: 5,
                                borderRadius: '50%',
                                background: 'radial-gradient(circle at 35% 35%, rgba(255,255,255,0.18), rgba(123,220,255,0.06) 55%, rgba(0,0,0,0) 72%)'
                            }} />
                        </div>

                        <div>
                            <div style={{
                                fontSize: 20,
                                fontWeight: 900,
                                letterSpacing: 1,
                                lineHeight: 1,
                                backgroundImage: 'linear-gradient(90deg, #b9f3ff, #ffd700, #b06cff, #b9f3ff)',
                                backgroundSize: '200% 200%',
                                animation: 'stShopShimmer 6s ease infinite',
                                WebkitBackgroundClip: 'text',
                                color: 'transparent',
                                filter: 'drop-shadow(0 0 12px rgba(123,220,255,0.22))'
                            }}>
                                ğŸŒ€ æ—¶ç©ºå•†åŸ
                            </div>
                            <div style={{ marginTop: 4, fontSize: 12, color: '#9ad7e8' }}>
                                ç”¨æ—¶ç©ºå¸æ¢å–è·¨ä¸–çè— Â· è´­ä¹°åæ°¸ä¹…ç”Ÿæ•ˆ
                            </div>
                        </div>
                    </div>

                    <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                        <div style={{ textAlign: 'right' }}>
                            <div style={{ fontSize: 10, color: '#88b7c8' }}>å½“å‰æ—¶ç©ºå¸</div>
                            <div style={{
                                fontSize: 18,
                                fontWeight: 900,
                                color: '#ffffff',
                                textShadow: '0 0 12px rgba(123,220,255,0.25)'
                            }}>
                                ğŸŒ€ {coin.toLocaleString()}
                            </div>
                        </div>

                        <button
                            onClick={onClose}
                            title="å…³é—­"
                            style={{
                                width: 38,
                                height: 38,
                                borderRadius: 12,
                                border: '1px solid rgba(255,255,255,0.14)',
                                background: 'rgba(0,0,0,0.35)',
                                color: '#fff',
                                cursor: 'pointer',
                                fontWeight: 900,
                                boxShadow: 'inset 0 1px 0 rgba(255,255,255,0.08)'
                            }}
                        >
                            âœ•
                        </button>
                    </div>
                </div>

                {/* å†…å®¹ */}
                <div style={{
                    position: 'relative',
                    padding: 18,
                    maxHeight: 'calc(90vh - 84px)',
                    overflow: 'auto'
                }}>
                    <div style={{
                        display: 'grid',
                        gap: 14
                    }}>
                        {items.map((item) => {
                            const owned = isOwned(item);
                            const price = Math.max(0, Math.floor(Number(item.price) || 0));
                            const canAfford = coin >= price;
                            const bonusText = item.bonus ? formatBonusText(item.bonus) : '';
                            const rarity = rarityMeta(item.rarity);
                            const imgBroken = !!brokenImages?.[item.id];

                            return (
                                <div
                                    key={item.id}
                                    style={{
                                        position: 'relative',
                                        borderRadius: 14,
                                        overflow: 'hidden',
                                        border: owned
                                            ? '2px solid rgba(76,175,80,0.45)'
                                            : (item.rarity === 'legendary'
                                                ? '2px solid rgba(255,215,0,0.55)'
                                                : '1px solid rgba(123,220,255,0.22)'),
                                        background: owned
                                            ? 'linear-gradient(135deg, rgba(20,35,22,0.55) 0%, rgba(10,16,12,0.55) 100%)'
                                            : 'linear-gradient(135deg, rgba(123,220,255,0.12) 0%, rgba(0,0,0,0.20) 38%, rgba(255,215,0,0.06) 100%)',
                                        boxShadow: owned
                                            ? '0 0 18px rgba(76,175,80,0.12)'
                                            : '0 0 22px rgba(123,220,255,0.10)',
                                    }}
                                >
                                    {/* é¡¶éƒ¨é£˜å¸¦ */}
                                    <div style={{
                                        position: 'absolute',
                                        top: 12,
                                        left: -42,
                                        transform: 'rotate(-12deg)',
                                        padding: '6px 54px',
                                        fontSize: 11,
                                        fontWeight: 900,
                                        letterSpacing: 1,
                                        color: '#111',
                                        background: owned
                                            ? 'linear-gradient(90deg, rgba(76,175,80,0.95), rgba(120,220,120,0.75))'
                                            : 'linear-gradient(90deg, rgba(255,215,0,0.95), rgba(123,220,255,0.75))',
                                        boxShadow: '0 10px 24px rgba(0,0,0,0.35)',
                                        opacity: 0.95
                                    }}>
                                        {owned ? 'å·²æ‹¥æœ‰' : `${rarity.name} Â· é™å®š`}
                                    </div>

                                    <div style={{
                                        display: 'grid',
                                        gridTemplateColumns: '240px 1fr',
                                        gap: 14,
                                        padding: 14
                                    }}>
                                        {/* å·¦ä¾§ï¼šå±•ç¤ºå›¾ */}
                                        <div style={{
                                            position: 'relative',
                                            height: 160,
                                            borderRadius: 12,
                                            overflow: 'hidden',
                                            border: '1px solid rgba(255,255,255,0.10)',
                                            background: 'rgba(0,0,0,0.30)',
                                            boxShadow: 'inset 0 0 0 1px rgba(0,0,0,0.35)'
                                        }}>
                                            {/* å‘å…‰è¾¹ */}
                                            <div style={{
                                                position: 'absolute',
                                                inset: -40,
                                                background: owned
                                                    ? 'radial-gradient(circle at 30% 30%, rgba(76,175,80,0.18), transparent 55%)'
                                                    : 'radial-gradient(circle at 30% 30%, rgba(255,215,0,0.18), transparent 55%)',
                                                animation: 'stShopFloat 4.8s ease-in-out infinite',
                                                pointerEvents: 'none'
                                            }} />
                                            {item.imageUrl && !imgBroken ? (
                                                <img
                                                    src={item.imageUrl}
                                                    alt={item.name}
                                                    style={{
                                                        width: '100%',
                                                        height: '100%',
                                                        objectFit: 'cover',
                                                        filter: owned ? 'none' : 'saturate(1.05) contrast(1.05)',
                                                    }}
                                                    onError={() => {
                                                        // å›¾ç‰‡ç¼ºå¤±æ—¶é™çº§ä¸º icon
                                                        setBrokenImages(prev => ({ ...(prev || {}), [item.id]: true }));
                                                    }}
                                                />
                                            ) : null}
                                            <div style={{
                                                position: 'absolute',
                                                inset: 0,
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                pointerEvents: 'none'
                                            }}>
                                                <div style={{
                                                    fontSize: 44,
                                                    opacity: (item.imageUrl && !imgBroken) ? 0 : 0.9,
                                                    filter: owned ? 'none' : 'drop-shadow(0 0 14px rgba(255,215,0,0.18))'
                                                }}>
                                                    {item.icon || 'âœ¨'}
                                                </div>
                                            </div>

                                            <div style={{
                                                position: 'absolute',
                                                left: 0,
                                                right: 0,
                                                bottom: 0,
                                                padding: '8px 10px',
                                                background: 'linear-gradient(0deg, rgba(0,0,0,0.85), transparent)',
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'baseline'
                                            }}>
                                                <div style={{ fontSize: 12, fontWeight: 900, color: '#fff' }}>
                                                    {item.name}
                                                </div>
                                                <div style={{ fontSize: 11, fontWeight: 900, color: rarity.color }}>
                                                    {rarity.name}
                                                </div>
                                            </div>
                                        </div>

                                        {/* å³ä¾§ï¼šä¿¡æ¯ */}
                                        <div style={{ display: 'flex', flexDirection: 'column' }}>
                                            <div style={{
                                                display: 'flex',
                                                alignItems: 'baseline',
                                                justifyContent: 'space-between',
                                                gap: 10
                                            }}>
                                                <div style={{ fontSize: 16, fontWeight: 900, color: '#ffd700' }}>
                                                    {item.name}
                                                </div>

                                                <div style={{
                                                    fontSize: 11,
                                                    color: owned ? 'rgba(120,220,120,0.95)' : '#b9f3ff',
                                                    fontWeight: 900,
                                                    padding: '4px 10px',
                                                    borderRadius: 999,
                                                    border: owned
                                                        ? '1px solid rgba(120,220,120,0.25)'
                                                        : '1px solid rgba(123,220,255,0.22)',
                                                    background: owned
                                                        ? 'rgba(76,175,80,0.10)'
                                                        : 'rgba(123,220,255,0.08)',
                                                }}>
                                                    {owned ? 'æ°¸ä¹…ç”Ÿæ•ˆ' : 'è·¨ä¸–æ°¸ä¹…'}
                                                </div>
                                            </div>

                                            <div style={{
                                                marginTop: 8,
                                                fontSize: 12,
                                                color: '#d7e8ee',
                                                lineHeight: 1.6,
                                                background: 'rgba(0,0,0,0.22)',
                                                border: '1px solid rgba(255,255,255,0.06)',
                                                borderRadius: 10,
                                                padding: 10
                                            }}>
                                                {item.description || 'ä¸€ä»¶ç©¿è¶Šæ—¶ç©ºçš„ç¥ç§˜æ”¶è—ã€‚'}
                                                {item.flavor && (
                                                    <div style={{ marginTop: 8, fontSize: 11, color: '#9ad7e8', fontStyle: 'italic' }}>
                                                        {item.flavor}
                                                    </div>
                                                )}
                                            </div>

                                            <div style={{
                                                marginTop: 10,
                                                display: 'grid',
                                                gridTemplateColumns: '1fr 1fr',
                                                gap: 10
                                            }}>
                                                <div style={{
                                                    padding: 10,
                                                    borderRadius: 10,
                                                    border: '1px solid rgba(255,255,255,0.08)',
                                                    background: 'rgba(0,0,0,0.22)'
                                                }}>
                                                    <div style={{ fontSize: 10, color: '#88b7c8', marginBottom: 4 }}>æ•ˆæœ</div>
                                                    <div style={{
                                                        fontSize: 12,
                                                        fontWeight: 900,
                                                        color: owned ? 'rgba(120,220,120,0.95)' : '#ffd700'
                                                    }}>
                                                        {bonusText || 'â€”'}
                                                    </div>
                                                </div>

                                                <div style={{
                                                    padding: 10,
                                                    borderRadius: 10,
                                                    border: '1px solid rgba(255,255,255,0.08)',
                                                    background: 'rgba(0,0,0,0.22)'
                                                }}>
                                                    <div style={{ fontSize: 10, color: '#88b7c8', marginBottom: 4 }}>è·å–</div>
                                                    <div style={{ fontSize: 12, fontWeight: 900, color: '#fff' }}>
                                                        {item.type === 'mount' ? 'ç‚¹äº®åéª‘å›¾é‰´' : 'ç›´æ¥è·å–'}
                                                    </div>
                                                </div>
                                            </div>

                                            <div style={{
                                                marginTop: 'auto',
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'space-between',
                                                gap: 10,
                                                paddingTop: 12
                                            }}>
                                                <div>
                                                    <div style={{ fontSize: 10, color: '#88b7c8' }}>ä»·æ ¼</div>
                                                    <div style={{
                                                        fontSize: 18,
                                                        fontWeight: 900,
                                                        color: canAfford ? '#ffffff' : '#ffb1b1',
                                                        textShadow: '0 0 12px rgba(123,220,255,0.18)'
                                                    }}>
                                                        ğŸŒ€ {price.toLocaleString()}
                                                    </div>
                                                </div>

                                                <Button
                                                    onClick={() => onBuy(item)}
                                                    disabled={owned || !canAfford}
                                                    style={{
                                                        minWidth: 170,
                                                        padding: '10px 14px',
                                                        borderRadius: 12,
                                                        fontSize: 13,
                                                        fontWeight: 900,
                                                        background: owned
                                                            ? 'linear-gradient(180deg, rgba(60,60,60,0.45), rgba(30,30,30,0.45))'
                                                            : (canAfford
                                                                ? 'linear-gradient(180deg, rgba(255,215,0,0.90), rgba(123,220,255,0.35))'
                                                                : 'linear-gradient(180deg, rgba(180,80,80,0.55), rgba(120,30,30,0.55))'),
                                                        border: owned
                                                            ? '1px solid rgba(255,255,255,0.10)'
                                                            : (canAfford
                                                                ? '1px solid rgba(255,215,0,0.60)'
                                                                : '1px solid rgba(255,120,120,0.35)'),
                                                        color: owned ? '#aaa' : '#111',
                                                        boxShadow: owned
                                                            ? 'none'
                                                            : (canAfford
                                                                ? '0 0 22px rgba(255,215,0,0.15), 0 0 22px rgba(123,220,255,0.12)'
                                                                : 'none'),
                                                        textShadow: owned ? 'none' : '0 1px 0 rgba(255,255,255,0.25)'
                                                    }}
                                                >
                                                    {owned ? 'âœ“ å·²æ‹¥æœ‰' : (canAfford ? 'âœ¨ è´­ä¹°' : 'â›” æ—¶ç©ºå¸ä¸è¶³')}
                                                </Button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            );
                        })}

                        {items.length === 0 && (
                            <div style={{ color: '#888', textAlign: 'center', padding: 20 }}>
                                æ—¶ç©ºè£‚éš™æ­£åœ¨é‡è¿â€¦ç¨åå†æ¥çœ‹çœ‹ã€‚
                            </div>
                        )}
                    </div>
                </div>

                {/* Toast */}
                {toast && (
                    <div style={{
                        position: 'absolute',
                        left: '50%',
                        bottom: 16,
                        transform: 'translateX(-50%)',
                        padding: '10px 14px',
                        borderRadius: 999,
                        background: toast.type === 'success'
                            ? 'rgba(76,175,80,0.18)'
                            : (toast.type === 'error'
                                ? 'rgba(220,80,80,0.18)'
                                : 'rgba(255,255,255,0.08)'),
                        border: toast.type === 'success'
                            ? '1px solid rgba(76,175,80,0.35)'
                            : (toast.type === 'error'
                                ? '1px solid rgba(220,80,80,0.35)'
                                : '1px solid rgba(123,220,255,0.22)'),
                        color: '#fff',
                        fontSize: 12,
                        fontWeight: 800,
                        boxShadow: '0 10px 30px rgba(0,0,0,0.35)',
                        backdropFilter: 'blur(6px)',
                        textShadow: '0 1px 2px rgba(0,0,0,0.6)'
                    }}>
                        {toast.text}
                    </div>
                )}
            </div>
        </div>
    );
};



// ==================== PAGE: MAP (with Drag & Drop) ====================
const TalentPage = ({ state, dispatch }) => {
    const characters = state.characters || [];
    const [selectedId, setSelectedId] = useState(characters[0]?.id || '');

    useEffect(() => {
        if (!selectedId && characters[0]?.id) setSelectedId(characters[0].id);
        if (selectedId && !characters.some(c => c.id === selectedId)) {
            setSelectedId(characters[0]?.id || '');
        }
    }, [characters, selectedId]);

    const character = characters.find(c => c.id === selectedId);

    if (!character) {
        return (
            <Panel title="å¤©èµ‹">
                <div style={{ color: '#888', textAlign: 'center', padding: 20 }}>
                    è¿˜æ²¡æœ‰è§’è‰²ï¼Œå…ˆå»â€œè§’è‰²â€é¡µé¢åˆ›å»ºä¸€ä¸ªå§ã€‚
                </div>
            </Panel>
        );
    }

    const tiers = TALENTS[character.classId] || [];
    const talents = character.talents || {};

    const isTierUnlocked = (tier) => (character.level || 1) >= tier;

    const chooseTalent = (tier, talentId) => {
        if (!isTierUnlocked(tier)) return;
        dispatch({ type: 'SET_TALENT', payload: { characterId: character.id, tier, talentId } });
    };

    const cardStyle = (tier, optionId) => {
        const picked = talents?.[tier] === optionId;
        const hasPick = Boolean(talents?.[tier]);
        const locked = !isTierUnlocked(tier);

        const dim = hasPick && !picked;
        return {
            background: picked
                ? 'linear-gradient(135deg, rgba(201,162,39,0.20) 0%, rgba(120,90,20,0.15) 100%)'
                : 'rgba(0,0,0,0.25)',
            border: picked ? '2px solid #c9a227' : '2px solid rgba(74,60,42,0.9)',
            borderRadius: 10,
            padding: 14,
            cursor: (locked || dim) ? 'not-allowed' : 'pointer',
            opacity: locked ? 0.45 : (dim ? 0.25 : 1),
            transition: 'all 0.15s',
            boxShadow: picked ? '0 0 14px rgba(201,162,39,0.25)' : 'none',
            userSelect: 'none',
        };
    };

    return (
        <div>
            <Panel
                title="å¤©èµ‹"
                actions={
                    <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                        <div style={{ fontSize: 12, color: '#aaa' }}>é€‰æ‹©è§’è‰²ï¼š</div>
                        <select
                            value={selectedId}
                            onChange={(e) => setSelectedId(e.target.value)}
                            style={{
                                padding: '6px 10px',
                                background: 'rgba(0,0,0,0.4)',
                                border: '1px solid #4a3c2a',
                                borderRadius: 6,
                                color: '#fff',
                                fontSize: 12,
                                cursor: 'pointer'
                            }}
                        >
                            {characters.map(c => (
                                <option key={c.id} value={c.id}>
                                    {c.name}ï¼ˆLv{c.level}ï¼‰
                                </option>
                            ))}
                        </select>
                    </div>
                }
            >
                <div style={{ color: '#888', fontSize: 12, marginBottom: 10 }}>
                    æ¯10çº§è§£é”ä¸€è¡Œï¼Œæ¯è¡Œ3é€‰1ã€‚
                </div>

                {tiers.map(tierDef => {
                    const tier = tierDef.tier;
                    const locked = !isTierUnlocked(tier);
                    const picked = talents?.[tier];

                    return (
                        <div key={tier} style={{
                            marginBottom: 14,
                            padding: 14,
                            background: 'rgba(0,0,0,0.18)',
                            border: '1px solid rgba(201,162,39,0.12)',
                            borderRadius: 10,
                        }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', marginBottom: 10 }}>
                                <div style={{ color: '#ffd700', fontWeight: 700 }}>
                                    Lv{tier} å¤©èµ‹
                                </div>
                                <div style={{ fontSize: 12, color: locked ? '#a66' : '#7f7' }}>
                                    {locked ? `æœªè§£é”ï¼ˆéœ€è¦ Lv${tier}ï¼‰` : (picked ? `å·²é€‰æ‹©ï¼š${tierDef.options.find(o => o.id === picked)?.name || picked}` : 'æœªé€‰æ‹©')}
                                </div>
                            </div>

                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 12 }}>
                                {tierDef.options.map(opt => (
                                    <div
                                        key={opt.id}
                                        style={cardStyle(tier, opt.id)}
                                        onClick={() => {
                                            if (locked) return;
                                            // å¦‚æœå·²é€‰è¿™ä¸€é¡¹ï¼Œåˆ™ä¸åšåˆ‡æ¢ï¼ˆé¿å…è¯¯è§¦ï¼‰
                                            if (talents?.[tier] === opt.id) return;
                                            // å¦‚æœæ˜¯å ä½ï¼ˆé¢„ç•™ï¼‰è¡Œï¼Œå…ˆä¸å…è®¸é€‰æ‹©ï¼ˆé¿å…è¯¯å¯¼ï¼‰
                                            if (tier >= 80) return;
                                            chooseTalent(tier, opt.id);
                                        }}
                                        title={locked ? 'æœªè§£é”' : (tier >= 80 ? 'é¢„ç•™å¤©èµ‹ï¼Œå¾…å®ç°' : 'ç‚¹å‡»é€‰æ‹©')}
                                    >
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 8 }}>
                                            <div style={{ fontWeight: 700, color: '#fff' }}>{opt.name}</div>
                                            {talents?.[tier] === opt.id && (
                                                <div style={{ color: '#c9a227', fontSize: 12, fontWeight: 800 }}>âœ“ å·²ç‚¹äº®</div>
                                            )}
                                        </div>
                                        <div style={{ fontSize: 12, color: '#bbb', lineHeight: 1.45 }}>
                                            {opt.description}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    );
                })}
            </Panel>
        </div>
    );
};

const MapPage = ({ state, dispatch }) => {
    const [draggedChar, setDraggedChar] = useState(null);

    const handleDragStart = (e, charId) => {
        setDraggedChar(charId);
        // âœ… Edge/éƒ¨åˆ†æµè§ˆå™¨éœ€è¦ setData æ‰ä¼šè®¤ä¸ºè¿™æ˜¯â€œæœ‰æ•ˆæ‹–æ‹½â€
        e.dataTransfer.setData('text/plain', charId);
        e.dataTransfer.effectAllowed = 'move';
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    };

    const handleDrop = (e, zoneId) => {
        e.preventDefault();
        if (draggedChar) {
            dispatch({
                type: 'ASSIGN_ZONE',
                payload: { characterId: draggedChar, zoneId }
            });
            setDraggedChar(null);
        }
    };

    // è·å–æ‰€æœ‰åœ¨ä¸»åŸèµ„æºå»ºç­‘å·¥ä½œçš„è§’è‰²ID
    const resourceAssignedIds = new Set(
        Object.values(state.resourceAssignments || {}).flat()
    );

    // è¿‡æ»¤ï¼šæ—¢ä¸åœ¨åœ°å›¾æ‰“æ€ªï¼Œä¹Ÿä¸åœ¨ä¸»åŸé‡‡é›†
    const unassignedChars = state.characters.filter(c =>
        !state.assignments[c.id] && !resourceAssignedIds.has(c.id)
    );

    return (
        <div>
            {/* æœªåˆ†é…çš„è§’è‰²åˆ—è¡¨ */}
            {unassignedChars.length > 0 && (
                <div
                    style={{
                        position: 'sticky',
                        top: 12,
                        zIndex: 50,
                        // å¯é€‰ï¼šå¦‚æœè§’è‰²å¾ˆå¤šï¼Œå›ºå®šæ è‡ªå·±æ»šåŠ¨
                        maxHeight: '40vh',
                        overflowY: 'auto',
                    }}
                >
                    <Panel title="å¯æ´¾é£è§’è‰²" style={{ marginBottom: 16 }}>
                        <div style={{
                            display: 'flex',
                            gap: 12,
                            flexWrap: 'wrap'
                        }}>
                            {unassignedChars.map(char => (
                                <div
                                    key={char.id}
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, char.id)}
                                    style={{
                                        padding: '12px 16px',
                                        background: 'linear-gradient(135deg, rgba(201,162,39,0.2), rgba(139,115,25,0.1))',
                                        border: '2px solid #c9a227',
                                        borderRadius: 6,
                                        cursor: 'grab',
                                        transition: 'all 0.2s',
                                        userSelect: 'none'
                                    }}
                                    onMouseEnter={(e) => {
                                        e.currentTarget.style.transform = 'translateY(-4px)';
                                        e.currentTarget.style.boxShadow = '0 4px 12px rgba(201,162,39,0.4)';
                                    }}
                                    onMouseLeave={(e) => {
                                        e.currentTarget.style.transform = 'translateY(0)';
                                        e.currentTarget.style.boxShadow = 'none';
                                    }}
                                >
                                    <div style={{ fontSize: 14, color: '#ffd700', fontWeight: 600 }}>
                                        {char.name}
                                    </div>
                                    <div style={{ fontSize: 11, color: '#888', marginTop: 4 }}>
                                        Lv.{char.level} {CLASSES[char.classId].name}
                                    </div>
                                </div>
                            ))}
                        </div>
                        <div style={{
                            marginTop: 12,
                            fontSize: 12,
                            color: '#888',
                            fontStyle: 'italic'
                        }}>
                            ğŸ’¡ æ‹–æ‹½è§’è‰²åˆ°åŒºåŸŸè¿›è¡Œåˆ†é…
                        </div>
                    </Panel>
                </div>
            )}

            {/* åŒºåŸŸåˆ—è¡¨ */}
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: 16 }}>
                {Object.values(state.zones).map(zone => {
                    const assignedChars = Object.entries(state.assignments)
                        .filter(([_, zId]) => zId === zone.id)
                        .map(([cId, _]) => state.characters.find(c => c.id === cId))
                        .filter(Boolean);

                    return (
                        <div
                            key={zone.id}
                            onDragOver={zone.unlocked ? handleDragOver : undefined}
                            onDrop={zone.unlocked ? (e) => handleDrop(e, zone.id) : undefined}
                            style={{
                                opacity: zone.unlocked ? 1 : 0.6,
                                transition: 'all 0.2s'
                            }}
                        >
                            <Panel title={zone.name}>
                                <div style={{ fontSize: 13, color: '#aaa', marginBottom: 12 }}>
                                    ç­‰çº§: {zone.level} | {zone.unlocked ? 'âœ“ å·²è§£é”' : `ğŸ”’ éœ€è¦ç­‰çº§ ${zone.unlockLevel}`}
                                </div>

                                {zone.unlocked && (
                                    <>
                                        <div style={{ marginBottom: 12 }}>
                                            <div style={{ fontSize: 12, color: '#888', marginBottom: 8 }}>æ€ªç‰©:</div>
                                            {zone.enemies?.map((enemy, i) => (
                                                <div key={i} style={{
                                                    fontSize: 11,
                                                    padding: 6,
                                                    background: 'rgba(0,0,0,0.3)',
                                                    borderRadius: 4,
                                                    marginBottom: 4
                                                }}>
                                                    {enemy.name} (HP: {enemy.hp}, æ”»å‡»: {enemy.attack})
                                                </div>
                                            ))}
                                        </div>

                                        <div style={{
                                            minHeight: 60,
                                            padding: 12,
                                            background: 'rgba(201,162,39,0.05)',
                                            border: '2px dashed #4a3c2a',
                                            borderRadius: 6,
                                            marginBottom: 12
                                        }}>
                                            <div style={{ fontSize: 12, color: '#888', marginBottom: 8 }}>
                                                å·²åˆ†é…è§’è‰²:
                                            </div>
                                            {assignedChars.length > 0 ? (
                                                assignedChars.map(char => (
                                                    <div key={char.id} style={{
                                                        display: 'flex',
                                                        justifyContent: 'space-between',
                                                        alignItems: 'center',
                                                        padding: 6,
                                                        background: 'rgba(201,162,39,0.1)',
                                                        borderRadius: 4,
                                                        marginBottom: 4
                                                    }}>
                                                        <span style={{ fontSize: 11 }}>{char.name} (Lv.{char.level})</span>
                                                        <Button
                                                            onClick={() => dispatch({
                                                                type: 'UNASSIGN_CHARACTER',
                                                                payload: { characterId: char.id }
                                                            })}
                                                            variant="danger"
                                                            style={{ padding: '4px 8px', fontSize: 10 }}
                                                        >
                                                            å¬å›
                                                        </Button>
                                                    </div>
                                                ))
                                            ) : (
                                                <div style={{ fontSize: 11, color: '#666', fontStyle: 'italic', textAlign: 'center' }}>
                                                    æ‹–æ‹½è§’è‰²åˆ°æ­¤å¤„
                                                </div>
                                            )}
                                        </div>
                                    </>
                                )}
                            </Panel>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

// ==================== PAGE: CHARACTER ====================
const CharacterPage = ({ state, dispatch }) => {
    const [showCreate, setShowCreate] = useState(false);
    const [newChar, setNewChar] = useState({ name: '', race: RACES[0], classId: 'protection_warrior' });
    const [selectedCharId, setSelectedCharId] = useState(null);
    const [showSkillEditor, setShowSkillEditor] = useState(null);
    const [showSkillViewer, setShowSkillViewer] = useState(null);
    const [showCombatLogs, setShowCombatLogs] = useState(false);

    const createCharacter = () => {
        if (newChar.name.trim()) {
            dispatch({ type: 'CREATE_CHARACTER', payload: newChar });
            setNewChar({ name: '', race: RACES[0], classId: 'protection_warrior' });
            setShowCreate(false);
        }
    };

    const expandCost = 1000 * Math.pow(2, state.characterSlots);
    const hasAvailableSlots = state.characters.length < state.characterSlots;

    return (
        <div>
            {showCombatLogs && (
                <CombatLogsModal
                    logs={state.combatLogs}
                    onClose={() => setShowCombatLogs(false)}
                    onClear={() => {
                        dispatch({ type: 'CLEAR_COMBAT_LOGS' });
                        setShowCombatLogs(false);
                    }}
                />
            )}

            {showSkillEditor && (
                <SkillEditorModal
                    character={showSkillEditor}
                    onClose={() => setShowSkillEditor(null)}
                    onSave={(charId, skillSets, activeSkillSet) => {
                        dispatch({ type: 'UPDATE_SKILL_SETS', payload: { characterId: charId, skillSets, activeSkillSet } });
                    }}
                    state={state}
                />
            )}

            {showSkillViewer && (
                <SkillViewerModal
                    character={showSkillViewer}
                    onClose={() => setShowSkillViewer(null)}
                />
            )}

            {selectedCharId && (
                <CharacterDetailsModal
                    characterId={selectedCharId}
                    state={state}
                    onClose={() => setSelectedCharId(null)}
                    onUnequip={(charId, slot) => {
                        dispatch({ type: 'UNEQUIP_ITEM', payload: { characterId: charId, slot } });
                    }}
                    onEditSkills={() => {
                        const latest = state.characters.find(c => c.id === selectedCharId);
                        if (latest) setShowSkillEditor(latest);
                        setSelectedCharId(null);
                    }}
                    onViewSkills={() => {
                        const latest = state.characters.find(c => c.id === selectedCharId);
                        if (latest) setShowSkillViewer(latest);
                        setSelectedCharId(null);
                    }}
                    onSyncSkills={() => dispatch({ type: 'SYNC_CHARACTER_SKILLS', payload: { characterId: selectedCharId } })}
                />
            )}

            <Panel
                title="è§’è‰²ç®¡ç†"
                actions={
                    <div style={{ display: 'flex', gap: 8 }}>
                        <Button
                            onClick={() => setShowCombatLogs(true)}
                            variant="secondary"
                        >
                            ğŸ“œ æˆ˜æ–—æ—¥å¿— ({state.combatLogs.length})
                        </Button>
                        <Button
                            onClick={() => setShowCreate(!showCreate)}
                            disabled={!hasAvailableSlots}
                        >
                            {showCreate ? 'âœ— å–æ¶ˆ' : '+ åˆ›å»ºè§’è‰²'}
                        </Button>
                        <Button
                            onClick={() => dispatch({ type: 'EXPAND_CHARACTER_SLOTS' })}
                            variant="secondary"
                            disabled={state.characterSlots >= state.maxCharacterSlots || state.resources.gold < expandCost}
                        >
                            æ‰©å±•æ§½ä½ ({state.characterSlots}/{state.maxCharacterSlots}) - ğŸª™{expandCost}
                        </Button>
                    </div>
                }
            >
                <div style={{ fontSize: 13, color: '#aaa', marginBottom: 16 }}>
                    è§’è‰²æ§½ä½: {state.characters.length} / {state.characterSlots}
                </div>

                {showCreate && (
                    <div style={{
                        padding: 16,
                        background: 'rgba(0,0,0,0.3)',
                        borderRadius: 6,
                        marginBottom: 16,
                        border: '1px solid #4a3c2a'
                    }}>
                        <div style={{ marginBottom: 12 }}>
                            <label style={{ display: 'block', fontSize: 12, color: '#c9a227', marginBottom: 4 }}>
                                è§’è‰²å
                            </label>
                            <input
                                type="text"
                                value={newChar.name}
                                onChange={(e) => setNewChar({ ...newChar, name: e.target.value })}
                                placeholder="è¾“å…¥è§’è‰²å..."
                                style={{
                                    width: '100%',
                                    padding: '8px 12px',
                                    background: 'rgba(0,0,0,0.4)',
                                    border: '1px solid #4a3c2a',
                                    borderRadius: 4,
                                    color: '#fff',
                                    fontSize: 13
                                }}
                            />
                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 12, marginBottom: 12 }}>
                            <div>
                                <label style={{ display: 'block', fontSize: 12, color: '#c9a227', marginBottom: 4 }}>
                                    ç§æ—
                                </label>
                                <select
                                    value={newChar.race}
                                    onChange={(e) => setNewChar({ ...newChar, race: e.target.value })}
                                    style={{
                                        width: '100%',
                                        padding: '8px 12px',
                                        background: 'rgba(0,0,0,0.4)',
                                        border: '1px solid #4a3c2a',
                                        borderRadius: 4,
                                        color: '#fff',
                                        fontSize: 13,
                                        cursor: 'pointer'
                                    }}
                                >
                                    {RACES.map(race => (
                                        <option key={race} value={race}>{race}</option>
                                    ))}
                                </select>
                            </div>

                            <div>
                                <label style={{ display: 'block', fontSize: 12, color: '#c9a227', marginBottom: 4 }}>
                                    èŒä¸š
                                </label>
                                <select
                                    value={newChar.classId}
                                    onChange={(e) => setNewChar({ ...newChar, classId: e.target.value })}
                                    style={{
                                        width: '100%',
                                        padding: '8px 12px',
                                        background: 'rgba(0,0,0,0.4)',
                                        border: '1px solid #4a3c2a',
                                        borderRadius: 4,
                                        color: '#fff',
                                        fontSize: 13,
                                        cursor: 'pointer'
                                    }}
                                >
                                    {Object.values(CLASSES).map(cls => (
                                        <option key={cls.id} value={cls.id}>{cls.name}</option>
                                    ))}
                                </select>
                            </div>
                        </div>

                        <Button onClick={createCharacter} disabled={!newChar.name.trim()}>
                            âœ“ åˆ›å»º
                        </Button>
                    </div>
                )}

                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))', gap: 12 }}>
                    {state.characters.map(char => {
                        const assignment = state.assignments[char.id];
                        const zone = assignment ? state.zones[assignment] : null;
                        const equippedCount = Object.keys(char.equipment || {}).length;

                        // è„±æˆ˜æ—¶é—´ï¼ˆå¯è¢«åŠŸèƒ½å»ºç­‘ï¼šè¾‰å…‰ç¯å¡” ç¼©çŸ­ï¼‰
                        const glowLighthouseCount = state.functionalBuildings?.glow_lighthouse || 0;
                        const regenDelayMs = Math.max(0, 5000 - glowLighthouseCount * 1000);
                        const timeSinceCombat = Date.now() - (char.lastCombatTime || 0);
                        const regenSecondsLeft = Math.max(0, Math.ceil((regenDelayMs - timeSinceCombat) / 1000));

                        return (
                            <div
                                key={char.id}
                                onClick={() => setSelectedCharId(char.id)}
                                style={{
                                    cursor: 'pointer',
                                    padding: 12,
                                    borderRadius: 10,
                                    border: '1px solid #333',
                                    background: 'rgba(0,0,0,0.35)',
                                    transition: 'transform 0.06s ease',
                                }}
                                onMouseDown={(e) => {
                                    // å°å°æŒ‰å‹åé¦ˆï¼ˆå¯åˆ ï¼‰
                                    e.currentTarget.style.transform = 'scale(0.995)';
                                }}
                                onMouseMove={(e) => {
                                    e.currentTarget.style.transform = 'scale(1)';
                                }}
                                onMouseUp={(e) => {
                                    e.currentTarget.style.transform = 'scale(1)';
                                }}
                            >
                                {/* ===== é¡¶éƒ¨ä¿¡æ¯ ===== */}
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                    <div>
                                        {/* âœ… åå­—ä¸éœ€è¦å†å•ç‹¬ç»‘å®š onClickï¼Œå› ä¸ºæ•´ä¸ªå¡ç‰‡éƒ½èƒ½ç‚¹ */}
                                        <div style={{ fontSize: 14, fontWeight: 700, color: '#ffd700' }}>
                                            {char.name}
                                        </div>
                                        <div style={{ fontSize: 11, color: '#aaa', marginTop: 4 }}>
                                            Lv.{char.level} Â· {char.race} Â· {CLASSES[char.classId]?.name}
                                        </div>
                                    </div>

                                    <div style={{ textAlign: 'right' }}>
                                        {zone && (
                                            <div style={{
                                                padding: '4px 8px',
                                                background: 'rgba(201,162,39,0.2)',
                                                borderRadius: 4,
                                                fontSize: 10,
                                                color: '#c9a227',
                                                marginBottom: 4
                                            }}>
                                                ğŸ“ {zone.name}
                                            </div>
                                        )}
                                        <div style={{ fontSize: 10, color: '#888' }}>
                                            è£…å¤‡: {equippedCount}/{Object.keys(EQUIPMENT_SLOTS).length}
                                        </div>
                                    </div>
                                </div>

                                <StatBar
                                    label="ç”Ÿå‘½"
                                    current={char.stats.currentHp}
                                    max={char.stats.maxHp}
                                    color="#f44336"
                                />
                                <StatBar
                                    label="ç»éªŒ"
                                    current={char.exp}
                                    max={char.expToNext}
                                    color="#4CAF50"
                                />

                                <div style={{ fontSize: 11, color: '#888', marginTop: 6 }}>
                                    {char.combatState
                                        ? 'âš”ï¸ æˆ˜æ–—ä¸­'
                                        : (timeSinceCombat < regenDelayMs
                                                ? `ğŸ•’ è„±æˆ˜å›è¡€ ${regenSecondsLeft} ç§’åå¼€å§‹`
                                                : `ğŸ’š è„±æˆ˜å›è¡€ä¸­ï¼šæ¯ç§’ +${10 + (state.functionalBuildings?.plaza_fountain || 0) * 2}`
                                        )
                                    }
                                </div>

                                <div style={{
                                    display: 'grid',
                                    gridTemplateColumns: '1fr 1fr',
                                    gap: 8,
                                    fontSize: 11,
                                    color: '#aaa',
                                    marginTop: 12,
                                    marginBottom: 12
                                }}>
                                    <div>ç”Ÿå‘½: {Math.floor(char.stats.currentHp)} / {Math.floor(char.stats.maxHp)}</div>
                                    <div>æ³•åŠ›: {Math.floor(char.stats.currentMp)} / {Math.floor(char.stats.maxMp)}</div>
                                    <div>æ”»å‡»: {formatStatForDisplay('attack', char.stats.attack)}</div>
                                    <div>æŠ¤ç”²: {Math.floor(char.stats.armor)}</div>
                                </div>

                                {/* âœ… è§’è‰²å¡ç‰‡ï¼šæŸ¥çœ‹æŠ€èƒ½ï¼ˆæ’é™¤â€œä¼‘æ¯/æ™®é€šæ”»å‡»â€ï¼‰ + ç¼–è¾‘æŠ€èƒ½ */}
                                <div style={{ display: 'flex', gap: 8 }}>
                                    <Button
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            setShowSkillViewer(char);
                                        }}
                                        variant="secondary"
                                        style={{ flex: 1, fontSize: 11, padding: '6px 8px' }}
                                    >
                                        æŸ¥çœ‹æŠ€èƒ½
                                    </Button>
                                    <Button
                                        onClick={(e) => {
                                            e.stopPropagation();     // âœ… é˜²æ­¢è§¦å‘å¡ç‰‡ç‚¹å‡»æ‰“å¼€è¯¦æƒ…
                                            setShowSkillEditor(char);
                                        }}
                                        variant="secondary"
                                        style={{ flex: 1, fontSize: 11, padding: '6px 8px' }}
                                    >
                                        ç¼–è¾‘æŠ€èƒ½
                                    </Button>
                                    <Button
                                        variant="danger"
                                        onClick={() => {
                                            if (window.confirm("ç¡®å®šè¦åˆ é™¤è¯¥è§’è‰²å—ï¼Ÿ")) {
                                                dispatch({ type: "DELETE_CHARACTER", payload: { characterId: char.id } });
                                            }
                                        }}
                                    >
                                        ğŸ—‘ åˆ é™¤
                                    </Button>
                                </div>
                            </div>
                        );

                    })}
                </div>
            </Panel>
        </div>
    );
};

// ==================== PAGE: INVENTORY ====================
const InventoryPage = ({ state, dispatch }) => {
    const [selectedItem, setSelectedItem] = useState(null);
    const [draggedItemId, setDraggedItemId] = useState(null);
    const [draggedIndex, setDraggedIndex] = useState(null);

    const mechanicalArmCount = state.functionalBuildings?.mechanical_arm ?? 0;
    const autoMergeSlots = Math.min(10, mechanicalArmCount);

    const handleDropToEmpty = (e, targetIndex) => {
        e.preventDefault();

        if (draggedIndex !== null && draggedIndex !== targetIndex) {
            dispatch({
                type: 'MOVE_INVENTORY_ITEM',
                payload: { fromIndex: draggedIndex, toIndex: targetIndex }
            });
        }

        setDraggedItemId(null);
        setDraggedIndex(null);
    };

    return (
        <div>
            {/* âœ… è£…å¤‡è¯¦æƒ…æ¨¡æ€æ¡† - ç¡®ä¿è¿™éƒ¨åˆ†å­˜åœ¨ */}
            {selectedItem && selectedItem.type === 'equipment' && (
                <ItemDetailsModal
                    item={selectedItem}
                    onClose={() => setSelectedItem(null)}
                    onEquip={(charId, itemInstanceId) => {
                        dispatch({ type: 'EQUIP_ITEM', payload: { characterId: charId, itemInstanceId } });
                    }}
                    characters={state.characters}
                    state={state}
                    dispatch={dispatch}
                />
            )}

            <Panel
                title={`é“å…·æ  (${state.inventory.length}/${state.inventorySize})`}
                actions={
                    <div style={{ display: 'flex', gap: 8 }}>
                        <Button
                            variant="secondary"
                            onClick={() => dispatch({ type: 'SORT_INVENTORY' })}
                        >
                            ğŸ“¦ æ•´ç†èƒŒåŒ…
                        </Button>
                        <Button
                            variant="secondary"
                            onClick={() => {
                                const junkItems = state.inventory.filter(i => i?.type === 'junk' && (i.sellPrice || 0) > 0);
                                const totalGold = junkItems.reduce((sum, it) => sum + (it.sellPrice || 0), 0);

                                if (junkItems.length === 0) {
                                    alert('æ²¡æœ‰å¯å‡ºå”®çš„åƒåœ¾ã€‚');
                                    return;
                                }

                                if (window.confirm(`ä¸€é”®å‡ºå”® ${junkItems.length} ä»¶åƒåœ¾ï¼Œè·å¾— ğŸª™${totalGold} é‡‘å¸ï¼Ÿ`)) {
                                    dispatch({ type: 'SELL_ALL_JUNK' });
                                }
                            }}
                        >
                            ğŸ”˜ ä¸€é”®å–åƒåœ¾
                        </Button>
                    </div>
                }
            >
                <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fill, minmax(120px, 1fr))',
                    gap: 8
                }}>
                    {state.inventory.map((item, index) => (
                        <div
                            key={item.instanceId || item.id}
                            draggable={item.type === 'equipment'}
                            onDragStart={(e) => {
                                if (item.type !== 'equipment') return;
                                if (!item.instanceId) return;
                                setDraggedItemId(item.instanceId);
                                setDraggedIndex(index);
                                e.dataTransfer.effectAllowed = 'move';
                            }}
                            onDragOver={(e) => {
                                e.preventDefault();
                                e.dataTransfer.dropEffect = 'move';
                            }}
                            onDrop={(e) => {
                                e.preventDefault();

                                const fromInstanceId = draggedItemId;
                                const toInstanceId = item.instanceId;

                                if (!fromInstanceId || fromInstanceId === toInstanceId) {
                                    setDraggedItemId(null);
                                    setDraggedIndex(null);
                                    return;
                                }

                                const fromItem = state.inventory.find(i => i.instanceId === fromInstanceId);
                                const toItem = item;

                                if (!toItem || toItem.type !== 'equipment') {
                                    if (draggedIndex !== null) {
                                        dispatch({
                                            type: 'MOVE_INVENTORY_ITEM',
                                            payload: { fromIndex: draggedIndex, toIndex: index }
                                        });
                                    }
                                    setDraggedItemId(null);
                                    setDraggedIndex(null);
                                    return;
                                }

                                const isThunderfuryRecipe = (aId, bId) =>
                                    (aId === 'EQ_176' && bId === 'EQ_181') || (aId === 'EQ_181' && bId === 'EQ_176');

                                if (fromItem && fromItem.type === 'equipment' && (fromItem.id === toItem.id || isThunderfuryRecipe(fromItem.id, toItem.id))) {
                                    dispatch({
                                        type: 'MERGE_EQUIPMENT',
                                        payload: { instanceIdA: fromInstanceId, instanceIdB: toInstanceId }
                                    });
                                } else if (draggedIndex !== null) {
                                    dispatch({
                                        type: 'MOVE_INVENTORY_ITEM',
                                        payload: { fromIndex: draggedIndex, toIndex: index }
                                    });
                                }

                                setDraggedItemId(null);
                                setDraggedIndex(null);
                            }}
                            onDragEnd={() => {
                                setDraggedItemId(null);
                                setDraggedIndex(null);
                            }}
                            onClick={(e) => {
                                // âœ… æ¶ˆè€—å“ä½¿ç”¨
                                if (item.type === 'consumable' && item.canUse) {
                                    dispatch({ type: 'USE_ITEM', payload: { itemInstanceId: item.instanceId || item.id } });
                                    return;
                                }

                                // âœ… éè£…å¤‡ä¸å¤„ç†
                                if (item.type !== 'equipment') return;

                                // âœ… Shift+ç‚¹å‡»ï¼šé“¾å¼åˆæˆ
                                if (e.shiftKey && item.instanceId) {
                                    e.preventDefault();
                                    dispatch({ type: 'MERGE_EQUIPMENT_CHAIN', payload: { targetInstanceId: item.instanceId } });
                                    return;
                                }

                                // âœ… æ™®é€šç‚¹å‡»ï¼šæ‰“å¼€è¯¦æƒ…æ¨¡æ€æ¡†
                                setSelectedItem(item);
                            }}
                            onContextMenu={(e) => {
                                e.preventDefault();

                                if (item.sellPrice) {
                                    if (window.confirm(`å‡ºå”® ${item.name}ï¼Œè·å¾— ğŸª™${item.sellPrice} é‡‘å¸ï¼Ÿ`)) {
                                        dispatch({ type: 'SELL_ITEM', payload: { itemInstanceId: item.instanceId || item.id } });
                                    }
                                } else {
                                    if (window.confirm(`ç¡®å®šè¦ä¸¢å¼ƒ ${item.name} å—ï¼Ÿ`)) {
                                        dispatch({ type: 'USE_ITEM', payload: { itemInstanceId: item.instanceId || item.id } });
                                    }
                                }
                            }}
                            style={{
                                position: 'relative',
                                padding: 12,
                                background: item.type === 'equipment'
                                    ? `linear-gradient(135deg, ${(item.qualityColor || getRarityColor(item.rarity))}22, rgba(0,0,0,0.3))`
                                    : 'rgba(0,0,0,0.3)',
                                border: `2px solid ${item.type === 'equipment' ? (item.qualityColor || getRarityColor(item.rarity)) : '#4a3c2a'}`,
                                outline: (draggedItemId && item.type === 'equipment' && draggedItemId === item.instanceId)
                                    ? '2px solid #ffd700'
                                    : 'none',
                                borderRadius: 6,
                                textAlign: 'center',
                                cursor: item.type === 'equipment' ? 'grab' : 'default',
                                transition: 'all 0.2s'
                            }}
                            onMouseEnter={(e) => {
                                if (item.type === 'equipment') {
                                    e.currentTarget.style.transform = 'translateY(-4px)';
                                    e.currentTarget.style.boxShadow = `0 4px 12px ${item.qualityColor}66`;
                                }
                            }}
                            onMouseLeave={(e) => {
                                if (item.type === 'equipment') {
                                    e.currentTarget.style.transform = 'translateY(0)';
                                    e.currentTarget.style.boxShadow = 'none';
                                }
                            }}
                        >
                            <div style={{ fontSize: 28, marginBottom: 8 }}>
                                <ItemIcon item={item} size={32} />
                            </div>
                            <div style={{
                                fontSize: 11,
                                color: item.type === 'equipment' ? item.qualityColor : '#ffd700',
                                fontWeight: item.type === 'equipment' ? 600 : 'normal'
                            }}>
                                {item.name}
                            </div>
                            {item.type === 'equipment' && (
                                <div style={{ fontSize: 9, color: '#888', marginTop: 4 }}>
                                    Lv.{item.currentLevel ?? item.level ?? 0}
                                </div>
                            )}
                            {(() => {
                                    const effects = getEquipmentSpecialEffectList(item);
                                    if (!effects || effects.length === 0) return null;

                                    const se = effects[0];
                                    const more = effects.length - 1;

                                    return (
                                        <div style={{
                                            marginTop: '4px',
                                            fontSize: '11px',
                                            color: '#f1c40f',
                                            fontWeight: '500',
                                            background: 'rgba(255, 152, 0, 0.15)',
                                            padding: '2px 6px',
                                            borderRadius: '4px',
                                            display: 'inline-block'
                                        }}>
                                            âš¡ {se.type === 'map_slayer'
                                                ? `åœ°å›¾ä¼¤å®³+${(se.bonusDamageVsMap * 100).toFixed(0)}%`
                                                : se.type === 'skill_slot_buff'
                                                    ? (() => {
                                                              const slots = Array.isArray(se.slots)
                                                                ? se.slots
                                                                : (Number.isFinite(Number(se.slot)) ? [Number(se.slot)] : []);
                                                              const slotText = slots.length ? slots.map(s => s + 1).join('ã€') : 'ï¼Ÿ';

                                                              const atk = Number(se.attackBonus) || 0;
                                                              const sp  = Number(se.spellPowerBonus) || 0;

                                                              const bonusText = [
                                                                atk ? `æ”»+${Math.floor(atk)}` : null,
                                                                sp  ? `æ³•å¼º+${Math.floor(sp)}` : null,
                                                              ].filter(Boolean).join(' ');

                                                              return `æŠ€èƒ½æ ${slotText} å¼ºåŒ–${bonusText ? `ï¼ˆ${bonusText}ï¼‰` : ''}`;
                                                            })()
                                                    : se.type === 'basic_attack_repeat'
                                                        ? `è¿å‡»${(se.chance * 100).toFixed(0)}%`
                                                        : se.type === 'proc_stat'
                                                            ? `${se.name || 'å±æ€§å¢ç›Š'} ${(se.chance * 100).toFixed(0)}%`
                                                            : se.type === 'proc_damage'
                                                                ? `${se.name || 'è§¦å‘ä¼¤å®³'} ${(se.chance * 100).toFixed(0)}%`
                                                                : se.type === 'ignore_defense'
                                                                    ? `æ— è§†é˜²å¾¡${((Number(se.pct ?? se.ignorePct ?? se.value) || 0) * 100).toFixed(0)}%`
                                                                    : se.type === 'thunderfury'
                                                                        ? `é—ªç”µé“¾${(se.chance * 100).toFixed(0)}%`
                                                                        : se.type
                                            }{more > 0 ? ` +${more}` : ''}
                                        </div>
                                    );
                                })()}
                            {index < autoMergeSlots && item?.type === 'equipment' && (
                                <div style={{
                                    position: 'absolute',
                                    top: 4,
                                    right: 4,
                                    background: 'rgba(76,175,80,0.85)',
                                    color: '#fff',
                                    fontSize: 10,
                                    padding: '3px 7px',
                                    borderRadius: 4,
                                    pointerEvents: 'none',
                                    zIndex: 10,
                                    border: '1px solid rgba(255,255,255,0.3)',
                                    boxShadow: '0 0 8px rgba(76,175,80,0.6)',
                                    fontWeight: 600
                                }}>
                                    ğŸ¦¾
                                </div>
                            )}
                        </div>
                    ))}

                    {/* ç©ºæ ä½ - æ”¯æŒæ‹–æ”¾ */}
                    {Array.from({ length: Math.max(0, state.inventorySize - state.inventory.length) }).map((_, i) => {
                        const targetIndex = state.inventory.length + i;
                        return (
                            <div
                                key={`empty_${i}`}
                                onDragOver={(e) => {
                                    e.preventDefault();
                                    e.dataTransfer.dropEffect = 'move';
                                }}
                                onDrop={(e) => handleDropToEmpty(e, targetIndex)}
                                style={{
                                    padding: 12,
                                    background: draggedItemId ? 'rgba(201,162,39,0.1)' : 'rgba(0,0,0,0.2)',
                                    border: draggedItemId ? '2px dashed #c9a227' : '1px dashed #333',
                                    borderRadius: 6,
                                    textAlign: 'center',
                                    opacity: draggedItemId ? 0.8 : 0.3,
                                    transition: 'all 0.2s',
                                    minHeight: 80,
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }}
                            >
                                <div style={{ fontSize: 28, color: draggedItemId ? '#c9a227' : '#333' }}>
                                    {draggedItemId ? 'ğŸ“¥' : 'âˆ…'}
                                </div>
                            </div>
                        );
                    })}
                </div>
            </Panel>
        </div>
    );
};

// ==================== PAGE: CITY (é‡æ–°è®¾è®¡) ====================
const CityPage = ({ state, dispatch }) => {
    const [draggedChar, setDraggedChar] = useState(null);
    const [activeTab, setActiveTab] = useState('resources'); // 'resources' | 'functional'

    // è·å–æœªè¢«æ´¾é£çš„è§’è‰²ï¼ˆä¸åœ¨åœ°å›¾ä¹Ÿä¸åœ¨èµ„æºå»ºç­‘ï¼‰
    const getAvailableChars = () => {
        const mapAssigned = new Set(Object.keys(state.assignments || {}));
        const resourceAssigned = new Set(
            Object.values(state.resourceAssignments || {}).flat()
        );

        return state.characters.filter(c =>
            !mapAssigned.has(c.id) && !resourceAssigned.has(c.id)
        );
    };

    const availableChars = getAvailableChars();

    // è·å–æŸå»ºç­‘çš„å·¥äººï¼ˆè¿‡æ»¤æ‰ä¸å­˜åœ¨çš„è§’è‰²ï¼‰
    const getWorkers = (buildingId) => {
        return (state.resourceAssignments?.[buildingId] || [])
            .map(id => state.characters.find(c => c.id === id))
            .filter(Boolean);  // âœ… è¿™è¡Œå·²ç»èƒ½è¿‡æ»¤æ‰æ‰¾ä¸åˆ°çš„è§’è‰²
    };

    const handleDragStart = (e, charId) => {
        setDraggedChar(charId);

        // âœ… Edge/éƒ¨åˆ†æµè§ˆå™¨éœ€è¦ setData æ‰ä¼šè®¤ä¸ºè¿™æ˜¯â€œæœ‰æ•ˆæ‹–æ‹½â€
        e.dataTransfer.setData('text/plain', charId);

        e.dataTransfer.effectAllowed = 'move';
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    };

    const handleDrop = (e, buildingId) => {
        e.preventDefault();

        // âœ… ç›´æ¥ä» dataTransfer è·å–æ•°æ®
        const charId = e.dataTransfer.getData('text/plain');

        console.log('handleDrop è§¦å‘:', { charId, buildingId }); // è°ƒè¯•æ—¥å¿—

        if (charId) {
            dispatch({
                type: 'ASSIGN_RESOURCE_BUILDING',
                payload: { characterId: charId, buildingId }
            });
        } else {
            console.warn('handleDrop: æ²¡æœ‰è·å–åˆ° charId');
        }
        setDraggedChar(null);
    };

    // âœ… èµ„æºæ˜¾ç¤ºé…ç½®ï¼ˆè¿‡æ»¤æ‰ population å’Œ maxPopulationï¼‰
    const resourceConfig = {
        gold: { icon: 'ğŸŸ¡', name: 'é‡‘å¸' },
        spacetimeCoin: { icon: 'ğŸŒ€', name: 'æ—¶ç©ºå¸' },
        wood: { icon: 'ğŸªµ', name: 'æœ¨æ' },
        ironOre: { icon: 'ğŸª™', name: 'é“çŸ¿' },
        ironIngot: { icon: 'ğŸ”©', name: 'é“é”­' },
        herb: { icon: 'ğŸŒ¿', name: 'è‰è¯' },
        leather: { icon: 'ğŸ¦Œ', name: 'æ¯›çš®' },
        magicEssence: { icon: 'ğŸ’', name: 'é­”æ³•ç²¾å' },
        alchemyOil: { icon: 'âš—ï¸', name: 'ç‚¼é‡‘æ²¹' }
    };

    // âœ… åªæ˜¾ç¤ºé…ç½®ä¸­å®šä¹‰çš„èµ„æº
    const displayedResources = Object.entries(state.resources)
        .filter(([key]) => resourceConfig[key]);

    return (
        <div>
            {/* èµ„æºæ€»è§ˆ */}
            <Panel title="ğŸ“¦ èµ„æºæ€»è§ˆ">
                <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fill, minmax(120px, 1fr))',
                    gap: 10
                }}>
                    {displayedResources.map(([key, value]) => {
                        const config = resourceConfig[key];
                        return (
                            <div key={key} style={{
                                padding: 12,
                                background: 'rgba(0,0,0,0.3)',
                                border: '1px solid #4a3c2a',
                                borderRadius: 8,
                                textAlign: 'center'
                            }}>
                                <div style={{ fontSize: 24, marginBottom: 4 }}>{config.icon}</div>
                                <div style={{ fontSize: 11, color: '#888', marginBottom: 2 }}>{config.name}</div>
                                <div style={{ fontSize: 16, color: '#ffd700', fontWeight: 600 }}>
                                    {Math.floor(value)}
                                </div>
                            </div>
                        );
                    })}
                </div>
            </Panel>

            {/* å¯æ´¾é£è§’è‰² */}
            {availableChars.length > 0 && (
                <Panel title="ğŸ‘¥ å¯æ´¾é£è§’è‰²" style={{ marginBottom: 16 }}>
                    <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }}>
                        {availableChars.map(char => {
                            const gatherStats = calculateGatherStats(char);
                            return (
                                <div
                                    key={char.id}
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, char.id)}
                                    style={{
                                        padding: 12,
                                        background: 'linear-gradient(135deg, rgba(201,162,39,0.2), rgba(139,115,25,0.1))',
                                        border: '2px solid #c9a227',
                                        borderRadius: 8,
                                        cursor: 'grab',
                                        transition: 'all 0.2s',
                                        minWidth: 140
                                    }}
                                >
                                    <div style={{ fontSize: 14, color: '#ffd700', fontWeight: 600, marginBottom: 4 }}>
                                        {char.name}
                                    </div>
                                    <div style={{ fontSize: 11, color: '#888', marginBottom: 8 }}>
                                        Lv.{char.level} {CLASSES[char.classId].name}
                                    </div>
                                    <div style={{ fontSize: 10, color: '#aaa', display: 'flex', gap: 8 }}>
                                        <span title="ç†Ÿç»ƒ">ğŸ”§{gatherStats.proficiency}</span>
                                        <span title="ç²¾ç»†">ğŸ¯{gatherStats.precision}</span>
                                        <span title="æ„ŸçŸ¥">ğŸ‘ï¸{gatherStats.perception}</span>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                    <div style={{ marginTop: 12, fontSize: 12, color: '#888', fontStyle: 'italic' }}>
                        ğŸ’¡ æ‹–æ‹½è§’è‰²åˆ°ä¸‹æ–¹å»ºç­‘è¿›è¡Œæ´¾é£é‡‡é›†
                    </div>
                </Panel>
            )}

            {/* Tab åˆ‡æ¢ */}
            <div style={{
                display: 'flex',
                gap: 4,
                marginBottom: 16,
                padding: 4,
                background: 'rgba(0,0,0,0.3)',
                borderRadius: 8,
                border: '1px solid #3a3a3a'
            }}>
                <button
                    onClick={() => setActiveTab('resources')}
                    style={{
                        flex: 1,
                        padding: '10px 16px',
                        background: activeTab === 'resources'
                            ? 'linear-gradient(180deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))'
                            : 'transparent',
                        border: activeTab === 'resources' ? '1px solid #c9a227' : '1px solid transparent',
                        borderRadius: 6,
                        color: activeTab === 'resources' ? '#ffd700' : '#888',
                        cursor: 'pointer',
                        fontFamily: 'inherit',
                        fontSize: 14,
                        fontWeight: 600
                    }}
                >
                    â›ï¸ èµ„æºå»ºç­‘
                </button>
                <button
                    onClick={() => setActiveTab('functional')}
                    style={{
                        flex: 1,
                        padding: '10px 16px',
                        background: activeTab === 'functional'
                            ? 'linear-gradient(180deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))'
                            : 'transparent',
                        border: activeTab === 'functional' ? '1px solid #c9a227' : '1px solid transparent',
                        borderRadius: 6,
                        color: activeTab === 'functional' ? '#ffd700' : '#888',
                        cursor: 'pointer',
                        fontFamily: 'inherit',
                        fontSize: 14,
                        fontWeight: 600
                    }}
                >
                    ğŸ›ï¸ åŠŸèƒ½å»ºç­‘
                </button>
            </div>

            {/* èµ„æºå»ºç­‘åŒºåŸŸ */}
            {activeTab === 'resources' && (
                <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fill, minmax(320px, 1fr))',
                    gap: 16
                }}>
                    {Object.values(RESOURCE_BUILDINGS).map(building => {
                        const workers = getWorkers(building.id);
                        const currentProduction = workers.length > 0
                            ? calculateBuildingProduction(building.id, workers.map(w => w.id), state)
                            : 0;

                        return (
                            <div
                                key={building.id}
                                onDragOver={handleDragOver}
                                onDrop={(e) => handleDrop(e, building.id)}
                                style={{
                                    background: 'linear-gradient(135deg, rgba(40,35,30,0.9), rgba(25,20,15,0.95))',
                                    border: workers.length > 0 ? '2px solid #c9a227' : '2px solid #4a3c2a',
                                    borderRadius: 12,
                                    overflow: 'hidden',
                                    transition: 'all 0.2s'
                                }}
                            >
                                {/* å»ºç­‘å¤´éƒ¨ */}
                                <div style={{
                                    padding: 16,
                                    background: workers.length > 0
                                        ? 'linear-gradient(180deg, rgba(201,162,39,0.15), transparent)'
                                        : 'linear-gradient(180deg, rgba(60,50,40,0.3), transparent)',
                                    borderBottom: '1px solid rgba(201,162,39,0.2)'
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                                        <div style={{
                                            width: 50,
                                            height: 50,
                                            background: 'rgba(0,0,0,0.4)',
                                            borderRadius: 8,
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            fontSize: 28,
                                            border: '1px solid rgba(201,162,39,0.3)'
                                        }}>
                                            {building.icon}
                                        </div>
                                        <div style={{ flex: 1 }}>
                                            <div style={{ fontSize: 16, color: '#ffd700', fontWeight: 600 }}>
                                                {building.name}
                                            </div>
                                            <div style={{ fontSize: 11, color: '#888', marginTop: 2 }}>
                                                {building.description}
                                            </div>
                                        </div>
                                        <div style={{ textAlign: 'right' }}>
                                            <div style={{ fontSize: 11, color: '#888' }}>å·¥äºº</div>
                                            <div style={{
                                                fontSize: 14,
                                                color: workers.length >= building.maxWorkers ? '#f44336' : '#4CAF50',
                                                fontWeight: 600
                                            }}>
                                                {workers.length}/{building.maxWorkers}
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* äº§å‡ºä¿¡æ¯ */}
                                <div style={{
                                    padding: '12px 16px',
                                    background: 'rgba(0,0,0,0.2)',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center'
                                }}>
                                    <div>
                                        <span style={{ fontSize: 11, color: '#888' }}>å½“å‰äº§å‡ºï¼š</span>
                                        <span style={{
                                            fontSize: 14,
                                            color: currentProduction > 0 ? '#4CAF50' : '#666',
                                            fontWeight: 600,
                                            marginLeft: 4
                                        }}>
                                            +{currentProduction.toFixed(1)}/ç§’
                                        </span>
                                    </div>
                                    {building.consumption && (
                                        <div style={{ fontSize: 11, color: '#f44336' }}>
                                            æ¶ˆè€—: {Object.entries(building.consumption).map(([r, a]) =>
                                            `${r}Ã—${a}`
                                        ).join(', ')}/äºº
                                        </div>
                                    )}
                                </div>

                                {/* å·¥äººåŒºåŸŸ */}
                                <div style={{
                                    padding: 16,
                                    minHeight: 80,
                                    background: 'rgba(201,162,39,0.03)',
                                    borderTop: '1px dashed rgba(201,162,39,0.2)'
                                }}>
                                    {workers.length > 0 ? (
                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8 }}>
                                            {workers.map(char => {
                                                const gatherStats = calculateGatherStats(char);
                                                return (
                                                    <div key={char.id} style={{
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: 8,
                                                        padding: '8px 12px',
                                                        background: 'rgba(201,162,39,0.1)',
                                                        border: '1px solid rgba(201,162,39,0.3)',
                                                        borderRadius: 6
                                                    }}>
                                                        <div>
                                                            <div style={{ fontSize: 12, color: '#ffd700' }}>
                                                                {char.name}
                                                            </div>
                                                            <div style={{ fontSize: 10, color: '#888' }}>
                                                                ğŸ”§{gatherStats.proficiency} ğŸ¯{gatherStats.precision} ğŸ‘ï¸{gatherStats.perception}
                                                            </div>
                                                        </div>
                                                        <button
                                                            onClick={() => dispatch({
                                                                type: 'UNASSIGN_RESOURCE_BUILDING',
                                                                payload: { characterId: char.id, buildingId: building.id }
                                                            })}
                                                            style={{
                                                                background: 'rgba(244,67,54,0.2)',
                                                                border: '1px solid rgba(244,67,54,0.5)',
                                                                borderRadius: 4,
                                                                color: '#f44336',
                                                                padding: '4px 8px',
                                                                fontSize: 10,
                                                                cursor: 'pointer'
                                                            }}
                                                        >
                                                            å¬å›
                                                        </button>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ) : (
                                        <div style={{
                                            height: '100%',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            color: '#555',
                                            fontSize: 12,
                                            fontStyle: 'italic'
                                        }}>
                                            æ‹–æ‹½è§’è‰²åˆ°æ­¤å¤„å¼€å§‹é‡‡é›†
                                        </div>
                                    )}
                                </div>
                            </div>
                        );
                    })}
                </div>
            )}

            {/* åŠŸèƒ½å»ºç­‘åŒºåŸŸ */}
            {activeTab === 'functional' && (
                <div>
                    {/* âœ… å–·æ³‰æ•ˆç‡æ±‡æ€»ï¼ˆå–·æ³‰è‰åª/å–·æ³‰å¤–é¥°ç‹¬ç«‹ä¹˜åŒºï¼‰ */}
                    {(() => {
                        const fountainCount = state.functionalBuildings?.plaza_fountain || 0;
                        const { lawnCount, decorCount, lawnMult, decorMult, totalMult } = getFountainEfficiency(state);
                        const fountainRegen = fountainCount * 2 * totalMult;

                        // æ²¡å»ºå–·æ³‰ä¹Ÿå…è®¸çœ‹é¢„è§ˆï¼ˆé¿å…ç”¨æˆ·ä¸çŸ¥é“æ€ä¹ˆæ¶¨ï¼‰
                        return (
                            <div style={{
                                marginBottom: 16,
                                padding: 14,
                                background: 'rgba(201,162,39,0.08)',
                                border: '1px solid rgba(201,162,39,0.35)',
                                borderRadius: 10
                            }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', gap: 12, flexWrap: 'wrap' }}>
                                    <div>
                                        <div style={{ color: '#ffd700', fontWeight: 700, fontSize: 13, marginBottom: 4 }}>
                                            â›² å–·æ³‰è„±æˆ˜å›è¡€æ•ˆç‡
                                        </div>
                                        <div style={{ color: '#aaa', fontSize: 11, lineHeight: 1.5 }}>
                                            å¹¿åœºå–·æ³‰æ•°é‡ï¼š<span style={{ color: '#fff' }}>{fountainCount}</span>ï¼ˆæ¯åº§åŸºç¡€ +2/ç§’ï¼‰
                                            <br />
                                            å–·æ³‰è‰åªï¼š{lawnCount}/20ï¼ˆÃ—{lawnMult.toFixed(2)}ï¼‰ï½œå–·æ³‰å¤–é¥°ï¼š{decorCount}/20ï¼ˆÃ—{decorMult.toFixed(2)}ï¼‰
                                            <br />
                                            æ€»å€ç‡ï¼š<span style={{ color: '#4CAF50', fontWeight: 700 }}>Ã—{totalMult.toFixed(2)}</span>
                                        </div>
                                    </div>
                                    <div style={{
                                        minWidth: 140,
                                        padding: '10px 12px',
                                        background: 'rgba(0,0,0,0.25)',
                                        borderRadius: 8,
                                        border: '1px solid rgba(255,255,255,0.08)'
                                    }}>
                                        <div style={{ color: '#888', fontSize: 11, marginBottom: 2 }}>å½“å‰å–·æ³‰é¢å¤–å›è¡€</div>
                                        <div style={{ color: fountainRegen > 0 ? '#4CAF50' : '#666', fontWeight: 800, fontSize: 16 }}>
                                            +{fountainRegen.toFixed(1)}/ç§’
                                        </div>
                                        <div style={{ color: '#666', fontSize: 10, marginTop: 2 }}>
                                            ï¼ˆä»…è„±æˆ˜ç”Ÿæ•ˆï¼‰
                                        </div>
                                    </div>
                                </div>
                            </div>
                        );
                    })()}

                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))',
                        gap: 16
                    }}>
                    {Object.values(FUNCTIONAL_BUILDINGS).map(building => {
                        const currentCount = state.functionalBuildings?.[building.id] || 0;
                        const isMaxed = currentCount >= building.maxCount;

                        // âœ… è§£é”æ¡ä»¶ï¼šå‡»è´¥æŒ‡å®š Boss
                        const unlocked = !building.unlockBoss || (state.defeatedBosses || []).includes(building.unlockBoss);

                        // âœ… è·å–åŠ¨æ€æˆæœ¬
                        const dynamicCost = getFunctionalBuildingCost(building.id, state);

                        // æ£€æŸ¥èµ„æºæ˜¯å¦è¶³å¤Ÿ
                        let canBuild = true;
                        Object.entries(dynamicCost).forEach(([res, amount]) => {
                            if ((state.resources[res] || 0) < amount) canBuild = false;
                        });

                        return (
                            <div key={building.id} style={{
                                padding: 20,
                                background: !unlocked
                                    ? 'rgba(0,0,0,0.45)'
                                    : currentCount > 0
                                    ? 'linear-gradient(135deg, rgba(76,175,80,0.1), rgba(40,35,30,0.9))'
                                    : 'rgba(0,0,0,0.3)',
                                border: !unlocked
                                    ? '2px solid rgba(180,180,180,0.25)'
                                    : (currentCount > 0 ? '2px solid #4CAF50' : '2px solid #4a3c2a'),
                                borderRadius: 12
                            }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: 12, marginBottom: 12 }}>
                                    <div style={{
                                        width: 48,
                                        height: 48,
                                        background: 'rgba(0,0,0,0.4)',
                                        borderRadius: 8,
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        fontSize: 26
                                    }}>
                                        {building.icon}
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <div style={{ fontSize: 16, color: '#ffd700', fontWeight: 600 }}>
                                            {building.name}
                                        </div>
                                        <div style={{
                                            fontSize: 12,
                                            color: currentCount > 0 ? '#4CAF50' : '#888'
                                        }}>
                                            å·²å»ºé€ : {currentCount}/{building.maxCount}
                                        </div>
                                    </div>
                                </div>

                                <div style={{
                                    fontSize: 12,
                                    color: '#aaa',
                                    marginBottom: 12,
                                    padding: 10,
                                    background: 'rgba(0,0,0,0.2)',
                                    borderRadius: 6
                                }}>
                                    {building.description}
                                    {!unlocked && (
                                        <div style={{
                                            marginTop: 8,
                                            paddingTop: 8,
                                            borderTop: '1px dashed rgba(255,255,255,0.15)',
                                            color: '#ff9800',
                                            fontSize: 11
                                        }}>
                                            ğŸ”’ è§£é”æ¡ä»¶ï¼šå‡»è´¥ {BOSS_NAMES[building.unlockBoss] || building.unlockBoss}
                                        </div>
                                    )}
                                </div>

                                {/* âœ… æ˜¾ç¤ºåŠ¨æ€æˆæœ¬ */}
                                <div style={{
                                    fontSize: 11,
                                    color: '#888',
                                    marginBottom: 12,
                                    padding: 10,
                                    background: 'rgba(0,0,0,0.15)',
                                    borderRadius: 6
                                }}>
                                    <div style={{ marginBottom: 4, color: '#aaa' }}>
                                        å»ºé€ æˆæœ¬ {currentCount > 0 && (
                                        <span style={{ color: '#ff9800', fontSize: 10 }}>
                                                (+{((Math.pow(1.2, currentCount) - 1) * 100).toFixed(0)}%)
                                            </span>
                                    )}ï¼š
                                    </div>
                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8 }}>
                                        {Object.entries(dynamicCost).map(([res, amount]) => {
                                            const names = {
                                                gold: 'ğŸŸ¡ é‡‘å¸',
                                                wood: 'ğŸªµ æœ¨æ',
                                                ironOre: 'ğŸª™ é“çŸ¿',
                                                ironIngot: 'ğŸ”© é“é”­',
                                                herb: 'ğŸŒ¿ è‰è¯',
                                                leather: 'ğŸ¦Œ æ¯›çš®',
                                                magicEssence: 'ğŸ’ é­”æ³•ç²¾å',
                                                alchemyOil: 'âš—ï¸ ç‚¼é‡‘æ²¹'
                                            };
                                            const hasEnough = (state.resources[res] || 0) >= amount;
                                            return (
                                                <span key={res} style={{
                                                    color: hasEnough ? '#4CAF50' : '#f44336',
                                                    padding: '2px 6px',
                                                    background: hasEnough ? 'rgba(76,175,80,0.1)' : 'rgba(244,67,54,0.1)',
                                                    borderRadius: 4,
                                                    border: `1px solid ${hasEnough ? 'rgba(76,175,80,0.3)' : 'rgba(244,67,54,0.3)'}`
                                                }}>
                                                    {names[res] || res}: {amount.toLocaleString()}
                                                </span>
                                            );
                                        })}
                                    </div>
                                </div>

                                <Button
                                    onClick={() => dispatch({
                                        type: 'BUILD_FUNCTIONAL',
                                        payload: { buildingId: building.id }
                                    })}
                                    disabled={!unlocked || !canBuild || isMaxed}
                                    style={{ width: '100%' }}
                                >
                                    {!unlocked ? 'æœªè§£é”' : (isMaxed ? 'å·²è¾¾ä¸Šé™' : 'å»ºé€ ')}
                                </Button>
                            </div>
                        );
                    })}
                    </div>
                </div>
            )}
        </div>
    );
};

// ==================== PAGE: RESEARCH ====================
const ResearchPage = ({ state, dispatch }) => {
    return (
        <Panel title="ç ”ç©¶">
            {state.currentResearch && (
                <div style={{
                    padding: 16,
                    background: 'rgba(201,162,39,0.1)',
                    border: '2px solid #c9a227',
                    borderRadius: 6,
                    marginBottom: 16
                }}>
                    <div style={{
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        marginBottom: 8
                    }}>
                        <span style={{ fontSize: 14, color: '#ffd700' }}>
                            æ­£åœ¨ç ”ç©¶: {RESEARCH[state.currentResearch].name}
                        </span>
                        <Button
                            onClick={() => dispatch({ type: 'CANCEL_RESEARCH' })}
                            variant="danger"
                            style={{ padding: '4px 12px', fontSize: 11 }}
                        >
                            å–æ¶ˆ
                        </Button>
                    </div>
                    <StatBar
                        label="è¿›åº¦"
                        current={state.researchProgress}
                        max={100}
                        color="#2196F3"
                    />
                </div>
            )}

            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: 12 }}>
                {Object.values(RESEARCH).map(research => {
                    const level = state.research[research.id] || 0;

                    // è§£é”æ¡ä»¶ï¼šå‡»è´¥æŒ‡å®šä¸–ç•Œé¦–é¢†
                    const unlocked = !research.unlockBoss || (state.defeatedBosses || []).includes(research.unlockBoss);

                    const cost = Math.floor(research.baseCost * Math.pow(1.2, level));
                    const canResearch = unlocked && !state.currentResearch && state.resources.gold >= cost;

                    return (
                        <div
                            key={research.id}
                            style={{
                                padding: 16,
                                background: 'rgba(0,0,0,0.3)',
                                border: '2px solid #4a3c2a',
                                borderRadius: 6,
                            }}
                        >
                            <h4 style={{ margin: '0 0 8px 0', fontSize: 14, color: '#ffd700' }}>
                                {research.name} (Lv.{level})
                            </h4>
                            <div style={{ fontSize: 11, color: '#aaa', marginBottom: 12 }}>
                                {research.description}
                            </div>
                            <div style={{ fontSize: 11, color: '#4CAF50', marginBottom: 12 }}>
                                æ•ˆæœ: +{(research.bonus * 100).toFixed(0)}% {research.effect}
                            </div>

                            {!unlocked && (
                                <div style={{ fontSize: 11, color: '#f44336', marginBottom: 12 }}>
                                    æœªè§£é”ï¼šéœ€è¦å‡»è´¥ {WORLD_BOSSES?.[research.unlockBoss]?.name || research.unlockBoss}
                                </div>
                            )}
                            <div style={{ fontSize: 11, color: '#888', marginBottom: 12 }}>
                                æˆæœ¬: ğŸª™{cost}
                            </div>
                            <Button
                                onClick={() => dispatch({ type: 'START_RESEARCH', payload: { researchId: research.id } })}
                                disabled={!canResearch}
                                style={{ width: '100%' }}
                            >
                                {unlocked ? 'ç ”ç©¶' : 'æœªè§£é”'}
                            </Button>
                        </div>
                    );
                })}
            </div>
        </Panel>
    );
};

// ==================== å®ä¼Ÿå®åº“ï¼ˆä¸–ç•Œé¦–é¢†é¡µå…¥å£ï¼‰ ====================
// è¯´æ˜ï¼š
// - 3 è¡Œ 3 åˆ—ï¼Œå…± 9 ä¸ªè£…å¤‡æ§½ä½
// - æ¯è¡Œæ¥è‡ªä¸€ç§å¾½ç« å¯å‡çº§è£…å¤‡æ± ï¼ˆé€šè¿‡ isXXXEquipment åˆ¤å®šï¼‰
// - æ¯ç§å¾½ç« éšæœº 3 ä»¶ï¼Œä½œä¸ºå®ä¼Ÿå®åº“å€™é€‰
// - é€‰æ‹© 1 ä»¶åç‚¹å‡»â€œé€‰æ‹©å¥–åŠ±â€è·å¾—ï¼ˆå¥–åŠ±è£…å¤‡ç­‰çº§å›ºå®šä¸º 5 çº§ï¼‰

const GRAND_VAULT_EQUIP_LEVEL = 5;

const GRAND_VAULT_RESET_HOUR = 9;

// ä»¥â€œæ—©ä¸Š 9 ç‚¹â€ä¸ºåˆ†ç•Œï¼Œå¾—åˆ°å½“å‰å®åº“çš„â€œæ—¥å‘¨æœŸâ€keyï¼ˆYYYY-MM-DDï¼‰
// - 08:59 å±äºâ€œæ˜¨å¤©â€çš„å®åº“å‘¨æœŸ
// - 09:00 èµ·å±äºâ€œä»Šå¤©â€çš„å®åº“å‘¨æœŸ
function getGrandVaultDayKey(now = new Date(), resetHour = GRAND_VAULT_RESET_HOUR) {
    const d = new Date(now);
    const h = d.getHours();
    if (h < resetHour) {
        d.setDate(d.getDate() - 1);
    }
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${y}-${m}-${day}`;
}

function getGrandVaultDayKeyByTs(ts = Date.now(), resetHour = GRAND_VAULT_RESET_HOUR) {
    return getGrandVaultDayKey(new Date(ts), resetHour);
}

// ä»ä¸–ç•Œé¦–é¢†å¥–åŠ±è¡¨ä¸­æ¨å¯¼ï¼šbossId -> badgeIdï¼ˆåªå– BADGE_UPGRADE_RULES ä¸­å­˜åœ¨çš„å¾½ç« ï¼‰
const GRAND_VAULT_BOSS_TO_BADGE = (() => {
    const map = {};
    Object.entries(BOSS_DATA || {}).forEach(([bossId, boss]) => {
        const items = boss?.rewards?.items || [];
        items.forEach(it => {
            const id = (typeof it === 'string') ? it : it?.id;
            if (!id) return;
            if (!BADGE_UPGRADE_RULES?.[id]) return;
            map[bossId] = id;
        });
    });
    return map;
})();

function getBossStrengthSnapshot(bossId) {
    const b = BOSS_DATA?.[bossId] || WORLD_BOSSES?.[bossId] || {};
    return {
        unlockLevel: Number(b.unlockLevel || 0),
        hp: Number(b.maxHp || b.hp || 0),
        attack: Number(b.attack || 0),
        defense: Number(b.defense || 0),
    };
}

function compareBossByStrengthDesc(aBossId, bBossId) {
    const a = getBossStrengthSnapshot(aBossId);
    const b = getBossStrengthSnapshot(bBossId);

    if (a.unlockLevel !== b.unlockLevel) return b.unlockLevel - a.unlockLevel;
    if (a.hp !== b.hp) return b.hp - a.hp;
    if (a.attack !== b.attack) return b.attack - a.attack;
    return b.defense - a.defense;
}

// å–â€œå·²å‡»æ€è¿‡â€çš„ä¸–ç•Œé¦–é¢†ï¼ˆä¼˜å…ˆç”¨è·¨ä¸–ç´¯è®¡ worldBossKillCountsï¼›å…¼å®¹æœ¬ä¸– defeatedBossesï¼‰
function getKilledWorldBossIdsForVault(state) {
    const killed = new Set();

    const counts = state?.worldBossKillCounts || {};
    if (counts && typeof counts === 'object' && !Array.isArray(counts)) {
        Object.entries(counts).forEach(([bossId, n]) => {
            if ((Number(n) || 0) > 0) killed.add(bossId);
        });
    }

    (state?.defeatedBosses || []).forEach(bossId => {
        if (bossId) killed.add(bossId);
    });

    return Array.from(killed);
}

// æ ¹æ®â€œæ˜¯å¦å‡»æ€è¿‡è¯¥BOSSâ€å†³å®šå®åº“å±•ç¤ºçš„ 3 ä¸ªå¾½ç« ï¼šå–æœ€å¼ºçš„ä¸‰ä¸ª
function pickTopGrandVaultRowDefs(state, maxRows = 3) {
    const killedBosses = getKilledWorldBossIdsForVault(state)
        .filter(bossId => !!GRAND_VAULT_BOSS_TO_BADGE?.[bossId]);

    // å…ˆæŠŠ boss -> badge -> è§„åˆ™æ•´ç†å‡ºæ¥ï¼Œå†æŒ‰â€œå¾½ç« å¼ºåº¦â€æ’åºï¼ˆcap è¶Šé«˜è¶Šå¼ºï¼‰
    const enriched = killedBosses.map(bossId => {
        const badgeId = GRAND_VAULT_BOSS_TO_BADGE[bossId];
        const rule = BADGE_UPGRADE_RULES?.[badgeId];
        const cap = Number(rule?.cap || 0);
        const inc = Number(rule?.inc || 0);
        return { bossId, badgeId, rule, cap, inc };
    }).filter(x => x?.badgeId && x?.rule && typeof x.rule.isEligible === 'function');

    enriched.sort((a, b) => {
        // âœ… å–æœ€å¼ºçš„å¾½ç« ï¼šå…ˆæ¯” capï¼ˆä¸Šé™ï¼‰ï¼Œå†æ¯” incï¼ˆå•æ¬¡æå‡ï¼‰
        if (a.cap !== b.cap) return b.cap - a.cap;
        if (a.inc !== b.inc) return b.inc - a.inc;

        // åŒæ¡£ä½å…œåº•ï¼šå†æŒ‰ Boss æœ¬ä½“å¼ºåº¦æ’åºï¼Œä¿è¯ç¨³å®š
        return compareBossByStrengthDesc(a.bossId, b.bossId);
    });

    const chosen = enriched.slice(0, Math.max(0, Number(maxRows) || 0));

    return chosen.map(({ bossId, badgeId, rule }) => ({
        badgeId,
        zoneLabel: rule?.zoneLabel || 'æœªçŸ¥åœ°åŒº',
        bossLabel: BOSS_DATA?.[bossId]?.name || WORLD_BOSSES?.[bossId]?.name || bossId,
        isEligible: rule?.isEligible,
    }));
}


function pickRandomUniqueIds(ids = [], count = 3) {
    const arr = Array.isArray(ids) ? [...ids] : [];
    // Fisherâ€“Yates shuffle
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr.slice(0, Math.min(count, arr.length));
}

// ç”Ÿæˆ/åŒæ­¥å½“æ—¥å®ä¼Ÿå®åº“å†…å®¹ï¼š
// - ä»¥â€œæ—©ä¸Š9ç‚¹â€ä¸ºæ—¥åˆ·æ–°åˆ†ç•Œï¼ˆdayKeyï¼‰
// - å®åº“å±•ç¤ºçš„ 3 ä¸ªå¾½ç« ï¼šæ ¹æ®æ˜¯å¦å‡»æ€è¿‡ BOSSï¼Œå–æœ€å¼ºçš„ä¸‰ä¸ª
// - åŒä¸€æ—¥å‘¨æœŸå†…ï¼Œæ¯ä¸ªå¾½ç« çš„ 3 ä¸ªå€™é€‰è£…å¤‡å›ºå®šï¼ˆå­˜äº grandVault.badgePicksï¼‰ï¼Œé¿å…åå¤æ‰“å¼€åˆ·å‡ºä¸åŒç»“æœ
function computeGrandVaultSnapshot(state, nowTs = Date.now()) {
    const dayKey = getGrandVaultDayKeyByTs(nowTs);

    const gv0 = (state?.grandVault && typeof state.grandVault === 'object' && !Array.isArray(state.grandVault))
        ? state.grandVault
        : {};

    let gv = { ...gv0 };

    // å…¼å®¹æ—§æ¡£/å¼‚å¸¸å­—æ®µ
    if (typeof gv.dayKey !== 'string') gv.dayKey = '';
    if (typeof gv.claimedDayKey !== 'string') gv.claimedDayKey = '';
    if (typeof gv.lastRefreshAt !== 'number') gv.lastRefreshAt = 0;
    if (typeof gv.claimedAt !== 'number') gv.claimedAt = 0;
    if (typeof gv.badgePicks !== 'object' || gv.badgePicks == null || Array.isArray(gv.badgePicks)) gv.badgePicks = {};

    let changed = false;

    // ===== æ¯æ—¥æ—©ä¸Š9ç‚¹åˆ·æ–°ï¼šè¿›å…¥æ–° dayKey åæ¸…ç©ºå½“æ—¥ç¼“å­˜ =====
    if (gv.dayKey !== dayKey) {
        gv.dayKey = dayKey;
        gv.badgePicks = {};
        gv.rows = null;
        gv.lastRefreshAt = nowTs;
        changed = true;
    }

    // å–æœ€å¼ºçš„ä¸‰ä¸ªå¾½ç« ï¼ˆéšå‡»æ€è§£é”è€Œå˜åŒ–ï¼‰
    const rowDefs = pickTopGrandVaultRowDefs(state, 3);

    const nextBadgePicks = { ...(gv.badgePicks || {}) };
    let picksChanged = false;

    const rows = rowDefs.map(def => {
        const pool = Object.values(FIXED_EQUIPMENTS || {})
            .filter(tpl => tpl?.type === 'equipment' && def.isEligible?.(tpl))
            .map(tpl => tpl.id)
            .filter(Boolean);

        // è¯»å–/æ ¡éªŒæ—§çš„ picks
        let picks = nextBadgePicks[def.badgeId];
        if (Array.isArray(picks)) {
            const used = new Set();
            picks = picks
                .filter(id => pool.includes(id))
                .filter(id => (used.has(id) ? false : (used.add(id), true)));
        } else {
            picks = [];
        }

        // ä¸è¶³ 3 ä¸ªåˆ™è¡¥é½ï¼ˆä»å‰©ä½™æ± éšæœºå–ï¼‰
        if (picks.length < 3) {
            const remain = pool.filter(id => !picks.includes(id));
            const fill = pickRandomUniqueIds(remain, 3 - picks.length);
            if (fill.length > 0) picksChanged = true;
            picks = [...picks, ...fill];
        }

        // å¦‚æœæ± å­ä¸è¶³ 3 ä¸ªï¼Œå°±æŒ‰æ± å­é•¿åº¦æˆªæ–­
        picks = picks.slice(0, Math.min(3, pool.length));

        const prev = nextBadgePicks[def.badgeId];
        const prevKey = Array.isArray(prev) ? prev.join('|') : '';
        const nowKey = picks.join('|');
        if (prevKey !== nowKey) picksChanged = true;

        nextBadgePicks[def.badgeId] = picks;

        return {
            ...def,
            equipTemplateIds: picks
        };
    });

    // rows å˜åŒ–ï¼ˆä¾‹å¦‚å‡»æ€äº†æ›´å¼º Bossï¼ŒTop3 å¾½ç« å˜åŒ–ï¼‰
    const prevRows = Array.isArray(gv.rows) ? gv.rows : null;
    const sameRows = (() => {
        if (!prevRows) return false;
        if (prevRows.length !== rows.length) return false;
        for (let i = 0; i < rows.length; i++) {
            const a = prevRows[i];
            const b = rows[i];
            if (a?.badgeId !== b?.badgeId) return false;
            const ae = Array.isArray(a?.equipTemplateIds) ? a.equipTemplateIds : [];
            const be = Array.isArray(b?.equipTemplateIds) ? b.equipTemplateIds : [];
            if (ae.length !== be.length) return false;
            for (let j = 0; j < ae.length; j++) {
                if (ae[j] !== be[j]) return false;
            }
        }
        return true;
    })();

    if (!sameRows) {
        gv.rows = rows;
        changed = true;
    }

    if (picksChanged) {
        gv.badgePicks = nextBadgePicks;
        changed = true;
    }

    return { dayKey, rows, grandVault: gv, changed };
}

// æ—§è°ƒç”¨ç‚¹å…¼å®¹ï¼šç›´æ¥è¿”å› rows
function buildGrandVaultRows(state) {
    return computeGrandVaultSnapshot(state).rows;
}

function getEquipmentPreviewAtLevel(templateId, level = GRAND_VAULT_EQUIP_LEVEL) {
    const tpl = getEquipmentTemplate(templateId);
    if (!tpl) return null;
    const lv = clamp(Number(level) || 0, 0, tpl.maxLevel ?? 100);
    return {
        ...tpl,
        qualityColor: getRarityColor(tpl.rarity),
        currentLevel: lv,
        stats: scaleStats(tpl.baseStats || {}, tpl.growth || {}, lv)
    };
}

function describeEquipmentSpecialEffect(eq) {
    const effects = getEquipmentSpecialEffectList(eq);
    if (!effects || effects.length === 0) return [];

    return effects.map(se => {
        if (!se) return '';

        if (se.type === 'skill_slot_buff') {
            const slots = (se.slots || []).map(s => (Number(s) + 1)).filter(n => Number.isFinite(n));
            const parts = [];
            if (se.attackBonus) parts.push(`æ”»+${formatItemStatValue('attack', se.attackBonus)}`);
            if (se.spellPowerBonus) parts.push(`æ³•+${formatItemStatValue('spellPower', se.spellPowerBonus)}`);
            return `âš¡ æŠ€èƒ½æ ¼ ${slots.join('/') || '?'}ï¼š${parts.join(' ') || 'å¼ºåŒ–'}`;
        }

        if (se.type === 'basic_attack_repeat') {
            return `âš”ï¸ æ™®æ”» ${(Number(se.chance || 0) * 100).toFixed(0)}% è¿å‡»`;
        }

        if (se.type === 'proc_stat' && se.trigger === 'turn_start') {
            const chance = (Number(se.chance || 0) * 100).toFixed(0);
            const bonusText = formatProcStatBonusText(se.stats || {});
            return `ğŸ² æ¯å›åˆ ${chance}%ï¼š${bonusText || 'è§¦å‘å¢ç›Š'}`;
        }

        if (se.type === 'map_slayer') {
            return `ğŸ—ºï¸ åœ°å›¾ä¼¤å®³ +${((Number(se.bonusDamageVsMap || 0)) * 100).toFixed(0)}%`;
        }

        if (se.type === 'ignore_defense') {
            const pct = Number(se.pct ?? se.ignorePct ?? se.value) || 0;
            return `ğŸ›¡ï¸ æ— è§†é˜²å¾¡ ${(pct * 100).toFixed(0)}%`;
        }

        if (se.type === 'proc_damage' && se.trigger === 'turn_start') {
            const chance = (Number(se.chance || 0) * 100).toFixed(0);
            const school = getSchoolCn(se.school || 'physical');
            const basedOn = (se.basedOn === 'spellPower') ? 'æ³•å¼º' : 'æ”»å‡»';
            const mult = Number(se.damageMult) || 0;
            const flat = Number(se.damageFlat) || 0;
            const parts = [];
            if (mult) parts.push(`${String(mult).replace(/\.0+$/, '')}Ã—${basedOn}`);
            if (flat) parts.push(`+${Math.floor(flat)}`);
            const dmgText = parts.length > 0 ? parts.join('') : basedOn;
            return `ğŸ”¥ æ¯å›åˆ ${chance}%ï¼š${dmgText} ${school}ä¼¤å®³`;
        }

        if (se.type === 'thunderfury' && se.trigger === 'turn_start') {
            const chance = (Number(se.chance || 0) * 100).toFixed(0);
            return `âš¡ é—ªç”µé“¾ ${chance}%`;
        }

        return `âš¡ ç‰¹æ•ˆï¼š${se.type}`;
    }).filter(Boolean);
}

const GrandVaultModal = ({ rows, inventoryFull, onClose, onClaim }) => {
    const [selectedId, setSelectedId] = React.useState('');
    const [hover, setHover] = React.useState(null); // { id, x, y }

    const selectedPreview = selectedId ? getEquipmentPreviewAtLevel(selectedId, GRAND_VAULT_EQUIP_LEVEL) : null;

    if (!rows || rows.length === 0) return null;

    const tooltipPreview = hover?.id ? getEquipmentPreviewAtLevel(hover.id, GRAND_VAULT_EQUIP_LEVEL) : null;
    const tooltipEffects = tooltipPreview ? describeEquipmentSpecialEffect(tooltipPreview) : [];

    const tooltipX = (() => {
        const x = Number(hover?.x) || 0;
        const w = 300;
        const pad = 14;
        if (typeof window === 'undefined') return x + 16;
        return Math.max(pad, Math.min(x + 16, window.innerWidth - w - pad));
    })();
    const tooltipY = (() => {
        const y = Number(hover?.y) || 0;
        const h = 240;
        const pad = 14;
        if (typeof window === 'undefined') return y + 16;
        return Math.max(pad, Math.min(y + 16, window.innerHeight - h - pad));
    })();

    const canClaim = !!selectedId && !inventoryFull;

    return (
        <div
            style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: 'rgba(0,0,0,0.88)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 2400,
                padding: 18,
            }}
            onClick={onClose}
        >
            <div
                style={{
                    width: 980,
                    maxWidth: '96vw',
                    maxHeight: '92vh',
                    overflow: 'auto',
                    background: 'linear-gradient(135deg, rgba(35,28,22,0.98) 0%, rgba(18,14,11,0.98) 100%)',
                    border: '3px solid rgba(201,162,39,0.85)',
                    borderRadius: 14,
                    boxShadow: '0 12px 44px rgba(0,0,0,0.65), inset 0 1px 0 rgba(255,255,255,0.06)',
                    position: 'relative',
                    padding: 22,
                }}
                onClick={(e) => e.stopPropagation()}
            >
                {/* é¡¶éƒ¨æ ‡é¢˜ */}
                <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    position: 'relative',
                    paddingBottom: 12,
                    marginBottom: 14,
                    borderBottom: '1px solid rgba(201,162,39,0.20)'
                }}>
                    <div style={{
                        fontSize: 22,
                        fontWeight: 800,
                        color: '#ffd700',
                        textShadow: '2px 2px 6px rgba(0,0,0,0.8)',
                        letterSpacing: 1
                    }}>
                        ğŸ›ï¸ å®ä¼Ÿå®åº“
                    </div>

                    <button
                        onClick={onClose}
                        style={{
                            position: 'absolute',
                            right: 0,
                            top: 0,
                            width: 34,
                            height: 34,
                            borderRadius: 8,
                            border: '1px solid rgba(255,255,255,0.15)',
                            background: 'rgba(0,0,0,0.35)',
                            color: '#ffd700',
                            fontWeight: 900,
                            cursor: 'pointer'
                        }}
                        title="å…³é—­"
                    >
                        âœ•
                    </button>
                </div>

                <div style={{
                    textAlign: 'center',
                    color: '#c9a227',
                    fontSize: 13,
                    marginBottom: 18,
                    opacity: 0.95
                }}>
                    ä½ åªèƒ½ä»å®ä¼Ÿå®åº“ä¸­é€‰æ‹© <b style={{ color: '#ffd700' }}>ä¸€ä»¶</b> å¥–åŠ±ã€‚
                </div>

                {/* 3 è¡Œ 3 åˆ— */}
                <div style={{ display: 'flex', flexDirection: 'column', gap: 14 }}>
                    {rows.map((row) => {
                        const badge = ITEMS?.[row.badgeId];
                        return (
                            <div
                                key={row.badgeId}
                                style={{
                                    display: 'grid',
                                    gridTemplateColumns: '180px 1fr',
                                    gap: 14,
                                    alignItems: 'stretch',
                                    padding: 14,
                                    background: 'rgba(0,0,0,0.22)',
                                    border: '1px solid rgba(255,255,255,0.08)',
                                    borderRadius: 12,
                                }}
                            >
                                {/* å·¦ä¾§æ ‡ç­¾ */}
                                <div style={{
                                    display: 'flex',
                                    flexDirection: 'column',
                                    justifyContent: 'center',
                                    padding: 12,
                                    borderRadius: 10,
                                    background: 'linear-gradient(135deg, rgba(201,162,39,0.16) 0%, rgba(60,45,18,0.10) 100%)',
                                    border: '1px solid rgba(201,162,39,0.25)'
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                                        <div style={{
                                            width: 34,
                                            height: 34,
                                            borderRadius: 8,
                                            background: 'rgba(0,0,0,0.35)',
                                            border: '1px solid rgba(255,255,255,0.10)',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center'
                                        }}>
                                            <ItemIcon item={badge} size={28} />
                                        </div>
                                        <div style={{ lineHeight: 1.2 }}>
                                            <div style={{ fontSize: 16, fontWeight: 900, color: '#ffd700' }}>
                                                {row.zoneLabel}
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', marginTop: 2 }}>
                                                {badge?.name || row.badgeId}
                                            </div>
                                        </div>
                                    </div>

                                    <div style={{ marginTop: 10, fontSize: 11, color: '#aaa', lineHeight: 1.45 }}>
                                        æ¥æºï¼š<span style={{ color: '#e8dcc4' }}>{row.bossLabel}</span>
                                        <div style={{ color: '#888', marginTop: 4 }}>
                                            éšæœº 3 ä»¶å¯å‡çº§è£…å¤‡
                                        </div>
                                    </div>
                                </div>

                                {/* å³ä¾§ 3 ä¸ªè£…å¤‡æ§½ */}
                                <div
                                    style={{
                                        display: 'grid',
                                        gridTemplateColumns: 'repeat(3, 1fr)',
                                        gap: 12,
                                    }}
                                >
                                    {(row.equipTemplateIds || []).map((templateId) => {
                                        const preview = getEquipmentPreviewAtLevel(templateId, GRAND_VAULT_EQUIP_LEVEL);
                                        if (!preview) return null;
                                        const picked = selectedId === templateId;

                                        return (
                                            <div
                                                key={templateId}
                                                onClick={() => setSelectedId(templateId)}
                                                onMouseEnter={(e) => setHover({ id: templateId, x: e.clientX, y: e.clientY })}
                                                onMouseMove={(e) => {
                                                    setHover((h) => (h && h.id === templateId)
                                                        ? { ...h, x: e.clientX, y: e.clientY }
                                                        : h
                                                    );
                                                }}
                                                onMouseLeave={() => setHover(null)}
                                                style={{
                                                    userSelect: 'none',
                                                    cursor: 'pointer',
                                                    padding: 14,
                                                    borderRadius: 12,
                                                    background: picked
                                                        ? 'linear-gradient(135deg, rgba(201,162,39,0.18) 0%, rgba(90,70,18,0.12) 100%)'
                                                        : 'rgba(0,0,0,0.25)',
                                                    border: picked
                                                        ? '2px solid #ffd700'
                                                        : `2px solid ${preview.qualityColor}55`,
                                                    boxShadow: picked
                                                        ? '0 0 16px rgba(255,215,0,0.20)'
                                                        : 'none',
                                                    position: 'relative',
                                                    minHeight: 92,
                                                    transition: 'all 0.12s',
                                                    opacity: inventoryFull ? 0.95 : 1
                                                }}
                                                title="ç‚¹å‡»é€‰æ‹©"
                                            >
                                                {picked && (
                                                    <div style={{
                                                        position: 'absolute',
                                                        top: 10,
                                                        right: 10,
                                                        fontSize: 12,
                                                        fontWeight: 900,
                                                        color: '#0b0b0b',
                                                        background: 'linear-gradient(180deg, #ffd700, #c9a227)',
                                                        borderRadius: 999,
                                                        padding: '4px 10px',
                                                        border: '1px solid rgba(0,0,0,0.25)',
                                                        boxShadow: '0 2px 10px rgba(0,0,0,0.35)'
                                                    }}>
                                                        âœ“ å·²é€‰
                                                    </div>
                                                )}

                                                <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                                                    <div style={{
                                                        width: 46,
                                                        height: 46,
                                                        borderRadius: 10,
                                                        background: 'rgba(0,0,0,0.35)',
                                                        border: '1px solid rgba(255,255,255,0.10)',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexShrink: 0
                                                    }}>
                                                        <ItemIcon item={preview} size={38} />
                                                    </div>

                                                    <div style={{ minWidth: 0 }}>
                                                        <div style={{
                                                            fontSize: 13,
                                                            fontWeight: 800,
                                                            color: preview.qualityColor,
                                                            whiteSpace: 'nowrap',
                                                            overflow: 'hidden',
                                                            textOverflow: 'ellipsis'
                                                        }}>
                                                            {preview.name}
                                                        </div>
                                                        <div style={{ fontSize: 11, color: '#aaa', marginTop: 4 }}>
                                                            {EQUIPMENT_SLOTS?.[preview.slot]?.name || preview.slot} Â· Lv.{GRAND_VAULT_EQUIP_LEVEL}
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        );
                    })}
                </div>

                {/* åº•éƒ¨ï¼šé€‰æ‹©å¥–åŠ± */}
                <div style={{
                    marginTop: 18,
                    paddingTop: 16,
                    borderTop: '1px solid rgba(201,162,39,0.18)',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    gap: 10
                }}>
                    {selectedPreview ? (
                        <div style={{
                            fontSize: 12,
                            color: '#aaa',
                            textAlign: 'center'
                        }}>
                            å·²é€‰æ‹©ï¼š<span style={{ color: selectedPreview.qualityColor, fontWeight: 800 }}>{selectedPreview.name}</span>
                            <span style={{ color: '#888' }}>ï¼ˆLv.{GRAND_VAULT_EQUIP_LEVEL}ï¼‰</span>
                        </div>
                    ) : (
                        <div style={{ fontSize: 12, color: '#888', textAlign: 'center' }}>
                            è¯·é€‰æ‹©ä¸€ä»¶è£…å¤‡ä½œä¸ºå¥–åŠ±ã€‚
                        </div>
                    )}

                    {inventoryFull && (
                        <div style={{
                            fontSize: 12,
                            color: '#ff6b6b',
                            textAlign: 'center'
                        }}>
                            âš ï¸ èƒŒåŒ…å·²æ»¡ï¼Œæ— æ³•é¢†å–å¥–åŠ±ã€‚
                        </div>
                    )}

                    <Button
                        onClick={() => {
                            if (!canClaim) return;
                            onClaim?.(selectedId);
                        }}
                        disabled={!canClaim}
                        style={{
                            padding: '12px 40px',
                            fontSize: 14,
                            borderRadius: 8
                        }}
                    >
                        é€‰æ‹©å¥–åŠ±
                    </Button>
                </div>

                {/* æ‚¬åœå±æ€§ Tooltip */}
                {tooltipPreview && (
                    <div
                        style={{
                            position: 'fixed',
                            left: tooltipX,
                            top: tooltipY,
                            width: 300,
                            padding: 12,
                            background: 'rgba(10,10,10,0.92)',
                            border: `2px solid ${tooltipPreview.qualityColor}`,
                            borderRadius: 10,
                            boxShadow: '0 10px 30px rgba(0,0,0,0.6)',
                            zIndex: 2600,
                            pointerEvents: 'none'
                        }}
                    >
                        <div style={{
                            fontWeight: 900,
                            color: tooltipPreview.qualityColor,
                            fontSize: 14,
                            marginBottom: 4
                        }}>
                            {tooltipPreview.name}
                        </div>
                        <div style={{ fontSize: 11, color: '#bbb', marginBottom: 10 }}>
                            {EQUIPMENT_SLOTS?.[tooltipPreview.slot]?.name || tooltipPreview.slot} Â· Lv.{GRAND_VAULT_EQUIP_LEVEL}
                        </div>

                        <div style={{
                            borderTop: '1px solid rgba(255,255,255,0.10)',
                            paddingTop: 8,
                            display: 'flex',
                            flexDirection: 'column',
                            gap: 4
                        }}>
                            {Object.entries(tooltipPreview.stats || {}).length === 0 ? (
                                <div style={{ fontSize: 11, color: '#888' }}>ï¼ˆæ— å±æ€§ï¼‰</div>
                            ) : (
                                Object.entries(tooltipPreview.stats || {}).map(([stat, value]) => (
                                    <div key={stat} style={{ display: 'flex', justifyContent: 'space-between', fontSize: 11 }}>
                                        <span style={{ color: '#aaa' }}>{STAT_LABELS?.[stat] || stat}</span>
                                        <span style={{ color: '#4CAF50', fontWeight: 800 }}>+{formatItemStatValue(stat, value)}</span>
                                    </div>
                                ))
                            )}
                        </div>

                        {tooltipEffects.length > 0 && (
                            <div style={{
                                marginTop: 10,
                                paddingTop: 8,
                                borderTop: '1px solid rgba(255,255,255,0.10)',
                                display: 'flex',
                                flexDirection: 'column',
                                gap: 4
                            }}>
                                {tooltipEffects.map((line, idx) => (
                                    <div key={idx} style={{ fontSize: 11, color: '#ffb74d', lineHeight: 1.35 }}>
                                        {line}
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
};

// ==================== WorldBossPage ä¿®æ”¹ ====================
const WorldBossPage = ({ state, dispatch }) => {
    const [showVault, setShowVault] = useState(false);
    const [vaultRows, setVaultRows] = useState(null);

    const openVault = () => {
        const nowTs = Date.now();
        const snap = computeGrandVaultSnapshot(state, nowTs);
        const dayKey = snap.dayKey;
        const gv = snap.grandVault || {};

        // âœ… å½“æ—¥å·²é¢†å–ï¼šç‚¹å‡»æç¤º
        if (gv.claimedDayKey === dayKey) {
            alert('å®ä¼Ÿå®åº“ï¼šå½“æ—¥å·²ç»é¢†å–ã€‚');
            return;
        }

        const rows = Array.isArray(snap.rows) ? snap.rows : [];
        if (!rows || rows.length === 0) {
            alert('å®ä¼Ÿå®åº“ï¼šä½ å°šæœªå‡»æ€è¿‡å¯è®¡å…¥å®åº“çš„ä¸–ç•Œé¦–é¢†ï¼Œæš‚æ— å¯ç”¨å¥–åŠ±ã€‚');
            return;
        }

        // âœ… åŒæ­¥åˆ°å­˜æ¡£ï¼šä¿è¯åŒä¸€æ—¥å‘¨æœŸå†…ä¸ä¼šåå¤æ‰“å¼€åˆ·æ–°å‡ºä¸åŒç»“æœ
        if (snap.changed) {
            dispatch({ type: 'SET_GRAND_VAULT', payload: { grandVault: gv } });
        }

        setVaultRows(rows);
        setShowVault(true);
    };

    const VaultButton = ({ onClick }) => (
        <button
            onClick={onClick}
            style={{
                padding: '8px 14px',
                borderRadius: 8,
                border: '2px solid rgba(201,162,39,0.9)',
                background: 'linear-gradient(180deg, rgba(201,162,39,0.25), rgba(139,115,25,0.18))',
                color: '#ffd700',
                fontWeight: 900,
                fontSize: 12,
                cursor: 'pointer',
                boxShadow: '0 2px 10px rgba(0,0,0,0.35)',
                textShadow: '1px 1px 2px rgba(0,0,0,0.7)',
                letterSpacing: 0.5
            }}
            title="æ‰“å¼€å®ä¼Ÿå®åº“"
        >
            ğŸ›ï¸ å®ä¼Ÿå®åº“
        </button>
    );

    return (
        <Panel
            title="ä¸–ç•Œé¦–é¢†"
            actions={
                <>
                    <VaultButton onClick={openVault} />
                </>
            }
        >
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: 16 }}>
                {Object.values(WORLD_BOSSES).map(boss => {
                    const bossData = BOSS_DATA[boss.id] || boss;
                    const unlocked = !boss.unlockLevel || state.characters.some(c => c.level >= (boss.unlockLevel || 0));
                    const cdSeconds = state.bossCooldowns?.[boss.id] || 0;
                    const cdText = cdSeconds > 0 ? `${String(Math.floor(cdSeconds / 60)).padStart(2, '0')}:${String(cdSeconds % 60).padStart(2, '0')}` : '';

                    // ===== è‡ªåŠ¨å‡»æ€ï¼ˆè·¨ä¸–ç´¯è®¡10æ¬¡è§£é”ï¼‰ =====
                    const totalKills = state.worldBossKillCounts?.[boss.id] || 0;
                    const autoEnabled = !!state.worldBossAutoKill?.[boss.id];
                    const autoUnlocked = totalKills >= 10;

                    // æ™®ç‘æ–¯æ‰˜å¥³å£«ç‰¹æ®Šè§£é”æ¡ä»¶
                    if (boss.id === 'prestor_lady' && !state.worldBossProgress?.prestor_lady) {
                        return null;
                    }

                    return (
                        <div key={boss.id} style={{
                            padding: 20,
                            background: unlocked
                                ? 'linear-gradient(135deg, rgba(180,50,50,0.2) 0%, rgba(80,20,20,0.3) 100%)'
                                : 'rgba(0,0,0,0.3)',
                            border: `2px solid ${unlocked ? '#a03030' : '#333'}`,
                            borderRadius: 12,
                            opacity: unlocked ? 1 : 0.5,
                            boxShadow: unlocked ? '0 4px 20px rgba(160,48,48,0.3)' : 'none'
                        }}>
                            {/* BOSSå›¾ç‰‡åŒºåŸŸ */}
                            <div style={{
                                width: '100%',
                                height: 180,
                                background: 'linear-gradient(135deg, rgba(60,20,20,0.5) 0%, rgba(30,10,10,0.6) 100%)',
                                border: '2px solid rgba(180,50,50,0.4)',
                                borderRadius: 10,
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                marginBottom: 16,
                                overflow: 'hidden',
                                position: 'relative',
                                boxShadow: 'inset 0 0 30px rgba(0,0,0,0.5)'
                            }}>
                                {boss.icon ? (
                                    <img
                                        src={boss.icon}
                                        alt={boss.name}
                                        style={{
                                            width: '100%',
                                            height: '100%',
                                            objectFit: 'cover',
                                            filter: unlocked ? 'none' : 'grayscale(100%)'
                                        }}
                                    />
                                ) : (
                                    <div style={{
                                        fontSize: 64,
                                        opacity: 0.6,
                                        filter: unlocked
                                            ? 'drop-shadow(0 0 15px rgba(255,100,100,0.5))'
                                            : 'grayscale(100%)'
                                    }}>
                                        {unlocked ? 'ğŸ²' : 'ğŸ”’'}
                                    </div>
                                )}

                                {/* é”å®šé®ç½© */}
                                {!unlocked && (
                                    <div style={{
                                        position: 'absolute',
                                        top: 0,
                                        left: 0,
                                        right: 0,
                                        bottom: 0,
                                        background: 'rgba(0,0,0,0.6)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center'
                                    }}>
                                        <span style={{ fontSize: 48 }}>ğŸ”’</span>
                                    </div>
                                )}

                                {/* åº•éƒ¨æ¸å˜ */}
                                <div style={{
                                    position: 'absolute',
                                    bottom: 0,
                                    left: 0,
                                    right: 0,
                                    height: '40%',
                                    background: 'linear-gradient(0deg, rgba(0,0,0,0.8) 0%, transparent 100%)',
                                    pointerEvents: 'none'
                                }} />
                            </div>

                            {/* BOSSåç§° */}
                            <h3 style={{
                                textAlign: 'center',
                                color: unlocked ? '#ff6b6b' : '#666',
                                margin: '0 0 12px 0',
                                fontSize: 20,
                                textShadow: unlocked ? '0 0 10px rgba(255,107,107,0.5)' : 'none'
                            }}>
                                {boss.name}
                            </h3>

                            {/* BOSSå±æ€§é¢„è§ˆ */}
                            {unlocked && (
                                <div style={{
                                    display: 'grid',
                                    gridTemplateColumns: 'repeat(3, 1fr)',
                                    gap: 8,
                                    marginBottom: 16,
                                    padding: 10,
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: 6
                                }}>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>ç”Ÿå‘½</div>
                                        <div style={{ fontSize: 12, color: '#f44336', fontWeight: 600 }}>
                                            {(bossData.maxHp || boss.hp)?.toLocaleString()}
                                        </div>
                                    </div>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>æ”»å‡»</div>
                                        <div style={{ fontSize: 12, color: '#ff9800', fontWeight: 600 }}>
                                            {bossData.attack || boss.attack}
                                        </div>
                                    </div>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>é˜²å¾¡</div>
                                        <div style={{ fontSize: 12, color: '#4CAF50', fontWeight: 600 }}>
                                            {bossData.defense || boss.defense}
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* æŒ‘æˆ˜æŒ‰é’® / è§£é”æ¡ä»¶ */}
                            {unlocked ? (
                                <div>
                                    {/* è‡ªåŠ¨å‡»æ€å¼€å…³ */}
                                    <div style={{
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'space-between',
                                        gap: 10,
                                        padding: '8px 10px',
                                        marginBottom: 10,
                                        background: 'rgba(0,0,0,0.22)',
                                        border: '1px solid rgba(255,255,255,0.08)',
                                        borderRadius: 6
                                    }}>
                                        <div style={{ lineHeight: 1.2 }}>
                                            <div style={{ fontSize: 12, color: '#ffd700', fontWeight: 700 }}>
                                                ğŸ¤– è‡ªåŠ¨å‡»æ€
                                            </div>
                                            <div style={{ fontSize: 10, color: '#aaa' }}>
                                                {autoUnlocked
                                                    ? 'CDç»“æŸåè‡ªåŠ¨å‡»æ€å¹¶æ‰è½'
                                                    : `è§£é”ï¼šç´¯è®¡å‡»æ€ ${totalKills}/10`}
                                            </div>
                                        </div>
                                        <button
                                            onClick={() => dispatch({ type: 'TOGGLE_WORLD_BOSS_AUTOKILL', payload: { bossId: boss.id } })}
                                            disabled={!autoUnlocked}
                                            style={{
                                                border: '1px solid rgba(255,255,255,0.12)',
                                                background: autoEnabled ? 'rgba(76,175,80,0.18)' : 'rgba(255,255,255,0.06)',
                                                color: autoUnlocked ? (autoEnabled ? '#7CFF7C' : '#ddd') : '#666',
                                                padding: '6px 10px',
                                                borderRadius: 999,
                                                fontSize: 11,
                                                fontWeight: 800,
                                                cursor: autoUnlocked ? 'pointer' : 'not-allowed',
                                                opacity: autoUnlocked ? 1 : 0.7
                                            }}
                                        >
                                            {autoEnabled ? 'å¼€å¯' : 'å…³é—­'}
                                        </button>
                                    </div>

                                    {cdSeconds > 0 && (
                                        <div style={{
                                            textAlign: 'center',
                                            marginBottom: 10,
                                            padding: '8px 10px',
                                            background: 'rgba(0,0,0,0.25)',
                                            border: '1px solid rgba(255,255,255,0.08)',
                                            borderRadius: 6,
                                            color: '#ffd700',
                                            fontSize: 12
                                        }}>
                                            â³ é‡ç”Ÿå†·å´ä¸­ï¼š<b>{cdText}</b>
                                        </div>
                                    )}
                                    <Button
                                        variant="danger"
                                        style={{
                                            width: '100%',
                                            padding: '10px 16px',
                                            fontSize: 14,
                                            fontWeight: 600,
                                            opacity: cdSeconds > 0 ? 0.6 : 1
                                        }}
                                        disabled={cdSeconds > 0}
                                        onClick={() => dispatch({ type: 'OPEN_BOSS_PREPARE', payload: boss.id })}
                                    >
                                        {cdSeconds > 0 ? `â³ é‡ç”Ÿä¸­ (${cdText})` : 'âš”ï¸ æŒ‘æˆ˜'}
                                    </Button>
                                </div>
                            ) : (
                                <div style={{
                                    textAlign: 'center',
                                    color: '#666',
                                    padding: '10px',
                                    background: 'rgba(0,0,0,0.2)',
                                    borderRadius: 6,
                                    fontSize: 12
                                }}>
                                    ğŸ”’ éœ€è¦ç­‰çº§ {boss.unlockLevel || 0}
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>

            {/* ==================== å›¢é˜Ÿé¦–é¢†åŒºåŸŸï¼ˆæ¡†æ¶ï¼‰ ==================== */}
            <div style={{
                marginTop: 24,
                paddingTop: 20,
                borderTop: '1px solid rgba(201,162,39,0.2)'
            }}>
                <div style={{
                    display: 'flex',
                    alignItems: 'flex-end',
                    justifyContent: 'space-between',
                    gap: 12,
                    marginBottom: 16
                }}>
                    <div>
                        <div style={{
                            fontSize: 18,
                            fontWeight: 900,
                            color: '#ffd700',
                            textShadow: '0 0 14px rgba(255,215,0,0.25)'
                        }}>
                            ğŸ§© å›¢é˜Ÿé¦–é¢†
                        </div>
                        <div style={{ fontSize: 12, color: '#aaa', marginTop: 6 }}>

                        </div>
                    </div>

                    <div style={{
                        fontSize: 11,
                        color: '#888',
                        padding: '6px 10px',
                        background: 'rgba(0,0,0,0.25)',
                        border: '1px solid rgba(255,255,255,0.08)',
                        borderRadius: 8
                    }}>
                        ğŸ‘¥ 5äººæˆ˜æ–—
                    </div>
                </div>

                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: 16 }}>
                    {Object.values(TEAM_BOSSES).map(boss => {
                        const bossData = BOSS_DATA[boss.id] || boss;
                        const unlocked = !boss.unlockLevel || state.characters.some(c => c.level >= (boss.unlockLevel || 0));
                        const cdSeconds = state.bossCooldowns?.[boss.id] || 0;
                        const cdText = cdSeconds > 0
                            ? `${String(Math.floor(cdSeconds / 60)).padStart(2, '0')}:${String(cdSeconds % 60).padStart(2, '0')}`
                            : '';

                        const partySize = getBossPartySize(boss.id);

                        return (
                            <div key={boss.id} style={{
                                padding: 20,
                                background: unlocked
                                    ? 'linear-gradient(135deg, rgba(255,120,0,0.14) 0%, rgba(60,20,10,0.32) 100%)'
                                    : 'rgba(0,0,0,0.3)',
                                border: `2px solid ${unlocked ? 'rgba(255,140,0,0.65)' : '#333'}`,
                                borderRadius: 12,
                                opacity: unlocked ? 1 : 0.5,
                                boxShadow: unlocked ? '0 4px 20px rgba(255,140,0,0.18)' : 'none'
                            }}>
                                {/* BOSSå›¾ç‰‡åŒºåŸŸ */}
                                <div style={{
                                    width: '100%',
                                    height: 180,
                                    background: 'linear-gradient(135deg, rgba(90,30,10,0.55) 0%, rgba(25,10,6,0.75) 100%)',
                                    border: '2px solid rgba(255,140,0,0.35)',
                                    borderRadius: 10,
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    marginBottom: 16,
                                    overflow: 'hidden',
                                    position: 'relative',
                                    boxShadow: 'inset 0 0 30px rgba(0,0,0,0.55)'
                                }}>
                                    {boss.icon ? (
                                        <img
                                            src={boss.icon}
                                            alt={boss.name}
                                            style={{
                                                width: '100%',
                                                height: '100%',
                                                objectFit: 'cover',
                                                filter: unlocked ? 'none' : 'grayscale(100%)'
                                            }}
                                        />
                                    ) : (
                                        <div style={{
                                            fontSize: 64,
                                            opacity: 0.7,
                                            filter: unlocked
                                                ? 'drop-shadow(0 0 18px rgba(255,140,0,0.45))'
                                                : 'grayscale(100%)'
                                        }}>
                                            {unlocked ? 'ğŸ”¥' : 'ğŸ”’'}
                                        </div>
                                    )}

                                    {/* æ ‡ç­¾ï¼šå›¢é˜Ÿé¦–é¢† */}
                                    <div style={{
                                        position: 'absolute',
                                        top: 10,
                                        left: 10,
                                        padding: '4px 8px',
                                        borderRadius: 8,
                                        background: 'rgba(0,0,0,0.55)',
                                        border: '1px solid rgba(255,140,0,0.35)',
                                        color: '#ffb74d',
                                        fontSize: 11,
                                        fontWeight: 900,
                                        letterSpacing: 0.5
                                    }}>
                                        å›¢é˜Ÿé¦–é¢† Â· {partySize}äºº
                                    </div>

                                    {/* é”å®šé®ç½© */}
                                    {!unlocked && (
                                        <div style={{
                                            position: 'absolute',
                                            top: 0,
                                            left: 0,
                                            right: 0,
                                            bottom: 0,
                                            background: 'rgba(0,0,0,0.6)',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center'
                                        }}>
                                            <span style={{ fontSize: 48 }}>ğŸ”’</span>
                                        </div>
                                    )}

                                    {/* åº•éƒ¨æ¸å˜ */}
                                    <div style={{
                                        position: 'absolute',
                                        bottom: 0,
                                        left: 0,
                                        right: 0,
                                        height: '40%',
                                        background: 'linear-gradient(0deg, rgba(0,0,0,0.85) 0%, transparent 100%)',
                                        pointerEvents: 'none'
                                    }} />
                                </div>

                                {/* BOSSåç§° */}
                                <h3 style={{
                                    textAlign: 'center',
                                    color: unlocked ? '#ffb74d' : '#666',
                                    margin: '0 0 12px 0',
                                    fontSize: 20,
                                    textShadow: unlocked ? '0 0 10px rgba(255,140,0,0.25)' : 'none'
                                }}>
                                    {boss.name}
                                </h3>

                                {/* BOSSå±æ€§é¢„è§ˆ */}
                                {unlocked && (
                                    <div style={{
                                        display: 'grid',
                                        gridTemplateColumns: 'repeat(3, 1fr)',
                                        gap: 8,
                                        marginBottom: 16,
                                        padding: 10,
                                        background: 'rgba(0,0,0,0.3)',
                                        borderRadius: 6
                                    }}>
                                        <div style={{ textAlign: 'center' }}>
                                            <div style={{ fontSize: 10, color: '#888' }}>ç”Ÿå‘½</div>
                                            <div style={{ fontSize: 12, color: '#f44336', fontWeight: 600 }}>
                                                {(bossData.maxHp || boss.hp)?.toLocaleString()}
                                            </div>
                                        </div>
                                        <div style={{ textAlign: 'center' }}>
                                            <div style={{ fontSize: 10, color: '#888' }}>æ”»å‡»</div>
                                            <div style={{ fontSize: 12, color: '#ff9800', fontWeight: 600 }}>
                                                {bossData.attack || boss.attack}
                                            </div>
                                        </div>
                                        <div style={{ textAlign: 'center' }}>
                                            <div style={{ fontSize: 10, color: '#888' }}>é˜²å¾¡</div>
                                            <div style={{ fontSize: 12, color: '#4CAF50', fontWeight: 600 }}>
                                                {bossData.defense || boss.defense}
                                            </div>
                                        </div>
                                    </div>
                                )}

                                {/* æŒ‘æˆ˜æŒ‰é’® / è§£é”æ¡ä»¶ */}
                                {unlocked ? (
                                    <div>
                                        {cdSeconds > 0 && (
                                            <div style={{
                                                textAlign: 'center',
                                                marginBottom: 10,
                                                padding: '8px 10px',
                                                background: 'rgba(0,0,0,0.25)',
                                                border: '1px solid rgba(255,255,255,0.08)',
                                                borderRadius: 6,
                                                color: '#ffd700',
                                                fontSize: 12
                                            }}>
                                                â³ é‡ç”Ÿå†·å´ä¸­ï¼š<b>{cdText}</b>
                                            </div>
                                        )}
                                        <Button
                                            variant="danger"
                                            style={{
                                                width: '100%',
                                                padding: '10px 16px',
                                                fontSize: 14,
                                                fontWeight: 600,
                                                opacity: cdSeconds > 0 ? 0.6 : 1
                                            }}
                                            disabled={cdSeconds > 0}
                                            onClick={() => dispatch({ type: 'OPEN_BOSS_PREPARE', payload: boss.id })}
                                        >
                                            {cdSeconds > 0 ? `â³ é‡ç”Ÿä¸­ (${cdText})` : 'ğŸ”¥ è¿›å…¥å‡†å¤‡'}
                                        </Button>
                                    </div>
                                ) : (
                                    <div style={{
                                        textAlign: 'center',
                                        color: '#666',
                                        padding: '10px',
                                        background: 'rgba(0,0,0,0.2)',
                                        borderRadius: 6,
                                        fontSize: 12
                                    }}>
                                        ğŸ”’ éœ€è¦ç­‰çº§ {boss.unlockLevel || 0}
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>
            </div>

            {showVault && (
                <GrandVaultModal
                    rows={vaultRows}
                    inventoryFull={(state.inventory?.length || 0) >= (state.inventorySize || 0)}
                    onClose={() => setShowVault(false)}
                    onClaim={(templateId) => {
                        if (!templateId) return;
                        dispatch({ type: 'CLAIM_GRAND_VAULT_REWARD', payload: { templateId } });
                        setShowVault(false);
                    }}
                />
            )}
        </Panel>
    );
};

// ==================== PAGE: ACHIEVEMENT ====================
const AchievementPage = ({ state }) => {
    return (
        <Panel title="æˆå°±">
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: 12 }}>
                {Object.values(ACHIEVEMENTS).map(achievement => {
                    const unlocked = state.achievements[achievement.id];
                    const bonusText = formatBonusText(achievement.reward);

                    return (
                        <div
                            key={achievement.id}
                            style={{
                                padding: 16,
                                background: unlocked ? 'rgba(201,162,39,0.2)' : 'rgba(0,0,0,0.3)',
                                border: `2px solid ${unlocked ? '#c9a227' : '#4a3c2a'}`,
                                borderRadius: 6,
                                opacity: unlocked ? 1 : 0.6
                            }}
                        >
                            <div style={{ fontSize: 32, textAlign: 'center', marginBottom: 8 }}>
                                {achievement.icon}
                            </div>

                            <h4 style={{
                                margin: '0 0 8px 0',
                                fontSize: 14,
                                color: unlocked ? '#ffd700' : '#888',
                                textAlign: 'center'
                            }}>
                                {achievement.name}
                            </h4>

                            <div style={{
                                fontSize: 11,
                                color: '#aaa',
                                textAlign: 'center',
                                marginBottom: 8
                            }}>
                                {achievement.description}
                            </div>

                            {/* âœ… BONUS å±•ç¤ºï¼ˆå·²è§£é”æ˜¾ç¤ºâ€œå·²è·å¾—â€ï¼Œæœªè§£é”æ˜¾ç¤ºâ€œå¥–åŠ±é¢„è§ˆâ€ä¹Ÿè¡Œï¼‰ */}
                            {!!bonusText && (
                                <div style={{
                                    fontSize: 11,
                                    color: unlocked ? '#4CAF50' : '#9aa0a6',
                                    textAlign: 'center',
                                    padding: '6px 8px',
                                    background: unlocked ? 'rgba(76,175,80,0.10)' : 'rgba(255,255,255,0.04)',
                                    borderRadius: 6,
                                    border: unlocked ? '1px solid rgba(76,175,80,0.25)' : '1px solid rgba(255,255,255,0.08)',
                                    marginBottom: 8
                                }}>
                                    {unlocked ? `å¥–åŠ±ï¼š${bonusText}` : `å¥–åŠ±ï¼š${bonusText}`}
                                </div>
                            )}

                            {unlocked && (
                                <div style={{
                                    fontSize: 10,
                                    color: '#4CAF50',
                                    textAlign: 'center',
                                    padding: '4px 8px',
                                    background: 'rgba(76,175,80,0.1)',
                                    borderRadius: 4
                                }}>
                                    âœ“ å·²è§£é”
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        </Panel>
    );
};


// ==================== PAGE: CODEX ====================
const CodexPage = ({ state, dispatch }) => {
    const [tab, setTab] = React.useState('equipment'); // 'equipment' | 'junk' | 'effects'
// ===== è£…å¤‡æ‚¬æµ®æç¤ºï¼ˆå®ä¼Ÿå®åº“é£æ ¼ï¼‰=====
    const [hoveredEquip, setHoveredEquip] = React.useState(null); // { tpl, unlocked, lv100, dropEnabled }
    const [tooltipPos, setTooltipPos] = React.useState({ x: 0, y: 0 });

    const STAT_LABELS = {
        hp: 'ç”Ÿå‘½å€¼',
        mp: 'æ³•åŠ›å€¼',
        attack: 'æ”»å‡»',
        spellPower: 'æ³•æœ¯å¼ºåº¦',
        armor: 'æŠ¤ç”²',
        magicResist: 'æ³•æœ¯æŠ—æ€§',
        blockValue: 'æ ¼æŒ¡å€¼',
        blockRate: 'æ ¼æŒ¡ç‡',
        critRate: 'æš´å‡»',
        haste: 'æ€¥é€Ÿ',
        mastery: 'ç²¾é€š',
        versatility: 'å…¨èƒ½',
        critDamage: 'æš´å‡»ä¼¤å®³',
        lifeSteal: 'å¸è¡€',
        dodgeRate: 'é—ªé¿',
    };

    const SLOT_LABELS = {
        head: 'å¤´éƒ¨',
        chest: 'èƒ¸éƒ¨',
        legs: 'è…¿éƒ¨',
        hands: 'æ‰‹éƒ¨',
        feet: 'è„šéƒ¨',
        shoulder: 'è‚©éƒ¨',
        waist: 'è…°éƒ¨',
        wrist: 'æ‰‹è…•',
        neck: 'é¡¹é“¾',
        ring: 'æˆ’æŒ‡',
        mainHand: 'ä¸»æ‰‹',
        offHand: 'å‰¯æ‰‹',
        trinket: 'é¥°å“',
    };

    const formatEquipStat = (k, vRaw) => {
        const v = Number(vRaw) || 0;
        const label = STAT_LABELS[k] || k;

        // ç™¾åˆ†æ¯”ç‚¹æ•°ï¼ˆä¾‹å¦‚ æš´å‡»=+6%ï¼‰
        const percentPointStats = new Set(['critRate', 'haste', 'mastery', 'versatility', 'blockRate', 'dodgeRate']);
        if (percentPointStats.has(k)) {
            const val = Math.round(v * 10) / 10;
            const sign = val >= 0 ? '+' : '';
            return { label, value: `${sign}${val}%` };
        }

        // æš´å‡»ä¼¤å®³ï¼šé¢å¤–å€ç‡ï¼ˆ0.10 => +10%ï¼‰
        if (k === 'critDamage') {
            const pct = Math.round(v * 1000) / 10;
            const sign = pct >= 0 ? '+' : '';
            return { label, value: `${sign}${pct}%` };
        }

        const val = Math.floor(v);
        const sign = val >= 0 ? '+' : '';
        return { label, value: `${sign}${val}` };
    };

    const handleEquipMouseMove = (e) => {
        const pad = 16;
        const w = 280;
        const h = 260;
        const vw = window.innerWidth || 1200;
        const vh = window.innerHeight || 800;

        let x = (e.clientX ?? 0) + 18;
        let y = (e.clientY ?? 0) + 18;

        if (x + w + pad > vw) x = (e.clientX ?? 0) - w - 18;
        if (y + h + pad > vh) y = (e.clientY ?? 0) - h - 18;

        x = Math.max(pad, Math.min(vw - w - pad, x));
        y = Math.max(pad, Math.min(vh - h - pad, y));

        setTooltipPos({ x, y });
    };

    const renderEquipTooltip = () => {
        if (!hoveredEquip?.tpl) return null;
        const { tpl, unlocked, lv100, dropEnabled } = hoveredEquip;

        const displayLv = lv100 ? 100 : (Number(tpl.level) || 0);
        const scaled = scaleStats(tpl.baseStats || {}, tpl.growth || {}, displayLv);

        const statLines = Object.entries(scaled)
            .filter(([, v]) => (Number(v) || 0) !== 0)
            .map(([k, v]) => formatEquipStat(k, v));

        const rarityColor = getRarityColor(tpl.rarity);
        const slotText = SLOT_LABELS[tpl.slot] || tpl.slot || 'æœªçŸ¥éƒ¨ä½';

        return (
            <div
                style={{
                    position: 'fixed',
                    left: tooltipPos.x,
                    top: tooltipPos.y,
                    width: 280,
                    zIndex: 9999,
                    pointerEvents: 'none',
                    background: 'linear-gradient(180deg, rgba(18,18,18,0.96), rgba(8,8,8,0.92))',
                    border: '1px solid rgba(255,255,255,0.12)',
                    borderRadius: 10,
                    boxShadow: '0 18px 40px rgba(0,0,0,0.55)',
                    padding: 12,
                }}
            >
                <div style={{ display: 'flex', gap: 10, alignItems: 'center', marginBottom: 8 }}>
                    <div style={{
                        width: 38, height: 38, borderRadius: 8,
                        background: 'rgba(0,0,0,0.35)',
                        border: '1px solid rgba(255,255,255,0.10)',
                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                        flexShrink: 0
                    }}>
                        <ItemIcon item={tpl} size={28} />
                    </div>

                    <div style={{ minWidth: 0 }}>
                        <div style={{
                            fontSize: 13,
                            fontWeight: 900,
                            color: unlocked ? rarityColor : '#666',
                            textShadow: unlocked ? '0 0 10px rgba(0,0,0,0.55)' : 'none',
                            lineHeight: 1.2,
                            whiteSpace: 'nowrap',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                        }}>
                            {tpl.name}
                        </div>

                        <div style={{ marginTop: 2, fontSize: 10, color: '#aaa' }}>
                            {slotText} Â· Lv.{displayLv}{lv100 ? ' âœ¨' : ''}
                        </div>
                    </div>
                </div>

                <div style={{ height: 1, background: 'rgba(255,255,255,0.08)', margin: '8px 0' }} />

                <div style={{ fontSize: 11, color: '#ddd', display: 'flex', flexDirection: 'column', gap: 4 }}>
                    {statLines.length > 0 ? statLines.map((row, i) => (
                        <div key={i} style={{ display: 'flex', justifyContent: 'space-between', gap: 10 }}>
                            <span style={{ color: '#bbb' }}>{row.label}</span>
                            <span style={{ color: '#fff', fontWeight: 800 }}>{row.value}</span>
                        </div>
                    )) : (
                        <div style={{ color: '#777' }}>æ— å±æ€§</div>
                    )}
                </div>

                <div style={{ height: 1, background: 'rgba(255,255,255,0.08)', margin: '10px 0 8px' }} />

                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', fontSize: 10 }}>
                <span style={{ color: unlocked ? '#8ee18e' : '#777' }}>
                    {unlocked ? 'âœ… å·²ç‚¹äº®å›¾é‰´' : 'ğŸ”’ æœªç‚¹äº®å›¾é‰´'}
                </span>
                    <span style={{ color: dropEnabled ? 'rgba(120,220,120,0.9)' : 'rgba(255,80,80,0.9)' }}>
                    æ‰è½ï¼š{dropEnabled ? 'å¼€å¯' : 'å…³é—­'}
                </span>
                </div>
            </div>
        );
    };


    const allowDrop = (id) => state.dropFilters?.[id] !== false;

    // ===== è£…å¤‡å›¾é‰´ =====
    const allEquipTemplates = [
        ...Object.values(FIXED_EQUIPMENTS),
        ...Object.values(QUEST_REWARD_EQUIPMENTS),
    ];
    const equipCodexSet = new Set(state.codex || []);
    const lv100CodexSet = new Set(state.codexEquipLv100 || []);

    const hasLevel100 = (equipmentId) => {
        return lv100CodexSet.has(equipmentId);
    };

    // ===== åƒåœ¾å›¾é‰´ =====
    const allJunkTemplates = Object.values(ITEMS).filter(it => it?.type === 'junk');
    const junkCodexSet = new Set(state.codexJunk || []);

    // ===== åéª‘å›¾é‰´ =====
    const mountTemplates = Array.isArray(MOUNT_CODEX) ? MOUNT_CODEX : [];
    const mountCodexSet = new Set(state.codexMounts || []);

    // ===== Boss å¾½ç« ï¼ˆå¯åœ¨å›¾é‰´é‡Œå¼€å…³æ‰è½ï¼‰ =====
    const badgeTemplates = Object.keys(BADGE_UPGRADE_RULES || {})
        .map(id => ITEMS?.[id])
        .filter(Boolean);

    const TabButton = ({ id, children }) => (
        <button
            onClick={() => setTab(id)}
            style={{
                padding: '8px 14px',
                borderRadius: 6,
                cursor: 'pointer',
                fontFamily: 'inherit',
                fontSize: 12,
                fontWeight: 700,
                border: tab === id ? '2px solid #c9a227' : '2px solid #4a3c2a',
                color: tab === id ? '#ffd700' : '#888',
                background: tab === id
                    ? 'linear-gradient(180deg, rgba(201,162,39,0.25), rgba(139,115,25,0.18))'
                    : 'rgba(0,0,0,0.25)',
                boxShadow: tab === id ? '0 0 12px rgba(255,215,0,0.15)' : 'none',
                transition: 'all 0.15s',
            }}
        >
            {children}
        </button>
    );

    const toggleDrop = (itemId) => {
        dispatch({
            type: 'TOGGLE_DROP_FILTER',
            payload: { itemId }
        });
    };

    const DropTag = ({ enabled }) => (
        <div style={{
            marginTop: 8,
            fontSize: 9,
            fontWeight: 800,
            display: 'inline-block',
            padding: '2px 6px',
            borderRadius: 999,
            border: enabled ? '1px solid rgba(120,220,120,0.5)' : '1px solid rgba(255,80,80,0.55)',
            color: enabled ? 'rgba(120,220,120,0.9)' : 'rgba(255,80,80,0.9)',
            background: enabled ? 'rgba(120,220,120,0.08)' : 'rgba(255,80,80,0.08)',
        }}>
            {enabled ? 'æ‰è½ï¼šå¼€å¯' : 'æ‰è½ï¼šå…³é—­'}
        </div>
    );

    const CardShell = ({ children, onClick, disabledDrop }) => (
        <div
            onClick={onClick}
            style={{
                cursor: 'pointer',
                userSelect: 'none',
                position: 'relative',
                padding: 12,
                borderRadius: 8,
                textAlign: 'center',
                transition: 'all 0.15s',
                outline: 'none',
                opacity: disabledDrop ? 0.55 : 1,
                filter: disabledDrop ? 'grayscale(35%)' : 'none'
            }}
        >
            {children}
            {disabledDrop && (
                <div style={{
                    position: 'absolute',
                    top: 6,
                    right: 6,
                    fontSize: 10,
                    fontWeight: 900,
                    color: 'rgba(255,80,80,0.95)',
                    background: 'rgba(0,0,0,0.45)',
                    padding: '2px 6px',
                    borderRadius: 999,
                    border: '1px solid rgba(255,80,80,0.5)'
                }}>
                    ğŸš«
                </div>
            )}
        </div>
    );

    // ===== å›¾é‰´é›†é½æ•ˆæœæ¸²æŸ“ =====
    const renderEffectsTab = () => {
        return (
            <div>
                <div style={{ fontSize: 12, color: '#888', marginBottom: 16 }}>
                    é›†é½æŒ‡å®šåŒºåŸŸçš„æ‰€æœ‰è£…å¤‡ Lv.100 å›¾é‰´åï¼Œå…¨é˜Ÿæ°¸ä¹…è·å¾—å¯¹åº”åŠ æˆ
                </div>

                <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
                    {CODEX_SET_EFFECTS.map(effect => {
                        const collected = effect.equipIds.filter(id => lv100CodexSet.has(id)).length;
                        const total = effect.equipIds.length;
                        const isComplete = collected === total;
                        const progress = collected / total;

                        return (
                            <div
                                key={effect.id}
                                style={{
                                    padding: 16,
                                    background: isComplete
                                        ? `linear-gradient(135deg, ${effect.color}22, ${effect.color}11)`
                                        : 'rgba(0,0,0,0.3)',
                                    border: isComplete
                                        ? `2px solid ${effect.color}`
                                        : '1px solid #4a3c2a',
                                    borderRadius: 10,
                                    boxShadow: isComplete ? `0 0 20px ${effect.color}33` : 'none',
                                    transition: 'all 0.3s'
                                }}
                            >
                                <div style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    marginBottom: 10
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                                        <span style={{
                                            fontSize: 20,
                                            filter: isComplete ? 'none' : 'grayscale(100%)',
                                            opacity: isComplete ? 1 : 0.5
                                        }}>
                                            {isComplete ? 'âœ…' : 'ğŸ”’'}
                                        </span>
                                        <span style={{
                                            fontSize: 16,
                                            fontWeight: 700,
                                            color: isComplete ? effect.color : '#888'
                                        }}>
                                            {effect.name}
                                        </span>
                                    </div>

                                    <span style={{
                                        fontSize: 13,
                                        fontWeight: 600,
                                        color: isComplete ? '#4CAF50' : '#888',
                                        padding: '4px 10px',
                                        background: isComplete ? 'rgba(76,175,80,0.15)' : 'rgba(0,0,0,0.2)',
                                        borderRadius: 6,
                                        border: isComplete ? '1px solid rgba(76,175,80,0.3)' : '1px solid #333'
                                    }}>
                                        {collected}/{total}
                                    </span>
                                </div>

                                {/* è¿›åº¦æ¡ */}
                                <div style={{
                                    height: 6,
                                    background: 'rgba(0,0,0,0.4)',
                                    borderRadius: 3,
                                    overflow: 'hidden',
                                    marginBottom: 10
                                }}>
                                    <div style={{
                                        height: '100%',
                                        width: `${progress * 100}%`,
                                        background: isComplete
                                            ? `linear-gradient(90deg, ${effect.color}, ${effect.color}cc)`
                                            : 'linear-gradient(90deg, #666, #888)',
                                        borderRadius: 3,
                                        transition: 'width 0.3s'
                                    }} />
                                </div>

                                {/* æ•ˆæœæè¿° */}
                                <div style={{
                                    fontSize: 13,
                                    color: isComplete ? '#fff' : '#666',
                                    padding: '8px 12px',
                                    background: isComplete ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.15)',
                                    borderRadius: 6,
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: 8
                                }}>
                                    <span style={{ color: effect.color, fontWeight: 700 }}>æ•ˆæœï¼š</span>
                                    <span style={{
                                        color: isComplete ? '#ffd700' : '#666',
                                        fontWeight: isComplete ? 600 : 400
                                    }}>
                                        {effect.effect}
                                    </span>
                                    {isComplete && (
                                        <span style={{
                                            marginLeft: 'auto',
                                            fontSize: 11,
                                            color: '#4CAF50',
                                            fontWeight: 700
                                        }}>
                                            ç”Ÿæ•ˆä¸­
                                        </span>
                                    )}
                                </div>

                                {/* è£…å¤‡åˆ—è¡¨ï¼ˆæŠ˜å æ˜¾ç¤ºï¼‰ */}
                                <details style={{ marginTop: 10 }}>
                                    <summary style={{
                                        cursor: 'pointer',
                                        fontSize: 11,
                                        color: '#888',
                                        outline: 'none'
                                    }}>
                                        æŸ¥çœ‹è£…å¤‡åˆ—è¡¨
                                    </summary>
                                    <div style={{
                                        marginTop: 8,
                                        display: 'flex',
                                        flexWrap: 'wrap',
                                        gap: 6
                                    }}>
                                        {effect.equipIds.map(id => {
                                            const tpl = FIXED_EQUIPMENTS[id];
                                            const has100 = lv100CodexSet.has(id);
                                            return (
                                                <span
                                                    key={id}
                                                    style={{
                                                        fontSize: 10,
                                                        padding: '3px 8px',
                                                        borderRadius: 4,
                                                        background: has100 ? 'rgba(76,175,80,0.2)' : 'rgba(0,0,0,0.3)',
                                                        border: has100 ? '1px solid rgba(76,175,80,0.5)' : '1px solid #333',
                                                        color: has100 ? '#4CAF50' : '#666'
                                                    }}
                                                >
                                                    {has100 ? 'âœ“' : 'â—‹'} {tpl?.name || id}
                                                </span>
                                            );
                                        })}
                                    </div>
                                </details>
                            </div>
                        );
                    })}
                </div>

                {/* ç»Ÿè®¡æ€»è§ˆ */}
                <div style={{
                    marginTop: 20,
                    padding: 16,
                    background: 'rgba(201,162,39,0.1)',
                    border: '1px solid rgba(201,162,39,0.3)',
                    borderRadius: 10
                }}>
                    <div style={{ fontSize: 14, color: '#c9a227', fontWeight: 700, marginBottom: 10 }}>
                        ğŸ“Š é›†é½è¿›åº¦æ€»è§ˆ
                    </div>
                    <div style={{ display: 'flex', gap: 16, flexWrap: 'wrap' }}>
                        {CODEX_SET_EFFECTS.map(effect => {
                            const collected = effect.equipIds.filter(id => lv100CodexSet.has(id)).length;
                            const total = effect.equipIds.length;
                            const isComplete = collected === total;
                            return (
                                <div key={effect.id} style={{
                                    fontSize: 12,
                                    color: isComplete ? effect.color : '#666'
                                }}>
                                    {isComplete ? 'âœ…' : 'â¬œ'} {effect.name}
                                </div>
                            );
                        })}
                    </div>
                </div>
            </div>
        );
    };

    return (
        <Panel
            title="å›¾é‰´"
            actions={
                <div style={{ display: 'flex', gap: 8 }}>
                    <TabButton id="effects">âš¡ é›†é½æ•ˆæœ</TabButton>
                    <TabButton id="equipment">ğŸ›¡ï¸ è£…å¤‡</TabButton>
                    <TabButton id="badges">ğŸ… å¾½ç« </TabButton>
                    <TabButton id="mounts">ğŸ´ åéª‘</TabButton>
                    <TabButton id="junk">ğŸ§º åƒåœ¾</TabButton>
                </div>
            }
        >
            {/* ===== é›†é½æ•ˆæœ ===== */}
            {tab === 'effects' && renderEffectsTab()}

            {/* ===== è£…å¤‡å›¾é‰´ ===== */}
            {tab === 'equipment' && (
                <>
                    <div style={{ fontSize: 12, color: '#888', marginBottom: 12 }}>
                        âœ… ç‚¹äº®ï¼šå·²è·å¾—è¿‡ã€€|ã€€âœ¨ é‡‘è¾¹ï¼šå·²è¾¾ Lv.100ã€€|ã€€ç‚¹å‡»åˆ‡æ¢æ‰è½å¼€å…³
                    </div>

                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(auto-fill, minmax(90px, 1fr))',
                        gap: 10
                    }}>
                        {allEquipTemplates.map((tpl) => {
                            const unlocked = equipCodexSet.has(tpl.id);
                            const lv100 = hasLevel100(tpl.id);

                            const dropEnabled = allowDrop(tpl.id);
                            const disabledDrop = !dropEnabled;

                            return (
                                <div
                                    key={tpl.id}
                                    onMouseEnter={(e) => {
                                        setHoveredEquip({ tpl, unlocked, lv100, dropEnabled });
                                        handleEquipMouseMove(e);
                                    }}
                                    onMouseMove={handleEquipMouseMove}
                                    onMouseLeave={() => setHoveredEquip(null)}
                                    style={{
                                        background: unlocked ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.18)',
                                        borderRadius: 8,
                                        border: lv100
                                            ? '2px solid rgba(255, 215, 0, 0.95)'
                                            : `1px solid ${unlocked ? '#4a3c2a' : '#333'}`,
                                        boxShadow: lv100 ? '0 0 10px rgba(255,215,0,0.35)' : 'none',
                                    }}
                                >
                                    <CardShell
                                        onClick={() => toggleDrop(tpl.id)}
                                        disabledDrop={disabledDrop}
                                    >
                                        <div style={{ fontSize: 26, marginBottom: 6 }}>
                                            <ItemIcon item={tpl} size={28} />
                                        </div>

                                        <div style={{
                                            fontSize: 10,
                                            color: unlocked ? '#ffd700' : '#555',
                                            lineHeight: 1.2,
                                            minHeight: 26,
                                            opacity: unlocked ? 1 : 0.7
                                        }}>
                                            {tpl.name}
                                        </div>

                                        <div style={{
                                            marginTop: 6,
                                            fontSize: 9,
                                            color: unlocked ? '#aaa' : '#444'
                                        }}>
                                            {unlocked ? 'å·²è·å–' : 'æœªè·å–'}
                                        </div>

                                        {lv100 && (
                                            <div style={{
                                                marginTop: 6,
                                                fontSize: 9,
                                                color: '#ffd700',
                                                fontWeight: 900
                                            }}>
                                                Lv.100 âœ¨
                                            </div>
                                        )}

                                        <DropTag enabled={dropEnabled} />
                                    </CardShell>
                                </div>
                            );
                        })}
                    </div>
                </>
            )}


            {/* ===== åéª‘å›¾é‰´ ===== */}
            {tab === 'mounts' && (
                <>
                    <div style={{ fontSize: 12, color: '#888', marginBottom: 12 }}>
                        âœ… ç‚¹äº®ï¼šå‡»æ€ä¸–ç•Œé¦–é¢†/åœ°åŒºæˆ˜æ–—èƒœåˆ©æœ‰æ¦‚ç‡è·å¾—åéª‘ï¼Œæˆ–åœ¨æ—¶ç©ºå•†åŸè´­ä¹°
                    </div>

                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(auto-fill, minmax(140px, 1fr))',
                        gap: 10
                    }}>
                        {mountTemplates.map((m) => {
                            const unlocked = mountCodexSet.has(m.id);
                            const bonusText = m.bonus ? formatBonusText(m.bonus) : '';

                            return (
                                <div
                                    key={m.id}
                                    title={`${m.name}${m.dropChance ? `ï¼ˆæ‰è½ç‡ ${Math.round(m.dropChance * 100)}%ï¼‰` : ''}`}
                                    style={{
                                        background: unlocked ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.18)',
                                        borderRadius: 10,
                                        border: unlocked ? '2px solid rgba(255, 215, 0, 0.85)' : '1px solid #333',
                                        boxShadow: unlocked ? '0 0 12px rgba(255,215,0,0.18)' : 'none',
                                        padding: 12,
                                        textAlign: 'center'
                                    }}
                                >
                                    <div style={{
                                        width: '100%',
                                        height: 114,
                                        borderRadius: 8,
                                        background: 'rgba(0,0,0,0.25)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        border: '1px solid rgba(255,255,255,0.08)',
                                        marginBottom: 8,
                                        overflow: 'hidden'
                                    }}>
                                        {m.imageUrl
                                            ? (
                                                <img
                                                    src={m.imageUrl}
                                                    alt={m.name}
                                                    style={{ width: '100%', height: '100%', objectFit: 'cover' }}
                                                />
                                            )
                                            : (
                                                <div style={{ fontSize: 36, opacity: unlocked ? 1 : 0.35 }}>
                                                    {m.icon || 'ğŸ´'}
                                                </div>
                                            )
                                        }
                                    </div>

                                    <div style={{
                                        fontSize: 12,
                                        fontWeight: 800,
                                        color: unlocked ? '#ffd700' : '#555',
                                        lineHeight: 1.2,
                                        minHeight: 28
                                    }}>
                                        {m.name}
                                    </div>

                                    <div style={{ marginTop: 4, fontSize: 10, color: '#777' }}>
                                        {m.source}{m.dropChance ? `ï¼ˆ${Math.round(m.dropChance * 100)}%ï¼‰` : ''}
                                    </div>

                                    {!!bonusText && (
                                        <div style={{
                                            marginTop: 8,
                                            fontSize: 10,
                                            fontWeight: 800,
                                            color: unlocked ? 'rgba(120,220,120,0.95)' : '#666',
                                            background: unlocked ? 'rgba(120,220,120,0.10)' : 'rgba(255,255,255,0.04)',
                                            border: unlocked ? '1px solid rgba(120,220,120,0.25)' : '1px solid rgba(255,255,255,0.08)',
                                            borderRadius: 6,
                                            padding: '6px 8px',
                                        }}>
                                            {bonusText}
                                        </div>
                                    )}

                                    <div style={{ marginTop: 8, fontSize: 9, color: unlocked ? '#aaa' : '#444' }}>
                                        {unlocked ? 'å·²è·å¾—' : 'æœªè·å¾—'}
                                    </div>
                                </div>
                            );
                        })}

                        {mountTemplates.length === 0 && (
                            <div style={{ color: '#666', fontSize: 12 }}>
                                å½“å‰æ²¡æœ‰å®šä¹‰åéª‘
                            </div>
                        )}
                    </div>
                </>
            )}

            {/* ===== å¾½ç« å›¾é‰´ï¼ˆBoss æ‰è½ï¼‰ ===== */}
            {tab === 'badges' && (
                <>
                    <div style={{ fontSize: 12, color: '#888', marginBottom: 12 }}>
                        âœ… ç‚¹äº®ï¼šæ›¾è·å¾—è¿‡è¯¥å¾½ç« ã€€|ã€€ç‚¹å‡»åˆ‡æ¢æ‰è½å¼€å…³ï¼ˆå½±å“ä¸–ç•Œé¦–é¢† / è‡ªåŠ¨å‡»æ€ / å…¶å®ƒæ‰è½æ¥æºï¼‰
                    </div>

                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(auto-fill, minmax(110px, 1fr))',
                        gap: 10
                    }}>
                        {badgeTemplates.map((tpl) => {
                            const unlocked = junkCodexSet.has(tpl.id) || (state.inventory || []).some(i => i?.id === tpl.id);
                            const dropEnabled = allowDrop(tpl.id);
                            const disabledDrop = !dropEnabled;

                            return (
                                <div
                                    key={tpl.id}
                                    title={`${tpl.name}ï¼ˆç‚¹å‡»å¼€å…³æ‰è½ï¼‰`}
                                    style={{
                                        background: unlocked ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.18)',
                                        borderRadius: 8,
                                        border: `1px solid ${unlocked ? '#4a3c2a' : '#333'}`,
                                    }}
                                >
                                    <CardShell
                                        onClick={() => toggleDrop(tpl.id)}
                                        disabledDrop={disabledDrop}
                                    >
                                        <div style={{ fontSize: 26, marginBottom: 6 }}>
                                            <ItemIcon item={tpl} size={28} />
                                        </div>

                                        <div style={{
                                            fontSize: 10,
                                            color: unlocked ? '#ffd700' : '#555',
                                            lineHeight: 1.2,
                                            minHeight: 30,
                                            opacity: unlocked ? 1 : 0.7
                                        }}>
                                            {tpl.name}
                                        </div>

                                        <div style={{
                                            marginTop: 6,
                                            fontSize: 9,
                                            color: unlocked ? '#aaa' : '#444'
                                        }}>
                                            {unlocked ? 'å·²è·å–' : 'æœªè·å–'}
                                        </div>

                                        <DropTag enabled={dropEnabled} />
                                    </CardShell>
                                </div>
                            );
                        })}

                        {badgeTemplates.length === 0 && (
                            <div style={{ color: '#666', fontSize: 12 }}>
                                å½“å‰æ²¡æœ‰å®šä¹‰ Boss å¾½ç« 
                            </div>
                        )}
                    </div>
                </>
            )}

            {/* ===== åƒåœ¾å›¾é‰´ ===== */}
            {tab === 'junk' && (
                <>
                    <div style={{ fontSize: 12, color: '#888', marginBottom: 12 }}>
                        âœ… ç‚¹äº®ï¼šå·²è·å¾—è¿‡è¯¥åƒåœ¾ã€€|ã€€ç‚¹å‡»åˆ‡æ¢æ‰è½å¼€å…³
                    </div>

                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(auto-fill, minmax(90px, 1fr))',
                        gap: 10
                    }}>
                        {allJunkTemplates.map((tpl) => {
                            const unlocked = junkCodexSet.has(tpl.id);

                            const dropEnabled = allowDrop(tpl.id);
                            const disabledDrop = !dropEnabled;

                            return (
                                <div
                                    key={tpl.id}
                                    title={`${tpl.name}ï¼ˆç‚¹å‡»å¼€å…³æ‰è½ï¼‰`}
                                    style={{
                                        background: unlocked ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.18)',
                                        borderRadius: 8,
                                        border: `1px solid ${unlocked ? '#4a3c2a' : '#333'}`,
                                    }}
                                >
                                    <CardShell
                                        onClick={() => toggleDrop(tpl.id)}
                                        disabledDrop={disabledDrop}
                                    >
                                        <div style={{ fontSize: 26, marginBottom: 6 }}>
                                            <ItemIcon item={tpl} size={26} />
                                        </div>

                                        <div style={{
                                            fontSize: 10,
                                            color: unlocked ? '#ffd700' : '#555',
                                            lineHeight: 1.2,
                                            minHeight: 26,
                                            opacity: unlocked ? 1 : 0.7
                                        }}>
                                            {tpl.name}
                                        </div>

                                        <div style={{
                                            marginTop: 6,
                                            fontSize: 9,
                                            color: unlocked ? '#aaa' : '#444'
                                        }}>
                                            {unlocked ? 'å·²è·å–' : 'æœªè·å–'}
                                        </div>

                                        <div style={{
                                            marginTop: 4,
                                            fontSize: 9,
                                            color: unlocked ? '#888' : '#444'
                                        }}>
                                            ğŸª™ {tpl.sellPrice || 0}
                                        </div>

                                        <DropTag enabled={dropEnabled} />
                                    </CardShell>
                                </div>
                            );
                        })}

                        {allJunkTemplates.length === 0 && (
                            <div style={{ color: '#666', fontSize: 12 }}>
                                å½“å‰æ²¡æœ‰å®šä¹‰åƒåœ¾ç‰©å“
                            </div>
                        )}
                    </div>
                </>
            )}
            {renderEquipTooltip()}

        </Panel>
    );
};

// ==================== ä»»åŠ¡ç³»ç»Ÿæ•°æ®ç»“æ„ ====================

// ä»»åŠ¡çŠ¶æ€å¸¸é‡
const QUEST_STATUS = {
    NOT_STARTED: 'not_started',
    IN_PROGRESS: 'in_progress',
    COMPLETED: 'completed',
    FAILED: 'failed'
};

// èŒƒå…‹é‡Œå¤«é€šç¼‰ä»¤ä»»åŠ¡çº¿
const QUEST_CHAINS = {
    vancleef_wanted: {
        id: 'vancleef_wanted',
        name: 'èŒƒå…‹é‡Œå¤«é€šç¼‰ä»¤',
        description: 'æš´é£åŸå‘å¸ƒäº†å¯¹èŒƒå…‹é‡Œå¤«çš„é€šç¼‰ä»¤ï¼Œä½†äº‹æƒ…ä¼¼ä¹å¹¶ä¸ç®€å•...',
        icon: 'ğŸ“œ',
        unlockCondition: {
            type: 'boss_defeated',
            bossId: 'hogger'  // éœ€è¦å…ˆå‡»è´¥éœæ ¼
        },
        resetsOnRebirth: true,  // è½®å›é‡ç½®

        // ä»»åŠ¡æ­¥éª¤
        steps: {
            // ==================== ç¬¬ä¸€æ­¥ï¼šæ¥å—ä»»åŠ¡ ====================
            step_1_accept: {
                id: 'step_1_accept',
                title: 'ç¥ç§˜çš„é€šç¼‰ä»¤',
                description: 'ä½ åœ¨æš´é£åŸå…¬å‘Šæ¿ä¸Šå‘ç°äº†ä¸€å¼ é€šç¼‰ä»¤ï¼Œä¸Šé¢å†™ç€"è¿ªè²äºšå…„å¼Ÿä¼šé¦–é¢† è‰¾å¾·æ¸©Â·èŒƒå…‹é‡Œå¤«"ã€‚ä¸€ä½ç¥ç§˜çš„è´µæ—å¥³å£«æ­£åœ¨ä¸€æ—è§‚å¯Ÿç€...',
                dialogues: [
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'å•Šï¼Œå†’é™©è€…ï¼Œä½ å¯¹è¿™å¼ é€šç¼‰ä»¤æ„Ÿå…´è¶£å—ï¼ŸèŒƒå…‹é‡Œå¤«æ›¾æ˜¯æš´é£åŸçš„å·¥åŒ å¤§å¸ˆï¼Œå¦‚ä»Šå´æ²¦ä¸ºé€šç¼‰çŠ¯...'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'ä»–å¸¦é¢†è¿ªè²äºšå…„å¼Ÿä¼šåœ¨è¥¿éƒ¨è’é‡è‚†è™ï¼Œå¿…é¡»æœ‰äººé˜»æ­¢ä»–ã€‚ä½ æ„¿æ„æ¥å—è¿™ä¸ªä»»åŠ¡å—ï¼Ÿ'
                    }
                ],
                choices: [
                    {
                        id: 'accept_quest',
                        text: 'æ¥å—ä»»åŠ¡ï¼Œè¿½æŸ¥èŒƒå…‹é‡Œå¤«',
                        nextStep: 'step_2_investigate',
                        rewards: { gold: 500 }
                    },
                    {
                        id: 'ask_more',
                        text: 'æˆ‘æƒ³å…ˆäº†è§£æ›´å¤šå…³äºèŒƒå…‹é‡Œå¤«çš„äº‹æƒ…',
                        nextStep: 'step_1b_background',
                        rewards: null
                    },
                    {
                        id: 'refuse',
                        text: 'è¿™ä¸å…³æˆ‘çš„äº‹ï¼ˆç»“æŸä»»åŠ¡çº¿ï¼‰',
                        nextStep: null,
                        endQuest: true,
                        rewards: null
                    }
                ]
            },

            // ==================== ç¬¬ä¸€æ­¥åˆ†æ”¯ï¼šäº†è§£èƒŒæ™¯ ====================
            step_1b_background: {
                id: 'step_1b_background',
                title: 'èŒƒå…‹é‡Œå¤«çš„è¿‡å»',
                description: 'ä½ è¯¢é—®æ™®ç‘æ–¯æ‰˜å¥³å£«å…³äºèŒƒå…‹é‡Œå¤«çš„æ›´å¤šä¿¡æ¯...',
                dialogues: [
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'èŒƒå…‹é‡Œå¤«...ä»–æ›¾æ˜¯æš´é£åŸé‡å»ºå·¥ç¨‹çš„é¦–å¸­å·¥åŒ ã€‚åœ¨å…½äººæˆ˜äº‰åï¼Œä»–å¸¦é¢†å·¥åŒ ä»¬é‡å»ºäº†è¿™åº§åŸå¸‚ã€‚'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'ä½†åæ¥...è´µæ—ä»¬æ‹’ç»æ”¯ä»˜å·¥åŒ ä»¬åº”å¾—çš„æŠ¥é…¬ã€‚èŒƒå…‹é‡Œå¤«æ„¤æ€’åœ°ç¦»å¼€ï¼Œåˆ›å»ºäº†è¿ªè²äºšå…„å¼Ÿä¼šã€‚'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆå¥¹è¯´è¯æ—¶çœ¼ç¥é—ªçƒï¼Œä¼¼ä¹æœ‰æ‰€éšç’...ï¼‰'
                    }
                ],
                choices: [
                    {
                        id: 'accept_after_info',
                        text: 'æˆ‘æ˜ç™½äº†ï¼Œæˆ‘ä¼šè¿½æŸ¥èŒƒå…‹é‡Œå¤«',
                        nextStep: 'step_2_investigate',
                        rewards: { gold: 500 },
                        flagSet: ['knows_background']  // è®¾ç½®æ ‡è®°
                    },
                    {
                        id: 'suspicious',
                        text: 'ä¸ºä»€ä¹ˆè´µæ—ä¸ä»˜é’±ï¼Ÿæ˜¯è°åšçš„å†³å®šï¼Ÿ',
                        nextStep: 'step_1c_suspicion',
                        rewards: null,
                        flagSet: ['suspicious_of_nobles']
                    }
                ]
            },

            // ==================== ç¬¬ä¸€æ­¥åˆ†æ”¯ï¼šäº§ç”Ÿæ€€ç–‘ ====================
            step_1c_suspicion: {
                id: 'step_1c_suspicion',
                title: 'è´µæ—çš„ç§˜å¯†',
                description: 'ä½ çš„é—®é¢˜ä¼¼ä¹è§¦åŠ¨äº†æ™®ç‘æ–¯æ‰˜å¥³å£«çš„ç¥ç»...',
                dialogues: [
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: '...è¿™æ˜¯å¾ˆä¹…ä»¥å‰çš„äº‹äº†ã€‚å½“æ—¶çš„è´µæ—è®®ä¼šåšå‡ºäº†å†³å®šï¼Œæˆ‘ä¹Ÿæ— èƒ½ä¸ºåŠ›ã€‚'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆå¥¹çš„è¯­æ°”å˜å¾—å†·æ·¡ã€‚ä¹Ÿè®¸æˆ‘åº”è¯¥å¦å¤–è°ƒæŸ¥ä¸€ä¸‹...ï¼‰'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'æ— è®ºå¦‚ä½•ï¼ŒèŒƒå…‹é‡Œå¤«ç°åœ¨æ˜¯é€šç¼‰çŠ¯ã€‚ä½ æ˜¯è¦å¸®åŠ©æš´é£åŸï¼Œè¿˜æ˜¯è¦è¢–æ‰‹æ—è§‚ï¼Ÿ'
                    }
                ],
                choices: [
                    {
                        id: 'accept_suspicious',
                        text: 'æˆ‘ä¼šå»è°ƒæŸ¥çš„ï¼ˆä½†æˆ‘ä¼šä¿æŒè­¦æƒ•ï¼‰',
                        nextStep: 'step_2_investigate',
                        rewards: { gold: 500 },
                        flagSet: ['deeply_suspicious']
                    },
                    {
                        id: 'investigate_nobles',
                        text: 'æˆ‘æƒ³å…ˆè°ƒæŸ¥ä¸€ä¸‹è´µæ—è®®ä¼šçš„è®°å½•',
                        nextStep: 'step_2_alt_investigate_nobles',
                        rewards: null,
                        flagSet: ['investigating_nobles']
                    }
                ]
            },

            // ==================== ç¬¬äºŒæ­¥ï¼šè°ƒæŸ¥èŒƒå…‹é‡Œå¤« ====================
            step_2_investigate: {
                id: 'step_2_investigate',
                title: 'è¥¿éƒ¨è’é‡çš„è°ƒæŸ¥',
                description: 'ä½ å‰å¾€è¥¿éƒ¨è’é‡è°ƒæŸ¥è¿ªè²äºšå…„å¼Ÿä¼šçš„æ´»åŠ¨...',
                requirement: {
                    type: 'zone_battles',
                    zoneId: 'westfall',
                    count: 10
                },
                dialogues: [
                    {
                        speaker: 'å†œå¤«',
                        portrait: 'ğŸ‘¨â€ğŸŒ¾',
                        text: 'è¿ªè²äºšï¼Ÿä»–ä»¬ç¡®å®åœ¨è¿™é‡Œæ´»åŠ¨...ä½†ä½ çŸ¥é“å—ï¼Œä»–ä»¬ä»ä¸ä¼¤å®³æˆ‘ä»¬è¿™äº›å¹³æ°‘ã€‚'
                    },
                    {
                        speaker: 'å†œå¤«',
                        portrait: 'ğŸ‘¨â€ğŸŒ¾',
                        text: 'ä»–ä»¬åªæ”»å‡»é‚£äº›ä¸ºè´µæ—å·¥ä½œçš„å•†é˜Ÿã€‚æœ‰äººè¯´ï¼ŒèŒƒå…‹é‡Œå¤«æ˜¯è¢«å†¤æ‰çš„...'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆåœ¨æˆ˜æ–—ä¸­ï¼Œä½ å‘ç°äº†ä¸€äº›å¥‡æ€ªçš„æ–‡ä»¶...ï¼‰'
                    }
                ],
                onComplete: {
                    giveItem: 'IT_DEFIAS_DOCUMENT'  // ç»™äºˆè¿ªè²äºšæ–‡ä»¶
                },
                choices: [
                    {
                        id: 'continue_hunt',
                        text: 'ç»§ç»­è¿½æ•èŒƒå…‹é‡Œå¤«',
                        nextStep: 'step_3_deadmines',
                        rewards: { gold: 1000, exp: 2000 }
                    },
                    {
                        id: 'read_documents',
                        text: 'ä»”ç»†ç ”ç©¶è¿™äº›æ–‡ä»¶',
                        nextStep: 'step_2b_read_documents',
                        rewards: { exp: 1000 },
                        requireFlag: null  // æ‰€æœ‰äººéƒ½èƒ½é€‰
                    }
                ]
            },

            // ==================== ç¬¬äºŒæ­¥æ›¿ä»£ï¼šè°ƒæŸ¥è´µæ— ====================
            step_2_alt_investigate_nobles: {
                id: 'step_2_alt_investigate_nobles',
                title: 'æš´é£åŸæ¡£æ¡ˆé¦†',
                description: 'ä½ æ½œå…¥æš´é£åŸæ¡£æ¡ˆé¦†ï¼Œå¯»æ‰¾å½“å¹´å·¥ç¨‹æ¬¾çš„è®°å½•...',
                requirement: {
                    type: 'have_gold',
                    amount: 2000  // éœ€è¦è´¿èµ‚å®ˆå«
                },
                dialogues: [
                    {
                        speaker: 'æ¡£æ¡ˆç®¡ç†å‘˜',
                        portrait: 'ğŸ“š',
                        text: 'ï¼ˆåœ¨æ”¶ä¸‹ä½ çš„"ææ¬¾"åï¼‰å¥½å§...è¿™æ˜¯å½“å¹´çš„è´¢åŠ¡è®°å½•ã€‚'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆè®°å½•æ˜¾ç¤ºï¼Œå·¥ç¨‹æ¬¾è¢«ä¸€ä½"Kå¥³å£«"æ‰¹å‡†è½¬ç§»åˆ°äº†å…¶ä»–ç”¨é€”...Kï¼Ÿæ™®ç‘æ–¯æ‰˜ï¼Ÿï¼‰'
                    }
                ],
                onComplete: {
                    giveItem: 'IT_FINANCIAL_RECORD',
                    flagSet: ['found_financial_proof']
                },
                choices: [
                    {
                        id: 'confront_prestor',
                        text: 'ç›´æ¥è´¨é—®æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        nextStep: 'step_3_alt_confront',
                        rewards: { exp: 3000 }
                    },
                    {
                        id: 'gather_more_evidence',
                        text: 'ç»§ç»­æ”¶é›†æ›´å¤šè¯æ®',
                        nextStep: 'step_3_alt_more_evidence',
                        rewards: { exp: 2000 }
                    }
                ]
            },

            // ==================== ç¬¬äºŒæ­¥åˆ†æ”¯ï¼šé˜…è¯»æ–‡ä»¶ ====================
            step_2b_read_documents: {
                id: 'step_2b_read_documents',
                title: 'è¿ªè²äºšçš„çœŸç›¸',
                description: 'ä½ ä»”ç»†é˜…è¯»äº†ä»è¿ªè²äºšæˆå‘˜èº«ä¸Šæœåˆ°çš„æ–‡ä»¶...',
                dialogues: [
                    {
                        speaker: 'ï¼ˆæ–‡ä»¶å†…å®¹ï¼‰',
                        portrait: 'ğŸ“„',
                        text: '"...æš´é£åŸè´µæ—èƒŒå›äº†æˆ‘ä»¬ã€‚æˆ‘ä»¬å»ºé€ äº†è¿™åº§åŸå¸‚ï¼Œå´è¢«åƒç‹—ä¸€æ ·èµ¶èµ°..."'
                    },
                    {
                        speaker: 'ï¼ˆæ–‡ä»¶å†…å®¹ï¼‰',
                        portrait: 'ğŸ“„',
                        text: '"...é‚£ä¸ªå¥³äººï¼Œå¥¹æ“æ§äº†ä¸€åˆ‡ã€‚å¥¹ä¸æ˜¯äººç±»ï¼Œå¥¹æ˜¯...é¾™..."'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜®',
                        text: 'ï¼ˆé¾™ï¼Ÿè¿™å¬èµ·æ¥å¤ªç–¯ç‹‚äº†...ä½†å¦‚æœæ˜¯çœŸçš„å‘¢ï¼Ÿï¼‰'
                    }
                ],
                onComplete: {
                    flagSet: ['knows_dragon_secret']
                },
                choices: [
                    {
                        id: 'dismiss_as_crazy',
                        text: 'è¿™æ˜¯ç–¯è¯ï¼Œç»§ç»­è¿½æ•èŒƒå…‹é‡Œå¤«',
                        nextStep: 'step_3_deadmines',
                        rewards: { gold: 1000, exp: 2000 }
                    },
                    {
                        id: 'investigate_dragon',
                        text: 'è°ƒæŸ¥è¿™ä¸ª"é¾™"çš„è¯´æ³•',
                        nextStep: 'step_3_dragon_investigation',
                        rewards: { exp: 3000 },
                        flagSet: ['pursuing_dragon_truth']
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥ï¼šè¿›æ”»æ­»äº¡çŸ¿äº• ====================
            step_3_deadmines: {
                id: 'step_3_deadmines',
                title: 'æ­»äº¡çŸ¿äº•',
                description: 'ä½ è¿½è¸ªèŒƒå…‹é‡Œå¤«åˆ°äº†ä»–çš„è€å·¢â€”â€”æ­»äº¡çŸ¿äº•...',
                requirement: {
                    type: 'character_level',
                    level: 25
                },
                dialogues: [
                    {
                        speaker: 'è¿ªè²äºšå®ˆå«',
                        portrait: 'âš”ï¸',
                        text: 'å…¥ä¾µè€…ï¼ä¿æŠ¤é˜Ÿé•¿ï¼'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆæ·±å…¥çŸ¿äº•ï¼Œä½ å‘ç°è¿™é‡Œæ­£åœ¨å»ºé€ ä¸€è‰˜å·¨å¤§çš„æˆ˜èˆ¹...èŒƒå…‹é‡Œå¤«åœ¨è®¡åˆ’ä»€ä¹ˆï¼Ÿï¼‰'
                    }
                ],
                choices: [
                    {
                        id: 'fight_vancleef',
                        text: 'ç›´æ¥ä¸èŒƒå…‹é‡Œå¤«æˆ˜æ–—',
                        nextStep: 'step_4_final_battle_vancleef',
                        rewards: { gold: 2000 }
                    },
                    {
                        id: 'talk_to_vancleef',
                        text: 'å°è¯•ä¸èŒƒå…‹é‡Œå¤«å¯¹è¯',
                        nextStep: 'step_3b_talk_vancleef',
                        rewards: null,
                        requireFlag: ['knows_background']  // éœ€è¦äº†è§£èƒŒæ™¯
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥åˆ†æ”¯ï¼šä¸èŒƒå…‹é‡Œå¤«å¯¹è¯ ====================
            step_3b_talk_vancleef: {
                id: 'step_3b_talk_vancleef',
                title: 'å·¥åŒ å¤§å¸ˆçš„æ‚²æ­Œ',
                description: 'ä½ é€‰æ‹©ä¸èŒƒå…‹é‡Œå¤«å¯¹è¯ï¼Œè€Œä¸æ˜¯ç«‹å³æˆ˜æ–—...',
                dialogues: [
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: '...ä½ å±…ç„¶æ„¿æ„å¬æˆ‘è¯´è¯ï¼Ÿå¤§å¤šæ•°"è‹±é›„"æ—©å°±æŒ¥å‰‘ç è¿‡æ¥äº†ã€‚'
                    },
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'æˆ‘ä»¬å»ºé€ äº†æš´é£åŸï¼Œç –ä¸€ç –ï¼ŒçŸ³ä¸€çŸ³ã€‚æˆ˜äº‰ç»“æŸåï¼Œè´µæ—ä»¬è¯´å›½åº“ç©ºè™šï¼Œæ— æ³•æ”¯ä»˜å·¥é’±ã€‚'
                    },
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'ä½†æˆ‘çŸ¥é“çœŸç›¸ã€‚æ˜¯é‚£ä¸ªå¥³äºº...æ™®ç‘æ–¯æ‰˜...å¥¹æŠŠé’±è½¬èµ°äº†ã€‚å¥¹ä¸æ˜¯äººç±»ï¼'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ä½ è¯´å¥¹ä¸æ˜¯äººç±»ï¼Ÿä½ æœ‰è¯æ®å—ï¼Ÿ'
                    },
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'æˆ‘è§è¿‡å¥¹å˜èº«...åœ¨å°˜æ³¥æ²¼æ³½çš„æ·±å¤„ï¼Œå¥¹æœ‰ä¸€ä¸ªå·¢ç©´ã€‚å»é‚£é‡Œæ‰¾è¯æ®å§ã€‚'
                    }
                ],
                onComplete: {
                    flagSet: ['allied_with_vancleef']
                },
                choices: [
                    {
                        id: 'believe_vancleef',
                        text: 'æˆ‘ç›¸ä¿¡ä½ ã€‚æˆ‘ä¼šå»è°ƒæŸ¥æ™®ç‘æ–¯æ‰˜',
                        nextStep: 'step_4_dragon_hunt',
                        rewards: { exp: 5000 },
                        flagSet: ['full_alliance']
                    },
                    {
                        id: 'still_arrest',
                        text: 'ä¸ç®¡æ€æ ·ï¼Œä½ ä»ç„¶æ˜¯é€šç¼‰çŠ¯',
                        nextStep: 'step_4_final_battle_vancleef',
                        rewards: { gold: 2000 }
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥æ›¿ä»£ï¼šè°ƒæŸ¥é¾™ ====================
            step_3_dragon_investigation: {
                id: 'step_3_dragon_investigation',
                title: 'è¿½å¯»é»‘é¾™çš„è¸ªè¿¹',
                description: 'ä½ å¼€å§‹è°ƒæŸ¥æ–‡ä»¶ä¸­æåˆ°çš„"é¾™"...',
                requirement: {
                    type: 'zone_battles',
                    zoneId: 'dustwallow_marsh',
                    count: 15
                },
                dialogues: [
                    {
                        speaker: 'å¡æ‹‰æ‘©æ³•å¸ˆ',
                        portrait: 'ğŸ§™',
                        text: 'é»‘é¾™ï¼Ÿåœ¨è¿™ç‰‡æ²¼æ³½ç¡®å®æœ‰é¾™çš„æ´»åŠ¨ç—•è¿¹...å¥¥å¦®å…‹å¸Œäºšçš„å·¢ç©´å°±åœ¨é™„è¿‘ã€‚'
                    },
                    {
                        speaker: 'å¡æ‹‰æ‘©æ³•å¸ˆ',
                        portrait: 'ğŸ§™',
                        text: 'æœ‰ä¼ è¨€è¯´ï¼Œé»‘é¾™å…¬ä¸»ä¼šåŒ–èº«ä¸ºäººç±»ï¼Œæ½œä¼åœ¨å„å›½çš„æƒåŠ›ä¸­å¿ƒ...'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜®',
                        text: 'ï¼ˆè¿™ä¸è¿ªè²äºšæ–‡ä»¶ä¸­çš„æè¿°å»åˆ...æ™®ç‘æ–¯æ‰˜å¥³å£«...ï¼‰'
                    }
                ],
                onComplete: {
                    giveItem: 'IT_DRAGON_SCALE_SAMPLE'
                },
                choices: [
                    {
                        id: 'find_more_proof',
                        text: 'å¯»æ‰¾æ›´å¤šè¯æ®è¯æ˜æ™®ç‘æ–¯æ‰˜çš„èº«ä»½',
                        nextStep: 'step_4_dragon_hunt',
                        rewards: { exp: 5000 }
                    },
                    {
                        id: 'report_to_king',
                        text: 'ç›´æ¥å‘å›½ç‹æŠ¥å‘Š',
                        nextStep: 'step_3c_report_king',
                        rewards: { gold: 3000 }
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥æ›¿ä»£ï¼šå‘å›½ç‹æŠ¥å‘Š ====================
            step_3c_report_king: {
                id: 'step_3c_report_king',
                title: 'å›½ç‹çš„æ€’ç«',
                description: 'ä½ è¯•å›¾å‘ç“¦é‡Œå®‰Â·ä¹Œç‘æ©å›½ç‹æŠ¥å‘Šæ™®ç‘æ–¯æ‰˜çš„çœŸå®èº«ä»½...',
                dialogues: [
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'ï¼ˆå¥¹æ°å¥½åœ¨åœºï¼‰é™›ä¸‹ï¼Œè¿™ä¸ªå†’é™©è€…åœ¨æ•£å¸ƒå…³äºæˆ‘çš„è°£è¨€...'
                    },
                    {
                        speaker: 'å›½ç‹',
                        portrait: 'ğŸ‘‘',
                        text: 'æ™®ç‘æ–¯æ‰˜å¥³å£«æ˜¯ç‹å›½æœ€å¿ è¯šçš„é¡¾é—®ï¼ä½ æœ‰è¯æ®å—ï¼Ÿ'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜°',
                        text: 'ï¼ˆæ²¡æœ‰ç¡®å‡¿è¯æ®ï¼Œä½ çš„è¯æ¯«æ— è¯´æœåŠ›...ä½ éœ€è¦æ‰¾åˆ°é“è¯ï¼ï¼‰'
                    }
                ],
                onComplete: {
                    flagSet: ['exposed_to_prestor']
                },
                choices: [
                    {
                        id: 'retreat_find_proof',
                        text: 'é€€ä¸‹ï¼Œå»å¯»æ‰¾ç¡®å‡¿è¯æ®',
                        nextStep: 'step_4_dragon_hunt',
                        rewards: null
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥æ›¿ä»£ï¼šç›´æ¥è´¨é—® ====================
            step_3_alt_confront: {
                id: 'step_3_alt_confront',
                title: 'å±é™©çš„å¯¹è´¨',
                description: 'ä½ å¸¦ç€è´¢åŠ¡è®°å½•ç›´æ¥é¢å¯¹æ™®ç‘æ–¯æ‰˜å¥³å£«...',
                dialogues: [
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜ ',
                        text: 'æ™®ç‘æ–¯æ‰˜å¥³å£«ï¼Œæˆ‘æœ‰è¯æ®è¡¨æ˜æ˜¯ä½ è½¬ç§»äº†å·¥åŒ ä»¬çš„å·¥é’±ï¼'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'ï¼ˆå¥¹çš„çœ¼ç›é—ªè¿‡ä¸€ä¸å±é™©çš„å…‰èŠ’ï¼‰ä½ åœ¨ç©ç«ï¼Œå‡¡äºº...'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‰',
                        text: 'ï¼ˆå¥¹å‘¨å›´çš„ç©ºæ°”å¼€å§‹æ‰­æ›²ï¼Œä½ æ„Ÿå—åˆ°äº†ä¸€è‚¡å¼ºå¤§çš„å¨å‹ï¼‰æ—¢ç„¶ä½ çŸ¥é“äº†å¤ªå¤š...'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜¨',
                        text: 'ï¼ˆå¥¹...å¥¹çœŸçš„ä¸æ˜¯äººç±»ï¼ä½ å¿…é¡»é€ƒè·‘å¹¶å¯»æ‰¾å¸®åŠ©ï¼ï¼‰'
                    }
                ],
                onComplete: {
                    flagSet: ['witnessed_transformation', 'prestor_hostile']
                },
                choices: [
                    {
                        id: 'escape_gather_allies',
                        text: 'é€ƒç¦»å¹¶å¬é›†ç›Ÿå‹',
                        nextStep: 'step_4_gather_allies',
                        rewards: { exp: 5000 }
                    }
                ]
            },

            // ==================== ç¬¬ä¸‰æ­¥æ›¿ä»£ï¼šæ”¶é›†æ›´å¤šè¯æ® ====================
            step_3_alt_more_evidence: {
                id: 'step_3_alt_more_evidence',
                title: 'æ·±å…¥è°ƒæŸ¥',
                description: 'ä½ ç»§ç»­ç§˜å¯†æ”¶é›†å…³äºæ™®ç‘æ–¯æ‰˜å¥³å£«çš„è¯æ®...',
                requirement: {
                    type: 'have_item',
                    itemId: 'IT_BLACK_DRAGON_PROOF'  // éœ€è¦ä»å°˜æ³¥æ²¼æ³½è·å¾—
                },
                dialogues: [
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆä½ æ‰¾åˆ°äº†é»‘é¾™åŒ–èº«çš„è¯æ˜...ç°åœ¨è¯æ®ç¡®å‡¿äº†ï¼ï¼‰'
                    }
                ],
                choices: [
                    {
                        id: 'prepare_battle',
                        text: 'å‡†å¤‡ä¸é»‘é¾™æˆ˜æ–—',
                        nextStep: 'step_4_dragon_hunt',
                        rewards: { exp: 5000 }
                    }
                ]
            },

            // ==================== ç¬¬å››æ­¥ï¼šçŒæ€é»‘é¾™ ====================
            step_4_dragon_hunt: {
                id: 'step_4_dragon_hunt',
                title: 'æ­éœ²çœŸç›¸',
                description: 'ä½ æ”¶é›†äº†è¶³å¤Ÿçš„è¯æ®ï¼Œæ˜¯æ—¶å€™æ­éœ²æ™®ç‘æ–¯æ‰˜å¥³å£«çš„çœŸå®èº«ä»½äº†...',
                requirement: {
                    type: 'character_level',
                    level: 40
                },
                dialogues: [
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'ï¼ˆå¦‚æœä½ ä¸ä»–ç»“ç›Ÿï¼‰æˆ‘çš„å…„å¼Ÿä¼šä¼šæ”¯æ´ä½ ã€‚è®©é‚£æ¡é»‘é¾™ä»˜å‡ºä»£ä»·ï¼'
                    },
                    {
                        speaker: 'é›·å…‹è¨',
                        portrait: 'ğŸ»',
                        text: 'ï¼ˆå¦‚æœä½ æ›¾å¸®åŠ©è¿‡ä»–ï¼‰æˆ‘ä¹Ÿä¼šåŠ©ä½ ä¸€è‡‚ä¹‹åŠ›ï¼Œæœ‹å‹ã€‚'
                    },
                    {
                        speaker: 'ä½ ',
                        portrait: 'âš”ï¸',
                        text: 'æ™®ç‘æ–¯æ‰˜å¥³å£«...ä¸ï¼Œå¥¥å¦®å…‹å¸Œäºšï¼ä½ çš„é˜´è°‹åˆ°æ­¤ä¸ºæ­¢ï¼'
                    }
                ],
                choices: [
                    {
                        id: 'final_battle_dragon',
                        text: 'å‘èµ·æœ€ç»ˆæˆ˜æ–—ï¼',
                        nextStep: 'ending_dragon_slayer',
                        rewards: null  // å¥–åŠ±åœ¨ç»“å±€ä¸­ç»™
                    }
                ]
            },

            // ==================== ç¬¬å››æ­¥æ›¿ä»£ï¼šå¬é›†ç›Ÿå‹ ====================
            step_4_gather_allies: {
                id: 'step_4_gather_allies',
                title: 'å¬é›†ç›Ÿå‹',
                description: 'ä½ éœ€è¦å¼ºå¤§çš„ç›Ÿå‹æ¥å¯¹æŠ—é»‘é¾™...',
                requirement: {
                    type: 'boss_defeated',
                    bossId: 'vancleef'  // éœ€è¦å…ˆå’ŒèŒƒå…‹é‡Œå¤«å’Œè§£æˆ–å‡»è´¥ä»–
                },
                dialogues: [
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'æ‰€ä»¥ä½ ç»ˆäºç›¸ä¿¡æˆ‘äº†...å¥½ï¼Œè¿ªè²äºšå…„å¼Ÿä¼šå°†ä¸ä½ å¹¶è‚©ä½œæˆ˜ï¼'
                    }
                ],
                choices: [
                    {
                        id: 'attack_dragon',
                        text: 'è”åˆè¿›æ”»é»‘é¾™ï¼',
                        nextStep: 'ending_dragon_slayer',
                        rewards: null
                    }
                ]
            },

            // ==================== ç¬¬å››æ­¥ï¼šæœ€ç»ˆæˆ˜æ–—ï¼ˆèŒƒå…‹é‡Œå¤«çº¿ï¼‰ ====================
            step_4_final_battle_vancleef: {
                id: 'step_4_final_battle_vancleef',
                title: 'æ­»äº¡çŸ¿äº•å†³æˆ˜',
                description: 'ä½ ä¸èŒƒå…‹é‡Œå¤«å±•å¼€æœ€ç»ˆå†³æˆ˜...',
                requirement: {
                    type: 'boss_defeated',
                    bossId: 'vancleef'
                },
                dialogues: [
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'è±æ©å›½ç‹å¿æ¸…äº†æ¬ æˆ‘ä»¬çš„å€º...ä½ çš„ä¹Ÿåˆ°æœŸäº†ï¼'
                    },
                    {
                        speaker: 'ï¼ˆæˆ˜æ–—åï¼‰',
                        portrait: 'âš”ï¸',
                        text: 'ï¼ˆèŒƒå…‹é‡Œå¤«å€’ä¸‹äº†...ä»–çš„çœ¼ä¸­æ»¡æ˜¯ä¸ç”˜ï¼‰'
                    },
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'ï¼ˆä¸´ç»ˆå‰ï¼‰é‚£ä¸ªå¥³äºº...å¥¹æ‰æ˜¯...çœŸæ­£çš„æ•Œäºº...'
                    }
                ],
                choices: [
                    {
                        id: 'ignore_words',
                        text: 'æ— è§†ä»–çš„é—è¨€ï¼Œè¿”å›æš´é£åŸé¢†èµ',
                        nextStep: 'ending_bounty_hunter',
                        rewards: null
                    },
                    {
                        id: 'heed_warning',
                        text: 'ä»–çš„è¯è®©æˆ‘åœ¨æ„...è°ƒæŸ¥æ™®ç‘æ–¯æ‰˜',
                        nextStep: 'step_5_post_vancleef_investigation',
                        rewards: null,
                        flagSet: ['posthumous_warning']
                    }
                ]
            },

            // ==================== ç¬¬äº”æ­¥ï¼šå‡»æ€èŒƒå…‹é‡Œå¤«åçš„è°ƒæŸ¥ ====================
            step_5_post_vancleef_investigation: {
                id: 'step_5_post_vancleef_investigation',
                title: 'æ­»è€…çš„è­¦å‘Š',
                description: 'èŒƒå…‹é‡Œå¤«çš„é—è¨€è®©ä½ æ— æ³•å®‰å¿ƒã€‚ä½ å†³å®šè°ƒæŸ¥æ™®ç‘æ–¯æ‰˜å¥³å£«...',
                requirement: {
                    type: 'zone_battles',
                    zoneId: 'dustwallow_marsh',
                    count: 20
                },
                dialogues: [
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ¤”',
                        text: 'ï¼ˆåœ¨å°˜æ³¥æ²¼æ³½æ·±å¤„ï¼Œä½ å‘ç°äº†é»‘é¾™çš„ç—•è¿¹...èŒƒå…‹é‡Œå¤«è¯´çš„æ˜¯çœŸçš„ï¼ï¼‰'
                    }
                ],
                onComplete: {
                    giveItem: 'IT_BLACK_DRAGON_PROOF'
                },
                choices: [
                    {
                        id: 'hunt_dragon',
                        text: 'ä¸ºèŒƒå…‹é‡Œå¤«å¤ä»‡ï¼ŒçŒæ€é»‘é¾™ï¼',
                        nextStep: 'ending_redemption',
                        rewards: null
                    }
                ]
            },

            // ==================== ç»“å±€ï¼šèµé‡‘çŒäºº ====================
            ending_bounty_hunter: {
                id: 'ending_bounty_hunter',
                title: 'ç»“å±€ï¼šèµé‡‘çŒäºº',
                isEnding: true,
                branch: 'suppress_vancleef',
                description: 'ä½ æˆåŠŸå‡»æ€äº†èŒƒå…‹é‡Œå¤«ï¼Œå®Œæˆäº†æš´é£åŸçš„é€šç¼‰ä»»åŠ¡ã€‚',
                dialogues: [
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'å¹²å¾—å¥½ï¼Œå†’é™©è€…ã€‚èŒƒå…‹é‡Œå¤«ç»ˆäºè¢«ç»³ä¹‹ä»¥æ³•äº†ã€‚è¿™æ˜¯ä½ åº”å¾—çš„å¥–åŠ±ã€‚'
                    },
                    {
                        speaker: 'æ™®ç‘æ–¯æ‰˜å¥³å£«',
                        portrait: 'ğŸ‘¸',
                        text: 'ï¼ˆå¥¹çš„ç¬‘å®¹è®©ä½ æ„Ÿåˆ°ä¸€ä¸å¯’æ„...ä½†ä½ é€‰æ‹©äº†å¿½è§†å®ƒï¼‰'
                    },
                    {
                        speaker: 'ï¼ˆæ—ç™½ï¼‰',
                        portrait: 'ğŸ“œ',
                        text: 'ä½ å®Œæˆäº†é€šç¼‰ä»»åŠ¡ï¼Œè·å¾—äº†ä¸°åšçš„æŠ¥é…¬ã€‚ä½†çœŸç›¸...æˆ–è®¸æ°¸è¿œè¢«åŸ‹è—åœ¨æ­»äº¡çŸ¿äº•çš„æ·±å¤„ã€‚'
                    }
                ],
                rewards: {
                    gold: 50000,
                    exp: 30000,
                    items: [
                        { id: 'EQ_QUEST_BOUNTY_CLOAK', guaranteed: true }  // èµé‡‘çŒäººæŠ«é£
                    ],
                    title: 'æš´é£åŸèµé‡‘çŒäºº'
                }
            },

            // ==================== ç»“å±€ï¼šå± é¾™è€… ====================
            ending_dragon_slayer: {
                id: 'ending_dragon_slayer',
                title: 'ç»“å±€ï¼šå± é¾™è€…',
                isEnding: true,
                branch: 'slay_prestor',
                description: 'ä½ æ­éœ²äº†æ™®ç‘æ–¯æ‰˜å¥³å£«çš„çœŸå®èº«ä»½ï¼Œå¹¶ä¸é»‘é¾™å…¬ä¸»å±•å¼€æœ€ç»ˆå†³æˆ˜ï¼',
                requirement: {
                    type: 'boss_defeated',
                    bossId: 'prestor_lady'
                },
                dialogues: [
                    {
                        speaker: 'å¥¥å¦®å…‹å¸Œäºš',
                        portrait: 'ğŸ‰',
                        text: 'æ„šè ¢çš„å‡¡äººï¼ä½ ä»¥ä¸ºä½ èƒ½æˆ˜èƒœæˆ‘ï¼Ÿæˆ‘æ˜¯æ­»äº¡ä¹‹ç¿¼çš„å¥³å„¿ï¼'
                    },
                    {
                        speaker: 'ï¼ˆæˆ˜æ–—åï¼‰',
                        portrait: 'âš”ï¸',
                        text: 'ï¼ˆé»‘é¾™å…¬ä¸»å€’ä¸‹äº†ï¼Œå¥¹çš„ä¼ªè£…å½»åº•ç“¦è§£ï¼‰'
                    },
                    {
                        speaker: 'å›½ç‹',
                        portrait: 'ğŸ‘‘',
                        text: '...æˆ‘ç«Ÿç„¶è¢«å¥¹è’™è”½äº†è¿™ä¹ˆä¹…ã€‚å‹‡å£«ï¼Œä½ æ‹¯æ•‘äº†æ•´ä¸ªç‹å›½ï¼'
                    },
                    {
                        speaker: 'èŒƒå…‹é‡Œå¤«',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: 'ï¼ˆå¦‚æœå­˜æ´»ï¼‰æ­£ä¹‰...ç»ˆäºå¾—åˆ°äº†ä¼¸å¼ ã€‚ä¹Ÿè®¸ï¼Œæ˜¯æ—¶å€™è®©è¿ªè²äºšå…„å¼Ÿä¼šè§£æ•£äº†ã€‚'
                    }
                ],
                rewards: {
                    gold: 100000,
                    exp: 80000,
                    items: [
                        { id: 'EQ_QUEST_DRAGON_SLAYER_RING', guaranteed: true },  // å± é¾™è€…ä¹‹æˆ’
                        { id: 'EQ_QUEST_ONYXIA_SCALE_CLOAK', guaranteed: true }   // å¥¥å¦®å…‹å¸Œäºšé³ç‰‡æŠ«é£
                    ],
                    title: 'é»‘é¾™ç»ˆç»“è€…',
                    unlockBoss: 'prestor_lady_heroic'  // è§£é”è‹±é›„éš¾åº¦
                }
            },

            // ==================== ç»“å±€ï¼šæ•‘èµ ====================
            ending_redemption: {
                id: 'ending_redemption',
                title: 'ç»“å±€ï¼šè¿Ÿæ¥çš„æ•‘èµ',
                isEnding: true,
                branch: 'slay_prestor',
                description: 'è™½ç„¶èŒƒå…‹é‡Œå¤«å·²ç»æ­»å»ï¼Œä½†ä½ ä¸ºä»–æ­éœ²äº†çœŸç›¸ï¼Œå¹¶å‡»è´¥äº†çœŸæ­£çš„å¹•åé»‘æ‰‹ã€‚',
                requirement: {
                    type: 'boss_defeated',
                    bossId: 'prestor_lady'
                },
                dialogues: [
                    {
                        speaker: 'ä½ ',
                        portrait: 'ğŸ˜”',
                        text: 'èŒƒå…‹é‡Œå¤«...æˆ‘ä¸ºä½ æŠ¥ä»‡äº†ã€‚ä½ çš„å†¤å±ˆï¼Œç»ˆäºå¾—åˆ°äº†æ´—æ¸…ã€‚'
                    },
                    {
                        speaker: 'è¿ªè²äºšæ®‹å…š',
                        portrait: 'ğŸ´â€â˜ ï¸',
                        text: '...è°¢è°¢ä½ ï¼Œå†’é™©è€…ã€‚è™½ç„¶é˜Ÿé•¿å·²ç»ä¸åœ¨äº†ï¼Œä½†çœŸç›¸ç»ˆäºå¤§ç™½äºå¤©ä¸‹ã€‚'
                    },
                    {
                        speaker: 'å›½ç‹',
                        portrait: 'ğŸ‘‘',
                        text: 'æˆ‘ä¼šé‡æ–°è¯„ä¼°å¯¹è¿ªè²äºšå…„å¼Ÿä¼šçš„åˆ¤å†³ã€‚èŒƒå…‹é‡Œå¤«å’Œå·¥åŒ ä»¬...ä»–ä»¬å€¼å¾—æ›´å¥½çš„å¯¹å¾…ã€‚'
                    }
                ],
                rewards: {
                    gold: 80000,
                    exp: 60000,
                    items: [
                        { id: 'EQ_QUEST_REDEMPTION_BLADE', guaranteed: true }  // æ•‘èµä¹‹åˆƒ
                    ],
                    title: 'çœŸç›¸è¿½å¯»è€…'
                }
            }
        }
    }
};

// ä»»åŠ¡ç‰©å“
const QUEST_ITEMS = {
    IT_DEFIAS_DOCUMENT: {
        id: 'IT_DEFIAS_DOCUMENT',
        name: 'è¿ªè²äºšå¯†ä¿¡',
        icon: 'ğŸ“„',
        type: 'quest',
        rarity: 'blue',
        description: 'ä»è¿ªè²äºšæˆå‘˜èº«ä¸Šæœåˆ°çš„å¯†ä¿¡ï¼Œä¸Šé¢æåˆ°äº†ä¸€äº›ä»¤äººä¸å®‰çš„å†…å®¹...'
    },
    IT_FINANCIAL_RECORD: {
        id: 'IT_FINANCIAL_RECORD',
        name: 'æš´é£åŸè´¢åŠ¡è®°å½•',
        icon: 'ğŸ“Š',
        type: 'quest',
        rarity: 'blue',
        description: 'æ˜¾ç¤ºå·¥ç¨‹æ¬¾è¢«ç¥ç§˜è½¬ç§»çš„è´¢åŠ¡è®°å½•'
    },
    IT_DRAGON_SCALE_SAMPLE: {
        id: 'IT_DRAGON_SCALE_SAMPLE',
        name: 'é»‘é¾™é³ç‰‡æ ·æœ¬',
        icon: 'ğŸ‰',
        type: 'quest',
        rarity: 'purple',
        description: 'åœ¨å°˜æ³¥æ²¼æ³½å‘ç°çš„é»‘é¾™é³ç‰‡ï¼Œè¯æ˜è¿™é‡Œæœ‰é¾™çš„æ´»åŠ¨'
    }
};

// ä»»åŠ¡å¥–åŠ±è£…å¤‡
const QUEST_REWARD_EQUIPMENTS = {
    EQ_QUEST_BOUNTY_CLOAK: {
        id: 'EQ_QUEST_BOUNTY_CLOAK',
        name: 'èµé‡‘çŒäººçš„æŠ«é£',
        icon: 'icons/wow/vanilla/armor/INV_Misc_Cape_18.png',
        type: 'equipment',
        slot: 'cloak',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 500,
            attack: 100,
            critRate: 5,
            gold_bonus: 10  // ç‰¹æ®Šï¼šé‡‘å¸è·å–+10%
        },
        growth: { hp: 2, attack: 2, critRate: 2 },
        description: 'å®Œæˆæš´é£åŸé€šç¼‰ä»»åŠ¡çš„å¥–åŠ±'
    },
    EQ_QUEST_DRAGON_SLAYER_RING: {
        id: 'EQ_QUEST_DRAGON_SLAYER_RING',
        name: 'å± é¾™è€…ä¹‹æˆ’',
        icon: 'icons/wow/vanilla/armor/INV_Jewelry_Ring_15.png',
        type: 'equipment',
        slot: 'ring1',
        rarity: 'orange',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 800,
            attack: 200,
            spellPower: 200,
            critRate: 10,
            critDamage: 0.3
        },
        growth: { hp: 2, attack: 2, spellPower: 2, critRate: 2, critDamage: 2 },
        description: 'å‡»è´¥é»‘é¾™å…¬ä¸»çš„è¯æ˜'
    },
    EQ_QUEST_ONYXIA_SCALE_CLOAK: {
        id: 'EQ_QUEST_ONYXIA_SCALE_CLOAK',
        name: 'å¥¥å¦®å…‹å¸Œäºšé³ç‰‡æŠ«é£',
        icon: 'icons/wow/vanilla/armor/INV_Misc_Cape_20.png',
        type: 'equipment',
        slot: 'cloak',
        rarity: 'orange',
        level: 0,
        maxLevel: 100,
        baseStats: {
            hp: 1000,
            armor: 150,
            magicResist: 50,
            versatility: 15
        },
        growth: { hp: 2, armor: 2, magicResist: 2, versatility: 2 },
        specialEffect: {
            type: 'map_slayer',
            bonusDamageVsMap: 0.25  // åœ°å›¾æˆ˜æ–—+25%ä¼¤å®³
        },
        description: 'ç”¨å¥¥å¦®å…‹å¸Œäºšçš„é³ç‰‡åˆ¶æˆï¼Œæ•£å‘ç€é¾™ç„°çš„ä½™æ¸©'
    },
    EQ_QUEST_REDEMPTION_BLADE: {
        id: 'EQ_QUEST_REDEMPTION_BLADE',
        name: 'æ•‘èµä¹‹åˆƒ',
        icon: 'icons/wow/vanilla/weapons/INV_Sword_48.png',
        type: 'equipment',
        slot: 'mainHand',
        rarity: 'purple',
        level: 0,
        maxLevel: 100,
        baseStats: {
            attack: 1000,
            versatility: 20,
            hp: 2000
        },
        growth: { attack: 2, versatility: 2, hp: 2 },
        description: 'ä¸ºé€è€…ä¼¸å¼ æ­£ä¹‰ï¼Œä¸ºç”Ÿè€…å¸¦æ¥æ•‘èµ'
    }
};

// ==================== ä»»åŠ¡é¡µé¢UIç»„ä»¶ ====================
const QuestPage = ({ state, dispatch }) => {
    const [selectedQuest, setSelectedQuest] = useState(null);
    const [showDialogue, setShowDialogue] = useState(false);
    const [dialogueIndex, setDialogueIndex] = useState(0);

    // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦è§£é”
    const isQuestUnlocked = (quest) => {
        if (!quest.unlockCondition) return true;

        if (quest.unlockCondition.type === 'boss_defeated') {
            return state.defeatedBosses?.includes(quest.unlockCondition.bossId);
        }
        return false;
    };

    // æ£€æŸ¥æ­¥éª¤æ¡ä»¶æ˜¯å¦æ»¡è¶³
    const isStepRequirementMet = (step) => {
        if (!step.requirement) return true;

        switch (step.requirement.type) {
            case 'zone_battles':
                // ç®€åŒ–ï¼šæ£€æŸ¥æ˜¯å¦æœ‰è§’è‰²åœ¨è¯¥åŒºåŸŸæˆ˜æ–—è¿‡è¶³å¤Ÿæ¬¡æ•°
                return true;  // å®é™…å®ç°éœ€è¦è¿½è¸ªæˆ˜æ–—æ¬¡æ•°
            case 'character_level':
                return state.characters.some(c => c.level >= step.requirement.level);
            case 'boss_defeated':
                return state.defeatedBosses?.includes(step.requirement.bossId);
            case 'have_gold':
                return state.resources.gold >= step.requirement.amount;
            case 'have_item':
                return state.inventory.some(i => i.id === step.requirement.itemId) ||
                    state.questItems?.some(i => i.id === step.requirement.itemId);
            default:
                return true;
        }
    };

    // è·å–å½“å‰å¯ç”¨ä»»åŠ¡
    const availableQuests = Object.values(QUEST_CHAINS).filter(quest => {
        const progress = state.questProgress?.[quest.id];
        const unlocked = isQuestUnlocked(quest);
        const notCompleted = progress?.status !== QUEST_STATUS.COMPLETED;
        return unlocked && notCompleted;
    });

    // æ¸²æŸ“ä»»åŠ¡å¡ç‰‡
    const renderQuestCard = (quest) => {
        const progress = state.questProgress?.[quest.id];
        const isStarted = progress?.status === QUEST_STATUS.IN_PROGRESS;
        const currentStep = isStarted ? quest.steps[progress.currentStep] : null;

        return (
            <div
                key={quest.id}
                onClick={() => setSelectedQuest(quest)}
                style={{
                    padding: 16,
                    background: isStarted
                        ? 'linear-gradient(135deg, rgba(201,162,39,0.15), rgba(139,115,25,0.1))'
                        : 'rgba(0,0,0,0.3)',
                    border: isStarted ? '2px solid #c9a227' : '2px solid #4a3c2a',
                    borderRadius: 10,
                    cursor: 'pointer',
                    transition: 'all 0.2s'
                }}
            >
                <div style={{ display: 'flex', alignItems: 'center', gap: 12, marginBottom: 8 }}>
                    <span style={{ fontSize: 32 }}>{quest.icon}</span>
                    <div>
                        <div style={{ fontSize: 16, color: '#ffd700', fontWeight: 600 }}>
                            {quest.name}
                        </div>
                        <div style={{ fontSize: 11, color: isStarted ? '#4CAF50' : '#888' }}>
                            {isStarted ? `è¿›è¡Œä¸­ï¼š${currentStep?.title}` : 'æœªå¼€å§‹'}
                        </div>
                    </div>
                </div>
                <div style={{ fontSize: 12, color: '#aaa', lineHeight: 1.5 }}>
                    {quest.description}
                </div>
            </div>
        );
    };

    // æ¸²æŸ“ä»»åŠ¡è¯¦æƒ…æ¨¡æ€æ¡†
    const renderQuestModal = () => {
        if (!selectedQuest) return null;

        const quest = selectedQuest;
        const progress = state.questProgress?.[quest.id];
        const isStarted = progress?.status === QUEST_STATUS.IN_PROGRESS;
        const currentStep = isStarted ? quest.steps[progress.currentStep] : quest.steps[Object.keys(quest.steps)[0]];
        const requirementMet = isStepRequirementMet(currentStep);

        return (
            <div style={{
                position: 'fixed',
                top: 0, left: 0, right: 0, bottom: 0,
                background: 'rgba(0,0,0,0.9)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 1000
            }} onClick={() => setSelectedQuest(null)}>
                <div style={{
                    width: 700,
                    maxHeight: '85vh',
                    overflowY: 'auto',
                    background: 'linear-gradient(135deg, #1a1510 0%, #0d0a07 100%)',
                    border: '3px solid #c9a227',
                    borderRadius: 12,
                    padding: 24
                }} onClick={e => e.stopPropagation()}>
                    {/* ä»»åŠ¡æ ‡é¢˜ */}
                    <div style={{
                        textAlign: 'center',
                        marginBottom: 20,
                        paddingBottom: 16,
                        borderBottom: '1px solid rgba(201,162,39,0.3)'
                    }}>
                        <div style={{ fontSize: 48, marginBottom: 8 }}>{quest.icon}</div>
                        <h2 style={{ margin: 0, color: '#ffd700', fontSize: 24 }}>{quest.name}</h2>
                        <div style={{ color: '#888', fontSize: 12, marginTop: 8 }}>
                            {currentStep?.title}
                        </div>
                    </div>

                    {/* å½“å‰æ­¥éª¤æè¿° */}
                    <div style={{
                        background: 'rgba(0,0,0,0.3)',
                        borderRadius: 8,
                        padding: 16,
                        marginBottom: 16,
                        border: '1px solid #4a3c2a'
                    }}>
                        <div style={{ fontSize: 14, color: '#e8dcc4', lineHeight: 1.6 }}>
                            {currentStep?.description}
                        </div>
                    </div>

                    {/* æ¡ä»¶æ£€æŸ¥ */}
                    {currentStep?.requirement && (
                        <div style={{
                            background: requirementMet ? 'rgba(76,175,80,0.1)' : 'rgba(244,67,54,0.1)',
                            borderRadius: 8,
                            padding: 12,
                            marginBottom: 16,
                            border: `1px solid ${requirementMet ? 'rgba(76,175,80,0.3)' : 'rgba(244,67,54,0.3)'}`
                        }}>
                            <div style={{
                                fontSize: 12,
                                color: requirementMet ? '#4CAF50' : '#f44336',
                                display: 'flex',
                                alignItems: 'center',
                                gap: 8
                            }}>
                                {requirementMet ? 'âœ“' : 'âœ—'}
                                {currentStep.requirement.type === 'character_level' &&
                                    `éœ€è¦è§’è‰²ç­‰çº§ ${currentStep.requirement.level}`}
                                {currentStep.requirement.type === 'zone_battles' &&
                                    `éœ€è¦åœ¨${ZONES[currentStep.requirement.zoneId]?.name}æˆ˜æ–—${currentStep.requirement.count}æ¬¡`}
                                {currentStep.requirement.type === 'boss_defeated' &&
                                    `éœ€è¦å‡»è´¥${BOSS_DATA[currentStep.requirement.bossId]?.name}`}
                                {currentStep.requirement.type === 'have_gold' &&
                                    `éœ€è¦${currentStep.requirement.amount}é‡‘å¸`}
                            </div>
                        </div>
                    )}

                    {/* å¯¹è¯æŒ‰é’® */}
                    {currentStep?.dialogues && currentStep.dialogues.length > 0 && (
                        <Button
                            onClick={() => {
                                setShowDialogue(true);
                                setDialogueIndex(0);
                            }}
                            style={{ width: '100%', marginBottom: 16 }}
                            variant="secondary"
                        >
                            ğŸ“– æŸ¥çœ‹å¯¹è¯
                        </Button>
                    )}

                    {/* é€‰æ‹©åˆ—è¡¨ */}
                    {currentStep?.choices && (
                        <div style={{ marginBottom: 16 }}>
                            <div style={{ fontSize: 14, color: '#c9a227', marginBottom: 12 }}>
                                åšå‡ºé€‰æ‹©ï¼š
                            </div>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                                {currentStep.choices.map(choice => {
                                    const canChoose = requirementMet &&
                                        (!choice.requireFlag || choice.requireFlag.every(f => progress?.flags?.includes(f)));

                                    return (
                                        <button
                                            key={choice.id}
                                            onClick={() => {
                                                if (!canChoose) return;

                                                if (!isStarted) {
                                                    dispatch({ type: 'START_QUEST', payload: { questId: quest.id }});
                                                }
                                                dispatch({
                                                    type: 'QUEST_CHOICE',
                                                    payload: { questId: quest.id, choiceId: choice.id }
                                                });

                                                // å¦‚æœæ˜¯ç»“å±€ï¼Œå…³é—­æ¨¡æ€æ¡†
                                                if (choice.nextStep && quest.steps[choice.nextStep]?.isEnding) {
                                                    setSelectedQuest(null);
                                                }
                                            }}
                                            disabled={!canChoose}
                                            style={{
                                                padding: '12px 16px',
                                                background: canChoose
                                                    ? 'linear-gradient(135deg, rgba(201,162,39,0.2), rgba(139,115,25,0.15))'
                                                    : 'rgba(60,60,60,0.3)',
                                                border: canChoose ? '2px solid #c9a227' : '2px solid #444',
                                                borderRadius: 8,
                                                color: canChoose ? '#ffd700' : '#666',
                                                cursor: canChoose ? 'pointer' : 'not-allowed',
                                                fontFamily: 'inherit',
                                                fontSize: 13,
                                                textAlign: 'left',
                                                transition: 'all 0.2s'
                                            }}
                                        >
                                            <div style={{ marginBottom: 4 }}>{choice.text}</div>
                                            {choice.rewards && (
                                                <div style={{ fontSize: 11, color: '#4CAF50' }}>
                                                    å¥–åŠ±ï¼š
                                                    {choice.rewards.gold && `ğŸª™${choice.rewards.gold} `}
                                                    {choice.rewards.exp && `â­${choice.rewards.exp}`}
                                                </div>
                                            )}
                                            {choice.requireFlag && !canChoose && (
                                                <div style={{ fontSize: 10, color: '#f44336', marginTop: 4 }}>
                                                    éœ€è¦ç‰¹å®šæ¡ä»¶
                                                </div>
                                            )}
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    {/* ç»“å±€æ£€æŸ¥ */}
                    {currentStep?.isEnding && (
                        <div style={{
                            background: 'linear-gradient(135deg, rgba(255,215,0,0.15), rgba(201,162,39,0.1))',
                            borderRadius: 10,
                            padding: 20,
                            border: '2px solid #ffd700',
                            textAlign: 'center'
                        }}>
                            <div style={{ fontSize: 18, color: '#ffd700', fontWeight: 700, marginBottom: 12 }}>
                                ğŸ† {currentStep.title}
                            </div>
                            <div style={{ fontSize: 13, color: '#e8dcc4', marginBottom: 16 }}>
                                {currentStep.description}
                            </div>

                            {/* ç»“å±€å¥–åŠ±é¢„è§ˆ */}
                            {currentStep.rewards && (
                                <div style={{
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: 8,
                                    padding: 12,
                                    marginBottom: 16
                                }}>
                                    <div style={{ fontSize: 12, color: '#c9a227', marginBottom: 8 }}>ç»“å±€å¥–åŠ±ï¼š</div>
                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8, justifyContent: 'center' }}>
                                        {currentStep.rewards.gold && (
                                            <span style={{ color: '#ffd700' }}>ğŸª™ {currentStep.rewards.gold}</span>
                                        )}
                                        {currentStep.rewards.exp && (
                                            <span style={{ color: '#4CAF50' }}>â­ {currentStep.rewards.exp}</span>
                                        )}
                                        {currentStep.rewards.title && (
                                            <span style={{ color: '#a335ee' }}>ğŸ… ç§°å·ï¼š{currentStep.rewards.title}</span>
                                        )}
                                    </div>
                                    {currentStep.rewards.items && (
                                        <div style={{ marginTop: 8, fontSize: 11, color: '#ff9800' }}>
                                            + {currentStep.rewards.items.length} ä»¶è£…å¤‡
                                        </div>
                                    )}
                                </div>
                            )}

                            <Button
                                onClick={() => {
                                    dispatch({ type: 'COMPLETE_QUEST_ENDING', payload: { questId: quest.id }});
                                    setSelectedQuest(null);
                                }}
                                disabled={!isStepRequirementMet(currentStep)}
                            >
                                ğŸ‰ å®Œæˆä»»åŠ¡
                            </Button>

                            {!isStepRequirementMet(currentStep) && (
                                <div style={{ fontSize: 11, color: '#f44336', marginTop: 8 }}>
                                    éœ€è¦æ»¡è¶³æ¡ä»¶æ‰èƒ½å®Œæˆ
                                </div>
                            )}
                        </div>
                    )}

                    {/* å…³é—­æŒ‰é’® */}
                    <div style={{ textAlign: 'center', marginTop: 16 }}>
                        <Button onClick={() => setSelectedQuest(null)} variant="secondary">
                            å…³é—­
                        </Button>
                    </div>
                </div>
            </div>
        );
    };

    // æ¸²æŸ“å¯¹è¯æ¨¡æ€æ¡†
    const renderDialogueModal = () => {
        if (!showDialogue || !selectedQuest) return null;

        const progress = state.questProgress?.[selectedQuest.id];
        const currentStep = progress?.currentStep
            ? selectedQuest.steps[progress.currentStep]
            : selectedQuest.steps[Object.keys(selectedQuest.steps)[0]];

        if (!currentStep?.dialogues) return null;

        const dialogue = currentStep.dialogues[dialogueIndex];
        const isLast = dialogueIndex >= currentStep.dialogues.length - 1;

        return (
            <div style={{
                position: 'fixed',
                top: 0, left: 0, right: 0, bottom: 0,
                background: 'rgba(0,0,0,0.95)',
                display: 'flex',
                alignItems: 'flex-end',
                justifyContent: 'center',
                zIndex: 1001,
                padding: 40
            }} onClick={() => {
                if (isLast) {
                    setShowDialogue(false);
                } else {
                    setDialogueIndex(prev => prev + 1);
                }
            }}>
                <div style={{
                    width: '100%',
                    maxWidth: 800,
                    background: 'linear-gradient(180deg, rgba(30,25,20,0.98), rgba(20,15,10,0.99))',
                    border: '3px solid #c9a227',
                    borderRadius: 12,
                    padding: 24,
                    marginBottom: 40
                }} onClick={e => e.stopPropagation()}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 16, marginBottom: 16 }}>
                        <div style={{
                            width: 60,
                            height: 60,
                            background: 'rgba(0,0,0,0.4)',
                            borderRadius: '50%',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontSize: 32,
                            border: '2px solid #4a3c2a'
                        }}>
                            {dialogue.portrait}
                        </div>
                        <div style={{ fontSize: 18, color: '#ffd700', fontWeight: 600 }}>
                            {dialogue.speaker}
                        </div>
                    </div>

                    <div style={{
                        fontSize: 16,
                        color: '#e8dcc4',
                        lineHeight: 1.8,
                        minHeight: 80
                    }}>
                        {dialogue.text}
                    </div>

                    <div style={{
                        marginTop: 16,
                        textAlign: 'right',
                        fontSize: 12,
                        color: '#888'
                    }}>
                        {isLast ? 'ç‚¹å‡»å…³é—­' : 'ç‚¹å‡»ç»§ç»­'} ({dialogueIndex + 1}/{currentStep.dialogues.length})
                    </div>
                </div>
            </div>
        );
    };

    return (
        <div>
            <Panel title="ğŸ“œ ä»»åŠ¡">
                <div style={{ fontSize: 12, color: '#888', marginBottom: 16 }}>
                    å®Œæˆä»»åŠ¡è·å¾—ä¸°åšå¥–åŠ±ã€‚æ¯æ¬¡è½®å›ä»»åŠ¡è¿›åº¦ä¼šé‡ç½®ï¼Œä½†è·å¾—çš„ç§°å·å’Œæˆå°±æ°¸ä¹…ä¿ç•™ã€‚
                </div>

                {/* å·²å®Œæˆçš„ä»»åŠ¡åˆ†æ”¯ */}
                {state.completedQuestBranches?.length > 0 && (
                    <div style={{
                        background: 'rgba(76,175,80,0.1)',
                        borderRadius: 8,
                        padding: 12,
                        marginBottom: 16,
                        border: '1px solid rgba(76,175,80,0.3)'
                    }}>
                        <div style={{ fontSize: 12, color: '#4CAF50', marginBottom: 8 }}>
                            ğŸ† å·²å®Œæˆçš„ä»»åŠ¡çº¿ï¼ˆå†å²è®°å½•ï¼‰
                        </div>
                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8 }}>
                            {state.completedQuestBranches.map((record, i) => (
                                <span key={i} style={{
                                    padding: '4px 10px',
                                    background: 'rgba(76,175,80,0.2)',
                                    borderRadius: 4,
                                    fontSize: 11,
                                    color: '#81c784'
                                }}>
                                    {QUEST_CHAINS[record.questId]?.name} - {record.branch === 'slay_prestor' ? 'å± é¾™è€…' : 'èµé‡‘çŒäºº'}
                                </span>
                            ))}
                        </div>
                    </div>
                )}

                {/* ä»»åŠ¡åˆ—è¡¨ */}
                {availableQuests.length === 0 ? (
                    <div style={{ textAlign: 'center', padding: 40, color: '#666' }}>
                        <div style={{ fontSize: 48, marginBottom: 16 }}>ğŸ”’</div>
                        <div>æš‚æ— å¯ç”¨ä»»åŠ¡</div>
                        <div style={{ fontSize: 12, marginTop: 8 }}>
                            å‡»è´¥ä¸–ç•Œé¦–é¢†éœæ ¼åè§£é”ç¬¬ä¸€ä¸ªä»»åŠ¡
                        </div>
                    </div>
                ) : (
                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',
                        gap: 16
                    }}>
                        {availableQuests.map(renderQuestCard)}
                    </div>
                )}
            </Panel>

            {renderQuestModal()}
            {renderDialogueModal()}
        </div>
    );
};

// ==================== åœ¨èœå•ä¸­æ·»åŠ ä»»åŠ¡é¡µé¢ ====================
// åœ¨ menus æ•°ç»„ä¸­æ·»åŠ ï¼š
// { id: 'quest', name: 'ä»»åŠ¡', icon: 'ğŸ“œ' },

// åœ¨ renderPage å‡½æ•°ä¸­æ·»åŠ ï¼š
// case 'quest': return <QuestPage state={state} dispatch={dispatch} />;

// ==================== Bosså‡†å¤‡æ¨¡æ€ï¼ˆé‡æ–°è®¾è®¡ç‰ˆï¼‰ ====================
const BossPrepareModal = ({ state, dispatch }) => {
    const bossId = state.prepareBoss;
    console.log('bossId:', bossId);
    console.log('BOSS_DATA:', BOSS_DATA);
    console.log('boss:', BOSS_DATA[bossId]);
    if (!bossId) return null;
    const boss = BOSS_DATA[bossId];

    // âœ… å›¢é˜Ÿé¦–é¢†/ä¸–ç•Œé¦–é¢†åŒºåˆ†ï¼ˆæ¡†æ¶ï¼‰
    const bossMeta = getBossMeta(bossId) || {};
    const isTeam = isTeamBoss(bossId);
    const teamSize = Math.max(1, (state.bossTeam || []).length || getBossPartySize(bossId));
    // ===== è§’è‰²çŠ¶æ€ï¼ˆå¾…å‘½ / åœ°å›¾æˆ˜æ–— / é‡‡é›†ï¼‰ =====
    const mapAssignments = state.assignments || {};
    const resourceAssignments = state.resourceAssignments || {};

    // charId -> buildingIdï¼ˆä¸»åŸé‡‡é›†ï¼‰
    const resourceBuildingByCharId = {};
    Object.entries(resourceAssignments).forEach(([buildingId, workers]) => {
        (workers || []).forEach(cid => { resourceBuildingByCharId[cid] = buildingId; });
    });

    // Bosså‡†å¤‡ç•Œé¢éœ€è¦å±•ç¤ºã€æ‰€æœ‰è§’è‰²ã€‘ï¼ˆåŒ…å«åœ°å›¾æˆ˜æ–—/é‡‡é›†ä¸­è§’è‰²ï¼‰
    // æ’åºï¼šå¾…å‘½è§’è‰²ä¼˜å…ˆå±•ç¤º
    const allCharacters = [...(state.characters || [])].sort((a, b) => {
        const aBusy = !!(mapAssignments[a.id] || resourceBuildingByCharId[a.id]);
        const bBusy = !!(mapAssignments[b.id] || resourceBuildingByCharId[b.id]);
        if (aBusy !== bBusy) return aBusy ? 1 : -1; // å¾…å‘½åœ¨å‰
        return (b.level || 0) - (a.level || 0); // åŒç»„æŒ‰ç­‰çº§é™åº
    });
    const [dragged, setDragged] = useState(null);

    const BOSS_ACTION_NAME = {
        espionage: 'è°æŠ¥',
        black_dragon_flame: 'é»‘é¾™ä¹‹ç‚',
        fangs_and_claws: 'å°–ç‰™ä¸åˆ©çˆª',
        normal_attack: 'æ™®é€šæ”»å‡»',

        // ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯
        ragnaros_wrath: 'æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ€’',
        elemental_fury: 'å…ƒç´ æ€’ç«',
        magma_eruption: 'å²©æµ†å–·å‘',
        purify_all: 'è®©ç«ç„°å‡€åŒ–ä¸€åˆ‡',
        submerge: 'ä¸‹æ½œ',

        // å…¶ä»–bossä¹Ÿå¯ä»¥é€æ­¥è¡¥é½
        mortal_strike: 'è‡´æ­»æ‰“å‡»',
        summon_cannoneers: 'ç«ç‚®æ‰‹å‡†å¤‡',
        board_the_deck: 'ç™»ä¸Šç”²æ¿',
        summon: 'å¬å”¤',
        strike: 'é‡å‡»',
        soul_storm:'çµé­‚å¼ºé£',
        fallen_crusaders :'å •è½çš„åå­—å†›',
        banish_soul:'æ”¾é€çµé­‚',
        soul_reaper:'çµé­‚æ”¶å‰²è€…',

        // âœ… è¾¾æ ¼å…°Â·ç´¢ç‘æ£®å¤§å¸
        flame_strike: 'çƒˆç„°æ‰“å‡»',
        lava_burst: 'ç†”å²©çˆ†è£‚',
        battle_shout: 'æˆ˜æ–—æ€’å¼',

        // âœ… é»‘æš—é™¢é•¿åŠ ä¸
        shadow_bolt: 'æš—å½±ç®­',
        summon_apprentices: 'å¬å”¤äº¡çµå­¦å¾’',
        shadow_curse: 'æš—å½±è¯…å’’',
        dark_storm: 'é»‘æš—é£æš´',

        // âœ… ç‘æ–‡æˆ´å°”ç”·çˆµ
        cleave: 'é¡ºåŠˆæ–©',
        summon_skeleton_army: 'å¬å”¤éª·é«…å¤§å†›',
        shadow_shock: 'æš—å½±éœ‡å‡»',

        // âœ… é›·å¾·Â·é»‘æ‰‹
        flame_breath: 'çƒˆç„°åæ¯',
        leap_slash: 'è·³è·ƒæ–©å‡»',

        // âœ… è¡€ç¥å“ˆå¡
        summon_hakkar_sons: 'å¬å”¤å“ˆå¡ä¹‹å­',
        blood_siphon: 'è¡€æ¶²è™¹å¸',
        corrupted_blood: 'å •è½ä¹‹è¡€',
        // âœ… æ— ç–¤è€…å¥¥æ–¯é‡Œå®‰
        ossirian_strength: 'å¥¥æ–¯é‡Œå®‰ä¹‹åŠ›',
        trample: 'è·µè¸',
        tongue_curse: 'ç»“èˆŒè¯…å’’',
        surrounding_winds: 'åŒ…å›´ä¹‹é£',
        // âœ… åŠ å°”
        flame_impact: 'çƒˆç„°å†²å‡»',
        summon_fire_elementals: 'å¬å”¤ç«å…ƒç´ ',
        flame_storm: 'çƒˆç„°é£æš´',
        fire_shock: 'ç«ç„°éœ‡å‡»',
        // âœ… è¿¦é¡¿ç”·çˆµ
        hellfire: 'åœ°ç‹±çƒˆç„°',
        soul_burn: 'çµé­‚ç‡ƒçƒ§',
        living_bomb: 'æ´»ä½“ç‚¸å¼¹',

        // âœ… ç„šåŒ–è€…å¤é›·æ›¼æ ¼
        lava_splash: 'ç†”å²©å–·æº…',
        earthquake: 'åœ°éœ‡æœ¯',
        pyroblast: 'ç‚çˆ†æœ¯',
        fury: 'ç‹‚æ€’',

        // âœ… ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯
        anti_physical_shield: 'åç‰©ç†æŠ¤ç›¾',
        arcane_explosion: 'å¥¥çˆ†æœ¯',
        anti_magic_shield: 'åé­”æ³•æŠ¤ç›¾',
    };

    const formatBossCycle = (boss) =>
        (boss?.cycle || []).map(id => BOSS_ACTION_NAME[id] || id).join(' â†’ ');

    // è®¡ç®—é˜Ÿä¼æ€»å±æ€§
    const teamStats = state.bossTeam.filter(Boolean).reduce((acc, charId) => {
        const char = state.characters.find(c => c.id === charId);
        if (char) {
            acc.totalHp += char.stats.maxHp || 0;
            acc.totalAttack += char.stats.attack || 0;
            acc.totalSpellPower += char.stats.spellPower || 0;
            acc.count += 1;
        }
        return acc;
    }, { totalHp: 0, totalAttack: 0, totalSpellPower: 0, count: 0 });

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.92)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: 20
        }}>
            <div style={{
                width: 1100,
                maxWidth: '95vw',
                maxHeight: '95vh',
                overflowY: 'auto',
                background: 'linear-gradient(180deg, #1a1208 0%, #0d0906 100%)',
                borderRadius: 16,
                border: '3px solid #8b6914',
                boxShadow: '0 0 60px rgba(139,105,20,0.4), inset 0 0 100px rgba(0,0,0,0.5)',
                position: 'relative'
            }}>
                {/* é¡¶éƒ¨è£…é¥°æ¡ */}
                <div style={{
                    height: 4,
                    background: 'linear-gradient(90deg, transparent, #c9a227, #ffd700, #c9a227, transparent)',
                    borderRadius: '16px 16px 0 0'
                }} />

                {/* æ ‡é¢˜åŒºåŸŸ */}
                <div style={{
                    textAlign: 'center',
                    padding: '20px 30px',
                    borderBottom: '1px solid rgba(201,162,39,0.2)',
                    background: 'linear-gradient(180deg, rgba(139,105,20,0.15) 0%, transparent 100%)'
                }}>
                    <div style={{
                        fontSize: 12,
                        color: '#888',
                        letterSpacing: 4,
                        marginBottom: 8
                    }}>
                        âš”ï¸ {isTeam ? 'å›¢é˜Ÿé¦–é¢†' : 'ä¸–ç•Œé¦–é¢†'}æŒ‘æˆ˜ {isTeam ? 'ï¼ˆ5äººï¼‰' : ''} âš”ï¸
                    </div>
                    <h2 style={{
                        margin: 0,
                        fontSize: 32,
                        color: '#ffd700',
                        textShadow: '0 0 20px rgba(255,215,0,0.5), 2px 2px 4px rgba(0,0,0,0.8)',
                        fontWeight: 700,
                        letterSpacing: 2
                    }}>
                        {boss.name}
                    </h2>
                </div>

                {/* ä¸»ä½“å†…å®¹ */}
                <div style={{
                    display: 'grid',
                    gridTemplateColumns: '320px 1fr',
                    gap: 0,
                    minHeight: 500
                }}>
                    {/* ==================== å·¦ä¾§ï¼šBOSSä¿¡æ¯åŒº ==================== */}
                    <div style={{
                        borderRight: '1px solid rgba(201,162,39,0.2)',
                        background: 'linear-gradient(180deg, rgba(80,20,20,0.2) 0%, rgba(40,10,10,0.3) 100%)',
                        padding: 20,
                        display: 'flex',
                        flexDirection: 'column'
                    }}>
                        {/* BOSSå›¾ç‰‡åŒºåŸŸ - å¸¦è¾¹æ¡†è£…é¥° */}
                        <div style={{
                            width: '100%',
                            aspectRatio: '1/1',
                            background: 'linear-gradient(135deg, rgba(100,30,30,0.3) 0%, rgba(40,10,10,0.5) 100%)',
                            border: '3px solid',
                            borderImage: 'linear-gradient(135deg, #8b3030, #4a1515, #8b3030) 1',
                            borderRadius: 12,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            marginBottom: 16,
                            position: 'relative',
                            overflow: 'hidden',
                            boxShadow: `
        inset 0 0 40px rgba(0,0,0,0.5),
        0 4px 20px rgba(0,0,0,0.4),
        0 0 30px rgba(139,48,48,0.3)
    `
                        }}>
                            {bossMeta?.icon ? (
                                <img
                                    src={bossMeta.icon}
                                    alt={boss.name}
                                    style={{
                                        width: '100%',
                                        height: '100%',
                                        objectFit: 'cover',
                                        filter: 'contrast(1.1) saturate(1.1)'  // è®©å›¾ç‰‡æ›´é²œè‰³
                                    }}
                                />
                            ) : (
                                <div style={{
                                    fontSize: 80,
                                    opacity: 0.6,
                                    filter: 'drop-shadow(0 0 20px rgba(255,100,100,0.5))'
                                }}>
                                    {isTeam ? 'ğŸ”¥' : 'ğŸ²'}
                                </div>
                            )}

                            {/* é¡¶éƒ¨æ¸å˜é®ç½© - è®©å›¾ç‰‡è¾¹ç¼˜æ›´èåˆ */}
                            <div style={{
                                position: 'absolute',
                                top: 0,
                                left: 0,
                                right: 0,
                                height: '30%',
                                background: 'linear-gradient(180deg, rgba(0,0,0,0.4) 0%, transparent 100%)',
                                pointerEvents: 'none'
                            }} />

                            {/* åº•éƒ¨æ¸å˜é®ç½© */}
                            <div style={{
                                position: 'absolute',
                                bottom: 0,
                                left: 0,
                                right: 0,
                                height: '30%',
                                background: 'linear-gradient(0deg, rgba(0,0,0,0.6) 0%, transparent 100%)',
                                pointerEvents: 'none'
                            }} />

                            {/* è§’è½è£…é¥° */}
                            <div style={{
                                position: 'absolute',
                                top: 0,
                                left: 0,
                                right: 0,
                                bottom: 0,
                                border: '3px solid transparent',
                                borderImage: 'linear-gradient(45deg, #8b3030, transparent, transparent, #8b3030) 1',
                                pointerEvents: 'none'
                            }} />

                        </div>



                        {/* BOSSå±æ€§ */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: 8,
                            padding: 12,
                            marginBottom: 16,
                            border: '1px solid rgba(180,50,50,0.3)'
                        }}>
                            <div style={{
                                fontSize: 12,
                                color: '#ff6b6b',
                                fontWeight: 600,
                                marginBottom: 10,
                                textAlign: 'center',
                                borderBottom: '1px solid rgba(180,50,50,0.2)',
                                paddingBottom: 8
                            }}>
                                ğŸ“Š é¦–é¢†å±æ€§
                            </div>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 12 }}>
                                    <span style={{ color: '#888' }}>â¤ï¸ ç”Ÿå‘½å€¼</span>
                                    <span style={{ color: '#f44336', fontWeight: 600 }}>{boss.maxHp?.toLocaleString()}</span>
                                </div>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 12 }}>
                                    <span style={{ color: '#888' }}>âš”ï¸ æ”»å‡»åŠ›</span>
                                    <span style={{ color: '#ff9800', fontWeight: 600 }}>{boss.attack}</span>
                                </div>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 12 }}>
                                    <span style={{ color: '#888' }}>ğŸ›¡ï¸ é˜²å¾¡åŠ›</span>
                                    <span style={{ color: '#4CAF50', fontWeight: 600 }}>{boss.defense}</span>
                                </div>
                            </div>
                        </div>

                        {/* BOSSæŠ€èƒ½è¯´æ˜ */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: 8,
                            padding: 12,
                            flex: 1,
                            border: '1px solid rgba(180,50,50,0.3)'
                        }}>
                            <div style={{
                                fontSize: 12,
                                color: '#ff6b6b',
                                fontWeight: 600,
                                marginBottom: 10,
                                textAlign: 'center',
                                borderBottom: '1px solid rgba(180,50,50,0.2)',
                                paddingBottom: 8
                            }}>
                                ğŸ“œ æŠ€èƒ½æœºåˆ¶
                            </div>

                            <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                                {/* éœæ ¼çš„æŠ€èƒ½ */}
                                {bossId === 'hogger' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,100,100,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ’¥ é‡å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹ç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.heavyMultiplier}å€</span> æ”»å‡»çš„ç‰©ç†ä¼¤å®³
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ‘¥ å¬å”¤å°å¼Ÿ
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}</span> ä¸ª{boss.minion?.name || 'å°å¼Ÿ'}
                                                <br/>
                                                <span style={{ color: '#888' }}>
                            (HP:{boss.minion?.maxHp} / æ”»å‡»:{boss.minion?.attack})
                        </span>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {/* èŒƒå…‹é‡Œå¤«çš„æŠ€èƒ½ */}
                                {bossId === 'vancleef' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,100,100,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                âš”ï¸ è‡´æ­»æ‰“å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹ç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.mortalStrikeMultiplier}å€</span> æ”»å‡»ä¼¤å®³
                                                <br/>
                                                <span style={{ color: '#ff6b6b' }}>
                            å¹¶é™ä½ç›®æ ‡å—åˆ°æ²»ç–—æ•ˆæœ {(boss.mortalStrikeDebuff?.healingReduction || 0.5) * 100}%ï¼ŒæŒç»­{boss.mortalStrikeDebuff?.duration || 2}å›åˆ
                        </span>
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ”« ç«ç‚®æ‰‹å‡†å¤‡ï¼
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}</span> ä¸ª{boss.minion?.name || 'ç«ç‚®æ‰‹'}
                                                <br/>
                                                <span style={{ color: '#888' }}>
                            (HP:{boss.minion?.maxHp} / æ¯å›åˆå¯¹å…¨é˜Ÿé€ æˆBossæ”»å‡»Ã—{boss.minion?.aoeDamageMultiplier}ä¼¤å®³)
                        </span>
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ›¡ï¸ ç™»ä¸Šç”²æ¿ï¼
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å‘½ä»¤æ‰€æœ‰ç«ç‚®æ‰‹ç™»ä¸Šç”²æ¿
                                                <br/>
                                                <span style={{ color: '#2196F3' }}>
                            ç«ç‚®æ‰‹å…ç–«ä»»ä½•ä¼¤å®³
                        </span>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {bossId === 'prestor_lady' && (
                                    <div style={{
                                        marginTop: 12,
                                        padding: 12,
                                        background: 'rgba(120,30,30,0.12)',
                                        borderRadius: 8,
                                        border: '1px solid rgba(255,80,80,0.25)'
                                    }}>
                                        <div style={{ fontSize: 12, color: '#ffb3b3', fontWeight: 700, marginBottom: 8 }}>
                                            ğŸ‰ éšè—ä¸–ç•ŒBossï¼šæ™®ç‘æ–¯æ‰˜å¥³å£«ï¼ˆé»‘é¾™åŒ–èº«ï¼‰
                                        </div>

                                        <div style={{ display: 'grid', gap: 10, fontSize: 11, color: '#ddd', lineHeight: 1.6 }}>
                                            <div style={{ padding: 10, background: 'rgba(0,0,0,0.25)', borderRadius: 6 }}>
                                                <div style={{ color: '#ffd700', fontWeight: 700, marginBottom: 4 }}>æŠ€èƒ½1ï¼šè°æŠ¥</div>
                                                <div>
                                                    å¯¹å½“å‰ç›®æ ‡åŠå‘¨å›´é˜Ÿå‹é€ æˆæ€»è®¡ <b>Bossæ”»å‡»åŠ›Ã—{boss.espionageDamageMultiplier ?? 10}</b> çš„æš—å½±ä¼¤å®³ã€‚<br/>
                                                    <span style={{ color: '#aaa' }}>åˆ†æ•£ç«™ä½ï¼šåªå‘½ä¸­1å·ä½ï¼›é›†ä¸­ç«™ä½ï¼šå­˜æ´»æˆå‘˜åˆ†æ‘Šã€‚</span>
                                                </div>
                                            </div>

                                            <div style={{ padding: 10, background: 'rgba(0,0,0,0.25)', borderRadius: 6 }}>
                                                <div style={{ color: '#ffd700', fontWeight: 700, marginBottom: 4 }}>æŠ€èƒ½2ï¼šé»‘é¾™ä¹‹ç‚</div>
                                                <div>
                                                    å¯¹æ‰€æœ‰è§’è‰²æ–½åŠ  <b>1å±‚</b> é»‘é¾™ä¹‹ç‚ï¼ˆå¯å åŠ ï¼‰ã€‚æ¯å›åˆæŸå¤±
                                                    <b> Bossæ”»å‡»åŠ›Ã—{boss.blackFlameDoTMultiplier ?? 0.2}Ã—å±‚æ•°</b>ã€‚<br/>
                                                    <span style={{ color: '#aaa' }}>é»˜è®¤æŒç»­æ•´åœºæˆ˜æ–—ï¼ˆæ°¸ä¹…DOTï¼‰ã€‚</span>
                                                </div>
                                            </div>

                                            <div style={{ padding: 10, background: 'rgba(0,0,0,0.25)', borderRadius: 6 }}>
                                                <div style={{ color: '#ffd700', fontWeight: 700, marginBottom: 4 }}>æŠ€èƒ½3ï¼šå°–ç‰™ä¸åˆ©çˆª</div>
                                                <div>
                                                    å¯¹1å·ä½é€ æˆ <b>Bossæ”»å‡»åŠ›Ã—{boss.fangsMultiplier ?? 3}</b> çš„ç‰©ç†ä¼¤å®³ï¼Œé™„åŠ æµè¡€ã€‚<br/>
                                                    æµè¡€ï¼šæ¯å›åˆ <b>Bossæ”»å‡»åŠ›Ã—{boss.bleedDoTMultiplier ?? 0.8}</b>ï¼ŒæŒç»­ <b>{boss.bleedDuration ?? 3}</b> å›åˆã€‚
                                                </div>
                                            </div>

                                        </div>
                                    </div>
                                )}

                                {bossId === 'thalnos' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸŒ€ çµé­‚å¼ºé£
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹ç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.soulStormMultiplier}å€</span> æ”»å‡»çš„æš—å½±ä¼¤å®³
                                                <br/>
                                                å¹¶æ–½åŠ DOTï¼šæ¯å›åˆ <span style={{ color: '#ffd700' }}>{boss.soulStormDoTMultiplier}å€</span> æ”»å‡»ä¼¤å®³ï¼ŒæŒç»­ {boss.soulStormDoTDuration} å›åˆ
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>é›†ä¸­ç«™ä½ï¼šå¯¹æ‰€æœ‰ç›®æ ‡ç”Ÿæ•ˆ</span>
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ‘» æ”¾é€çµé­‚
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.banishSoulMultiplier}å€</span> æ”»å‡»çš„æš—å½±ä¼¤å®³
                                                <br/>
                                                <span style={{ color: '#f44336' }}>å¹¶ä½¿ç›®æ ‡ã€ææƒ§ã€‘ï¼Œæ— æ³•è¡ŒåŠ¨ {boss.fearDuration} å›åˆ</span>
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                âš”ï¸ å •è½çš„åå­—å†›
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}</span> ä¸ª{boss.minion?.name}
                                                <br/>
                                                <span style={{ color: '#888' }}>
                                                    (HP:{boss.minion?.maxHp} / æ”»å‡»:ç­‰äºBossæ”»å‡»)
                                                </span>
                                                <br/>
                                                åå­—å†›åªæ”»å‡»1å·ä½ï¼ˆå¦å…‹ï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,152,0,0.1)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #ff9800'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ffb74d', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ’€ çµé­‚æ”¶å‰²è€…
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹æ‰€æœ‰ç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>(å½“å‰å­˜æ´»åå­—å†›æ•°é‡ + {boss.soulReaperBaseMultiplier}) Ã— Bossæ”»å‡»</span> çš„æš—å½±ä¼¤å®³
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>åå­—å†›è¶Šå¤šï¼Œä¼¤å®³è¶Šé«˜ï¼</span>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {bossId === 'dagran_thaurissan' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,152,0,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #ff9800'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ffb74d', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ”¥ çƒˆç„°æ‰“å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å½“å‰å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.flameStrikeFireMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                å¹¶é¢å¤–é€ æˆ <span style={{ color: '#ffd700' }}>{boss.flameStrikePhysicalMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆå¯è¢«æŠ¤ç”²/æ ¼æŒ¡å‡å…ï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸŒ‹ ç†”å²©çˆ†è£‚
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.lavaBurstMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                å¹¶æ–½åŠ ã€ç¼çƒ§ã€‘DOTï¼šæ¯å›åˆ <span style={{ color: '#ffd700' }}>{boss.burnDoTMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°ä¼¤å®³ï¼ŒæŒç»­ {boss.burnDoTDuration} å›åˆ
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ“£ æˆ˜æ–—æ€’å¼
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                æœ¬åœºæˆ˜æ–— Boss æ”»å‡»æé«˜ <span style={{ color: '#ffd700' }}>{Math.round((boss.battleShoutAttackPct || 0.1) * 100)}%</span>ï¼ˆå¯å åŠ ï¼‰ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸ
                                            </div>
                                        </div>
                                    </>
                                )}


                                {bossId === 'darkmaster_gandling' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ¹ æš—å½±ç®­
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å½“å‰å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.shadowBoltMultiplier}å€</span> Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ‘¥ å¬å”¤äº¡çµå­¦å¾’
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}</span> ä¸ª{boss.minion?.name}
                                                <br/>
                                                <span style={{ color: '#888' }}>
                    (HP:{boss.minion?.maxHp} / æ”»å‡»&é˜²å¾¡: ç­‰äºBoss)
                </span>
                                                <br/>
                                                å­¦å¾’æ¯å›åˆå¯¹éšæœºç›®æ ‡é‡Šæ”¾ã€æš—å½±ç®­ã€‘ï¼šé€ æˆ <span style={{ color: '#ffd700' }}>{boss.minionShadowBoltMultiplier}å€</span> Bossæ”»å‡» çš„æš—å½±ä¼¤å®³
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ•¯ï¸ æš—å½±è¯…å’’
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹éšæœºç›®æ ‡æ–½åŠ <span style={{ color: '#ffd700' }}>è¯…å’’</span>ï¼šé­”æ³•æŠ—æ€§é™ä½ <span style={{ color: '#ffd700' }}>{boss.shadowCurseMagicResistDown}</span>
                                                ï¼ŒæŒç»­ {boss.shadowCurseDuration} å›åˆ
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>é­”æŠ—å¯ä¸ºè´Ÿï¼ŒæŒ‰å…¬å¼è®¡ç®—å¢ä¼¤</span>
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(0,0,0,0.22)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #673ab7'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#b388ff', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸŒªï¸ é»‘æš—é£æš´
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹ç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.darkStormMultiplier}å€</span> Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>é›†ä¸­ç«™ä½ï¼šå¯¹æ‰€æœ‰ç›®æ ‡ç”Ÿæ•ˆ</span>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {bossId === 'baron_rivendare' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸª“ é¡ºåŠˆæ–©
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                <span style={{ color: '#ff9800' }}>åˆ†æ•£ç«™ä½ï¼š</span>å¯¹å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.cleaveMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡å¯å‡å…ï¼‰
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>é›†ä¸­ç«™ä½ï¼š</span>å¯¹æ‰€æœ‰è§’è‰²é€ æˆ <span style={{ color: '#ffd700' }}>{boss.cleaveMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(0,0,0,0.22)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #673ab7'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#b388ff', fontWeight: 600, marginBottom: 4 }}>
                                                â˜ ï¸ è‡´æ­»æ‰“å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.mortalStrikeMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                                <br/>
                                                å¹¶æ–½åŠ <span style={{ color: '#ffd700' }}>å‡ç–—</span>ï¼šæ²»ç–—é‡é™ä½ <span style={{ color: '#ffd700' }}>{Math.round((boss.mortalStrikeDebuff?.healingReduction ?? 0.5) * 100)}%</span>ï¼ŒæŒç»­ {boss.mortalStrikeDebuff?.duration ?? 2} å›åˆ
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9C27B0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ•¯ï¸ æš—å½±éœ‡å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.shadowShockMultiplier}å€</span> Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                å¹¶æ–½åŠ DOTï¼šæ¯å›åˆ <span style={{ color: '#ffd700' }}>{boss.shadowShockDotMultiplier}å€</span> Bossæ”»å‡» çš„æš—å½±ä¼¤å®³ï¼ŒæŒç»­ {boss.shadowShockDotDuration} å›åˆ
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ’€ å¬å”¤éª·é«…å¤§å†›
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}</span> ä¸ª{boss.minion?.name}
                                                <br/>
                                                éª·é«…æ¯å›åˆå¯¹å¦å…‹æŒ¥ç ï¼šé€ æˆ <span style={{ color: '#ffd700' }}>{boss.skeletonSlashMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                            </div>
                                        </div>
                                    </>
                                )}

                                {bossId === 'rend_blackhand' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,87,34,0.12)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #ff5722'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ffab91', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ”¥ çƒˆç„°åæ¯
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å½“å‰å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.flameBreathMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡å¯å‡å…ï¼‰
                                                <br/>
                                                å¹¶å¯¹<span style={{ color: '#ff9800' }}>æ‰€æœ‰è§’è‰²</span>é€ æˆä¸€æ¬¡ç­‰åŒäºâ€œå¦å…‹å®é™…æ‰¿ä¼¤â€çš„<span style={{ color: '#ff9800' }}>ç«ç„°ä¼¤å®³</span>ï¼ˆå„è‡ªè®¡ç®—é­”æŠ—ï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸª“ é¡ºåŠˆæ–©
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                <span style={{ color: '#ff9800' }}>åˆ†æ•£ç«™ä½ï¼š</span>å¯¹å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.cleaveMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡å¯å‡å…ï¼‰
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>é›†ä¸­ç«™ä½ï¼š</span>å¯¹æ‰€æœ‰è§’è‰²é€ æˆ <span style={{ color: '#ffd700' }}>{boss.cleaveMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ¦˜ è·³è·ƒæ–©å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                <span style={{ color: '#ff9800' }}>é›†ä¸­ç«™ä½ï¼š</span>å¯¹å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.leapSlashMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                                <br/>
                                                <span style={{ color: '#ff9800' }}>åˆ†æ•£ç«™ä½ï¼š</span>å¯¹<span style={{ color: '#ffd700' }}>é™¤å¦å…‹å¤–</span>çš„éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.leapSlashMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³
                                            </div>
                                        </div>
                                    </>
                                )}


                                {bossId === 'hakkar' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(76,175,80,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #4caf50'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#81c784', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ‘¥ å¬å”¤å“ˆå¡ä¹‹å­
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}ä¸ª</span>ã€{boss.minion?.name}ã€‘ï¼ˆæ¯ä¸ªç”Ÿå‘½ {boss.minion?.maxHp?.toLocaleString()}ï¼‰
                                                <br/>
                                                {boss.minion?.name} ä¼šå¯¹å½“å‰å¦å…‹å–·å<span style={{ color: '#8bc34a' }}>é…¸æ¶²</span>ï¼Œé€ æˆ <span style={{ color: '#ffd700' }}>{boss.acidMultiplier}å€</span> Bossæ”»å‡» çš„<span style={{ color: '#8bc34a' }}>è‡ªç„¶ä¼¤å®³</span>ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                {boss.minion?.name} æ­»äº¡ä¼šä½¿å…¨é˜Ÿè·å¾— <span style={{ color: '#8bc34a' }}>æ¯’æ€§ä¹‹è¡€</span>ï¼šæ¯å›åˆé€ æˆ <span style={{ color: '#ffd700' }}>{boss.toxicBloodDotAtkCoeff}å€</span> BOSSæ”»å‡» çš„è‡ªç„¶ä¼¤å®³ï¼ŒæŒç»­ {boss.toxicBloodDuration} å›åˆï¼ˆä¸å¯å å±‚ï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ©¸ è¡€æ¶²è™¹å¸
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹<span style={{ color: '#ff9800' }}>æ‰€æœ‰è§’è‰²</span>é€ æˆ <span style={{ color: '#ffd700' }}>{boss.bloodSiphonMultiplier}å€</span> Bossæ”»å‡» çš„è‡ªç„¶ä¼¤å®³
                                                <br/>
                                                æ¯ä¸ª<span style={{ color: '#e57373' }}>æœªæ‹¥æœ‰æ¯’æ€§ä¹‹è¡€</span>çš„è§’è‰²ï¼šä¸ºå“ˆå¡å›å¤ <span style={{ color: '#ffd700' }}>{Math.round((boss.bloodSiphonHealPctPerNonToxic || 0) * 100)}%</span> æœ€å¤§ç”Ÿå‘½
                                                <br/>
                                                æ¯ä¸ª<span style={{ color: '#81c784' }}>æ‹¥æœ‰æ¯’æ€§ä¹‹è¡€</span>çš„è§’è‰²ï¼šå¯¹å“ˆå¡é€ æˆ <span style={{ color: '#ffd700' }}>{Math.round((boss.bloodSiphonSelfDmgPctPerToxic || 0) * 100)}%</span> æœ€å¤§ç”Ÿå‘½ çš„åå™¬ä¼¤å®³
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9c27b0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                â˜ ï¸ å •è½ä¹‹è¡€
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                <span style={{ color: '#ffd700' }}>åˆ†æ•£ç«™ä½</span>ï¼šéšæœº1åè§’è‰²è·å¾—1å±‚ã€å •è½ä¹‹è¡€ã€‘
                                                <br/>
                                                <span style={{ color: '#ffd700' }}>é›†ä¸­ç«™ä½</span>ï¼šæ‰€æœ‰è§’è‰²è·å¾—1å±‚ã€å •è½ä¹‹è¡€ã€‘
                                                <br/>
                                                ã€å •è½ä¹‹è¡€ã€‘ä¸º<span style={{ color: '#81c784' }}>ä¸­æ¯’DOT</span>ï¼Œæ¯å±‚æ¯å›åˆé€ æˆ <span style={{ color: '#ffd700' }}>{boss.corruptedBloodDotMultiplier}å€</span> Bossæ”»å‡» çš„<span style={{ color: '#9c27b0' }}>æš—å½±ä¼¤å®³</span>ï¼Œå¯å å±‚è‡³æˆ˜æ–—ç»“æŸ
                                            </div>
                                        </div>
                                    </>
                                )}


                                {bossId === 'garr' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,87,34,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #ff5722'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ffab91', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ”¥ çƒˆç„°å†²å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.flameImpactMultiplier}å€</span> Bossæ”»å‡» çš„<span style={{ color: '#ff7043' }}>ç«ç„°æ³•æœ¯ä¼¤å®³</span>ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                å¹¶æ–½åŠ ã€ç¼çƒ§ã€‘DOTï¼šæ¯å›åˆ <span style={{ color: '#ffd700' }}>{boss.flameImpactDotMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°ä¼¤å®³ï¼ŒæŒç»­ {boss.flameImpactDotDuration} å›åˆ
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(76,175,80,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #4caf50'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#81c784', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸŒ‹ å¬å”¤ç«å…ƒç´ 
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.summonCount}ä¸ª</span>ã€{boss.minion?.name}ã€‘ï¼ˆæ¯ä¸ªç”Ÿå‘½ {boss.minion?.maxHp?.toLocaleString()}ï¼‰
                                                <br/>
                                                ç«å…ƒç´ æ¯å›åˆå¯¹éšæœºç›®æ ‡æ–½æ”¾ã€ç¼çƒ­ä¹‹ç—›ã€‘ï¼šé€ æˆ <span style={{ color: '#ffd700' }}>{boss.scorchingPainMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°æ³•æœ¯ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                å¹¶ä½¿ç›®æ ‡å—åˆ°æ³•æœ¯ä¼¤å®³æé«˜ <span style={{ color: '#ffd700' }}>{Math.round((boss.spellVulnerabilityPerStack || 0) * 100)}%</span>ï¼ˆå¯å å±‚ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,193,7,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #ffc107'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ffd54f', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸŒªï¸ çƒˆç„°é£æš´
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                é»˜è®¤å¯¹éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.flameStormMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°æ³•æœ¯ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                <span style={{ color: '#ffd700' }}>é›†ä¸­ç«™ä½</span>ï¼šæ”¹ä¸ºå¯¹æ‰€æœ‰è§’è‰²é€ æˆç›¸åŒä¼¤å®³
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ’¥ ç«ç„°éœ‡å‡»
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹<span style={{ color: '#ff9800' }}>æ‰€æœ‰è§’è‰²</span>é€ æˆ <span style={{ color: '#ffd700' }}>{boss.fireShockMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°æ³•æœ¯ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                <span style={{ color: '#ffd700' }}>åˆ†æ•£ç«™ä½</span>ï¼šé¢å¤–é™„å¸¦ã€å‡»é£ã€‘ï¼Œå…¨ä½“ä¸‹ä¸€å›åˆæ— æ³•è¡ŒåŠ¨
                                            </div>
                                        </div>
                                    </>
                                )}

                                {bossId === 'baron_geddon' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ”¥ åœ°ç‹±çƒˆç„°
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹<span style={{ color: '#ff9800' }}>æ‰€æœ‰è§’è‰²</span>é€ æˆ <span style={{ color: '#ffd700' }}>{boss.hellfireBaseMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°æ³•æœ¯ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                æ¯æ¬¡æ–½æ”¾ä¼šä½¿ä¸‹ä¸€æ¬¡ã€åœ°ç‹±çƒˆç„°ã€‘ä¼¤å®³é¢å¤–æé«˜ <span style={{ color: '#ffd700' }}>{boss.hellfireIncreaseMultiplier}å€</span> Bossæ”»å‡»ï¼ˆå¯å åŠ åˆ°æˆ˜æ–—ç»“æŸï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9c27b0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ•¯ï¸ çµé­‚ç‡ƒçƒ§
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å½“å‰å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.soulBurnMultiplier}å€</span> Bossæ”»å‡» çš„æ³•æœ¯ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,193,7,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #ffc107'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ffd54f', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ’£ æ´»ä½“ç‚¸å¼¹
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                é»˜è®¤å¯¹éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.livingBombMultiplier}å€</span> Bossæ”»å‡» çš„æ³•æœ¯ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                å¹¶ã€å‡»é£ã€‘ç›®æ ‡ï¼š<span style={{ color: '#ffd700' }}>{boss.livingBombKnockupDuration}å›åˆ</span>æ— æ³•è¡ŒåŠ¨
                                                <br/>
                                                <span style={{ color: '#ffd700' }}>é›†ä¸­ç«™ä½</span>ï¼šæ”¹ä¸ºå¯¹æ‰€æœ‰è§’è‰²é€ æˆç›¸åŒä¼¤å®³ï¼ˆç‚¸å¼¹ç›®æ ‡ä»ä¼šè¢«å‡»é£ï¼‰
                                            </div>
                                        </div>
                                    </>
                                )}

                                {bossId === 'golemagg' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,193,7,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #ffc107'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ffd54f', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸº è¢«åŠ¨ï¼šç†”ç«æ¶çŠ¬
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¼€åœºå›ºæœ‰ <span style={{ color: '#ffd700' }}>{boss.houndCount || 2}åª</span>ã€{boss.minion?.name || 'ç†”ç«æ¶çŠ¬'}ã€‘ï¼ˆæ¯åªç”Ÿå‘½ {Number(boss.houndHp || boss.minion?.maxHp || 0).toLocaleString()}ï¼‰
                                                <br/>
                                                ç†”ç«æ¶çŠ¬å¯¹<span style={{ color: '#ff9800' }}>å¦å…‹</span>æ™®é€šæ”»å‡»é€ æˆ <span style={{ color: '#ffd700' }}>{boss.houndNormalMultiplier || 1.2}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡å¯å‡å…ï¼‰
                                                <br/>
                                                å½“Bossç”Ÿå‘½å€¼ â‰¤ <span style={{ color: '#ffd700' }}>{Math.round(((boss.houndEnrageHpPct ?? 0.30) * 100))}%</span> æ—¶è¿›å…¥<span style={{ color: '#ff7043' }}>ç‹‚æš´</span>ï¼šå€ç‡å˜ä¸º <span style={{ color: '#ffd700' }}>{boss.houndEnrageMultiplier || 3}å€</span>
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸŒ‹ ç†”å²©å–·æº…
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹å½“å‰å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.lavaSplashMultiplier || 5}å€</span> Bossæ”»å‡» çš„<span style={{ color: '#ff7043' }}>ç«ç„°æ³•æœ¯ä¼¤å®³</span>ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                å¹¶ä½¿ç›®æ ‡å—åˆ°<span style={{ color: '#ff9800' }}>æ‰€æœ‰ä¼¤å®³</span>æé«˜ <span style={{ color: '#ffd700' }}>{Math.round((boss.lavaSplashVulnPerStack || 0.05) * 100)}%</span>ï¼ˆå¯å åŠ ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸŒ åœ°éœ‡æœ¯
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                <span style={{ color: '#ffd700' }}>åˆ†æ•£ç«™ä½</span>ï¼šå¯¹éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.earthquakeMultiplier || 3}å€</span> Bossæ”»å‡» çš„æ³•æœ¯ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                <span style={{ color: '#ffd700' }}>é›†ä¸­ç«™ä½</span>ï¼šå¯¹æ‰€æœ‰è§’è‰²é€ æˆç›¸åŒä¼¤å®³
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(156,39,176,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #9c27b0'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ”¥ ç‚çˆ†æœ¯
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.pyroblastMultiplier || 4}å€</span> Bossæ”»å‡» çš„<span style={{ color: '#ff7043' }}>ç«ç„°æ³•æœ¯ä¼¤å®³</span>ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                å¹¶ç•™ä¸‹ã€ä½™çƒ¬ã€‘DOTï¼šæ¯å›åˆ <span style={{ color: '#ffd700' }}>{boss.emberDotMultiplier || 1.5}å€</span> Bossæ”»å‡» çš„ç«ç„°ä¼¤å®³ï¼ŒæŒç»­ {boss.emberDotDuration || 4} å›åˆ
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(76,175,80,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #4caf50'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#81c784', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ˜¡ ç‹‚æ€’
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                ä½¿è‡ªèº«ä¸ç†”ç«æ¶çŠ¬é€ æˆçš„<span style={{ color: '#ff9800' }}>æ‰€æœ‰ä¼¤å®³</span>æé«˜ <span style={{ color: '#ffd700' }}>{Math.round((boss.furyPerStack || 0.05) * 100)}%</span>
                                                ï¼ˆå¯å åŠ ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸï¼‰
                                            </div>
                                        </div>
                                    </>
                                )}

                                {bossId === 'ossirian' && (
                                    <>
                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(255,193,7,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #ffc107'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ffd54f', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ’  è¢«åŠ¨ï¼šæ±²èƒ½æ°´æ™¶
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                æ¯ <span style={{ color: '#ffd700' }}>{boss.energyCrystalEvery || 4}</span> å›åˆç”Ÿæˆ 1 ä¸ªã€{boss.minion?.name || 'æ±²èƒ½æ°´æ™¶'}ã€‘
                                                ï¼ˆHP:{boss.minion?.maxHp?.toLocaleString()} / é˜²å¾¡:{boss.minion?.defense?.toLocaleString()}ï¼‰ï¼Œä¸Šé™1ä¸ªã€‚
                                                <br/>
                                                æ°´æ™¶è¢«å‡»æ¯åï¼šBoss é˜²å¾¡é™ä¸º <span style={{ color: '#ffd700' }}>{boss.defenseDownDefense?.toLocaleString()}</span>ï¼ŒæŒç»­ <span style={{ color: '#ffd700' }}>{boss.defenseDownDuration}</span> å›åˆã€‚
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(244,67,54,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #f44336'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ’ª å¥¥æ–¯é‡Œå®‰ä¹‹åŠ›
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                æ±²å–æ°´æ™¶ä¹‹åŠ›ï¼Œå¯¹å½“å‰å¦å…‹é€ æˆ <span style={{ color: '#ffd700' }}>{boss.ossirianStrengthMultiplier}å€</span> Bossæ”»å‡» çš„ç‰©ç†ä¼¤å®³ï¼ˆæŠ¤ç”²/æ ¼æŒ¡å¯å‡å…ï¼‰
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(76,175,80,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #4caf50'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#81c784', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ¾ è·µè¸
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                å¯¹æ‰€æœ‰è§’è‰²é€ æˆ <span style={{ color: '#ffd700' }}>{boss.trampleMultiplier}å€</span> Bossæ”»å‡» çš„è‡ªç„¶ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                <span style={{ color: '#ffd700' }}>åˆ†æ•£ç«™ä½</span>ï¼šé¢å¤–é™„å¸¦ã€å‡»é£ã€‘ï¼Œå…¨ä½“ä¸‹ä¸€å›åˆæ— æ³•è¡ŒåŠ¨
                                            </div>
                                        </div>


                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(33,150,243,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #2196F3'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸ—£ï¸ ç»“èˆŒè¯…å’’
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                æ‰€æœ‰è§’è‰²<span style={{ color: '#ff9800' }}>æ€¥é€Ÿä¸æš´å‡»</span>å±æ€§é™ä¸º0ï¼ŒæŒç»­ <span style={{ color: '#ffd700' }}>{boss.tongueCurseDuration}</span> å›åˆ
                                            </div>
                                        </div>

                                        <div style={{
                                            padding: 10,
                                            background: 'rgba(0,188,212,0.10)',
                                            borderRadius: 6,
                                            borderLeft: '3px solid #00bcd4'
                                        }}>
                                            <div style={{ fontSize: 12, color: '#4dd0e1', fontWeight: 600, marginBottom: 4 }}>
                                                ğŸŒªï¸ åŒ…å›´ä¹‹é£
                                            </div>
                                            <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                                é»˜è®¤å¯¹éšæœºè§’è‰²é€ æˆ <span style={{ color: '#ffd700' }}>{boss.surroundingWindsMultiplier}å€</span> Bossæ”»å‡» çš„è‡ªç„¶ä¼¤å®³ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                                <br/>
                                                <span style={{ color: '#ffd700' }}>é›†ä¸­ç«™ä½</span>ï¼šæ”¹ä¸ºå¯¹æ‰€æœ‰è§’è‰²é€ æˆç›¸åŒä¼¤å®³
                                            </div>
                                        </div>
                                    </>
                                )}

                                {/* ç®¡ç†è€…åŸƒå…‹ç´¢å›¾æ–¯çš„æŠ€èƒ½ */}
                                {bossId === 'majordomo_executus' && (
                                  <>
                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(255,193,7,0.10)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #ffc107'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#ffd54f', fontWeight: 600, marginBottom: 4 }}>
                                        ğŸ§© è¢«åŠ¨ï¼šçƒˆç„°è¡Œè€…éšä»
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        å¼€åœºå›ºæœ‰ <span style={{ color: '#ffd700' }}>{boss.healerCount || 2}å</span>ã€{boss.healerName || 'çƒˆç„°è¡Œè€…åŒ»å¸ˆ'}ã€‘ï¼ˆæ¯åç”Ÿå‘½ {Number(boss.healerHp || 0).toLocaleString()}ï¼‰
                                        <br/>
                                        å¼€åœºå›ºæœ‰ <span style={{ color: '#ffd700' }}>{boss.eliteCount || 2}å</span>ã€{boss.eliteName || 'çƒˆç„°è¡Œè€…ç²¾è‹±'}ã€‘ï¼ˆæ¯åç”Ÿå‘½ {Number(boss.eliteHp || 0).toLocaleString()}ï¼‰
                                        <br/>
                                      </div>
                                    </div>

                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(76,175,80,0.10)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #4caf50'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#81c784', fontWeight: 600, marginBottom: 4 }}>
                                        ğŸ‘¨â€âš•ï¸ åŒ»å¸ˆæ•ˆæœï¼šç¾¤ä½“æ²»ç–—
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        æ¯åã€{boss.healerName || 'çƒˆç„°è¡Œè€…åŒ»å¸ˆ'}ã€‘æ¯å›åˆä¸º<span style={{ color: '#ff9800' }}>æ‰€æœ‰å·±æ–¹å•ä½ï¼ˆå«BOSSï¼‰</span>å›å¤
                                        <span style={{ color: '#ffd700' }}> Bossæ”»å‡»Ã—{boss.healerHealMultiplier || 10}</span> çš„ç”Ÿå‘½å€¼
                                        <br/>
                                        <span style={{ color: '#888' }}>
                                         ï¼ˆæ€»æ²»ç–—é‡ä¼šéšå­˜æ´»åŒ»å¸ˆæ•°é‡å åŠ ï¼‰
                                        </span>
                                      </div>
                                    </div>

                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(244,67,54,0.10)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #f44336'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                        ğŸ—¡ï¸ ç²¾è‹±æ•ˆæœï¼šç¾¤ä½“æ³•æœ¯ç¼çƒ§
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        æ¯åã€{boss.eliteName || 'çƒˆç„°è¡Œè€…ç²¾è‹±'}ã€‘æ¯å›åˆå¯¹<span style={{ color: '#ff9800' }}>æ‰€æœ‰è§’è‰²</span>é€ æˆ
                                        <span style={{ color: '#ffd700' }}> Bossæ”»å‡»Ã—{boss.eliteAoEDamageMultiplier || 1.5}</span> çš„<span style={{ color: '#ff7043' }}>æ³•æœ¯ä¼¤å®³</span>ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                        <br/>
                                        <span style={{ color: '#888' }}>
                                         ï¼ˆæ€»ä¼¤å®³ä¼šéšå­˜æ´»ç²¾è‹±æ•°é‡å åŠ ï¼‰
                                        </span>
                                      </div>
                                    </div>

                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(33,150,243,0.10)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #2196F3'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                        ğŸ›¡ï¸ åç‰©ç†æŠ¤ç›¾
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        ä½¿<span style={{ color: '#ff9800' }}>æ‰€æœ‰å•ä½</span>ï¼ˆBOSS / åŒ»å¸ˆ / ç²¾è‹±ï¼‰å…ç–«<span style={{ color: '#ffd700' }}>ç‰©ç†ä¼¤å®³</span>
                                        <br/>
                                        æŒç»­ <span style={{ color: '#ffd700' }}>{boss.antiPhysicalDuration || 2}</span> å›åˆ
                                      </div>
                                    </div>

                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(156,39,176,0.10)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #9c27b0'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                        âœ¨ å¥¥çˆ†æœ¯
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        å¯¹<span style={{ color: '#ff9800' }}>æ‰€æœ‰è§’è‰²</span>é€ æˆ
                                        <span style={{ color: '#ffd700' }}> Bossæ”»å‡»Ã—{boss.arcaneExplosionMultiplier || 2}</span> çš„<span style={{ color: '#ff7043' }}>æ³•æœ¯ä¼¤å®³</span>ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                      </div>
                                    </div>

                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(255,235,59,0.10)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #ffeb3b'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#fff59d', fontWeight: 600, marginBottom: 4 }}>
                                        ğŸ§¿ åé­”æ³•æŠ¤ç›¾
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        ä½¿<span style={{ color: '#ff9800' }}>æ‰€æœ‰å•ä½</span>ï¼ˆBOSS / åŒ»å¸ˆ / ç²¾è‹±ï¼‰å…ç–«<span style={{ color: '#ffd700' }}>æ³•æœ¯ä¼¤å®³</span>
                                        <br/>
                                        æŒç»­ <span style={{ color: '#ffd700' }}>{boss.antiMagicDuration || 2}</span> å›åˆ
                                      </div>
                                    </div>
                                  </>

                                )}

                                {/* ç«ç„°ä¹‹ç‹æ‹‰æ ¼çº³ç½—æ–¯çš„æŠ€èƒ½ */}
                                {bossId === 'ragnaros' && (
                                  <>
                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(255,87,34,0.12)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #ff5722'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#ffab91', fontWeight: 600, marginBottom: 4 }}>
                                        ğŸ”¥ è¢«åŠ¨ï¼šè¨å¼—æ‹‰æ–¯ï¼Œç‚é­”æ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ‰‹
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        æ¯å›åˆå¯¹<span style={{ color: '#ff9800' }}>å¦å…‹</span>é€ æˆ
                                        <span style={{ color: '#ffd700' }}> {boss.sulfurasMultiplier}å€</span> Bossæ”»å‡» çš„
                                        <span style={{ color: '#ff7043' }}>ç«ç„°æ³•æœ¯ä¼¤å®³</span>ï¼ˆè®¡ç®—é­”æŠ—ï¼‰
                                      </div>
                                    </div>

                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(244,67,54,0.10)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #f44336'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#ff6b6b', fontWeight: 600, marginBottom: 4 }}>
                                        ğŸ’¥ æŠ€èƒ½1ï¼šæ‹‰æ ¼çº³ç½—æ–¯ä¹‹æ€’
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        <span style={{ color: '#ffd700' }}>é»˜è®¤ï¼š</span>å¯¹å¦å…‹é€ æˆ
                                        <span style={{ color: '#ffd700' }}> {boss.wrathMultiplier}å€</span> Bossæ”»å‡» çš„
                                        <span style={{ color: '#ff7043' }}>ç«ç„°æ³•æœ¯ä¼¤å®³</span>
                                        <br />
                                        <span style={{ color: '#64b5f6' }}>é›†ä¸­ç«™ä½ï¼š</span>å¯¹<span style={{ color: '#ff9800' }}>æ‰€æœ‰è§’è‰²</span>é€ æˆç›¸åŒä¼¤å®³
                                      </div>
                                    </div>

                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(156,39,176,0.10)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #9c27b0'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#ce93d8', fontWeight: 600, marginBottom: 4 }}>
                                        ğŸ”¥ æŠ€èƒ½2ï¼šå…ƒç´ æ€’ç«
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.elementalFuryMultiplier}å€</span> Bossæ”»å‡» çš„
                                        <span style={{ color: '#ff7043' }}>ç«ç„°æ³•æœ¯ä¼¤å®³</span>
                                        <br />
                                        å¹¶æ–½åŠ <span style={{ color: '#ffd700' }}>ä½™çƒ¬DOT</span>ï¼šæ¯å›åˆ
                                        <span style={{ color: '#ffd700' }}> {boss.emberDotMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°æ³•æœ¯ä¼¤å®³ï¼ŒæŒç»­
                                        <span style={{ color: '#ffd700' }}> {boss.emberDotDuration}</span> å›åˆ
                                        <br />
                                        <span style={{ color: '#81c784' }}>åˆ†æ•£ç«™ä½ï¼š</span>æ¯æ¬¡BOSSé‡Šæ”¾ã€ä¸‹æ½œã€‘ï¼Œè¯¥æŠ€èƒ½ç›®æ ‡ +1
                                      </div>
                                    </div>

                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(255,152,0,0.10)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #ff9800'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#ffcc80', fontWeight: 600, marginBottom: 4 }}>
                                        ğŸŒ‹ æŠ€èƒ½3ï¼šå²©æµ†å–·å‘
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        éšæœºç›®æ ‡é€ æˆ <span style={{ color: '#ffd700' }}>{boss.magmaEruptionMultiplier}å€</span> Bossæ”»å‡» çš„
                                        <span style={{ color: '#ff7043' }}>ç«ç„°æ³•æœ¯ä¼¤å®³</span>
                                        <br />
                                        <span style={{ color: '#81c784' }}>åˆ†æ•£ç«™ä½ï¼š</span>æ¯æ¬¡BOSSé‡Šæ”¾ã€ä¸‹æ½œã€‘ï¼Œè¯¥æŠ€èƒ½ç›®æ ‡ +1
                                      </div>
                                    </div>

                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(33,150,243,0.10)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #2196F3'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#64b5f6', fontWeight: 600, marginBottom: 4 }}>
                                        ğŸ•³ï¸ æŠ€èƒ½4ï¼šä¸‹æ½œ
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        BOSSå…ç–«æ‰€æœ‰ä¼¤å®³ï¼ŒæŒç»­ <span style={{ color: '#ffd700' }}>{boss.submergeDuration}</span> å›åˆ
                                        <br />
                                        å¬å”¤ <span style={{ color: '#ffd700' }}>{boss.sonCount}</span> ä¸ªã€ç«ç„°ä¹‹å­ã€‘ï¼ˆæ¯ä¸ªç”Ÿå‘½
                                        <span style={{ color: '#ffd700' }}> {Number(boss.sonHp || 0).toLocaleString()}</span>ï¼Œæ”»é˜²åŒBOSSï¼‰
                                        <br />
                                        ç«ç„°ä¹‹å­æ¯å›åˆå¯¹éšæœº<span style={{ color: '#ffd700' }}> {boss.sonBurnTargets}</span>ç›®æ ‡æ–½æ”¾ã€ç¼çƒ§ã€‘é€ æˆ
                                        <span style={{ color: '#ffd700' }}> {boss.sonBurnMultiplier}å€</span> Bossæ”»å‡» çš„ç«ç„°æ³•æœ¯ä¼¤å®³
                                      </div>
                                    </div>

                                    <div style={{
                                      padding: 10,
                                      background: 'rgba(255,193,7,0.10)',
                                      borderRadius: 6,
                                      borderLeft: '3px solid #ffc107'
                                    }}>
                                      <div style={{ fontSize: 12, color: '#ffd54f', fontWeight: 600, marginBottom: 4 }}>
                                        ğŸŒŠ æŠ€èƒ½5ï¼šè®©ç«ç„°å‡€åŒ–ä¸€åˆ‡
                                      </div>
                                      <div style={{ fontSize: 11, color: '#aaa', lineHeight: 1.5 }}>
                                        å¤šæ®µçƒ­æµªå¯¹<span style={{ color: '#ff9800' }}>æ‰€æœ‰è§’è‰²</span>é€ æˆ
                                        <span style={{ color: '#ffd700' }}> {boss.purifyMultiplier}å€</span> Bossæ”»å‡» çš„
                                        <span style={{ color: '#ff7043' }}>ç«ç„°æ³•æœ¯ä¼¤å®³</span>
                                        {boss.purifyWaves ? (
                                          <>ï¼Œå…±<span style={{ color: '#ffd700' }}> {boss.purifyWaves}</span>æ®µ</>
                                        ) : null}
                                      </div>
                                    </div>
                                  </>
                                )}

                            </div>

                            <div style={{
                                marginTop: 12,
                                padding: 10,
                                background: 'rgba(255,215,0,0.1)',
                                borderRadius: 6,
                                border: '1px dashed rgba(255,215,0,0.3)'
                            }}>
                                <div style={{ fontSize: 11, color: '#c9a227', fontWeight: 600, marginBottom: 4 }}>
                                    ğŸ”„ æŠ€èƒ½å¾ªç¯
                                </div>
                                <div style={{ fontSize: 11, color: '#888' }}>
                                    {bossId === 'hogger' && 'å¬å”¤ â†’ é‡å‡» â†’ é‡å‡» â†’ é‡å‡» â†’ å¾ªç¯'}
                                    {bossId === 'vancleef' && 'è‡´æ­»æ‰“å‡» â†’ ç«ç‚®æ‰‹å‡†å¤‡ â†’ è‡´æ­»æ‰“å‡» â†’ ç™»ä¸Šç”²æ¿ â†’ å¾ªç¯'}
                                    {bossId === 'ragnaros' && (
                                        <>
                                            {formatBossCycle(boss) || 'æœªçŸ¥'}
                                        </>
                                    )}
                                    {bossId !== 'hogger' && bossId !== 'vancleef' && bossId !== 'ragnaros' && (formatBossCycle(boss) || 'æœªçŸ¥')}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* ==================== å³ä¾§ï¼šé˜Ÿä¼é…ç½®åŒº ==================== */}
                    <div style={{
                        padding: 20,
                        display: 'flex',
                        flexDirection: 'column',
                        gap: 16
                    }}>
                        {/* é˜Ÿä¼é…ç½® */}
                        <div style={{
                            background: 'rgba(0,0,0,0.2)',
                            borderRadius: 10,
                            padding: 16,
                            border: '1px solid rgba(201,162,39,0.2)'
                        }}>
                            <div style={{
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center',
                                marginBottom: 12
                            }}>
                                <div style={{
                                    fontSize: 14,
                                    color: '#c9a227',
                                    fontWeight: 600
                                }}>
                                    âš”ï¸ é˜Ÿä¼é˜µå®¹ï¼ˆ{teamSize}äººï¼‰
                                </div>
                                <div style={{
                                    fontSize: 11,
                                    color: '#888',
                                    padding: '4px 10px',
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: 4
                                }}>
                                    ä½ç½®1ä¼˜å…ˆå—åˆ°æ”»å‡»
                                </div>
                            </div>

                            <div style={{
                                display: 'grid',
                                gridTemplateColumns: `repeat(${teamSize}, 1fr)`,
                                gap: 12
                            }}>
                                {Array.from({ length: teamSize }, (_, i) => i).map(slot => {
                                    const charId = state.bossTeam[slot];
                                    const char = charId ? state.characters.find(c => c.id === charId) : null;

                                    return (
                                        <div
                                            key={slot}
                                            onDrop={(e) => {
                                                e.preventDefault();
                                                if (dragged) {
                                                    dispatch({ type: 'SET_BOSS_TEAM_SLOT', payload: { slot, charId: dragged } });
                                                }
                                                setDragged(null);
                                            }}
                                            onDragOver={e => e.preventDefault()}
                                            style={{
                                                padding: 16,
                                                borderRadius: 10,
                                                minHeight: 120,
                                                background: char
                                                    ? 'linear-gradient(135deg, rgba(201,162,39,0.15) 0%, rgba(139,115,25,0.1) 100%)'
                                                    : 'rgba(0,0,0,0.3)',
                                                border: char
                                                    ? '2px solid rgba(201,162,39,0.5)'
                                                    : '2px dashed rgba(74,60,42,0.5)',
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                transition: 'all 0.2s',
                                                cursor: 'default'
                                            }}
                                        >
                                            {/* ä½ç½®æ ‡ç­¾ */}
                                            <div style={{
                                                position: 'absolute',
                                                top: 8,
                                                left: 8,
                                                fontSize: 10,
                                                color: slot === 0 ? '#f44336' : '#888',
                                                fontWeight: 600,
                                                padding: '2px 6px',
                                                background: 'rgba(0,0,0,0.4)',
                                                borderRadius: 3
                                            }}>
                                                ä½ç½®{slot + 1}
                                            </div>

                                            {char ? (
                                                <>
                                                    <div style={{
                                                        fontSize: 32,
                                                        marginBottom: 8
                                                    }}>
                                                        {char.classId === 'protection_warrior' ? 'ğŸ›¡ï¸' :
                                                            char.classId === 'discipline_priest' ? 'âœï¸' :
                                                                char.classId === 'frost_mage' ? 'â„ï¸' : 'ğŸ‘¤'}
                                                    </div>
                                                    <div style={{
                                                        fontSize: 13,
                                                        color: '#ffd700',
                                                        fontWeight: 600,
                                                        marginBottom: 4
                                                    }}>
                                                        {char.name}
                                                    </div>
                                                    <div style={{ fontSize: 11, color: '#888' }}>
                                                        Lv.{char.level} {CLASSES[char.classId].name}
                                                    </div>
                                                    <div style={{
                                                        fontSize: 10,
                                                        color: '#4CAF50',
                                                        marginTop: 4
                                                    }}>
                                                        HP: {char.stats.maxHp}
                                                    </div>

                                                    {/* ç§»é™¤æŒ‰é’® */}
                                                    <button
                                                        onClick={() => dispatch({
                                                            type: 'SET_BOSS_TEAM_SLOT',
                                                            payload: { slot, charId: null }
                                                        })}
                                                        style={{
                                                            position: 'absolute',
                                                            top: 8,
                                                            right: 8,
                                                            background: 'rgba(244,67,54,0.3)',
                                                            border: '1px solid rgba(244,67,54,0.5)',
                                                            borderRadius: 4,
                                                            color: '#f44336',
                                                            fontSize: 10,
                                                            padding: '2px 6px',
                                                            cursor: 'pointer'
                                                        }}
                                                    >
                                                        âœ•
                                                    </button>
                                                </>
                                            ) : (
                                                <>
                                                    <div style={{
                                                        fontSize: 32,
                                                        opacity: 0.3,
                                                        marginBottom: 8
                                                    }}>
                                                        â•
                                                    </div>
                                                    <div style={{
                                                        fontSize: 11,
                                                        color: '#555',
                                                        textAlign: 'center'
                                                    }}>
                                                        æ‹–æ‹½è§’è‰²åˆ°æ­¤å¤„
                                                    </div>
                                                </>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>

                            {/* é˜Ÿä¼æ€»å±æ€§ */}
                            {teamStats.count > 0 && (
                                <div style={{
                                    marginTop: 12,
                                    padding: 10,
                                    background: 'rgba(76,175,80,0.1)',
                                    borderRadius: 6,
                                    border: '1px solid rgba(76,175,80,0.2)',
                                    display: 'flex',
                                    justifyContent: 'space-around'
                                }}>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>é˜Ÿä¼æ€»HP</div>
                                        <div style={{ fontSize: 14, color: '#4CAF50', fontWeight: 600 }}>
                                            {teamStats.totalHp.toLocaleString()}
                                        </div>
                                    </div>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>æ€»æ”»å‡»</div>
                                        <div style={{ fontSize: 14, color: '#ff9800', fontWeight: 600 }}>
                                            {teamStats.totalAttack}
                                        </div>
                                    </div>
                                    <div style={{ textAlign: 'center' }}>
                                        <div style={{ fontSize: 10, color: '#888' }}>æ€»æ³•å¼º</div>
                                        <div style={{ fontSize: 14, color: '#2196F3', fontWeight: 600 }}>
                                            {teamStats.totalSpellPower}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* è§’è‰²åˆ—è¡¨ï¼ˆå±•ç¤ºå…¨éƒ¨è§’è‰²ï¼šå¾…å‘½/åœ°å›¾æˆ˜æ–—/é‡‡é›†ï¼‰ */}
                        <div style={{
                            background: 'rgba(0,0,0,0.2)',
                            borderRadius: 10,
                            padding: 16,
                            border: '1px solid rgba(201,162,39,0.2)',
                            flex: 1
                        }}>
                            <div style={{
                                fontSize: 14,
                                color: '#c9a227',
                                fontWeight: 600,
                                marginBottom: 12
                            }}>
                                ğŸ‘¥ æ‰€æœ‰è§’è‰² <span style={{ color: '#888', fontWeight: 400 }}>ï¼ˆä»…å¾…å‘½è§’è‰²å¯æ‹–æ‹½ï¼›åœ°å›¾æˆ˜æ–—/é‡‡é›†ä¸­è§’è‰²å¯åœ¨æ­¤å¬å›ï¼‰</span>
                            </div>

                            {allCharacters.length === 0 ? (
                                <div style={{
                                    textAlign: 'center',
                                    padding: 30,
                                    color: '#555'
                                }}>
                                    æš‚æ— è§’è‰²ï¼ˆè¯·å…ˆåœ¨ã€è§’è‰²ã€‘é¡µé¢åˆ›å»ºè§’è‰²ï¼‰
                                </div>
                            ) : (
                                <div style={{
                                    display: 'grid',
                                    gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))',
                                    gap: 10,
                                    overflowY: 'auto',
                                    padding: 4
                                }}>
                                    {allCharacters.map(char => {
                                        const isInTeam = state.bossTeam.includes(char.id);
                                        const zoneId = mapAssignments?.[char.id];
                                        const gatherBuildingId = resourceBuildingByCharId?.[char.id];
                                        const isMapFighting = !!zoneId;
                                        const isGathering = !!gatherBuildingId;
                                        const isBusy = isMapFighting || isGathering;
                                        const canDrag = !isInTeam && !isBusy;

                                        const zoneName = zoneId
                                            ? (state.zones?.[zoneId]?.name || ZONES?.[zoneId]?.name || zoneId)
                                            : '';
                                        const buildingName = gatherBuildingId
                                            ? (RESOURCE_BUILDINGS?.[gatherBuildingId]?.name || gatherBuildingId)
                                            : '';

                                        const recallCharacter = (e) => {
                                            e?.stopPropagation?.();
                                            // å…è®¸åŒæ—¶å…¼å®¹å¼‚å¸¸å­˜æ¡£ï¼ˆåŒä¸€è§’è‰²è¢«é”™è¯¯åœ°åˆ†é…åˆ°å¤šå¤„ï¼‰
                                            if (isMapFighting) {
                                                dispatch({
                                                    type: 'UNASSIGN_CHARACTER',
                                                    payload: { characterId: char.id }
                                                });
                                            }
                                            if (isGathering) {
                                                dispatch({
                                                    type: 'UNASSIGN_RESOURCE_BUILDING',
                                                    payload: { characterId: char.id, buildingId: gatherBuildingId }
                                                });
                                            }
                                        };

                                        return (
                                            <div
                                                key={char.id}
                                                draggable={canDrag}
                                                onDragStart={(e) => {
                                                    if (!canDrag) return;
                                                    setDragged(char.id);
                                                    // âœ… éƒ¨åˆ†æµè§ˆå™¨éœ€è¦ setData æ‰ä¼šè®¤ä¸ºè¿™æ˜¯â€œæœ‰æ•ˆæ‹–æ‹½â€
                                                    try {
                                                        e.dataTransfer.setData('text/plain', char.id);
                                                        e.dataTransfer.effectAllowed = 'move';
                                                    } catch (_) {}
                                                }}
                                                style={{
                                                    padding: 12,
                                                    background: isInTeam
                                                        ? 'rgba(76,175,80,0.1)'
                                                        : isMapFighting
                                                            ? 'rgba(244,67,54,0.08)'
                                                            : isGathering
                                                                ? 'rgba(33,150,243,0.08)'
                                                                : 'rgba(0,0,0,0.3)',
                                                    border: isInTeam
                                                        ? '1px solid rgba(76,175,80,0.3)'
                                                        : isMapFighting
                                                            ? '1px solid rgba(244,67,54,0.35)'
                                                            : isGathering
                                                                ? '1px solid rgba(33,150,243,0.35)'
                                                                : '1px solid rgba(74,60,42,0.5)',
                                                    borderRadius: 8,
                                                    cursor: canDrag ? 'grab' : 'default',
                                                    opacity: isInTeam ? 0.6 : isBusy ? 0.85 : 1,
                                                    transition: 'all 0.15s',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: 10
                                                }}
                                                title={
                                                    isMapFighting
                                                        ? `åœ°å›¾æˆ˜æ–—ä¸­ï¼š${zoneName || zoneId}`
                                                        : isGathering
                                                            ? `é‡‡é›†ä¸­ï¼š${buildingName || gatherBuildingId}`
                                                            : 'å¾…å‘½'
                                                }
                                            >
                                                <div style={{ fontSize: 24 }}>
                                                    {char.classId === 'protection_warrior' ? 'ğŸ›¡ï¸' :
                                                        char.classId === 'discipline_priest' ? 'âœï¸' :
                                                            char.classId === 'frost_mage' ? 'â„ï¸' : 'ğŸ‘¤'}
                                                </div>
                                                <div style={{ flex: 1, minWidth: 0 }}>
                                                    <div style={{
                                                        fontSize: 12,
                                                        color: isInTeam ? '#4CAF50' : '#ffd700',
                                                        fontWeight: 600
                                                    }}>
                                                        {char.name} {isInTeam && 'âœ“'}
                                                    </div>
                                                    <div style={{ fontSize: 10, color: '#888' }}>
                                                        Lv.{char.level} {CLASSES[char.classId].name}
                                                    </div>

                                                    {/* çŠ¶æ€æ ‡ç­¾ï¼šåœ°å›¾æˆ˜æ–— / é‡‡é›† / å¾…å‘½ */}
                                                    <div style={{
                                                        marginTop: 6,
                                                        display: 'flex',
                                                        flexWrap: 'wrap',
                                                        gap: 4
                                                    }}>
                                                        {!isBusy && (
                                                            <span style={{
                                                                fontSize: 9,
                                                                padding: '2px 6px',
                                                                borderRadius: 4,
                                                                background: 'rgba(255,255,255,0.06)',
                                                                border: '1px solid rgba(255,255,255,0.12)',
                                                                color: '#aaa',
                                                                fontWeight: 700
                                                            }}>
                                                                âœ… å¾…å‘½
                                                            </span>
                                                        )}
                                                        {isMapFighting && (
                                                            <span style={{
                                                                fontSize: 9,
                                                                padding: '2px 6px',
                                                                borderRadius: 4,
                                                                background: 'rgba(244,67,54,0.15)',
                                                                border: '1px solid rgba(244,67,54,0.35)',
                                                                color: '#ff8a80',
                                                                fontWeight: 700
                                                            }}>
                                                                âš”ï¸ åœ°å›¾æˆ˜æ–—ä¸­{zoneName ? `ï¼š${zoneName}` : ''}
                                                            </span>
                                                        )}
                                                        {isGathering && (
                                                            <span style={{
                                                                fontSize: 9,
                                                                padding: '2px 6px',
                                                                borderRadius: 4,
                                                                background: 'rgba(33,150,243,0.15)',
                                                                border: '1px solid rgba(33,150,243,0.35)',
                                                                color: '#90caf9',
                                                                fontWeight: 700
                                                            }}>
                                                                â›ï¸ é‡‡é›†ä¸­{buildingName ? `ï¼š${buildingName}` : ''}
                                                            </span>
                                                        )}
                                                    </div>
                                                </div>

                                                {/* å¬å›æŒ‰é’®ï¼šåœ°å›¾æˆ˜æ–—/é‡‡é›†ä¸­è§’è‰²å¯å¬å› */}
                                                {isBusy && (
                                                    <Button
                                                        onClick={recallCharacter}
                                                        variant="danger"
                                                        style={{
                                                            padding: '4px 8px',
                                                            fontSize: 10,
                                                            whiteSpace: 'nowrap'
                                                        }}
                                                    >
                                                        å¬å›
                                                    </Button>
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                        </div>

                        {/* æˆ˜æ–—ç­–ç•¥ */}
                        <div style={{
                            background: 'rgba(0,0,0,0.2)',
                            borderRadius: 10,
                            padding: 16,
                            border: '1px solid rgba(201,162,39,0.2)'
                        }}>
                            <div style={{
                                fontSize: 14,
                                color: '#c9a227',
                                fontWeight: 600,
                                marginBottom: 12
                            }}>
                                âš™ï¸ æˆ˜æ–—ç­–ç•¥
                            </div>

                            <div style={{
                                display: 'grid',
                                gridTemplateColumns: '1fr 1fr',
                                gap: 16
                            }}>
                                {/* æ”»å‡»ä¼˜å…ˆçº§ */}
                                <div style={{
                                    padding: 12,
                                    background: 'rgba(0,0,0,0.2)',
                                    borderRadius: 8,
                                    border: '1px solid rgba(74,60,42,0.3)'
                                }}>
                                    <div style={{ fontSize: 12, color: '#888', marginBottom: 8 }}>
                                        æ”»å‡»ä¼˜å…ˆçº§
                                    </div>
                                    <div style={{ display: 'flex', gap: 8 }}>
                                        <label style={{
                                            flex: 1,
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: 6,
                                            padding: '8px 12px',
                                            background: state.bossStrategy.priorityBoss
                                                ? 'rgba(244,67,54,0.15)'
                                                : 'rgba(0,0,0,0.2)',
                                            border: state.bossStrategy.priorityBoss
                                                ? '1px solid rgba(244,67,54,0.4)'
                                                : '1px solid transparent',
                                            borderRadius: 6,
                                            cursor: 'pointer',
                                            fontSize: 11
                                        }}>
                                            <input
                                                type="radio"
                                                name="priority"
                                                checked={state.bossStrategy.priorityBoss}
                                                onChange={() => dispatch({
                                                    type: 'SET_BOSS_STRATEGY',
                                                    payload: { key: 'priorityBoss', value: true }
                                                })}
                                            />
                                            <span style={{ color: state.bossStrategy.priorityBoss ? '#f44336' : '#888' }}>
                                                ğŸ¯ ä¼˜å…ˆBoss
                                            </span>
                                        </label>
                                        <label style={{
                                            flex: 1,
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: 6,
                                            padding: '8px 12px',
                                            background: !state.bossStrategy.priorityBoss
                                                ? 'rgba(156,39,176,0.15)'
                                                : 'rgba(0,0,0,0.2)',
                                            border: !state.bossStrategy.priorityBoss
                                                ? '1px solid rgba(156,39,176,0.4)'
                                                : '1px solid transparent',
                                            borderRadius: 6,
                                            cursor: 'pointer',
                                            fontSize: 11
                                        }}>
                                            <input
                                                type="radio"
                                                name="priority"
                                                checked={!state.bossStrategy.priorityBoss}
                                                onChange={() => dispatch({
                                                    type: 'SET_BOSS_STRATEGY',
                                                    payload: { key: 'priorityBoss', value: false }
                                                })}
                                            />
                                            <span style={{ color: !state.bossStrategy.priorityBoss ? '#ce93d8' : '#888' }}>
                                                ğŸ‘¥ ä¼˜å…ˆå°å¼Ÿ
                                            </span>
                                        </label>
                                    </div>
                                </div>

                                {/* ç«™ä½é€‰æ‹© */}
                                <div style={{
                                    padding: 12,
                                    background: 'rgba(0,0,0,0.2)',
                                    borderRadius: 8,
                                    border: '1px solid rgba(74,60,42,0.3)'
                                }}>
                                    <div style={{ fontSize: 12, color: '#888', marginBottom: 8 }}>
                                        ç«™ä½æ–¹å¼
                                    </div>
                                    <div style={{ display: 'flex', gap: 8 }}>
                                        <label style={{
                                            flex: 1,
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: 6,
                                            padding: '8px 12px',
                                            background: state.bossStrategy.stance === 'concentrated'
                                                ? 'rgba(33,150,243,0.15)'
                                                : 'rgba(0,0,0,0.2)',
                                            border: state.bossStrategy.stance === 'concentrated'
                                                ? '1px solid rgba(33,150,243,0.4)'
                                                : '1px solid transparent',
                                            borderRadius: 6,
                                            cursor: 'pointer',
                                            fontSize: 11
                                        }}>
                                            <input
                                                type="radio"
                                                name="stance"
                                                checked={state.bossStrategy.stance === 'concentrated'}
                                                onChange={() => dispatch({
                                                    type: 'SET_BOSS_STRATEGY',
                                                    payload: { key: 'stance', value: 'concentrated' }
                                                })}
                                            />
                                            <span style={{ color: state.bossStrategy.stance === 'concentrated' ? '#64b5f6' : '#888' }}>
                                                ğŸ“ é›†ä¸­ç«™ä½
                                            </span>
                                        </label>
                                        <label style={{
                                            flex: 1,
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: 6,
                                            padding: '8px 12px',
                                            background: state.bossStrategy.stance === 'dispersed'
                                                ? 'rgba(76,175,80,0.15)'
                                                : 'rgba(0,0,0,0.2)',
                                            border: state.bossStrategy.stance === 'dispersed'
                                                ? '1px solid rgba(76,175,80,0.4)'
                                                : '1px solid transparent',
                                            borderRadius: 6,
                                            cursor: 'pointer',
                                            fontSize: 11
                                        }}>
                                            <input
                                                type="radio"
                                                name="stance"
                                                checked={state.bossStrategy.stance === 'dispersed'}
                                                onChange={() => dispatch({
                                                    type: 'SET_BOSS_STRATEGY',
                                                    payload: { key: 'stance', value: 'dispersed' }
                                                })}
                                            />
                                            <span style={{ color: state.bossStrategy.stance === 'dispersed' ? '#81c784' : '#888' }}>
                                                ğŸ”€ åˆ†æ•£ç«™ä½
                                            </span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                {/* åº•éƒ¨æŒ‰é’®åŒº */}
                <div style={{
                    padding: '16px 24px',
                    borderTop: '1px solid rgba(201,162,39,0.2)',
                    background: 'linear-gradient(180deg, transparent, rgba(139,105,20,0.1))',
                    display: 'flex',
                    justifyContent: 'center',
                    gap: 16
                }}>
                    <Button
                        onClick={() => dispatch({ type: 'START_BOSS_COMBAT' })}
                        disabled={teamStats.count === 0}
                        style={{
                            padding: '12px 40px',
                            fontSize: 16,
                            fontWeight: 700
                        }}
                    >
                        âš”ï¸ å¼€å§‹æˆ˜æ–—
                    </Button>
                    <Button
                        variant="secondary"
                        onClick={() => dispatch({ type: 'CLOSE_BOSS_PREPARE' })}
                        style={{
                            padding: '12px 30px'
                        }}
                    >
                        å–æ¶ˆ
                    </Button>
                </div>

                {/* åº•éƒ¨è£…é¥°æ¡ */}
                <div style={{
                    height: 4,
                    background: 'linear-gradient(90deg, transparent, #c9a227, #ffd700, #c9a227, transparent)',
                    borderRadius: '0 0 16px 16px'
                }} />
            </div>
        </div>
    );
};

// ==================== Bossæˆ˜æ–—æ˜¾ç¤ºæ¨¡æ€ ====================
const BossCombatModal = ({ combat, state }) => {
    if (!combat) return null;
    const boss = BOSS_DATA[combat.bossId];
    if (!boss) return null;

    const isTeam = isTeamBoss(combat.bossId);

    const minionConfig = boss.minion || { name: 'å°å¼Ÿ', maxHp: 100 };
    const minionName = minionConfig.name || 'å°å¼Ÿ';

    // è®¡ç®—å­˜æ´»äººæ•°
    const aliveCount = combat.playerStates.filter(p => p.currentHp > 0).length;
    const totalCount = combat.playerStates.length;

    return (
        <div style={{
            position: 'fixed',
            top: '50%', left: '50%',
            transform: 'translate(-50%, -50%)',
            width: '90%',
            maxWidth: 1200,
            height: '90%',
            background: 'linear-gradient(135deg, rgba(30,15,15,0.98) 0%, rgba(15,8,8,0.99) 100%)',
            display: 'flex',
            flexDirection: 'column',
            zIndex: 1000,
            border: '4px solid #c9a227',
            borderRadius: 16,
            overflow: 'hidden',
            boxShadow: '0 0 60px rgba(201,162,39,0.4), inset 0 0 100px rgba(0,0,0,0.5)'
        }}>
            {/* é¡¶éƒ¨æ ‡é¢˜æ  */}
            <div style={{
                padding: '16px 24px',
                textAlign: 'center',
                background: 'linear-gradient(180deg, rgba(139,105,20,0.2) 0%, transparent 100%)',
                borderBottom: '1px solid rgba(201,162,39,0.3)'
            }}>
                <div style={{
                    fontSize: 12,
                    color: '#888',
                    letterSpacing: 3,
                    marginBottom: 6
                }}>
                    âš”ï¸ {isTeam ? 'å›¢é˜Ÿé¦–é¢†' : 'ä¸–ç•Œé¦–é¢†'}æˆ˜æ–—è¿›è¡Œä¸­ {isTeam ? 'ï¼ˆ5äººï¼‰' : ''} âš”ï¸
                </div>
                <div style={{
                    fontSize: 28,
                    color: '#ffd700',
                    fontWeight: 700,
                    textShadow: '0 0 20px rgba(255,215,0,0.5), 2px 2px 4px rgba(0,0,0,0.8)'
                }}>
                    {boss.name}
                </div>
                <div style={{
                    marginTop: 8,
                    display: 'flex',
                    justifyContent: 'center',
                    gap: 20,
                    fontSize: 13
                }}>
                    <span style={{ color: '#4CAF50' }}>
                        ç¬¬ <span style={{ fontSize: 18, fontWeight: 700 }}>{combat.round}</span> å›åˆ
                    </span>
                    <span style={{ color: '#888' }}>|</span>
                    <span style={{ color: aliveCount > 0 ? '#4CAF50' : '#f44336' }}>
                        å­˜æ´»: {aliveCount}/{totalCount}
                    </span>
                </div>
            </div>

            {/* ä¸»æˆ˜æ–—åŒºåŸŸ */}
            <div style={{
                display: 'grid',
                gridTemplateColumns: '1fr 1fr',
                gap: 0,
                flex: 1,
                overflow: 'hidden'
            }}>
                {/* å·¦ä¾§ï¼šæˆ‘æ–¹é˜Ÿä¼ */}
                <div style={{
                    borderRight: '1px solid rgba(201,162,39,0.2)',
                    padding: 20,
                    overflowY: 'auto',
                    background: 'linear-gradient(135deg, rgba(76,175,80,0.05) 0%, transparent 100%)'
                }}>
                    <h3 style={{
                        color: '#4CAF50',
                        marginBottom: 16,
                        paddingBottom: 10,
                        borderBottom: '1px solid rgba(76,175,80,0.3)',
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span style={{ fontSize: 20 }}>ğŸ›¡ï¸</span>
                        æˆ‘æ–¹é˜Ÿä¼
                    </h3>

                    {combat.playerStates.map((p, i) => {
                        // âœ… å…³é”®ä¿®å¤ï¼šç¡®ä¿æ˜¾ç¤ºçš„è¡€é‡ä¸å°äº0
                        const displayHp = Math.max(0, Math.floor(p.currentHp));
                        const maxHp = p.char.stats.maxHp || 1;
                        const isDead = p.currentHp <= 0;
                        const hpPercent = Math.max(0, Math.min(100, (displayHp / maxHp) * 100));

                        // æ ¹æ®è¡€é‡ç™¾åˆ†æ¯”å†³å®šé¢œè‰²
                        const getHpColor = () => {
                            if (isDead) return '#666';
                            if (hpPercent > 50) return '#4CAF50';
                            if (hpPercent > 25) return '#ff9800';
                            return '#f44336';
                        };

                        return (
                            <div
                                key={i}
                                style={{
                                    marginBottom: 16,
                                    padding: 14,
                                    background: isDead
                                        ? 'rgba(0,0,0,0.4)'
                                        : 'rgba(0,0,0,0.25)',
                                    borderRadius: 10,
                                    border: isDead
                                        ? '1px solid rgba(100,100,100,0.3)'
                                        : '1px solid rgba(76,175,80,0.2)',
                                    opacity: isDead ? 0.6 : 1,
                                    transition: 'all 0.3s',
                                    position: 'relative',
                                    overflow: 'hidden'
                                }}
                            >
                                {/* æ­»äº¡é®ç½© */}
                                {isDead && (
                                    <div style={{
                                        position: 'absolute',
                                        top: 0,
                                        left: 0,
                                        right: 0,
                                        bottom: 0,
                                        background: 'repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(0,0,0,0.1) 10px, rgba(0,0,0,0.1) 20px)',
                                        pointerEvents: 'none',
                                        zIndex: 1
                                    }} />
                                )}

                                {/* è§’è‰²ä¿¡æ¯å¤´éƒ¨ */}
                                <div style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    marginBottom: 10,
                                    position: 'relative',
                                    zIndex: 2
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                                        {/* ä½ç½®æ ‡è¯† */}
                                        <div style={{
                                            width: 28,
                                            height: 28,
                                            borderRadius: '50%',
                                            background: isDead
                                                ? 'rgba(100,100,100,0.3)'
                                                : i === 0
                                                    ? 'linear-gradient(135deg, #f44336, #c62828)'
                                                    : 'linear-gradient(135deg, #4CAF50, #2e7d32)',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            fontSize: 12,
                                            fontWeight: 700,
                                            color: '#fff',
                                            boxShadow: isDead ? 'none' : '0 2px 8px rgba(0,0,0,0.3)'
                                        }}>
                                            {i + 1}
                                        </div>

                                        {/* èŒä¸šå›¾æ ‡ */}
                                        <span style={{ fontSize: 20, filter: isDead ? 'grayscale(100%)' : 'none' }}>
                                            {p.char.classId === 'protection_warrior' ? 'ğŸ›¡ï¸' :
                                                p.char.classId === 'discipline_priest' ? 'âœï¸' :
                                                    p.char.classId === 'frost_mage' ? 'â„ï¸' : 'ğŸ‘¤'}
                                        </span>

                                        {/* åå­—å’Œç­‰çº§ */}
                                        <div>
                                            <div style={{
                                                fontSize: 14,
                                                fontWeight: 600,
                                                color: isDead ? '#888' : '#ffd700'
                                            }}>
                                                {p.char.name}
                                            </div>
                                            <div style={{ fontSize: 11, color: '#888' }}>
                                                Lv.{p.char.level} {CLASSES[p.char.classId]?.name || ''}
                                            </div>
                                        </div>
                                    </div>

                                    {/* çŠ¶æ€æ ‡ç­¾ */}
                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end', gap: 4 }}>
                                        {isDead ? (
                                            <span style={{
                                                padding: '4px 10px',
                                                background: 'linear-gradient(135deg, rgba(100,100,100,0.4), rgba(60,60,60,0.4))',
                                                borderRadius: 4,
                                                fontSize: 12,
                                                fontWeight: 700,
                                                color: '#aaa',
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: 4,
                                                border: '1px solid rgba(100,100,100,0.3)'
                                            }}>
                                                ğŸ’€ æ­»äº¡
                                            </span>
                                        ) : (
                                            <>
                                                {/* å‡ç–—debuff */}
                                                {p.debuffs?.mortalStrike && (
                                                    <span style={{
                                                        padding: '3px 8px',
                                                        background: 'rgba(255,100,100,0.2)',
                                                        borderRadius: 4,
                                                        fontSize: 10,
                                                        color: '#ff6b6b',
                                                        border: '1px solid rgba(255,100,100,0.3)'
                                                    }}>
                                                        ğŸ©¸ å‡ç–— {(p.debuffs.mortalStrike.healingReduction * 100)}% ({p.debuffs.mortalStrike.duration}å›åˆ)
                                                    </span>
                                                )}

                                                {/* ææƒ§debuff */}
                                                {p.debuffs?.fear && (
                                                    <span style={{
                                                        padding: '3px 8px',
                                                        background: 'rgba(180,120,255,0.18)',
                                                        borderRadius: 4,
                                                        fontSize: 10,
                                                        color: '#c6a0ff',
                                                        border: '1px solid rgba(180,120,255,0.28)'
                                                    }}>
                                                        ğŸ˜± ææƒ§ ({p.debuffs.fear.duration}å›åˆ)
                                                    </span>
                                                )}

                                                {/* å‡»é£debuff */}
                                                {p.debuffs?.knockup && (
                                                    <span style={{
                                                        padding: '3px 8px',
                                                        background: 'rgba(255,152,0,0.16)',
                                                        borderRadius: 4,
                                                        fontSize: 10,
                                                        color: '#ffb74d',
                                                        border: '1px solid rgba(255,152,0,0.26)'
                                                    }}>
                                                        ğŸ¦˜ å‡»é£ ({p.debuffs.knockup.duration}å›åˆ)
                                                    </span>
                                                )}

                                                {/* ç»“èˆŒè¯…å’’debuff */}
                                                {p.debuffs?.tongueCurse && (
                                                    <span style={{
                                                        padding: '3px 8px',
                                                        background: 'rgba(33,150,243,0.16)',
                                                        borderRadius: 4,
                                                        fontSize: 10,
                                                        color: '#64b5f6',
                                                        border: '1px solid rgba(33,150,243,0.26)'
                                                    }}>
                                                        ğŸ—£ï¸ ç»“èˆŒ ({p.debuffs.tongueCurse.duration}å›åˆ)
                                                    </span>
                                                )}

                                                {/* Buffæ˜¾ç¤º */}
                                                {p.buffs && p.buffs.length > 0 && (
                                                    <div style={{ display: 'flex', gap: 4 }}>
                                                        {p.buffs.slice(0, 3).map((buff, bi) => {
                                                            const icon = (() => {
                                                                switch (buff.type) {
                                                                    case 'icy_veins': return 'â„ï¸';
                                                                    case 'blade_flurry': return 'ğŸŒ€';
                                                                    case 'slice_and_dice': return 'âœ‚ï¸';
                                                                    case 'between_the_eyes': return 'ğŸ¯';
                                                                    case 'adrenaline_rush': return 'âš¡';
                                                                    case 'crimson_vial': return 'ğŸ©¸';
                                                                    case 'shield_wall': return 'ğŸ›¡ï¸';
                                                                    case 'haste': return 'âš¡';
                                                                    default: return 'âœ¨';
                                                                }
                                                            })();
                                                            const d = buff.duration;
                                                            const durText = (d === undefined || d === null || !Number.isFinite(Number(d)) || Number(d) >= 900)
                                                                ? 'âˆ'
                                                                : Number(d);
                                                            return (
                                                                <span
                                                                    key={bi}
                                                                    title={buff.type}
                                                                    style={{
                                                                        padding: '2px 6px',
                                                                        background: 'rgba(76,175,80,0.2)',
                                                                        borderRadius: 3,
                                                                        fontSize: 9,
                                                                        color: '#4CAF50'
                                                                    }}
                                                                >
                                                                    {icon} {durText}
                                                                </span>
                                                            );
                                                        })}
                                                    </div>
                                                )}
                                            </>
                                        )}
                                    </div>
                                </div>

                                {/* âœ… ç¾åŒ–åçš„è¡€æ¡ */}
                                <div style={{ position: 'relative', zIndex: 2 }}>
                                    <div style={{
                                        display: 'flex',
                                        justifyContent: 'space-between',
                                        fontSize: 11,
                                        color: isDead ? '#666' : '#aaa',
                                        marginBottom: 4
                                    }}>
                                        <span>ç”Ÿå‘½å€¼</span>
                                        <span style={{
                                            color: isDead ? '#666' : getHpColor(),
                                            fontWeight: 600
                                        }}>
                                            {/* âœ… å…³é”®ï¼šæ˜¾ç¤º0è€Œä¸æ˜¯è´Ÿæ•° */}
                                            {displayHp} / {Math.floor(maxHp)}
                                            {isDead && ' (æ­»äº¡)'}
                                        </span>
                                    </div>
                                    <div style={{
                                        height: 12,
                                        background: 'rgba(0,0,0,0.5)',
                                        borderRadius: 6,
                                        overflow: 'hidden',
                                        border: '1px solid rgba(255,255,255,0.1)',
                                        boxShadow: 'inset 0 2px 4px rgba(0,0,0,0.3)'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            // âœ… å…³é”®ï¼šè¡€æ¡å®½åº¦åŸºäºä¿®æ­£åçš„ç™¾åˆ†æ¯”
                                            width: `${hpPercent}%`,
                                            background: isDead
                                                ? '#444'
                                                : `linear-gradient(90deg, ${getHpColor()}, ${getHpColor()}cc)`,
                                            transition: 'width 0.3s ease-out, background 0.3s',
                                            boxShadow: isDead ? 'none' : `0 0 10px ${getHpColor()}66`,
                                            borderRadius: 6
                                        }} />
                                    </div>
                                </div>

                                {/* å¯’å†°æŒ‡/ç¥¸ç¦ç›¸ä¾/å¹»æƒ³æ›²/è¿å‡»ç‚¹æ˜¾ç¤º */}
                                {!isDead && (p.fingersOfFrost > 0 || p.fortuneMisfortuneStacks > 0 || (p.fantasiaStacks || 0) > 0 || (p.comboPoints || 0) > 0) && (
                                    <div style={{
                                        marginTop: 8,
                                        display: 'flex',
                                        gap: 8,
                                        position: 'relative',
                                        zIndex: 2
                                    }}>
                                        {p.fingersOfFrost > 0 && (
                                            <span style={{
                                                padding: '2px 8px',
                                                background: 'rgba(33,150,243,0.2)',
                                                borderRadius: 4,
                                                fontSize: 10,
                                                color: '#64b5f6',
                                                border: '1px solid rgba(33,150,243,0.3)'
                                            }}>
                                                â„ï¸ å¯’å†°æŒ‡ Ã—{p.fingersOfFrost}
                                            </span>
                                        )}
                                        {p.fortuneMisfortuneStacks > 0 && (
                                            <span style={{
                                                padding: '2px 8px',
                                                background: 'rgba(255,215,0,0.2)',
                                                borderRadius: 4,
                                                fontSize: 10,
                                                color: '#ffd700',
                                                border: '1px solid rgba(255,215,0,0.3)'
                                            }}>
                                                â˜¯ï¸ ç¥¸ç¦ Ã—{p.fortuneMisfortuneStacks}
                                            </span>
                                        )}
                                        {(p.fantasiaStacks || 0) > 0 && (
                                            <span style={{
                                                padding: '2px 8px',
                                                background: 'rgba(156,39,176,0.2)',
                                                borderRadius: 4,
                                                fontSize: 10,
                                                color: '#ce93d8',
                                                border: '1px solid rgba(156,39,176,0.3)'
                                            }}>
                                                ğŸ¼ å¹»æƒ³æ›² Ã—{p.fantasiaStacks}
                                            </span>
                                        )}

                                        {(p.comboPoints || 0) > 0 && (
                                            <span style={{
                                                padding: '2px 8px',
                                                background: 'rgba(255,193,7,0.2)',
                                                borderRadius: 4,
                                                fontSize: 10,
                                                color: '#ffd54f',
                                                border: '1px solid rgba(255,193,7,0.3)'
                                            }}>
                                                â­ æ˜Ÿ Ã—{p.comboPoints}
                                            </span>
                                        )}
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>

                {/* å³ä¾§ï¼šæ•Œäºº */}
                <div style={{
                    padding: 20,
                    overflowY: 'auto',
                    background: 'linear-gradient(135deg, rgba(244,67,54,0.05) 0%, transparent 100%)'
                }}>
                    <h3 style={{
                        color: '#f44336',
                        marginBottom: 16,
                        paddingBottom: 10,
                        borderBottom: '1px solid rgba(244,67,54,0.3)',
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span style={{ fontSize: 20 }}>ğŸ‘¹</span>
                        æ•Œæ–¹å•ä½
                    </h3>

                    {/* Bossè¡€æ¡ */}
                    <div style={{
                        marginBottom: 20,
                        padding: 16,
                        background: 'linear-gradient(135deg, rgba(244,67,54,0.1) 0%, rgba(0,0,0,0.3) 100%)',
                        borderRadius: 12,
                        border: '2px solid rgba(244,67,54,0.3)',
                        boxShadow: '0 4px 20px rgba(244,67,54,0.2)'
                    }}>
                        <div style={{
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            marginBottom: 12
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                                <span style={{ fontSize: 28 }}>ğŸ²</span>
                                <div>
                                    <div style={{
                                        fontSize: 18,
                                        fontWeight: 700,
                                        color: '#ff6b6b',
                                        textShadow: '0 0 10px rgba(255,107,107,0.5)'
                                    }}>
                                        {boss.name}
                                    </div>
                                    <div style={{ fontSize: 11, color: '#888' }}>ä¸–ç•Œé¦–é¢†</div>
                                </div>
                            </div>
                            <div style={{
                                fontSize: 14,
                                color: '#ff6b6b',
                                fontWeight: 600
                            }}>
                                {Math.max(0, Math.floor(combat.bossHp)).toLocaleString()} / {boss.maxHp.toLocaleString()}
                            </div>
                        </div>

                        {/* Bossè¡€æ¡ */}
                        <div style={{
                            height: 20,
                            background: 'rgba(0,0,0,0.5)',
                            borderRadius: 10,
                            overflow: 'hidden',
                            border: '1px solid rgba(255,107,107,0.3)',
                            boxShadow: 'inset 0 2px 6px rgba(0,0,0,0.4)'
                        }}>
                            <div style={{
                                height: '100%',
                                width: `${Math.max(0, Math.min(100, (combat.bossHp / boss.maxHp) * 100))}%`,
                                background: 'linear-gradient(90deg, #f44336, #ff6b6b, #f44336)',
                                transition: 'width 0.3s ease-out',
                                boxShadow: '0 0 15px rgba(244,67,54,0.6)',
                                borderRadius: 10,
                                position: 'relative',
                                overflow: 'hidden'
                            }}>
                                {/* è¡€æ¡é—ªå…‰æ•ˆæœ */}
                                <div style={{
                                    position: 'absolute',
                                    top: 0,
                                    left: 0,
                                    right: 0,
                                    height: '50%',
                                    background: 'linear-gradient(180deg, rgba(255,255,255,0.3), transparent)',
                                    borderRadius: '10px 10px 0 0'
                                }} />
                            </div>
                        </div>

                        {/* Boss DOTæ˜¾ç¤º */}
                        {combat.bossDots && combat.bossDots.length > 0 && (
                            <div style={{
                                marginTop: 10,
                                display: 'flex',
                                flexWrap: 'wrap',
                                gap: 6
                            }}>
                                {combat.bossDots.map((dot, di) => (
                                    <span key={di} style={{
                                        padding: '3px 8px',
                                        background: 'rgba(156,39,176,0.2)',
                                        borderRadius: 4,
                                        fontSize: 10,
                                        color: '#ce93d8',
                                        border: '1px solid rgba(156,39,176,0.3)'
                                    }}>
                                        ğŸ”¥ {dot.name || 'DOT'} ({dot.duration}å›åˆ)
                                    </span>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* å°å¼Ÿ/ç«ç‚®æ‰‹è¡€æ¡ */}
                    {combat.minions && combat.minions.length > 0 && (
                        <div>
                            <div style={{
                                fontSize: 14,
                                marginBottom: 12,
                                color: '#ce93d8',
                                display: 'flex',
                                alignItems: 'center',
                                gap: 8
                            }}>
                                <span style={{ fontSize: 16 }}>ğŸ‘¥</span>
                                {minionName} ({combat.minions.filter(m => m.hp > 0).length}/{combat.minions.length} å­˜æ´»)
                            </div>

                            <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                                {combat.minions.map((m, i) => {
                                    const minionMaxHp = m.maxHp || minionConfig.maxHp;
                                    const minionDisplayHp = Math.max(0, Math.floor(m.hp));
                                    const minionIsDead = m.hp <= 0;
                                    const minionHpPercent = Math.max(0, Math.min(100, (minionDisplayHp / minionMaxHp) * 100));
                                    const minionLabel = m.displayName || `${minionName} ${i + 1}`;

                                    return (
                                        <div key={i} style={{
                                            padding: 12,
                                            background: minionIsDead
                                                ? 'rgba(0,0,0,0.3)'
                                                : m.immune
                                                    ? 'rgba(33,150,243,0.1)'
                                                    : 'rgba(156,39,176,0.1)',
                                            borderRadius: 8,
                                            border: minionIsDead
                                                ? '1px solid rgba(100,100,100,0.2)'
                                                : m.immune
                                                    ? '1px solid rgba(33,150,243,0.3)'
                                                    : '1px solid rgba(156,39,176,0.3)',
                                            opacity: minionIsDead ? 0.5 : 1
                                        }}>
                                            <div style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'center',
                                                marginBottom: 6
                                            }}>
                                                <span style={{
                                                    fontSize: 12,
                                                    color: minionIsDead ? '#666' : m.immune ? '#64b5f6' : '#ce93d8'
                                                }}>
                                                    {minionLabel}
                                                    {minionIsDead && ' (æ­»äº¡)'}
                                                </span>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                                                    {/* å…ç–«çŠ¶æ€ */}
                                                    {m.immune && !minionIsDead && (
                                                        <span style={{
                                                            fontSize: 10,
                                                            color: '#2196F3',
                                                            padding: '2px 6px',
                                                            background: 'rgba(33,150,243,0.2)',
                                                            borderRadius: 4,
                                                            fontWeight: 600
                                                        }}>
                                                            ğŸ›¡ï¸ å…ç–«ä¸­
                                                        </span>
                                                    )}
                                                    <span style={{
                                                        fontSize: 11,
                                                        color: minionIsDead ? '#666' : '#aaa'
                                                    }}>
                                                        {minionDisplayHp} / {minionMaxHp}
                                                    </span>
                                                </div>
                                            </div>

                                            {/* å°å¼Ÿè¡€æ¡ */}
                                            <div style={{
                                                height: 8,
                                                background: 'rgba(0,0,0,0.4)',
                                                borderRadius: 4,
                                                overflow: 'hidden'
                                            }}>
                                                <div style={{
                                                    height: '100%',
                                                    width: `${minionHpPercent}%`,
                                                    background: minionIsDead
                                                        ? '#444'
                                                        : m.immune
                                                            ? 'linear-gradient(90deg, #2196F3, #64b5f6)'
                                                            : 'linear-gradient(90deg, #9C27B0, #ce93d8)',
                                                    transition: 'width 0.3s',
                                                    borderRadius: 4
                                                }} />
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                </div>
            </div>

            {/* æˆ˜æ–—æ—¥å¿— */}
            <div style={{
                height: 180,
                overflowY: 'auto',
                padding: '12px 16px',
                background: 'linear-gradient(180deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0.4) 100%)',
                fontSize: 12,
                borderTop: '2px solid rgba(201,162,39,0.3)',
                fontFamily: 'monospace'
            }}>
                <div style={{
                    fontSize: 11,
                    color: '#888',
                    marginBottom: 8,
                    borderBottom: '1px solid rgba(255,255,255,0.1)',
                    paddingBottom: 6
                }}>
                    ğŸ“œ æˆ˜æ–—æ—¥å¿—ï¼ˆæœ€è¿‘200æ¡ï¼‰
                </div>
                {combat.logs.slice(-200).map((log, i) => {
                    // âœ… å…¼å®¹å­—ç¬¦ä¸²å’Œå¯¹è±¡ä¸¤ç§æ ¼å¼
                    const isObject = typeof log === 'object' && log !== null;
                    const round = isObject ? log.round : null;
                    const text = isObject ? log.text : log;

                    return (
                        <div key={i} style={{
                            padding: '3px 0',
                            borderBottom: '1px solid rgba(255,255,255,0.03)',
                            color: text.includes('æ­»äº¡') || text.includes('é˜µäº¡') ? '#f44336' :
                                text.includes('å…ç–«') ? '#2196F3' :
                                    text.includes('è‡´æ­»æ‰“å‡»') ? '#ff6b6b' :
                                        text.includes('ç«ç‚®æ‰‹') || text.includes('å¬å”¤') ? '#ce93d8' :
                                            text.includes('ç™»ä¸Šç”²æ¿') ? '#64b5f6' :
                                                text.includes('æ²»ç–—') || text.includes('æ¢å¤') ? '#4CAF50' :
                                                    text.includes('æš´å‡»') ? '#ff9800' :
                                                        text.includes('èƒœåˆ©') ? '#ffd700' :
                                                            '#ccc'
                        }}>
                            {/* âœ… æ˜¾ç¤ºå›åˆæ•° */}
                            {round && <span style={{ color: '#888' }}>[å›åˆ{round}] </span>}
                            {text}
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

// ==================== éœæ ¼å‰§æƒ…æ¨¡æ€æ¡† ====================
const HoggerPlotModal = ({ state, dispatch }) => {
    if (!state.showHoggerPlot) return null;
    return (
        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }}>
            <div style={{ width: 600, padding: 40, background: '#1a1510', border: '3px solid #c9a227', borderRadius: 12, textAlign: 'center' }}>
                <h2 style={{ color: '#ffd700', marginBottom: 30 }}>è½®å›ä¹‹å§‹</h2>
                <p style={{ fontSize: 16, lineHeight: 1.8, color: '#e8dcc4' }}>
                    ä½ æ„Ÿåˆ°ä¸€é˜µå¤´æ™•ç›®çœ©ï¼Œè¿‡å¾€çš„ç§ç§ç™½é©¹è¿‡éš™ï¼Œç†Ÿæ‚‰çš„æ„Ÿè§‰æ¶Œä¸Šå¿ƒå¤´ï¼Œä»¿ä½›è¿™å·²ç»æ˜¯ä½ æ— æ•°æ¬¡å‡»è´¥è¿‡çš„å¯¹æ‰‹ï¼Œ<br/>
                    è¿™ä¸€ä¸–ä½ å‡»è´¥äº†å¼ºåŠ²çš„å¯¹æ‰‹éœæ ¼ï¼Œä¸‰åå¹´æ²³ä¸œä¸‰åå¹´æ²³è¥¿ï¼Œè«æ¬ºå°‘å¹´ç©·ã€‚
                </p>
                <Button onClick={() => dispatch({ type: 'CLOSE_HOGGER_PLOT' })} style={{ marginTop: 30 }}>
                    ç¡®å®š
                </Button>
            </div>
        </div>
    );
};

// ==================== è¡€è‰²åå­—å†›çš„å¾½ç« æ¨¡æ€æ¡†ï¼ˆé€‰æ‹©ç›®æ ‡è£…å¤‡ï¼‰ ====================
const ScarletBadgeModal = ({ state, dispatch }) => {
    if (!state.showScarletBadgeModal) return null;

    const badgeItemId = state.pendingBadgeItemId || 'IT_SCARLET_CRUSADER_BADGE';
    const rule = BADGE_UPGRADE_RULES?.[badgeItemId] || BADGE_UPGRADE_RULES.IT_SCARLET_CRUSADER_BADGE;

    const [selectedId, setSelectedId] = React.useState('');

    // èƒŒåŒ…é‡Œå¯å‡çº§çš„è¡€è‰²ä¿®é“é™¢è£…å¤‡
    const invCandidates = (state.inventory || [])
        .filter(i => i?.type === 'equipment' && i.instanceId && rule.isEligible(i))
        .map(eq => ({
            instanceId: eq.instanceId,
            label: `ğŸ’ èƒŒåŒ… Â· ${eq.name}ï¼ˆLv.${eq.currentLevel ?? eq.level ?? 0} â†’ Lv.${Math.min(rule.cap ?? 100, (eq.maxLevel ?? 100), (eq.currentLevel ?? eq.level ?? 0) + (rule.inc ?? 2))}ï¼‰`,
            eq
        }));

    // å·²ç©¿æˆ´çš„å¯å‡çº§è£…å¤‡
    const equippedCandidates = [];
    (state.characters || []).forEach(c => {
        Object.values(c.equipment || {}).forEach(eq => {
            if (!eq?.instanceId) return;
            if (!rule.isEligible(eq)) return;
            equippedCandidates.push({
                instanceId: eq.instanceId,
                label: `ğŸ§ ${c.name} Â· ${eq.name}ï¼ˆLv.${eq.currentLevel ?? eq.level ?? 0} â†’ Lv.${Math.min(rule.cap ?? 100, (eq.maxLevel ?? 100), (eq.currentLevel ?? eq.level ?? 0) + (rule.inc ?? 2))}ï¼‰`,
                eq
            });
        });
    });

    // å»é‡ï¼ˆåŒä¸€ä»¶è£…å¤‡ä¸åº”é‡å¤å‡ºç°ï¼‰
    const seen = new Set();
    const candidates = [...invCandidates, ...equippedCandidates].filter(c => {
        if (seen.has(c.instanceId)) return false;
        seen.add(c.instanceId);
        return true;
    });

    return (
        <div
            style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: 'rgba(0,0,0,0.9)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 2200,
                padding: 20
            }}
            onClick={() => dispatch({ type: 'CLOSE_SCARLET_BADGE_MODAL' })}
        >
            <div
                style={{
                    width: 620,
                    maxWidth: '95vw',
                    padding: 28,
                    background: 'linear-gradient(135deg, rgba(30,25,20,0.98) 0%, rgba(20,15,12,0.98) 100%)',
                    border: `3px solid ${rule.theme?.border || '#c62828'}`,
                    borderRadius: 14,
                    boxShadow: `0 10px 36px ${rule.theme?.shadow || 'rgba(198,40,40,0.25)'}`
                }}
                onClick={(e) => e.stopPropagation()}
            >
                <h2 style={{ margin: 0, color: rule.theme?.title || '#ff6b6b', textAlign: 'center' }}>{rule.title}</h2>
                <div style={{ marginTop: 12, fontSize: 13, color: '#e8dcc4', lineHeight: 1.7, textAlign: 'center' }}>

                    é€‰æ‹©ä¸€ä»¶ã€{rule.zoneLabel}ã€‘è£…å¤‡ï¼Œä½¿å…¶ç­‰çº§æå‡ <b style={{ color: '#ffd700' }}>+{rule.inc ?? 2}</b>ï¼ˆæœ€é«˜{rule.cap ?? 100}çº§ï¼‰ã€‚

                </div>

                <div style={{ marginTop: 18, padding: 14, background: 'rgba(0,0,0,0.35)', borderRadius: 10, border: '1px solid rgba(255,255,255,0.08)' }}>
                    {candidates.length === 0 ? (
                        <div style={{ color: '#ff6b6b', fontSize: 13, textAlign: 'center' }}>
                            å½“å‰æ²¡æœ‰å¯å‡çº§çš„ã€{rule.zoneLabel}ã€‘è£…å¤‡ï¼ˆèƒŒåŒ…æˆ–å·²ç©¿æˆ´ï¼‰ã€‚
                        </div>
                    ) : (
                        <>
                            <div style={{ fontSize: 12, color: '#c9a227', marginBottom: 10 }}>å¯é€‰æ‹©ç›®æ ‡</div>
                            <select
                                value={selectedId}
                                onChange={(e) => setSelectedId(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '10px 12px',
                                    background: 'rgba(0,0,0,0.45)',
                                    border: '1px solid rgba(255,255,255,0.15)',
                                    borderRadius: 8,
                                    color: '#fff',
                                    fontSize: 13,
                                    cursor: 'pointer'
                                }}
                            >
                                <option value="">è¯·é€‰æ‹©è£…å¤‡...</option>
                                {candidates.map(c => (
                                    <option key={c.instanceId} value={c.instanceId}>{c.label}</option>
                                ))}
                            </select>
                        </>
                    )}
                </div>

                <div style={{ display: 'flex', gap: 14, justifyContent: 'center', marginTop: 22 }}>
                    <Button
                        variant="danger"
                        disabled={candidates.length === 0 || !selectedId}
                        onClick={() => {
                            dispatch({ type: 'APPLY_SCARLET_BADGE', payload: { targetInstanceId: selectedId } });
                        }}
                    >
                        âœ… ç¡®è®¤å‡çº§
                    </Button>
                    <Button variant="secondary" onClick={() => dispatch({ type: 'CLOSE_SCARLET_BADGE_MODAL' })}>
                        å–æ¶ˆ
                    </Button>
                </div>
            </div>
        </div>
    );
};

// ==================== é‡ç”Ÿç¡®è®¤æ¨¡æ€æ¡† ====================
const RebirthConfirmModal = ({ state, dispatch }) => {
    if (!state.showRebirthConfirm) return null;
    const equippedCount = state.characters.reduce((s, c) => s + Object.values(c.equipment || {}).filter(Boolean).length, 0);
    const spaceNeeded = state.inventory.length + equippedCount > state.inventorySize;

    return (
        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }}>
            <div style={{ width: 500, padding: 30, background: '#1a1510', border: '3px solid #ff6b6b', borderRadius: 12 }}>
                <h2 style={{ color: '#ff6b6b', textAlign: 'center' }}>é‡ç”Ÿè½®å›ç¡®è®¤</h2>
                <p style={{ lineHeight: 1.6, margin: '20px 0' }}>
                    é‡ç”Ÿè½®å›å°†é‡ç½®ç‹å›½çš„å»ºç­‘ã€èµ„æºã€ç ”ç©¶ç­‰çº§ä»¥åŠè§’è‰²ï¼Œ<br/>
                    ä½†é“å…·æ å’Œè£…å¤‡ä¼šä¿ç•™ã€‚<br/>
                    âœ… åŠŸèƒ½å»ºç­‘å°†å…¨éƒ¨ä¿ç•™ï¼ˆä¸ä¼šæ¶ˆå¤±ï¼‰ã€‚<br/><br/>
                    {spaceNeeded ?
                        <span style={{ color: '#ff6b6b' }}>âš ï¸ èƒŒåŒ…ç©ºé—´ä¸è¶³ï¼Œæ— æ³•å®¹çº³æ‰€æœ‰è£…å¤‡ï¼</span> :
                        `éœ€è¦ ${equippedCount} ä¸ªèƒŒåŒ…ç©ºæ ¼å­˜æ”¾å½“å‰è£…å¤‡ã€‚`
                    }
                </p>
                <div style={{ display: 'flex', gap: 20, justifyContent: 'center' }}>
                    <Button onClick={() => dispatch({ type: 'PERFORM_REBIRTH' })} variant="danger" disabled={spaceNeeded}>
                        ç¡®è®¤é‡ç”Ÿ
                    </Button>
                    <Button onClick={() => dispatch({ type: 'CLOSE_REBIRTH_CONFIRM' })} variant="secondary">
                        å–æ¶ˆ
                    </Button>
                </div>
            </div>
        </div>
    );
};

// ==================== é‡ç”Ÿå‰§æƒ…æ¨¡æ€æ¡† ====================
const RebirthPlotModal = ({ state, dispatch }) => {
    if (!state.showRebirthPlot) return null;
    const p = state.showRebirthPlot;
    const bossNames = (p.defeatedBosses || []).map(id => {
        return BOSS_NAMES[id] || id;
    });
    return (
        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.95)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }}>
            <div style={{ width: 700, padding: 40, background: '#1a1510', border: '4px solid #ffd700', borderRadius: 16, textAlign: 'center' }}>
                <h2 style={{ color: '#ffd700', marginBottom: 30 }}>ç¬¬ {p.rebirthCount} ä¸–</h2>
                <p style={{ fontSize: 18, lineHeight: 2, color: '#e8dcc4' }}>
                    ä½ çœ¼å‰ä¸€é»‘ï¼Œä¸Šä¸€ä¸–ç»å†äº† {p.frame} å¸§çš„åŠªåŠ›ï¼Œ
                    {bossNames.length > 0 ? `å‡»è´¥äº†${bossNames.join('ã€')}ï¼Œ` : ''}
                    æœ€é«˜ç­‰çº§è¾¾åˆ° Lv.{p.maxLevel || 0}ã€‚<br/>
                    è¿™ä¸€ä¸–ï¼Œä½ è·å¾—äº† {p.newExp}% ç»éªŒå€¼ã€{p.newGold}% é‡‘å¸ã€{p.newDrop}% æ‰è½ã€<br/>
                    {p.newResearch}% ç ”ç©¶é€Ÿåº¦å¢å¹…ï¼Œå¹¶è·å¾—äº†ç¾ç»Šã€Œ{p.newBond}ã€ã€‚<br/><br/>
                    ä½ ç¼“ç¼“çå¼€åŒçœ¼ï¼Œ<br/>
                    è¿™æ˜¯ä½ ç»å†çš„ç¬¬ {p.rebirthCount} ä¸–ï¼Œè¿™ä¸€ä¸–ä½ æ„Ÿåˆ°å…¨èº«å……æ»¡äº†åŠ›é‡ï¼Œfighting!
                </p>
                <Button onClick={() => dispatch({ type: 'CLOSE_REBIRTH_PLOT' })} style={{ marginTop: 40, padding: '12px 40px', fontSize: 18 }}>
                    å¼€å§‹æ–°çš„ä¸€ä¸–
                </Button>
            </div>
        </div>
    );
};

// ==================== æœ¬ä¸–é‡ç”ŸåŠ æˆæ¨¡æ€æ¡† ====================
const RebirthBonusModal = ({ state, onClose }) => {
    const bonuses = state.rebirthBonuses || { exp: 0, gold: 0, drop: 0, researchSpeed: 0 };
    const bonds = state.rebirthBonds || [];
    const rebirthCount = state.rebirthCount || 0;

    // ç¾ç»Šè¯¦ç»†ä¿¡æ¯
    const BOND_DETAILS = {
        baoernai: {
            name: 'åŒ…äºŒå¥¶',
            description: 'é˜Ÿä¼ä¸­æœ‰1ä¸ªé˜²æŠ¤æˆ˜å£«å’Œ2ä¸ªæˆ’å¾‹ç‰§å¸ˆæ—¶ï¼Œæ¯å›åˆæˆ˜å£«å¯¹æ‰€æœ‰æ•Œäººé€ æˆæ ¼æŒ¡å€¼80%çš„é¢å¤–ä¼¤å®³'
        },
        jianyue: {
            name: 'ç®€çº¦è€Œä¸ç®€å•',
            description: 'é˜Ÿä¼å…¨ä¸ºåŒä¸€èŒä¸šæ—¶ï¼Œæ™®é€šæ”»å‡»ä¼¤å®³æé«˜150%'
        }
    };

    // æ‰€æœ‰å¯èƒ½çš„ç¾ç»Šæ± 
    const ALL_BONDS = ['baoernai', 'jianyue'];

    // BossåŠ æˆé…ç½®ï¼šä½¿ç”¨å…¨å±€ BOSS_BONUS_CONFIGï¼ˆå•ä¸€æ•°æ®æºï¼‰

    // å»é‡åçš„å·²è·å¾—ç¾ç»Š
    const uniqueBonds = [...new Set(bonds)];

    // ==================== è®¡ç®—é¢„æµ‹åŠ æˆï¼ˆæ–°å…¬å¼ï¼‰ ====================
    // å¸§æ•°åŠ æˆï¼šå¯¹æ•°å‡½æ•°ï¼Œ3600å¸§â†’10%, 36000å¸§â†’20%, 86400å¸§â†’30%
    const frame = state.lifeFrame || 0;
    const frameBonus = frame >= 360 ? 0.1 * Math.log10(frame / 360) : 0;

    // ç­‰çº§åŠ æˆï¼šæ¯çº§0.2%
    const maxLevel = state.characters.reduce((m, c) => Math.max(m, c.level || 0), 0);
    const levelBonus = maxLevel * 0.002;

    // BossåŠ æˆ
    const defeatedBosses = state.defeatedBosses || [];
    const totalBossBonus = defeatedBosses.reduce((sum, bossId) => sum + (BOSS_BONUS_CONFIG[bossId]?.bonus || 0), 0);

    // æ€»é¢„æµ‹åŠ æˆ
    // ä¸‰é¡¹ä¹˜åŒºï¼šå¸§æ•° / æœ€é«˜ç­‰çº§ / Bosså‡»æ€ â€”â€” ä¹˜ç®—ï¼Œä¸åŠ ç®—
    const predictedExp = (1 + frameBonus) * (1 + levelBonus) * (1 + totalBossBonus) - 1;
    const predictedGold = predictedExp;
    const predictedDrop = predictedExp * 0.6;
    const predictedResearch = predictedExp * 0.5;

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0,0,0,0.9)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 2000
        }} onClick={onClose}>
            <div style={{
                width: 680,
                maxHeight: '85vh',
                overflowY: 'auto',
                padding: 30,
                background: 'linear-gradient(135deg, #1a1510 0%, #0d0a07 100%)',
                border: '3px solid #c9a227',
                borderRadius: 12,
                boxShadow: '0 8px 32px rgba(201,162,39,0.3)'
            }} onClick={(e) => e.stopPropagation()}>
                <h2 style={{
                    color: '#ffd700',
                    textAlign: 'center',
                    marginBottom: 24,
                    textShadow: '2px 2px 4px rgba(0,0,0,0.8)'
                }}>
                    âš¡ è½®å›åŠ æˆæ€»è§ˆ
                </h2>

                {/* é‡ç”Ÿæ¬¡æ•° */}
                <div style={{
                    textAlign: 'center',
                    marginBottom: 24,
                    padding: '12px 20px',
                    background: 'rgba(201,162,39,0.15)',
                    borderRadius: 8,
                    border: '1px solid rgba(201,162,39,0.3)'
                }}>
                    <span style={{ color: '#c9a227', fontSize: 14 }}>å·²è½®å› </span>
                    <span style={{ color: '#ffd700', fontSize: 24, fontWeight: 700 }}>{rebirthCount}</span>
                    <span style={{ color: '#c9a227', fontSize: 14 }}> ä¸–</span>
                </div>

                {/* å½“å‰ç”Ÿæ•ˆåŠ æˆï¼ˆæ¥è‡ªä¸Šä¸€ä¸–ï¼‰ */}
                <div style={{
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 8,
                    padding: 16,
                    marginBottom: 20,
                    border: '1px solid #4a3c2a'
                }}>
                    <h3 style={{ color: '#c9a227', fontSize: 14, marginBottom: 12, borderBottom: '1px solid rgba(201,162,39,0.2)', paddingBottom: 8 }}>
                        ğŸ“Š å½“å‰ç”Ÿæ•ˆåŠ æˆï¼ˆæ¥è‡ªä¸Šä¸€ä¸–ï¼‰
                    </h3>
                    {rebirthCount === 0 ? (
                        <div style={{ color: '#666', textAlign: 'center', padding: 12, fontSize: 13 }}>
                            å°šæœªè½®å›ï¼Œæš‚æ— ç”Ÿæ•ˆåŠ æˆ
                        </div>
                    ) : (
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 12 }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', padding: '8px 12px', background: 'rgba(76,175,80,0.1)', borderRadius: 6, border: '1px solid rgba(76,175,80,0.3)' }}>
                                <span style={{ color: '#888' }}>â­ ç»éªŒå€¼</span>
                                <span style={{ color: '#4CAF50', fontWeight: 600 }}>+{(bonuses.exp * 100).toFixed(1)}%</span>
                            </div>
                            <div style={{ display: 'flex', justifyContent: 'space-between', padding: '8px 12px', background: 'rgba(255,215,0,0.1)', borderRadius: 6, border: '1px solid rgba(255,215,0,0.3)' }}>
                                <span style={{ color: '#888' }}>ğŸª™ é‡‘å¸</span>
                                <span style={{ color: '#ffd700', fontWeight: 600 }}>+{(bonuses.gold * 100).toFixed(1)}%</span>
                            </div>
                            <div style={{ display: 'flex', justifyContent: 'space-between', padding: '8px 12px', background: 'rgba(163,51,238,0.1)', borderRadius: 6, border: '1px solid rgba(163,51,238,0.3)' }}>
                                <span style={{ color: '#888' }}>ğŸ“¦ æ‰è½</span>
                                <span style={{ color: '#a335ee', fontWeight: 600 }}>+{(bonuses.drop * 100).toFixed(1)}%</span>
                            </div>
                            <div style={{ display: 'flex', justifyContent: 'space-between', padding: '8px 12px', background: 'rgba(0,112,221,0.1)', borderRadius: 6, border: '1px solid rgba(0,112,221,0.3)' }}>
                                <span style={{ color: '#888' }}>ğŸ”¬ ç ”ç©¶é€Ÿåº¦</span>
                                <span style={{ color: '#0070dd', fontWeight: 600 }}>+{(bonuses.researchSpeed * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                    )}
                </div>

                {/* é¢„æµ‹ï¼šå¦‚æœç°åœ¨é‡ç”Ÿèƒ½è·å¾—çš„åŠ æˆ */}
                <div style={{
                    background: 'rgba(255,107,107,0.1)',
                    borderRadius: 8,
                    padding: 16,
                    marginBottom: 20,
                    border: '1px solid rgba(255,107,107,0.3)'
                }}>
                    <h3 style={{ color: '#ff6b6b', fontSize: 14, marginBottom: 12, borderBottom: '1px solid rgba(255,107,107,0.2)', paddingBottom: 8 }}>
                        ğŸ”® è‹¥æ­¤åˆ»é‡ç”Ÿï¼Œä¸‹ä¸€ä¸–å°†è·å¾—
                    </h3>

                    {/* å½“å‰è¿›åº¦æ˜ç»† */}
                    <div style={{
                        background: 'rgba(0,0,0,0.2)',
                        borderRadius: 6,
                        padding: 12,
                        marginBottom: 12,
                        fontSize: 12
                    }}>
                        <div style={{ color: '#888', marginBottom: 8 }}>æœ¬ä¸–è¿›åº¦ï¼š</div>
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 8 }}>
                            <div>
                                <span style={{ color: '#666' }}>å¸§æ•°ï¼š</span>
                                <span style={{ color: '#ffd700' }}>{Math.floor(frame)}</span>
                                <span style={{ color: '#4CAF50', marginLeft: 4 }}>â†’ +{(frameBonus * 100).toFixed(1)}%</span>
                            </div>
                            <div>
                                <span style={{ color: '#666' }}>æœ€é«˜ç­‰çº§ï¼š</span>
                                <span style={{ color: '#ffd700' }}>Lv.{maxLevel}</span>
                                <span style={{ color: '#4CAF50', marginLeft: 4 }}>â†’ +{(levelBonus * 100).toFixed(1)}%</span>
                            </div>
                            <div>
                                <span style={{ color: '#666' }}>Bosså‡»æ€ï¼š</span>
                                <span style={{ color: '#ffd700' }}>{defeatedBosses.length}ä¸ª</span>
                                <span style={{ color: '#4CAF50', marginLeft: 4 }}>â†’ +{(totalBossBonus * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                        {defeatedBosses.length > 0 && (
                            <div style={{ marginTop: 8, display: 'flex', gap: 6, flexWrap: 'wrap' }}>
                                {defeatedBosses.map(bossId => (
                                    <span key={bossId} style={{
                                        padding: '2px 6px',
                                        background: 'rgba(255,107,107,0.2)',
                                        borderRadius: 3,
                                        fontSize: 10,
                                        color: '#ff6b6b'
                                    }}>
                                        âœ“ {BOSS_BONUS_CONFIG[bossId]?.name || bossId}
                                    </span>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* é¢„æµ‹åŠ æˆæ•°å€¼ */}
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 10 }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', padding: '6px 10px', background: 'rgba(0,0,0,0.2)', borderRadius: 4 }}>
                            <span style={{ color: '#888', fontSize: 12 }}>â­ ç»éªŒå€¼</span>
                            <span style={{ color: '#4CAF50', fontWeight: 600, fontSize: 12 }}>+{(predictedExp * 100).toFixed(1)}%</span>
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'space-between', padding: '6px 10px', background: 'rgba(0,0,0,0.2)', borderRadius: 4 }}>
                            <span style={{ color: '#888', fontSize: 12 }}>ğŸª™ é‡‘å¸</span>
                            <span style={{ color: '#ffd700', fontWeight: 600, fontSize: 12 }}>+{(predictedGold * 100).toFixed(1)}%</span>
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'space-between', padding: '6px 10px', background: 'rgba(0,0,0,0.2)', borderRadius: 4 }}>
                            <span style={{ color: '#888', fontSize: 12 }}>ğŸ“¦ æ‰è½</span>
                            <span style={{ color: '#a335ee', fontWeight: 600, fontSize: 12 }}>+{(predictedDrop * 100).toFixed(1)}%</span>
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'space-between', padding: '6px 10px', background: 'rgba(0,0,0,0.2)', borderRadius: 4 }}>
                            <span style={{ color: '#888', fontSize: 12 }}>ğŸ”¬ ç ”ç©¶é€Ÿåº¦</span>
                            <span style={{ color: '#0070dd', fontWeight: 600, fontSize: 12 }}>+{(predictedResearch * 100).toFixed(1)}%</span>
                        </div>
                    </div>

                    {/* ç¾ç»Šæ±  */}
                    <div style={{ marginTop: 12, padding: '8px 12px', background: 'rgba(255,215,0,0.1)', borderRadius: 6, border: '1px dashed rgba(255,215,0,0.3)' }}>
                        <div style={{ fontSize: 11, color: '#888', marginBottom: 4 }}>ç¾ç»Šï¼šéšæœºè·å¾—ä»¥ä¸‹ä¹‹ä¸€ï¼ˆåŒä¸€ç¾ç»Šåªç”Ÿæ•ˆä¸€æ¬¡ï¼‰</div>
                        <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
                            {ALL_BONDS.map(bondId => {
                                const owned = uniqueBonds.includes(bondId);
                                return (
                                    <span key={bondId} style={{
                                        padding: '3px 8px',
                                        background: owned ? 'rgba(102,102,102,0.3)' : 'rgba(201,162,39,0.2)',
                                        borderRadius: 4,
                                        fontSize: 11,
                                        color: owned ? '#666' : '#ffd700',
                                        textDecoration: owned ? 'line-through' : 'none'
                                    }}>
                                        {BOND_DETAILS[bondId]?.name || bondId}{owned ? 'ï¼ˆå·²æœ‰ï¼‰' : ''}
                                    </span>
                                );
                            })}
                        </div>
                    </div>

                    {/* æç¤ºï¼šåŠ æˆä¸å åŠ  */}
                    <div style={{ marginTop: 10, fontSize: 11, color: '#888', textAlign: 'center' }}>
                        âš ï¸ é‡ç”Ÿåï¼Œä¸Šè¿°åŠ æˆå°†<span style={{ color: '#ff6b6b' }}>æ›¿æ¢</span>å½“å‰ç”Ÿæ•ˆåŠ æˆï¼ˆä¸å åŠ ï¼‰
                    </div>
                </div>

                {/* å·²è·å¾—ç¾ç»Šåˆ—è¡¨ */}
                <div style={{
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 8,
                    padding: 16,
                    marginBottom: 20,
                    border: '1px solid #4a3c2a'
                }}>
                    <h3 style={{ color: '#c9a227', fontSize: 14, marginBottom: 12, borderBottom: '1px solid rgba(201,162,39,0.2)', paddingBottom: 8 }}>
                        ğŸ”— å·²è·å¾—ç¾ç»Š ({uniqueBonds.length}/{ALL_BONDS.length})
                    </h3>
                    {uniqueBonds.length === 0 ? (
                        <div style={{ color: '#666', textAlign: 'center', padding: 20 }}>
                            æš‚æ— ç¾ç»Š
                        </div>
                    ) : (
                        <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
                            {uniqueBonds.map(bondId => {
                                const detail = BOND_DETAILS[bondId] || { name: bondId, description: 'æœªçŸ¥ç¾ç»Š' };
                                return (
                                    <div key={bondId} style={{
                                        padding: 12,
                                        background: 'linear-gradient(135deg, rgba(201,162,39,0.1), rgba(139,115,25,0.05))',
                                        borderRadius: 6,
                                        border: '1px solid rgba(201,162,39,0.3)'
                                    }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 6 }}>
                                            <span style={{ color: '#ffd700', fontWeight: 600 }}>
                                                âœ“ {detail.name}
                                            </span>
                                            <span style={{ fontSize: 11, color: '#4CAF50' }}>ç”Ÿæ•ˆä¸­</span>
                                        </div>
                                        <div style={{ color: '#aaa', fontSize: 12, lineHeight: 1.5 }}>
                                            {detail.description}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    )}
                </div>

                {/* ç¾ç»Šæ± ä¸€è§ˆ */}
                <div style={{
                    background: 'rgba(0,0,0,0.3)',
                    borderRadius: 8,
                    padding: 16,
                    border: '1px solid #4a3c2a'
                }}>
                    <h3 style={{ color: '#c9a227', fontSize: 14, marginBottom: 12, borderBottom: '1px solid rgba(201,162,39,0.2)', paddingBottom: 8 }}>
                        ğŸ“œ ç¾ç»Šæ± ä¸€è§ˆ
                    </h3>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                        {ALL_BONDS.map(bondId => {
                            const detail = BOND_DETAILS[bondId] || { name: bondId, description: 'æœªçŸ¥ç¾ç»Š' };
                            const owned = uniqueBonds.includes(bondId);
                            return (
                                <div key={bondId} style={{
                                    padding: 10,
                                    background: owned ? 'rgba(76,175,80,0.1)' : 'rgba(0,0,0,0.2)',
                                    borderRadius: 6,
                                    border: owned ? '1px solid rgba(76,175,80,0.3)' : '1px solid rgba(74,60,42,0.5)'
                                }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 4 }}>
                                        <span style={{ color: owned ? '#4CAF50' : '#888', fontWeight: 600, fontSize: 13 }}>
                                            {owned ? 'âœ“ ' : ''}{detail.name}
                                        </span>
                                        {owned && (
                                            <span style={{ fontSize: 11, color: '#4CAF50' }}>å·²è·å¾—</span>
                                        )}
                                    </div>
                                    <div style={{ color: '#777', fontSize: 11, lineHeight: 1.4 }}>
                                        {detail.description}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>

                <div style={{ textAlign: 'center', marginTop: 24 }}>
                    <Button onClick={onClose} variant="secondary">
                        å…³é—­
                    </Button>
                </div>
            </div>
        </div>
    );
};

// ==================== ä»»åŠ¡è¿½è¸ªæ‚¬æµ®UI ====================
const QuestTracker = ({ state, dispatch, onOpenQuestPage }) => {
    const [isCollapsed, setIsCollapsed] = useState(false);
    const [expandedQuests, setExpandedQuests] = useState(new Set());
    const [isMinimized, setIsMinimized] = useState(false);

    // è·å–æ‰€æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡
    const activeQuests = Object.entries(state.questProgress || {})
        .filter(([_, progress]) => progress.status === 'in_progress')
        .map(([questId, progress]) => ({
            questId,
            progress,
            questData: QUEST_CHAINS[questId]
        }))
        .filter(q => q.questData);

    // æ£€æŸ¥æ­¥éª¤æ¡ä»¶è¿›åº¦
    const getRequirementProgress = (requirement) => {
        if (!requirement) return { met: true, current: 0, target: 0, text: '' };

        switch (requirement.type) {
            case 'zone_battles': {
                const zone = ZONES[requirement.zoneId];
                const zoneName = zone?.name || requirement.zoneId;
                const current = state.questBattleProgress?.[requirement.zoneId] || 0;
                const target = requirement.count;
                return {
                    met: current >= target,
                    current,
                    target,
                    text: `åœ¨${zoneName}æˆ˜æ–—`,
                    icon: 'âš”ï¸'
                };
            }
            case 'character_level': {
                const maxLevel = Math.max(...state.characters.map(c => c.level), 0);
                return {
                    met: maxLevel >= requirement.level,
                    current: maxLevel,
                    target: requirement.level,
                    text: `è§’è‰²ç­‰çº§è¾¾åˆ°`,
                    icon: 'â­'
                };
            }
            case 'boss_defeated': {
                const bossName = BOSS_DATA[requirement.bossId]?.name || requirement.bossId;
                const defeated = state.defeatedBosses?.includes(requirement.bossId);
                return {
                    met: defeated,
                    current: defeated ? 1 : 0,
                    target: 1,
                    text: `å‡»è´¥${bossName}`,
                    icon: 'ğŸ²'
                };
            }
            case 'have_gold': {
                return {
                    met: state.resources.gold >= requirement.amount,
                    current: Math.floor(state.resources.gold),
                    target: requirement.amount,
                    text: `å‡†å¤‡é‡‘å¸`,
                    icon: 'ğŸª™'
                };
            }
            case 'have_item': {
                const hasItem = state.inventory.some(i => i.id === requirement.itemId) ||
                    state.questItems?.some(i => i.id === requirement.itemId);
                const itemName = QUEST_ITEMS[requirement.itemId]?.name ||
                    ITEMS[requirement.itemId]?.name ||
                    requirement.itemId;
                return {
                    met: hasItem,
                    current: hasItem ? 1 : 0,
                    target: 1,
                    text: `è·å¾—${itemName}`,
                    icon: 'ğŸ“¦'
                };
            }
            default:
                return { met: true, current: 0, target: 0, text: '' };
        }
    };

    // åˆ‡æ¢ä»»åŠ¡å±•å¼€çŠ¶æ€
    const toggleQuestExpand = (questId) => {
        setExpandedQuests(prev => {
            const next = new Set(prev);
            if (next.has(questId)) {
                next.delete(questId);
            } else {
                next.add(questId);
            }
            return next;
        });
    };

    // ==================== æœ€å°åŒ–æ¨¡å¼ï¼ˆæ— è®ºæœ‰æ²¡æœ‰ä»»åŠ¡éƒ½é€‚ç”¨ï¼‰ ====================
    if (isMinimized) {
        return (
            <div
                onClick={() => setIsMinimized(false)}
                style={{
                    position: 'fixed',
                    top: 100,
                    right: 16,
                    width: 50,
                    height: 50,
                    background: 'linear-gradient(135deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))',
                    border: '2px solid #c9a227',
                    borderRadius: '50%',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    cursor: 'pointer',
                    boxShadow: '0 4px 20px rgba(201,162,39,0.3)',
                    zIndex: 100,
                    transition: 'all 0.3s'
                }}
                title="å±•å¼€ä»»åŠ¡è¿½è¸ª"
            >
                <div style={{ position: 'relative' }}>
                    <span style={{ fontSize: 24 }}>ğŸ“œ</span>
                    {/* ä»»åŠ¡æ•°é‡å¾½ç« ï¼ˆåªæœ‰æœ‰ä»»åŠ¡æ—¶æ‰æ˜¾ç¤ºï¼‰ */}
                    {activeQuests.length > 0 && (
                        <div style={{
                            position: 'absolute',
                            top: -8,
                            right: -8,
                            background: '#f44336',
                            color: '#fff',
                            fontSize: 10,
                            fontWeight: 700,
                            width: 18,
                            height: 18,
                            borderRadius: '50%',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            border: '2px solid #1a1510'
                        }}>
                            {activeQuests.length}
                        </div>
                    )}
                </div>
            </div>
        );
    }

    // ==================== æ²¡æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡æ—¶çš„æ˜¾ç¤º ====================
    if (activeQuests.length === 0) {
        return (
            <div style={{
                position: 'fixed',
                top: 100,
                right: 16,
                width: 280,
                background: 'linear-gradient(135deg, rgba(30,25,20,0.95) 0%, rgba(20,15,12,0.98) 100%)',
                border: '2px solid #4a3c2a',
                borderRadius: 10,
                padding: 12,
                boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                zIndex: 100,
                transition: 'all 0.3s'
            }}>
                <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between'
                }}>
                    <div style={{
                        fontSize: 13,
                        color: '#c9a227',
                        fontWeight: 600,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span>ğŸ“œ</span>
                        ä»»åŠ¡è¿½è¸ª
                    </div>
                    {/* âœ… ä¿®å¤ï¼šæ·»åŠ æœ€å°åŒ–å’ŒæŸ¥çœ‹ä»»åŠ¡æŒ‰é’® */}
                    <div style={{ display: 'flex', gap: 4 }}>
                        <button
                            onClick={() => setIsMinimized(true)}
                            style={{
                                background: 'rgba(100,100,100,0.3)',
                                border: '1px solid #666',
                                color: '#ccc',
                                fontSize: 12,
                                cursor: 'pointer',
                                padding: '4px 8px',
                                borderRadius: 4,
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                minWidth: 24,
                                minHeight: 24
                            }}
                            title="æœ€å°åŒ–"
                        >
                            â–
                        </button>
                        <button
                            onClick={() => onOpenQuestPage?.()}
                            style={{
                                background: 'rgba(201,162,39,0.2)',
                                border: '1px solid #c9a227',
                                borderRadius: 4,
                                color: '#c9a227',
                                fontSize: 10,
                                padding: '4px 8px',
                                cursor: 'pointer'
                            }}
                        >
                            æŸ¥çœ‹ä»»åŠ¡
                        </button>
                    </div>
                </div>
                <div style={{
                    marginTop: 12,
                    textAlign: 'center',
                    color: '#666',
                    fontSize: 12,
                    padding: '16px 0'
                }}>
                    <div style={{ fontSize: 24, marginBottom: 8 }}>ğŸ“­</div>
                    æš‚æ— è¿›è¡Œä¸­çš„ä»»åŠ¡
                </div>
            </div>
        );
    }

    // ==================== æœ‰ä»»åŠ¡æ—¶çš„æ­£å¸¸æ˜¾ç¤º ====================
    return (
        <div style={{
            position: 'fixed',
            top: 100,
            right: 16,
            width: isCollapsed ? 50 : 300,
            maxHeight: 'calc(100vh - 140px)',
            background: 'linear-gradient(135deg, rgba(30,25,20,0.97) 0%, rgba(20,15,12,0.99) 100%)',
            border: '2px solid #c9a227',
            borderRadius: 10,
            overflow: 'hidden',
            boxShadow: '0 4px 24px rgba(0,0,0,0.6), 0 0 20px rgba(201,162,39,0.15)',
            zIndex: 100,
            transition: 'width 0.3s ease',
            display: 'flex',
            flexDirection: 'column'
        }}>
            {/* æ ‡é¢˜æ  */}
            <div style={{
                padding: '10px 12px',
                background: 'linear-gradient(180deg, rgba(201,162,39,0.15) 0%, transparent 100%)',
                borderBottom: '1px solid rgba(201,162,39,0.3)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                flexShrink: 0
            }}>
                {!isCollapsed && (
                    <div style={{
                        fontSize: 14,
                        color: '#ffd700',
                        fontWeight: 600,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span>ğŸ“œ</span>
                        ä»»åŠ¡è¿½è¸ª
                        <span style={{
                            fontSize: 11,
                            color: '#888',
                            fontWeight: 400
                        }}>
                            ({activeQuests.length})
                        </span>
                    </div>
                )}

                <div style={{ display: 'flex', gap: 4 }}>
                    {!isCollapsed && (
                        <button
                            onClick={() => setIsMinimized(true)}
                            style={{
                                background: 'rgba(100,100,100,0.3)',
                                border: '1px solid #666',
                                color: '#ccc',
                                fontSize: 12,
                                cursor: 'pointer',
                                padding: '4px 8px',
                                borderRadius: 4,
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                minWidth: 24,
                                minHeight: 24
                            }}
                            title="æœ€å°åŒ–"
                        >
                            â–
                        </button>
                    )}
                    <button
                        onClick={() => setIsCollapsed(!isCollapsed)}
                        style={{
                            background: 'transparent',
                            border: 'none',
                            color: '#c9a227',
                            fontSize: 16,
                            cursor: 'pointer',
                            padding: '2px 6px',
                            borderRadius: 4,
                            transition: 'transform 0.3s'
                        }}
                        title={isCollapsed ? 'å±•å¼€' : 'æŠ˜å '}
                    >
                        {isCollapsed ? 'â—€' : 'â–¶'}
                    </button>
                </div>
            </div>

            {/* ä»»åŠ¡åˆ—è¡¨ */}
            {!isCollapsed && (
                <div style={{
                    flex: 1,
                    overflowY: 'auto',
                    padding: 8
                }}>
                    {activeQuests.map(({ questId, progress, questData }) => {
                        const currentStep = questData.steps[progress.currentStep];
                        const isExpanded = expandedQuests.has(questId);
                        const requirement = currentStep?.requirement;
                        const reqProgress = getRequirementProgress(requirement);

                        return (
                            <div
                                key={questId}
                                style={{
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: 8,
                                    marginBottom: 8,
                                    border: '1px solid rgba(201,162,39,0.2)',
                                    overflow: 'hidden',
                                    transition: 'all 0.2s'
                                }}
                            >
                                {/* ä»»åŠ¡æ ‡é¢˜ */}
                                <div
                                    onClick={() => toggleQuestExpand(questId)}
                                    style={{
                                        padding: '10px 12px',
                                        cursor: 'pointer',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: 10,
                                        background: isExpanded
                                            ? 'rgba(201,162,39,0.1)'
                                            : 'transparent',
                                        transition: 'background 0.2s'
                                    }}
                                >
                                    <span style={{
                                        fontSize: 20,
                                        transition: 'transform 0.2s',
                                        transform: isExpanded ? 'scale(1.1)' : 'scale(1)'
                                    }}>
                                        {questData.icon}
                                    </span>
                                    <div style={{ flex: 1, minWidth: 0 }}>
                                        <div style={{
                                            fontSize: 12,
                                            color: '#ffd700',
                                            fontWeight: 600,
                                            whiteSpace: 'nowrap',
                                            overflow: 'hidden',
                                            textOverflow: 'ellipsis'
                                        }}>
                                            {questData.name}
                                        </div>
                                        <div style={{
                                            fontSize: 10,
                                            color: '#888',
                                            marginTop: 2,
                                            whiteSpace: 'nowrap',
                                            overflow: 'hidden',
                                            textOverflow: 'ellipsis'
                                        }}>
                                            {currentStep?.title}
                                        </div>
                                    </div>
                                    <span style={{
                                        color: '#666',
                                        fontSize: 12,
                                        transition: 'transform 0.2s',
                                        transform: isExpanded ? 'rotate(90deg)' : 'rotate(0)'
                                    }}>
                                        â–¶
                                    </span>
                                </div>

                                {/* å±•å¼€å†…å®¹ */}
                                {isExpanded && (
                                    <div style={{
                                        padding: '0 12px 12px',
                                        borderTop: '1px solid rgba(201,162,39,0.1)'
                                    }}>
                                        {/* å½“å‰ç›®æ ‡ */}
                                        {requirement && (
                                            <div style={{
                                                marginTop: 10,
                                                padding: 10,
                                                background: reqProgress.met
                                                    ? 'rgba(76,175,80,0.15)'
                                                    : 'rgba(255,152,0,0.1)',
                                                borderRadius: 6,
                                                border: `1px solid ${reqProgress.met
                                                    ? 'rgba(76,175,80,0.3)'
                                                    : 'rgba(255,152,0,0.3)'}`
                                            }}>
                                                <div style={{
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: 8,
                                                    marginBottom: 6
                                                }}>
                                                    <span style={{ fontSize: 14 }}>{reqProgress.icon}</span>
                                                    <span style={{
                                                        fontSize: 11,
                                                        color: reqProgress.met ? '#4CAF50' : '#ff9800',
                                                        fontWeight: 600
                                                    }}>
                                                        {reqProgress.text}
                                                    </span>
                                                </div>

                                                {/* è¿›åº¦æ¡ */}
                                                <div style={{
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: 8
                                                }}>
                                                    <div style={{
                                                        flex: 1,
                                                        height: 6,
                                                        background: 'rgba(0,0,0,0.4)',
                                                        borderRadius: 3,
                                                        overflow: 'hidden'
                                                    }}>
                                                        <div style={{
                                                            height: '100%',
                                                            width: `${Math.min(100, (reqProgress.current / reqProgress.target) * 100)}%`,
                                                            background: reqProgress.met
                                                                ? 'linear-gradient(90deg, #4CAF50, #81c784)'
                                                                : 'linear-gradient(90deg, #ff9800, #ffb74d)',
                                                            borderRadius: 3,
                                                            transition: 'width 0.3s'
                                                        }} />
                                                    </div>
                                                    <span style={{
                                                        fontSize: 10,
                                                        color: reqProgress.met ? '#4CAF50' : '#ff9800',
                                                        fontWeight: 600,
                                                        minWidth: 45,
                                                        textAlign: 'right'
                                                    }}>
                                                        {reqProgress.current >= 1000
                                                            ? `${(reqProgress.current/1000).toFixed(1)}k`
                                                            : reqProgress.current
                                                        } / {reqProgress.target >= 1000
                                                        ? `${(reqProgress.target/1000).toFixed(1)}k`
                                                        : reqProgress.target
                                                    }
                                                    </span>
                                                </div>
                                            </div>
                                        )}

                                        {/* æ­¥éª¤æè¿° */}
                                        <div style={{
                                            marginTop: 10,
                                            fontSize: 11,
                                            color: '#aaa',
                                            lineHeight: 1.5,
                                            padding: '8px 0'
                                        }}>
                                            {currentStep?.description?.substring(0, 100)}
                                            {currentStep?.description?.length > 100 && '...'}
                                        </div>

                                        {/* å·²è·å¾—çš„æ ‡è®° */}
                                        {progress.flags && progress.flags.length > 0 && (
                                            <div style={{
                                                marginTop: 8,
                                                display: 'flex',
                                                flexWrap: 'wrap',
                                                gap: 4
                                            }}>
                                                {progress.flags.slice(0, 3).map(flag => (
                                                    <span key={flag} style={{
                                                        fontSize: 9,
                                                        padding: '2px 6px',
                                                        background: 'rgba(156,39,176,0.2)',
                                                        borderRadius: 3,
                                                        color: '#ce93d8',
                                                        border: '1px solid rgba(156,39,176,0.3)'
                                                    }}>
                                                        âœ“ {flag.replace(/_/g, ' ')}
                                                    </span>
                                                ))}
                                                {progress.flags.length > 3 && (
                                                    <span style={{
                                                        fontSize: 9,
                                                        padding: '2px 6px',
                                                        color: '#888'
                                                    }}>
                                                        +{progress.flags.length - 3}
                                                    </span>
                                                )}
                                            </div>
                                        )}

                                        {/* æ“ä½œæŒ‰é’® */}
                                        <div style={{
                                            marginTop: 10,
                                            display: 'flex',
                                            gap: 8
                                        }}>
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    onOpenQuestPage?.(questId);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '6px 10px',
                                                    background: 'linear-gradient(180deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))',
                                                    border: '1px solid #c9a227',
                                                    borderRadius: 4,
                                                    color: '#ffd700',
                                                    fontSize: 11,
                                                    cursor: 'pointer',
                                                    fontFamily: 'inherit'
                                                }}
                                            >
                                                æŸ¥çœ‹è¯¦æƒ…
                                            </button>

                                            {currentStep?.dialogues && (
                                                <button
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        dispatch({
                                                            type: 'SHOW_QUEST_DIALOGUE',
                                                            payload: { questId }
                                                        });
                                                    }}
                                                    style={{
                                                        padding: '6px 10px',
                                                        background: 'rgba(0,0,0,0.3)',
                                                        border: '1px solid #4a3c2a',
                                                        borderRadius: 4,
                                                        color: '#888',
                                                        fontSize: 11,
                                                        cursor: 'pointer',
                                                        fontFamily: 'inherit'
                                                    }}
                                                    title="æŸ¥çœ‹å¯¹è¯"
                                                >
                                                    ğŸ’¬
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>
            )}

            {/* åº•éƒ¨å¿«æ·æŒ‰é’® */}
            {!isCollapsed && (
                <div style={{
                    padding: 8,
                    borderTop: '1px solid rgba(201,162,39,0.2)',
                    flexShrink: 0
                }}>
                    <button
                        onClick={() => onOpenQuestPage?.()}
                        style={{
                            width: '100%',
                            padding: '8px 12px',
                            background: 'rgba(0,0,0,0.3)',
                            border: '1px solid #4a3c2a',
                            borderRadius: 6,
                            color: '#c9a227',
                            fontSize: 12,
                            cursor: 'pointer',
                            fontFamily: 'inherit',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: 6
                        }}
                    >
                        <span>ğŸ“‹</span>
                        æ‰“å¼€ä»»åŠ¡åˆ—è¡¨
                    </button>
                </div>
            )}
        </div>
    );
};

// ==================== ä»»åŠ¡æç¤ºToastç»„ä»¶ ====================
const QuestToast = ({ message, type, onClose }) => {
    useEffect(() => {
        const timer = setTimeout(onClose, 3000);
        return () => clearTimeout(timer);
    }, [onClose]);

    const colors = {
        progress: { bg: 'rgba(255,152,0,0.9)', border: '#ff9800', icon: 'ğŸ“' },
        complete: { bg: 'rgba(76,175,80,0.9)', border: '#4CAF50', icon: 'âœ…' },
        reward: { bg: 'rgba(156,39,176,0.9)', border: '#9C27B0', icon: 'ğŸ' },
        unlock: { bg: 'rgba(33,150,243,0.9)', border: '#2196F3', icon: 'ğŸ”“' }
    };

    const style = colors[type] || colors.progress;

    return (
        <div style={{
            position: 'fixed',
            top: 80,
            left: '50%',
            transform: 'translateX(-50%)',
            padding: '12px 24px',
            background: style.bg,
            border: `2px solid ${style.border}`,
            borderRadius: 8,
            color: '#fff',
            fontSize: 14,
            fontWeight: 600,
            boxShadow: '0 4px 20px rgba(0,0,0,0.4)',
            zIndex: 2000,
            display: 'flex',
            alignItems: 'center',
            gap: 10,
            animation: 'slideDown 0.3s ease'
        }}>
            <span style={{ fontSize: 20 }}>{style.icon}</span>
            {message}
        </div>
    );
};

// ==================== ä»»åŠ¡ç›®æ ‡æ‚¬æµ®æŒ‡ç¤ºå™¨ ====================
const QuestObjectiveIndicator = ({ zone, requirement, progress }) => {
    if (!requirement || requirement.zoneId !== zone.id) return null;

    const current = progress || 0;
    const target = requirement.count;
    const percent = Math.min(100, (current / target) * 100);

    return (
        <div style={{
            position: 'absolute',
            top: -8,
            right: -8,
            background: current >= target
                ? 'linear-gradient(135deg, #4CAF50, #81c784)'
                : 'linear-gradient(135deg, #ff9800, #ffc107)',
            borderRadius: '50%',
            width: 28,
            height: 28,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            border: '2px solid #1a1510',
            boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
            animation: current >= target ? 'none' : 'pulse 2s infinite'
        }}>
            <span style={{ fontSize: 14 }}>
                {current >= target ? 'âœ“' : 'ğŸ“œ'}
            </span>
        </div>
    );
};

// ==================== MAIN APP ====================
export default function WoWIdleGame() {
    const [state, dispatch] = useReducer(gameReducer, initialState);
    const [consoleOpen, setConsoleOpen] = useState(false);
    const [command, setCommand] = useState('');
    const [consoleLogs, setConsoleLogs] = useState([]);
    const [isPaused, setIsPaused] = useState(false);
    const [showExport, setShowExport] = useState(false);
    const [importData, setImportData] = useState('');
    const [showRebirthBonus, setShowRebirthBonus] = useState(false);
    const [spacetimeRewardInfo, setSpacetimeRewardInfo] = useState(null);
    const [showSpacetimeShop, setShowSpacetimeShop] = useState(false);
    const intervalRef = useRef(null);
    const saveIntervalRef = useRef(null);
    const spacetimeRewardDayKeyRef = useRef('');

    const lastTickRef = useRef(Date.now());
    const hiddenAtRef = useRef(null);
    // çŠ¶æ€
    const [questToasts, setQuestToasts] = useState([]);

    // æ·»åŠ toastçš„å‡½æ•°
    const addQuestToast = useCallback((message, type = 'progress') => {
        const id = Date.now();
        setQuestToasts(prev => [...prev, { id, message, type }]);
    }, []);

    // ç§»é™¤toast
    const removeQuestToast = useCallback((id) => {
        setQuestToasts(prev => prev.filter(t => t.id !== id));
    }, []);

    // æ‰“å¼€ä»»åŠ¡é¡µé¢çš„å‡½æ•°
    const handleOpenQuestPage = useCallback((questId) => {
        dispatch({ type: 'SET_MENU', payload: 'quest' });
        if (questId) {
            // å¯ä»¥è®¾ç½®é€‰ä¸­çš„ä»»åŠ¡
            dispatch({ type: 'SELECT_QUEST', payload: questId });
        }
    }, [dispatch]);

    // åŒæ­¥æ¯æ—¥ã€ä¿å­˜ã€‘å¥–åŠ±æ—¥æ ‡è¯†åˆ° refï¼Œé¿å…æå¿«è¿ç‚¹é€ æˆåˆ¤å®šä¸ä¸€è‡´
    useEffect(() => {
        spacetimeRewardDayKeyRef.current = state.spacetimeCoinDailyRewardDayKey || '';
    }, [state.spacetimeCoinDailyRewardDayKey]);

    // æŒ‰ ` é”®å¼€å…³æ§åˆ¶å°
    useEffect(() => {
        const handleKeyDown = (e) => {
            if (e.key === '`') {
                e.preventDefault();
                setConsoleOpen(prev => !prev);
                setCommand(''); // æ‰“å¼€æ—¶æ¸…ç©ºè¾“å…¥
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, []);

    useEffect(() => {
        const onVisChange = () => {
            if (document.hidden) {
                // åˆ‡èµ°ï¼šè®°å½•éšè—å¼€å§‹æ—¶é—´
                hiddenAtRef.current = Date.now();
                return;
            }

            // åˆ‡å›ï¼šè®¡ç®—ç¦»å¼€ç§’æ•°
            const hiddenAt = hiddenAtRef.current;
            hiddenAtRef.current = null;
            if (!hiddenAt) return;

            const deltaSeconds = Math.floor((Date.now() - hiddenAt) / 1000);
            if (deltaSeconds <= 0) return;

            // âœ… è¡¥ä¸€å‘ tick
            dispatch({ type: "TICK", payload: { deltaSeconds } });

            // âœ… å…³é”®ï¼šåŒæ­¥ lastTickRefï¼Œé˜²æ­¢ interval ä¸‹ä¸€æ¬¡åˆç”¨æ—§çš„ lastTickRef å†è¡¥ä¸€é
            if (lastTickRef?.current != null) {
                lastTickRef.current = Date.now();
            }
        };

        document.addEventListener("visibilitychange", onVisChange);
        return () => document.removeEventListener("visibilitychange", onVisChange);
    }, [dispatch]); // lastTickRef æ˜¯ refï¼Œä¸ç”¨æ”¾ä¾èµ–

    // åŠ è½½å­˜æ¡£
    useEffect(() => {
        const savedState = loadFromLocalStorage();
        if (savedState) {
            // åˆå¹¶åˆå§‹çŠ¶æ€å’Œä¿å­˜çš„çŠ¶æ€ï¼Œç¡®ä¿æ–°å­—æ®µæœ‰é»˜è®¤å€¼
            const mergedState = {
                ...initialState,
                ...savedState,

                // âœ… å…³é”®ï¼šé˜²æ­¢æ—§å­˜æ¡£æŠŠå¯¹è±¡å­—æ®µè¦†ç›–æˆ null
                // âœ… resources éœ€è¦åšæ·±åˆå¹¶ï¼Œé¿å…æ—§å­˜æ¡£ç¼ºå°‘æ–°èµ„æºå­—æ®µï¼ˆå¦‚ï¼šæ—¶ç©ºå¸ï¼‰
                resources: {
                    ...initialState.resources,
                    ...(savedState.resources && typeof savedState.resources === 'object' && !Array.isArray(savedState.resources)
                        ? savedState.resources
                        : {})
                },
                buildings: savedState.buildings && typeof savedState.buildings === 'object' ? savedState.buildings : {},
                functionalBuildings: savedState.functionalBuildings && typeof savedState.functionalBuildings === 'object' ? savedState.functionalBuildings : {},
                resourceAssignments: savedState.resourceAssignments && typeof savedState.resourceAssignments === 'object' ? savedState.resourceAssignments : {},
                assignments: savedState.assignments && typeof savedState.assignments === 'object' ? savedState.assignments : {},
                research: savedState.research && typeof savedState.research === 'object' ? savedState.research : {},
                dropFilters: savedState.dropFilters && typeof savedState.dropFilters === 'object' ? savedState.dropFilters : {},
                maxCharacterSlots: initialState.maxCharacterSlots,
                zones: JSON.parse(JSON.stringify(ZONES)),
                combatLogs: savedState.combatLogs || [],
                offlineRewards: null
            };

            // ä½¿ç”¨å¯¼å…¥åŠŸèƒ½åŠ è½½çŠ¶æ€
            dispatch({ type: 'IMPORT_SAVE', payload: encodeBase64(JSON.stringify(mergedState)) });
        }

        dispatch({ type: 'CALCULATE_OFFLINE_REWARDS' });
    }, []);

    // è‡ªåŠ¨ä¿å­˜ï¼ˆæ¯10ç§’ï¼‰
    useEffect(() => {
        saveIntervalRef.current = setInterval(() => {
            saveToLocalStorage(state);
        }, 10000);

        return () => {
            if (saveIntervalRef.current) {
                clearInterval(saveIntervalRef.current);
                saveToLocalStorage(state); // åœ¨ç»„ä»¶å¸è½½æ—¶ä¹Ÿä¿å­˜ä¸€æ¬¡
            }
        };
    }, [state]);

    // æ¸¸æˆä¸»å¾ªç¯
    useEffect(() => {
        if (!isPaused) {
            intervalRef.current = setInterval(() => {
                const now = Date.now();
                const deltaSeconds = Math.max(1, Math.floor((now - lastTickRef.current) / 1000));
                lastTickRef.current = now;

                dispatch({ type: 'TICK', payload: { deltaSeconds } });
            }, 1000);
        }
        return () => clearInterval(intervalRef.current);
    }, [isPaused]);




    const executeCommand = (cmd) => {
        const trimmed = cmd.trim();
        if (!trimmed) return;

        setConsoleLogs(prev => [...prev, `> ${trimmed}`]);

        const parts = trimmed.split(' ');
        const mainCmd = parts[0].toLowerCase();

        if (mainCmd === 'add') {
            const subCmd = parts[1]?.toLowerCase();

            if (subCmd === 'gold' && parts[2]) {
                const amount = parseFloat(parts[2]);
                if (!isNaN(amount) && amount > 0) {
                    dispatch({ type: 'CHEAT_ADD_GOLD', payload: amount });
                    setConsoleLogs(prev => [...prev, `âœ“ æˆåŠŸæ·»åŠ  ${amount} é‡‘å¸`]);
                } else {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šé‡‘å¸æ•°é‡å¿…é¡»æ˜¯æ­£æ•°']);
                }
            }else if (subCmd === 'spcoin' && parts[2]) {
                const amount = parseFloat(parts[2]);
                if (!isNaN(amount) && amount > 0) {
                    dispatch({ type: 'CHEAT_ADD_SPACETIME_COIN', payload: amount });
                    setConsoleLogs(prev => [...prev, `âœ“ æˆåŠŸæ·»åŠ  ${amount} æ—¶ç©ºå¸`]);
                } else {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šæ—¶ç©ºå¸æ•°é‡å¿…é¡»æ˜¯æ­£æ•°']);
                }
            }
            else if (subCmd === 'equip' && parts[2]) {
                const equipArg = parts[2];
                const [idRaw, levelStr] = equipArg.split(',');
                if (!idRaw) {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šè£…å¤‡IDä¸èƒ½ä¸ºç©º']);
                    return;
                }

                const id = idRaw.trim().toUpperCase();
                const level = parseInt(levelStr?.trim()) || 1;
                const clampedLevel = Math.max(1, Math.min(100, level));

                const tpl = getEquipmentTemplate(id) ;
                if (!tpl) {
                    setConsoleLogs(prev => [...prev, `âœ— é”™è¯¯ï¼šæ‰¾ä¸åˆ°è£…å¤‡ ID "${id}"`]);
                    return;
                }

                const instance = {
                    ...tpl,
                    instanceId: `cheat_${Date.now()}_${Math.random().toString(36)}`,
                    qualityColor: getRarityColor(tpl.rarity),
                    currentLevel: clampedLevel,
                    stats: scaleStats(tpl.baseStats, tpl.growth, clampedLevel)
                };

                dispatch({ type: 'CHEAT_ADD_EQUIPMENT', payload: instance });
                setConsoleLogs(prev => [...prev, `âœ“ æˆåŠŸæ·»åŠ  ${tpl.name} (ID: ${id}) Lv.${clampedLevel}`]);

                if (clampedLevel >= 100) {
                    dispatch({ type: 'CHEAT_ADD_LV100_CODEX', payload: id });
                }
            }
            else if (subCmd === 'bagslot' && parts[2]) {
                const amount = parseInt(parts[2]);
                if (!isNaN(amount) && amount > 0) {
                    dispatch({ type: 'CHEAT_ADD_BAGSLOT', payload: amount });
                    setConsoleLogs(prev => [...prev, `âœ“ æˆåŠŸå¢åŠ  ${amount} ä¸ªèƒŒåŒ…æ ä½ï¼ˆå½“å‰æ€»æ ä½ï¼š${state.inventorySize + amount}ï¼‰`]);
                } else {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šæ ä½æ•°é‡å¿…é¡»æ˜¯æ­£æ•´æ•°']);
                }
            }
            // ===== æ–°å¢ï¼šadd exp =====
            else if (subCmd === 'exp' && parts[2]) {
                const expArg = parts[2];
                const [amountStr, indexStr] = expArg.split(',');
                const amount = parseInt(amountStr?.trim());
                const index1Based = parseInt(indexStr?.trim());

                if (isNaN(amount) || amount <= 0) {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šç»éªŒå€¼å¿…é¡»æ˜¯æ­£æ•´æ•°']);
                    return;
                }
                if (isNaN(index1Based) || index1Based < 1 || index1Based > state.characters.length) {
                    setConsoleLogs(prev => [...prev, `âœ— é”™è¯¯ï¼šè§’è‰²ç´¢å¼•æ— æ•ˆï¼ˆå½“å‰æœ‰ ${state.characters.length} ä¸ªè§’è‰²ï¼Œç´¢å¼•èŒƒå›´ 1~${state.characters.length}ï¼‰`]);
                    return;
                }

                const charIndex = index1Based - 1; // è½¬ä¸º0-basedç´¢å¼•
                dispatch({ type: 'CHEAT_ADD_EXP', payload: { amount, charIndex } });
                const char = state.characters[charIndex];
                setConsoleLogs(prev => [...prev, `âœ“ æˆåŠŸç»™ ${char.name} (ç¬¬${index1Based}ä¸ªè§’è‰²) æ·»åŠ  ${amount} ç»éªŒ`]);
            }// ===== æ–°å¢ï¼šadd rebirth bonus exp,gold,drop,researchSpeed =====
            else if (subCmd === 'rebirth' && parts[2]?.toLowerCase() === 'bonus' && parts[3]) {
                const values = parts[3].split(',').map(s => parseFloat(s.trim()));
                if (values.length !== 4 || values.some(v => Number.isNaN(v)) || values.some(v => v < 0)) {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šç”¨æ³• add rebirth bonus <exp,gold,drop,researchSpeed>ï¼ˆ4ä¸ªéè´Ÿæ•°å­—ï¼‰']);
                    setConsoleLogs(prev => [...prev, '   ç¤ºä¾‹ï¼šadd rebirth bonus 0.2,0.2,0.1,0.1']);
                    return;
                }

                const [exp, gold, drop, researchSpeed] = values;
                dispatch({ type: 'CHEAT_SET_REBIRTH_BONUS', payload: { exp, gold, drop, researchSpeed } });
                setConsoleLogs(prev => [...prev, `âœ“ å·²è®¾ç½®è½®å›åŠ æˆï¼šexp=${exp}, gold=${gold}, drop=${drop}, research=${researchSpeed}`]);
            }
                // ===== æ–°å¢ï¼šadd set =====
                // ç”¨æ³•ï¼šadd set <setId>[,<level>]
            // ç¤ºä¾‹ï¼šadd set valor_set
            else if (subCmd === 'set' && parts[2]) {
                const setArg = parts[2];
                const [setIdRaw, levelStr] = setArg.split(',');

                const setId = (setIdRaw || '').trim();
                if (!setId) {
                    setConsoleLogs(prev => [...prev, 'âœ— é”™è¯¯ï¼šsetId ä¸èƒ½ä¸ºç©º']);
                    return;
                }

                const normalizedSetId = setId.toLowerCase();

                const parsedLevel = parseInt(levelStr?.trim());
                const level = Number.isFinite(parsedLevel) ? parsedLevel : 1;
                const clampedLevel = Math.max(1, Math.min(100, level));

                // æ”¶é›†æ‰€æœ‰è£…å¤‡æ¨¡æ¿ï¼ˆå¸¸è§„æ‰è½ + ä»»åŠ¡/å‰§æƒ…å¥–åŠ±ï¼‰
                const allTemplates = [
                    ...(FIXED_EQUIPMENTS ? Object.values(FIXED_EQUIPMENTS) : []),
                    ...(QUEST_REWARD_EQUIPMENTS ? Object.values(QUEST_REWARD_EQUIPMENTS) : []),
                ]
                    .filter(Boolean)
                    .filter(tpl => {
                        const sid = (tpl.setId || tpl.set || '').toString().toLowerCase();
                        return sid === normalizedSetId;
                    });

                if (allTemplates.length === 0) {
                    setConsoleLogs(prev => [...prev, `âœ— é”™è¯¯ï¼šæ‰¾ä¸åˆ° setId ä¸º "${normalizedSetId}" çš„è£…å¤‡`]);
                    return;
                }

                // å»é‡ï¼ˆæŒ‰è£…å¤‡IDï¼‰
                const uniqueTemplates = Array.from(
                    new Map(allTemplates.map(tpl => [tpl.id, tpl])).values()
                );

                // æ‰¹é‡æ·»åŠ 
                const addedLines = [];
                for (const tpl of uniqueTemplates) {
                    const instance = {
                        ...tpl,
                        instanceId: `cheat_${Date.now()}_${Math.random().toString(36)}`,
                        qualityColor: getRarityColor(tpl.rarity),
                        currentLevel: clampedLevel,
                        stats: scaleStats(tpl.baseStats || {}, tpl.growth || {}, clampedLevel)
                    };

                    dispatch({ type: 'CHEAT_ADD_EQUIPMENT', payload: instance });
                    addedLines.push(`   + ${tpl.name} (ID: ${tpl.id}) Lv.${clampedLevel}`);

                    if (clampedLevel >= 100) {
                        dispatch({ type: 'CHEAT_ADD_LV100_CODEX', payload: tpl.id });
                    }
                }

                const setName = SET_BONUSES?.[normalizedSetId]?.name || uniqueTemplates[0]?.setName || normalizedSetId;
                setConsoleLogs(prev => [
                    ...prev,
                    `âœ“ æˆåŠŸæ·»åŠ å¥—è£…ã€Œ${setName}ã€(setId: ${normalizedSetId}) å…± ${uniqueTemplates.length} ä»¶`,
                    ...addedLines
                ]);
            }
            else {
                setConsoleLogs(prev => [...prev, 'âœ— ç”¨æ³•ï¼š']);
                setConsoleLogs(prev => [...prev, '   add gold <æ•°é‡>']);
                setConsoleLogs(prev => [...prev, '   add equip <è£…å¤‡ID>,<ç­‰çº§>ï¼ˆç­‰çº§å¯é€‰ï¼‰']);
                setConsoleLogs(prev => [...prev, '   add bagslot <æ•°é‡>']);
                setConsoleLogs(prev => [...prev, '   add exp <ç»éªŒå€¼>,<è§’è‰²ç´¢å¼•>ï¼ˆç´¢å¼•ä»1å¼€å§‹ï¼‰']);
                setConsoleLogs(prev => [...prev, '   ç¤ºä¾‹ï¼šadd exp 99999,1']);
            }
        }
        else {
            setConsoleLogs(prev => [...prev, 'âœ— æœªçŸ¥å‘½ä»¤ï¼Œç›®å‰ä»…æ”¯æŒ add gold / add equip / add bagslot / add exp']);
        }

        setCommand('');
    };

    // ç”Ÿæˆæœ¬åœ°â€œæ—¥æ ‡è¯†â€ï¼ˆYYYY-MM-DDï¼‰ï¼Œç”¨äºæ¯æ—¥å¥–åŠ±åˆ¤å®š
    const getLocalDateKey = (d = new Date()) => {
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const dd = String(d.getDate()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
    };

    // ä¸‹è½½ txt æ–‡ä»¶ï¼ˆå†…å®¹ä¸ºå­˜æ¡£å­—ç¬¦ä¸²ï¼‰
    const downloadTxtFile = (filename, content) => {
        try {
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        } catch (e) {
            console.error('downloadTxtFile failed', e);
        }
    };

    const exportSave = () => {
        const now = new Date();
        const dayKey = getLocalDateKey(now);

        // ç”¨ ref åšä¸€æ¬¡â€œå³åˆ»é˜²æŠ–â€ï¼Œé¿å…æå¿«è¿ç‚¹æ—¶å‡ºç°é‡å¤å¥–åŠ±å¼¹çª—/é‡å¤å†™å…¥
        const claimedKey = spacetimeRewardDayKeyRef.current || state.spacetimeCoinDailyRewardDayKey || '';
        const alreadyClaimed = claimedKey === dayKey;

        // å…ˆæ„é€ æœ¬æ¬¡ç”¨äºâ€œä¿å­˜â€çš„çŠ¶æ€ï¼ˆç¡®ä¿å¯¼å‡ºçš„å­—ç¬¦ä¸²åŒ…å«å¥–åŠ±ä¸ä»Šæ—¥æ ‡è®°ï¼Œé¿å…å¯¼å‡º/å¯¼å…¥ç»•è¿‡æ¯æ—¥é™åˆ¶ï¼‰
        let stateForSave = state;

        if (!alreadyClaimed) {
            const rewardAmount = 1000;
            const nextTotal = (state.resources?.spacetimeCoin || 0) + rewardAmount;

            // ç«‹åˆ»æ›´æ–° refï¼Œé˜²æ­¢æå¿«è¿ç‚¹å¯¼è‡´é‡å¤åˆ¤å®š
            spacetimeRewardDayKeyRef.current = dayKey;

            // çœŸæ­£å‘å¸ï¼šå†™å…¥ stateï¼ˆè¿›å…¥è‡ªåŠ¨å­˜æ¡£/ä¸‹æ¬¡å¯¼å‡ºï¼‰
            dispatch({
                type: 'CLAIM_SPACETIME_COIN_DAILY_SAVE_REWARD',
                payload: { dayKey, amount: rewardAmount }
            });

            // å¼¹çª—æç¤º
            setSpacetimeRewardInfo({ amount: rewardAmount, total: nextTotal });

            // å¯¼å‡ºçš„å­˜æ¡£ä¹ŸåŒæ­¥åŒ…å«å¥–åŠ±
            stateForSave = {
                ...state,
                spacetimeCoinDailyRewardDayKey: dayKey,
                resources: {
                    ...(state.resources || {}),
                    spacetimeCoin: nextTotal
                }
            };
        }

        const saveData = encodeBase64(JSON.stringify(stateForSave));

        const hh = String(now.getHours()).padStart(2, '0');
        const mi = String(now.getMinutes()).padStart(2, '0');
        const ss = String(now.getSeconds()).padStart(2, '0');
        downloadTxtFile(`wow_save_${dayKey}_${hh}${mi}${ss}.txt`, saveData);

        setShowExport(true);
        setTimeout(() => setShowExport(false), 2000);
    };

    const importSave = () => {
        if (importData.trim()) {
            dispatch({ type: 'IMPORT_SAVE', payload: importData.trim() });
            setImportData('');
        }
    };

    const menus = [
        { id: 'map', name: 'åœ°å›¾', icon: 'ğŸ—ºï¸' },
        { id: 'character', name: 'è§’è‰²', icon: 'ğŸ‘¥' },
        { id: 'talent', name: 'å¤©èµ‹', icon: 'ğŸŒŸ' },
        { id: 'inventory', name: 'é“å…·', icon: 'ğŸ“¦' },
        { id: 'city', name: 'ä¸»åŸ', icon: 'ğŸ°' },
        { id: 'research', name: 'ç ”ç©¶', icon: 'ğŸ”¬' },
        { id: 'worldboss', name: 'ä¸–ç•Œé¦–é¢†', icon: 'ğŸ²' },
        { id: 'achievement', name: 'æˆå°±', icon: 'ğŸ†' },
        { id: 'codex', name: 'å›¾é‰´', icon: 'ğŸ“š' },
        { id: 'quest', name: 'ä»»åŠ¡', icon: 'ğŸ“œ' },
    ];

    const renderPage = () => {
        switch (state.currentMenu) {
            case 'map': return <MapPage state={state} dispatch={dispatch} />;
            case 'character': return <CharacterPage state={state} dispatch={dispatch} />;
            case 'talent': return <TalentPage state={state} dispatch={dispatch} />;
            case 'inventory': return <InventoryPage state={state} dispatch={dispatch} />;
            case 'city': return <CityPage state={state} dispatch={dispatch} />;
            case 'research': return <ResearchPage state={state} dispatch={dispatch} />;
            case 'worldboss': return <WorldBossPage state={state} dispatch={dispatch}/>;
            case 'achievement': return <AchievementPage state={state} />;
            case 'codex': return <CodexPage state={state} dispatch={dispatch} />;
            case 'quest': return <QuestPage state={state} dispatch={dispatch} />;
            default: return <MapPage state={state} dispatch={dispatch} />;
        }
    };

    return (
        <div style={{
            minHeight: '100vh',
            width: '100%',
            boxSizing: 'border-box',
            background: 'linear-gradient(135deg, #1a1510 0%, #0d0a07 50%, #151210 100%)',
            fontFamily: '"Noto Serif SC", "Cinzel", Georgia, serif',
            color: '#e8dcc4',
            padding: 16,
        }}>
            <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Noto+Serif+SC:wght@400;600&display=swap');
        
        * { box-sizing: border-box; }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background: #4a3c2a; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #5a4c3a; }
        
        select, input { font-family: inherit; }
      `}</style>

            {state.offlineRewards && (
                <OfflineRewardsModal
                    rewards={state.offlineRewards.rewards}
                    actualSeconds={state.offlineRewards.actualSeconds}
                    maxSeconds={state.offlineRewards.maxSeconds}
                    onClaim={() => dispatch({
                        type: 'APPLY_OFFLINE_REWARDS',
                        payload: state.offlineRewards
                    })}
                    onDismiss={() => dispatch({ type: 'DISMISS_OFFLINE_REWARDS' })}
                />
            )}

            {spacetimeRewardInfo && (
                <SpacetimeCoinRewardModal
                    amount={spacetimeRewardInfo.amount}
                    total={spacetimeRewardInfo.total}
                    onClose={() => setSpacetimeRewardInfo(null)}
                />
            )}

            {showSpacetimeShop && (
                <SpacetimeShopModal
                    state={state}
                    dispatch={dispatch}
                    onClose={() => setShowSpacetimeShop(false)}
                />
            )}

            {/* ===== æ·»åŠ ä¸¤ä¸ªBossæ¨¡æ€ ===== */}
            {state.prepareBoss && <BossPrepareModal state={state} dispatch={dispatch} />}
            {state.bossCombat && <BossCombatModal combat={state.bossCombat} state={state} />}

            <HoggerPlotModal state={state} dispatch={dispatch} />
            <ScarletBadgeModal state={state} dispatch={dispatch} />
            <RebirthConfirmModal state={state} dispatch={dispatch} />
            {state.showRebirthPlot && <RebirthPlotModal state={state} dispatch={dispatch} />}
            {showRebirthBonus && <RebirthBonusModal state={state} onClose={() => setShowRebirthBonus(false)} />}

            {/* Header */}
            <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: 16,
                padding: '12px 20px',
                background: 'linear-gradient(180deg, rgba(40,30,20,0.9), rgba(25,18,12,0.95))',
                border: '2px solid #4a3c2a',
                borderRadius: 8,
                boxShadow: '0 4px 12px rgba(0,0,0,0.5)',
            }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: 16 }}>
                    <h1 style={{
                        margin: 0,
                        fontSize: 24,
                        color: '#c9a227',
                        textShadow: '2px 2px 4px rgba(0,0,0,0.8)',
                        fontWeight: 700,
                    }}>
                        âš”ï¸ è‰¾æ³½æ‹‰æ–¯ä¸‡ä¸–è½®å›
                    </h1>
                    <span style={{
                        padding: '4px 12px',
                        background: 'rgba(201,162,39,0.2)',
                        borderRadius: 4,
                        fontSize: 12,
                        color: '#c9a227',
                    }}>
            æœ¬ä¸–å¸§: {Math.floor(state.lifeFrame || 0)} ï½œ æ€»å¸§: {Math.floor(state.frame)}
          </span>
                </div>

                <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                        <span style={{ fontSize: 12, color: '#888' }}>ğŸª™ {Math.floor(state.resources.gold)}</span>
                        <span style={{ fontSize: 12, color: '#888' }}>ğŸŒ€ {Math.floor(state.resources.spacetimeCoin || 0)}</span>
                        <Button
                            onClick={() => setShowSpacetimeShop(true)}
                            variant="secondary"
                            style={{
                                padding: '4px 10px',
                                fontSize: 11,
                                borderRadius: 999,
                                background: 'linear-gradient(180deg, rgba(123,220,255,0.22), rgba(60,120,180,0.12))',
                                border: '1px solid rgba(123,220,255,0.55)',
                                color: '#b9f3ff',
                                boxShadow: '0 0 14px rgba(123,220,255,0.18), inset 0 1px 0 rgba(255,255,255,0.08)',
                                textShadow: '0 0 10px rgba(123,220,255,0.35)',
                            }}
                        >
                            ğŸŒ€ æ—¶ç©ºå•†åŸ
                        </Button>
                    </div>

                    <Button onClick={() => setShowRebirthBonus(true)} variant="secondary" style={{ padding: '6px 10px', fontSize: 11 }}>
                        âš¡ è½®å›åŠ æˆ
                    </Button>

                    {state.rebirthUnlocked && (
                        <Button onClick={() => dispatch({ type: 'OPEN_REBIRTH_CONFIRM' })} variant="danger">
                            é‡ç”Ÿè½®å›
                        </Button>
                    )}

                    <Button onClick={() => setIsPaused(!isPaused)} variant="secondary">
                        {isPaused ? 'â–¶ï¸ ç»§ç»­' : 'â¸ï¸ æš‚åœ'}
                    </Button>

                    <Button onClick={exportSave} variant="secondary" disabled={showExport}>
                        {showExport ? 'âœ“ å·²ä¿å­˜' : 'ğŸ’¾ ä¿å­˜'}
                    </Button>

                    <div style={{ display: 'flex', gap: 4 }}>
                        <input
                            type="text"
                            placeholder="ç²˜è´´å­˜æ¡£..."
                            value={importData}
                            onChange={(e) => setImportData(e.target.value)}
                            style={{
                                padding: '6px 10px',
                                width: 120,
                                background: 'rgba(0,0,0,0.4)',
                                border: '1px solid #4a3c2a',
                                borderRadius: 4,
                                color: '#fff',
                                fontSize: 12,
                            }}
                        />
                        <Button onClick={importSave} variant="secondary">å¯¼å…¥</Button>
                    </div>
                </div>
            </div>

            {/* Navigation */}
            <div style={{
                display: 'flex',
                gap: 4,
                marginBottom: 16,
                padding: 4,
                background: 'rgba(0,0,0,0.3)',
                borderRadius: 8,
                border: '1px solid #3a3a3a',
            }}>
                {menus.map(menu => (
                    <button
                        key={menu.id}
                        onClick={() => dispatch({ type: 'SET_MENU', payload: menu.id })}
                        style={{
                            flex: 1,
                            padding: '12px 16px',
                            background: state.currentMenu === menu.id
                                ? 'linear-gradient(180deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))'
                                : 'transparent',
                            border: state.currentMenu === menu.id
                                ? '1px solid #c9a227'
                                : '1px solid transparent',
                            borderRadius: 6,
                            color: state.currentMenu === menu.id ? '#ffd700' : '#888',
                            cursor: 'pointer',
                            fontFamily: 'inherit',
                            fontSize: 13,
                            transition: 'all 0.2s',
                            textShadow: state.currentMenu === menu.id ? '0 0 10px rgba(255,215,0,0.5)' : 'none',
                        }}
                    >
                        {menu.icon} {menu.name}
                    </button>
                ))}
            </div>

            {/* Content */}
            <div style={{ minHeight: 'calc(100vh - 160px)' }}>
                {renderPage()}
            </div>

            {/* ä»»åŠ¡è¿½è¸ªæ‚¬æµ®UI */}
            <QuestTracker
                state={state}
                dispatch={dispatch}
                onOpenQuestPage={handleOpenQuestPage}
            />

            {/* ä»»åŠ¡æç¤ºToasts */}
            {questToasts.map(toast => (
                <QuestToast
                    key={toast.id}
                    message={toast.message}
                    type={toast.type}
                    onClose={() => removeQuestToast(toast.id)}
                />
            ))}

            {/* å¼€å‘è€…æ§åˆ¶å° */}
            {consoleOpen && (
                <div style={{
                    position: 'fixed',
                    bottom: 0,
                    left: 0,
                    right: 0,
                    background: 'rgba(0,0,0,0.95)',
                    borderTop: '2px solid #0f0',
                    padding: '10px',
                    zIndex: 9999,
                    fontFamily: 'monospace',
                    color: '#0f0',
                    maxHeight: '40vh',
                    display: 'flex',
                    flexDirection: 'column'
                }}>
                    <div style={{
                        flex: 1,
                        overflowY: 'auto',
                        marginBottom: '8px',
                        paddingRight: '8px'
                    }}>
                        {consoleLogs.map((log, i) => (
                            <div key={i}>{log}</div>
                        ))}
                    </div>
                    <input
                        autoFocus
                        value={command}
                        onChange={(e) => setCommand(e.target.value)}
                        onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                                executeCommand(command);
                            }
                        }}
                        placeholder="è¾“å…¥å‘½ä»¤ï¼ŒæŒ‰ Enter æ‰§è¡Œï¼ŒæŒ‰ ` å…³é—­"
                        style={{
                            width: '100%',
                            background: 'transparent',
                            border: '1px solid #0f0',
                            color: '#0f0',
                            padding: '8px',
                            fontFamily: 'monospace',
                            outline: 'none'
                        }}
                    />
                </div>
            )}
        </div>
    );
}

// ==================== CSSåŠ¨ç”»ï¼ˆæ·»åŠ åˆ°styleæ ‡ç­¾ä¸­ï¼‰   ====================
const questAnimationStyles = `
    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    }
    
    @keyframes pulse {
        0%, 100% {
            transform: scale(1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }
        50% {
            transform: scale(1.1);
            box-shadow: 0 2px 16px rgba(255,152,0,0.6);
        }
    }
    
    @keyframes glow {
        0%, 100% {
            box-shadow: 0 0 5px rgba(201,162,39,0.3);
        }
        50% {
            box-shadow: 0 0 20px rgba(201,162,39,0.6);
        }
    }
`;

// ==================== å¢å¼ºç‰ˆä»»åŠ¡è¿½è¸ªï¼ˆå¸¦åœ°å›¾æ ‡è®°ï¼‰ ====================
const EnhancedQuestTracker = ({ state, dispatch, onOpenQuestPage }) => {
    const [isCollapsed, setIsCollapsed] = useState(false);
    const [expandedQuests, setExpandedQuests] = useState(new Set());
    const [isMinimized, setIsMinimized] = useState(false);
    const [showHints, setShowHints] = useState(true);

    // è·å–æ‰€æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡
    const activeQuests = Object.entries(state.questProgress || {})
        .filter(([_, progress]) => progress.status === 'in_progress')
        .map(([questId, progress]) => ({
            questId,
            progress,
            questData: QUEST_CHAINS[questId]
        }))
        .filter(q => q.questData);

    // è·å–å½“å‰æ­¥éª¤éœ€è¦å»çš„åœ°ç‚¹
    const getQuestLocations = () => {
        const locations = [];

        activeQuests.forEach(({ questId, progress, questData }) => {
            const currentStep = questData.steps[progress.currentStep];
            if (!currentStep?.requirement) return;

            const req = currentStep.requirement;

            if (req.type === 'zone_battles' && req.zoneId) {
                locations.push({
                    questId,
                    questName: questData.name,
                    stepTitle: currentStep.title,
                    zoneId: req.zoneId,
                    zoneName: ZONES[req.zoneId]?.name,
                    type: 'battle',
                    current: state.questBattleProgress?.[req.zoneId] || 0,
                    target: req.count
                });
            }

            if (req.type === 'boss_defeated' && req.bossId) {
                locations.push({
                    questId,
                    questName: questData.name,
                    stepTitle: currentStep.title,
                    bossId: req.bossId,
                    bossName: BOSS_DATA[req.bossId]?.name,
                    type: 'boss',
                    completed: state.defeatedBosses?.includes(req.bossId)
                });
            }
        });

        return locations;
    };

    const questLocations = getQuestLocations();

    // æ£€æŸ¥æ­¥éª¤æ¡ä»¶è¿›åº¦
    const getRequirementProgress = (requirement) => {
        if (!requirement) return { met: true, current: 0, target: 0, text: '' };

        switch (requirement.type) {
            case 'zone_battles': {
                const zone = ZONES[requirement.zoneId];
                const zoneName = zone?.name || requirement.zoneId;
                const current = state.questBattleProgress?.[requirement.zoneId] || 0;
                const target = requirement.count;
                return {
                    met: current >= target,
                    current,
                    target,
                    text: `åœ¨${zoneName}æˆ˜æ–—`,
                    icon: 'âš”ï¸',
                    hint: `å‰å¾€åœ°å›¾ > ${zoneName}æ´¾é£è§’è‰²æˆ˜æ–—`
                };
            }
            case 'character_level': {
                const maxLevel = Math.max(...state.characters.map(c => c.level), 0);
                return {
                    met: maxLevel >= requirement.level,
                    current: maxLevel,
                    target: requirement.level,
                    text: `è§’è‰²ç­‰çº§è¾¾åˆ°`,
                    icon: 'â­',
                    hint: 'é€šè¿‡æˆ˜æ–—è·å¾—ç»éªŒå‡çº§'
                };
            }
            case 'boss_defeated': {
                const bossName = BOSS_DATA[requirement.bossId]?.name || requirement.bossId;
                const defeated = state.defeatedBosses?.includes(requirement.bossId);
                return {
                    met: defeated,
                    current: defeated ? 1 : 0,
                    target: 1,
                    text: `å‡»è´¥${bossName}`,
                    icon: 'ğŸ²',
                    hint: `å‰å¾€ä¸–ç•Œé¦–é¢†æŒ‘æˆ˜${bossName}`
                };
            }
            case 'have_gold': {
                return {
                    met: state.resources.gold >= requirement.amount,
                    current: Math.floor(state.resources.gold),
                    target: requirement.amount,
                    text: `å‡†å¤‡é‡‘å¸`,
                    icon: 'ğŸª™',
                    hint: 'é€šè¿‡æˆ˜æ–—å’Œå‡ºå”®ç‰©å“è·å¾—é‡‘å¸'
                };
            }
            case 'have_item': {
                const hasItem = state.inventory.some(i => i.id === requirement.itemId) ||
                    state.questItems?.some(i => i.id === requirement.itemId);
                const itemName = QUEST_ITEMS[requirement.itemId]?.name ||
                    ITEMS[requirement.itemId]?.name ||
                    requirement.itemId;
                return {
                    met: hasItem,
                    current: hasItem ? 1 : 0,
                    target: 1,
                    text: `è·å¾—${itemName}`,
                    icon: 'ğŸ“¦',
                    hint: 'é€šè¿‡æ¢ç´¢æˆ–æˆ˜æ–—è·å¾—ç‰©å“'
                };
            }
            default:
                return { met: true, current: 0, target: 0, text: '', hint: '' };
        }
    };

    // åˆ‡æ¢ä»»åŠ¡å±•å¼€çŠ¶æ€
    const toggleQuestExpand = (questId) => {
        setExpandedQuests(prev => {
            const next = new Set(prev);
            if (next.has(questId)) {
                next.delete(questId);
            } else {
                next.add(questId);
            }
            return next;
        });
    };

    // å¿«é€Ÿå¯¼èˆªåˆ°ç›®æ ‡ä½ç½®
    const navigateToLocation = (location) => {
        if (location.type === 'battle' && location.zoneId) {
            dispatch({ type: 'SET_MENU', payload: 'map' });
        } else if (location.type === 'boss') {
            dispatch({ type: 'SET_MENU', payload: 'worldboss' });
        }
    };

    // å¦‚æœæ²¡æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡
    if (activeQuests.length === 0) {
        return (
            <div style={{
                position: 'fixed',
                top: 100,
                right: 16,
                width: 280,
                background: 'linear-gradient(135deg, rgba(30,25,20,0.95) 0%, rgba(20,15,12,0.98) 100%)',
                border: '2px solid #4a3c2a',
                borderRadius: 10,
                padding: 12,
                boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                zIndex: 100
            }}>
                <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between'
                }}>
                    <div style={{
                        fontSize: 13,
                        color: '#c9a227',
                        fontWeight: 600,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span>ğŸ“œ</span>
                        ä»»åŠ¡è¿½è¸ª
                    </div>
                </div>
                <div style={{
                    marginTop: 12,
                    textAlign: 'center',
                    color: '#666',
                    fontSize: 12,
                    padding: '16px 0'
                }}>
                    <div style={{ fontSize: 24, marginBottom: 8 }}>ğŸ“­</div>
                    æš‚æ— è¿›è¡Œä¸­çš„ä»»åŠ¡
                    <button
                        onClick={() => onOpenQuestPage?.()}
                        style={{
                            display: 'block',
                            width: '100%',
                            marginTop: 12,
                            padding: '8px 12px',
                            background: 'rgba(201,162,39,0.2)',
                            border: '1px solid #c9a227',
                            borderRadius: 6,
                            color: '#c9a227',
                            fontSize: 11,
                            cursor: 'pointer',
                            fontFamily: 'inherit'
                        }}
                    >
                        æŸ¥çœ‹å¯ç”¨ä»»åŠ¡
                    </button>
                </div>
            </div>
        );
    }

    // æœ€å°åŒ–æ¨¡å¼
    if (isMinimized) {
        return (
            <div
                onClick={() => setIsMinimized(false)}
                style={{
                    position: 'fixed',
                    top: 100,
                    right: 16,
                    width: 50,
                    height: 50,
                    background: 'linear-gradient(135deg, rgba(201,162,39,0.3), rgba(139,115,25,0.2))',
                    border: '2px solid #c9a227',
                    borderRadius: '50%',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    cursor: 'pointer',
                    boxShadow: '0 4px 20px rgba(201,162,39,0.3)',
                    zIndex: 100,
                    animation: 'glow 2s infinite'
                }}
                title="å±•å¼€ä»»åŠ¡è¿½è¸ª"
            >
                <div style={{ position: 'relative' }}>
                    <span style={{ fontSize: 24 }}>ğŸ“œ</span>
                    <div style={{
                        position: 'absolute',
                        top: -8,
                        right: -8,
                        background: '#f44336',
                        color: '#fff',
                        fontSize: 10,
                        fontWeight: 700,
                        width: 18,
                        height: 18,
                        borderRadius: '50%',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        border: '2px solid #1a1510'
                    }}>
                        {activeQuests.length}
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div style={{
            position: 'fixed',
            top: 100,
            right: 16,
            width: isCollapsed ? 50 : 320,
            maxHeight: 'calc(100vh - 140px)',
            background: 'linear-gradient(135deg, rgba(30,25,20,0.97) 0%, rgba(20,15,12,0.99) 100%)',
            border: '2px solid #c9a227',
            borderRadius: 10,
            overflow: 'hidden',
            boxShadow: '0 4px 24px rgba(0,0,0,0.6), 0 0 20px rgba(201,162,39,0.15)',
            zIndex: 100,
            transition: 'width 0.3s ease',
            display: 'flex',
            flexDirection: 'column'
        }}>
            {/* æ ‡é¢˜æ  */}
            <div style={{
                padding: '10px 12px',
                background: 'linear-gradient(180deg, rgba(201,162,39,0.15) 0%, transparent 100%)',
                borderBottom: '1px solid rgba(201,162,39,0.3)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                flexShrink: 0
            }}>
                {!isCollapsed && (
                    <div style={{
                        fontSize: 14,
                        color: '#ffd700',
                        fontWeight: 600,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8
                    }}>
                        <span>ğŸ“œ</span>
                        ä»»åŠ¡è¿½è¸ª
                        <span style={{
                            fontSize: 11,
                            color: '#888',
                            fontWeight: 400
                        }}>
                            ({activeQuests.length})
                        </span>
                    </div>
                )}

                <div style={{ display: 'flex', gap: 4 }}>
                    {!isCollapsed && (
                        <>
                            <button
                                onClick={() => setShowHints(!showHints)}
                                style={{
                                    background: showHints ? 'rgba(201,162,39,0.2)' : 'transparent',
                                    border: showHints ? '1px solid #c9a227' : 'none',
                                    color: showHints ? '#c9a227' : '#666',
                                    fontSize: 12,
                                    cursor: 'pointer',
                                    padding: '2px 6px',
                                    borderRadius: 4
                                }}
                                title={showHints ? 'éšè—æç¤º' : 'æ˜¾ç¤ºæç¤º'}
                            >
                                ğŸ’¡
                            </button>
                            <button
                                onClick={() => setIsMinimized(true)}
                                style={{
                                    background: 'transparent',
                                    border: 'none',
                                    color: '#888',
                                    fontSize: 14,
                                    cursor: 'pointer',
                                    padding: '2px 6px',
                                    borderRadius: 4
                                }}
                                title="æœ€å°åŒ–"
                            >
                                â”€
                            </button>
                        </>
                    )}
                    <button
                        onClick={() => setIsCollapsed(!isCollapsed)}
                        style={{
                            background: 'transparent',
                            border: 'none',
                            color: '#c9a227',
                            fontSize: 16,
                            cursor: 'pointer',
                            padding: '2px 6px',
                            borderRadius: 4
                        }}
                        title={isCollapsed ? 'å±•å¼€' : 'æŠ˜å '}
                    >
                        {isCollapsed ? 'â—€' : 'â–¶'}
                    </button>
                </div>
            </div>

            {/* ä»»åŠ¡åˆ—è¡¨ */}
            {!isCollapsed && (
                <div style={{
                    flex: 1,
                    overflowY: 'auto',
                    padding: 8
                }}>
                    {activeQuests.map(({ questId, progress, questData }) => {
                        const currentStep = questData.steps[progress.currentStep];
                        const isExpanded = expandedQuests.has(questId);
                        const requirement = currentStep?.requirement;
                        const reqProgress = getRequirementProgress(requirement);

                        return (
                            <div
                                key={questId}
                                style={{
                                    background: 'rgba(0,0,0,0.3)',
                                    borderRadius: 8,
                                    marginBottom: 8,
                                    border: '1px solid rgba(201,162,39,0.2)',
                                    overflow: 'hidden'
                                }}
                            >
                                {/* ä»»åŠ¡æ ‡é¢˜ */}
                                <div
                                    onClick={() => toggleQuestExpand(questId)}
                                    style={{
                                        padding: '10px 12px',
                                        cursor: 'pointer',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: 10,
                                        background: isExpanded ? 'rgba(201,162,39,0.1)' : 'transparent'
                                    }}
                                >
                                    <span style={{ fontSize: 20 }}>{questData.icon}</span>
                                    <div style={{ flex: 1, minWidth: 0 }}>
                                        <div style={{
                                            fontSize: 12,
                                            color: '#ffd700',
                                            fontWeight: 600,
                                            whiteSpace: 'nowrap',
                                            overflow: 'hidden',
                                            textOverflow: 'ellipsis'
                                        }}>
                                            {questData.name}
                                        </div>
                                        <div style={{
                                            fontSize: 10,
                                            color: '#888',
                                            marginTop: 2
                                        }}>
                                            {currentStep?.title}
                                        </div>
                                    </div>

                                    {/* å¿«é€ŸçŠ¶æ€æŒ‡ç¤º */}
                                    {requirement && (
                                        <div style={{
                                            width: 24,
                                            height: 24,
                                            borderRadius: '50%',
                                            background: reqProgress.met
                                                ? 'rgba(76,175,80,0.3)'
                                                : 'rgba(255,152,0,0.3)',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            fontSize: 12
                                        }}>
                                            {reqProgress.met ? 'âœ“' : reqProgress.icon}
                                        </div>
                                    )}

                                    <span style={{
                                        color: '#666',
                                        fontSize: 12,
                                        transform: isExpanded ? 'rotate(90deg)' : 'rotate(0)',
                                        transition: 'transform 0.2s'
                                    }}>
                                        â–¶
                                    </span>
                                </div>

                                {/* å±•å¼€å†…å®¹ */}
                                {isExpanded && (
                                    <div style={{
                                        padding: '0 12px 12px',
                                        borderTop: '1px solid rgba(201,162,39,0.1)'
                                    }}>
                                        {/* å½“å‰ç›®æ ‡ */}
                                        {requirement && (
                                            <div style={{
                                                marginTop: 10,
                                                padding: 10,
                                                background: reqProgress.met
                                                    ? 'rgba(76,175,80,0.15)'
                                                    : 'rgba(255,152,0,0.1)',
                                                borderRadius: 6,
                                                border: `1px solid ${reqProgress.met
                                                    ? 'rgba(76,175,80,0.3)'
                                                    : 'rgba(255,152,0,0.3)'}`
                                            }}>
                                                <div style={{
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: 8,
                                                    marginBottom: 6
                                                }}>
                                                    <span style={{ fontSize: 14 }}>{reqProgress.icon}</span>
                                                    <span style={{
                                                        fontSize: 11,
                                                        color: reqProgress.met ? '#4CAF50' : '#ff9800',
                                                        fontWeight: 600,
                                                        flex: 1
                                                    }}>
                                                        {reqProgress.text}
                                                    </span>
                                                    <span style={{
                                                        fontSize: 10,
                                                        color: reqProgress.met ? '#4CAF50' : '#ff9800'
                                                    }}>
                                                        {reqProgress.current}/{reqProgress.target}
                                                    </span>
                                                </div>

                                                {/* è¿›åº¦æ¡ */}
                                                <div style={{
                                                    height: 4,
                                                    background: 'rgba(0,0,0,0.4)',
                                                    borderRadius: 2,
                                                    overflow: 'hidden'
                                                }}>
                                                    <div style={{
                                                        height: '100%',
                                                        width: `${Math.min(100, (reqProgress.current / reqProgress.target) * 100)}%`,
                                                        background: reqProgress.met
                                                            ? '#4CAF50'
                                                            : 'linear-gradient(90deg, #ff9800, #ffc107)',
                                                        borderRadius: 2,
                                                        transition: 'width 0.3s'
                                                    }} />
                                                </div>

                                                {/* æç¤º */}
                                                {showHints && !reqProgress.met && reqProgress.hint && (
                                                    <div style={{
                                                        marginTop: 8,
                                                        fontSize: 10,
                                                        color: '#888',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: 4
                                                    }}>
                                                        <span>ğŸ’¡</span>
                                                        {reqProgress.hint}
                                                    </div>
                                                )}
                                            </div>
                                        )}

                                        {/* å¿«é€Ÿå¯¼èˆªæŒ‰é’® */}
                                        {questLocations.filter(l => l.questId === questId).map((location, idx) => (
                                            <button
                                                key={idx}
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    navigateToLocation(location);
                                                }}
                                                style={{
                                                    width: '100%',
                                                    marginTop: 8,
                                                    padding: '8px 10px',
                                                    background: 'linear-gradient(135deg, rgba(33,150,243,0.2), rgba(21,101,192,0.15))',
                                                    border: '1px solid rgba(33,150,243,0.4)',
                                                    borderRadius: 6,
                                                    color: '#64b5f6',
                                                    fontSize: 11,
                                                    cursor: 'pointer',
                                                    fontFamily: 'inherit',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    gap: 6
                                                }}
                                            >
                                                <span>ğŸ§­</span>
                                                å‰å¾€ {location.zoneName || location.bossName}
                                            </button>
                                        ))}

                                        {/* æŸ¥çœ‹è¯¦æƒ…æŒ‰é’® */}
                                        <button
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                onOpenQuestPage?.(questId);
                                            }}
                                            style={{
                                                width: '100%',
                                                marginTop: 8,
                                                padding: '8px 10px',
                                                background: 'rgba(0,0,0,0.3)',
                                                border: '1px solid #4a3c2a',
                                                borderRadius: 6,
                                                color: '#c9a227',
                                                fontSize: 11,
                                                cursor: 'pointer',
                                                fontFamily: 'inherit'
                                            }}
                                        >
                                            ğŸ“– æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ…
                                        </button>
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>
            )}
        </div>
    );
};

export { QuestTracker, EnhancedQuestTracker, QuestToast, QuestObjectiveIndicator, questAnimationStyles };